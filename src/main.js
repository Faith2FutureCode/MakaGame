import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import { FBXLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
import { MeshoptDecoder } from 'https://unpkg.com/three@0.160.0/examples/jsm/libs/meshopt_decoder.module.js';
import {
  GameState,
  PLAYER_STATUS_DEFS,
  PRAYER_DEFS,
  MONSTER_ABILITY_IDS,
  DEFAULT_MONSTER_ICONS,
  MONSTER_SLOT_MACHINE_COLUMNS,
  MONSTER_SLOT_MACHINE_DEFAULT_SPIN_DURATION,
  MONSTER_SLOT_MACHINE_DEFAULT_REVEAL_DURATION,
  MONSTER_SLOT_MACHINE_SPIN_REFRESH,
  MONSTER_SLOT_MACHINE_IDLE_REFRESH,
  prayerBindingLookup,
  randomMonsterAbility,
  formatAbilityKeyLabel,
  buildDefaultPlayerStatusConfig,
  buildDefaultPrayerBindings,
  rebuildPrayerBindingLookup,
  ensurePrayerState,
  createDefaultMonsterState,
  normalizeMonsterState,
  createDefaultPlayerFloatState,
  createDefaultPracticeDummy,
  practiceDummyDefaults
} from './core/state.js';
import { createEngine } from './core/engine.js';
import { initSettingsPanel } from './ui/settingsPanel.js';
import { createSettingHelp } from './ui/settingHelp.js';
import { createSettingsSearch } from './ui/settingsSearch.js';
import { clamp, clamp01, smoothstep01, clampFloat, sanitizeHexColor, degToRad, radToDeg } from './utils/math.js';
import { createCollisionHelpers } from './systems/collisionSystem.js';
import { createCombatSystem } from './systems/combatSystem.js';
import { createSpawnSystem } from './systems/spawnSystem.js';
import { createPhysicsSystem } from './systems/physicsSystem.js';
import { createAbilitySystem } from './systems/abilitySystem.js';
import { buildCoarseBlocks, buildNavGrid } from './utils/grid.js';
import { createEventBus } from './core/events.js';
import { initMobaSettingsMenu } from './genres/moba/settings.js';
/* MakaMoba Ã¢â‚¬â€ Sidebar + Portal endpoints + non-overlap + Scoring (overlay) */

  // Elements
  const app  = document.getElementById('app');
  const stage = document.getElementById('stage');
  const view = document.getElementById('view');
  const hitboxImg = document.getElementById('hitbox');
  const img   = document.getElementById('map');
  const canvas= document.getElementById('layer');
  const ctx   = canvas.getContext('2d');
  const fogCanvas = document.createElement('canvas');
  const fogCtx = fogCanvas.getContext('2d');
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas ? minimapCanvas.getContext('2d') : null;
  const MINIMAP_BASE_SIZE = 220;
  const MINIMAP_MARGIN = 16;
  const MAX_MAP_DIMENSION = 6000;
  const MAX_MAP_PIXELS = 36000000; // cap to ~36 MP to avoid huge canvases
  const settingsSearchOverlay = document.getElementById('settingsSearch');
  const settingsSearchInput = document.getElementById('settingsSearchInput');
  const settingsSearchResultsEl = document.getElementById('settingsSearchResults');
  const settingsSearchEmptyEl = document.getElementById('settingsSearchEmpty');
  const settingsSearchEmptyPrimary = document.getElementById('settingsSearchEmptyPrimary');
  const settingsSearchEmptySecondary = document.getElementById('settingsSearchEmptySecondary');
  const settingsSearchStatusEl = document.getElementById('settingsSearchStatus');
  const settingsSearchFacetsEl = document.getElementById('settingsSearchFacets');
  const settingsSearchRecentsEl = document.getElementById('settingsSearchRecents');
  const settingsSearchHelpBtn = document.getElementById('settingsSearchHelpBtn');
  const settingsSearchHelpEl = document.getElementById('settingsSearchHelp');
  const settingsSearchHelpClose = document.getElementById('settingsSearchHelpClose');
  const settingsSearchAskBtn = document.getElementById('settingsSearchAskBtn');
  const engine = createEngine();
  const events = createEventBus();

  const mapState = GameState.map;
  const blueSpawns = GameState.spawns.blue;
  const redSpawns = GameState.spawns.red;
  let player = GameState.player;
  mapState.artScale = Number.isFinite(mapState.artScale) ? mapState.artScale : 1;
  const stagePointerState = mapState.stagePointer;
  const minimapState = GameState.hud.minimap;
  const minions = GameState.minions;
  const pendingSpawns = GameState.spawns.pending;
  const laneConfigs = GameState.lanes.configs;
  const laneDragState = (GameState.lanes.drag && typeof GameState.lanes.drag === 'object')
    ? GameState.lanes.drag
    : (GameState.lanes.drag = {});
  const portalDragState = (GameState.spawns.drag && typeof GameState.spawns.drag === 'object')
    ? GameState.spawns.drag
    : (GameState.spawns.drag = {});
  const turretDragState = (GameState.turrets.drag && typeof GameState.turrets.drag === 'object')
    ? GameState.turrets.drag
    : (GameState.turrets.drag = {});
  const cameraState = GameState.camera;
  const hudState = GameState.hud;
  hudState.playerFloat = normalizePlayerFloatState(hudState.playerFloat);
  hudState.cursor = normalizeCursorState(hudState.cursor);
  hudState.pings = normalizePingState(hudState.pings);
  hudState.keybinds = normalizeKeybindState(hudState.keybinds);
  hudState.spellCasting = hudState.spellCasting || {
    defaultCastType: 'quickIndicator',
    normalModifier: { key: '', code: '', label: 'â€”' },
    quickModifier: { key: '', code: '', label: 'â€”' },
    quickIndicatorModifier: { key: '', code: '', label: 'â€”' }
  };
  const spellCastingConfig = hudState.spellCasting;
  const abilityRuntime = hudState.abilityRuntime || (hudState.abilityRuntime = {});
  abilityRuntime.flameChomperSequence = Math.max(1, Number(abilityRuntime.flameChomperSequence) || 1);
  abilityRuntime.scatterChargeSequence = Math.max(1, Number(abilityRuntime.scatterChargeSequence) || 1);
  abilityRuntime.linkLashSequence = Math.max(1, Number(abilityRuntime.linkLashSequence) || 1);
  abilityRuntime.backlineSeizureSequence = Math.max(1, Number(abilityRuntime.backlineSeizureSequence) || 1);
  abilityRuntime.mourningMarchSequence = Math.max(1, Number(abilityRuntime.mourningMarchSequence) || 1);
  abilityRuntime.emberGuardianSequence = Math.max(1, Number(abilityRuntime.emberGuardianSequence) || 1);
  abilityRuntime.stockadeSequence = Math.max(1, Number(abilityRuntime.stockadeSequence) || 1);
  abilityRuntime.glacialUpliftSequence = Math.max(1, Number(abilityRuntime.glacialUpliftSequence) || 1);
  abilityRuntime.emberWaltzSequence = Math.max(1, Number(abilityRuntime.emberWaltzSequence) || 1);
  abilityRuntime.flipbladeSequence = Math.max(1, Number(abilityRuntime.flipbladeSequence) || 1);
  abilityRuntime.trailblazeSequence = Math.max(1, Number(abilityRuntime.trailblazeSequence) || 1);
  abilityRuntime.phalanxSurgeSequence = Math.max(1, Number(abilityRuntime.phalanxSurgeSequence) || 1);
  abilityRuntime.graviticSequence = Math.max(1, Number(abilityRuntime.graviticSequence) || 1);
  abilityRuntime.eventHorizonSequence = Math.max(1, Number(abilityRuntime.eventHorizonSequence) || 1);
  abilityRuntime.skyScoutSequence = Math.max(1, Number(abilityRuntime.skyScoutSequence) || 1);
  abilityRuntime.temporalVeilSequence = Math.max(1, Number(abilityRuntime.temporalVeilSequence) || 1);
  abilityRuntime.edgeFluxSequence = Math.max(1, Number(abilityRuntime.edgeFluxSequence) || 1);
  abilityRuntime.cycloneAxesSequence = Math.max(1, Number(abilityRuntime.cycloneAxesSequence) || 1);
  abilityRuntime.convergingGaleSequence = Math.max(1, Number(abilityRuntime.convergingGaleSequence) || 1);
  abilityRuntime.venomBloomSequence = Math.max(1, Number(abilityRuntime.venomBloomSequence) || 1);
  abilityRuntime.miasmaSequence = Math.max(1, Number(abilityRuntime.miasmaSequence) || 1);
  abilityRuntime.fangStrikeSequence = Math.max(1, Number(abilityRuntime.fangStrikeSequence) || 1);
  abilityRuntime.stoneGazeSequence = Math.max(1, Number(abilityRuntime.stoneGazeSequence) || 1);
  abilityRuntime.windpiercerStacks = Math.max(0, Number(abilityRuntime.windpiercerStacks) || 0);
  abilityRuntime.windpiercerStackExpires = Math.max(0, Number(abilityRuntime.windpiercerStackExpires) || 0);
  abilityRuntime.skyfireVolleySequence = Math.max(0, Number(abilityRuntime.skyfireVolleySequence) || 0);
  abilityRuntime.chronoLoopSequence = Math.max(1, Number(abilityRuntime.chronoLoopSequence) || 1);
  abilityRuntime.abilityCycleIndex = Math.max(0, Number(abilityRuntime.abilityCycleIndex) || 0);
  abilityRuntime.galeThrustStacks = Math.max(0, Math.floor(Number(abilityRuntime.galeThrustStacks) || 0));
  abilityRuntime.galeThrustStackTimer = Math.max(0, Number(abilityRuntime.galeThrustStackTimer) || 0);
  const abilityTunables = hudState.abilityTunables;
  const cursorState = hudState.cursor;
  const pingState = hudState.pings;
  const keybindState = hudState.keybinds;
  // Multi-team (experimental) state
  const defaultTeamColors = ['#4da1ff', '#ff6b6b', '#8ae66c', '#f8d34b', '#b388ff', '#ff9f40', '#50e3c2', '#ff7bb0', '#7ad7f0', '#c2c2c2'];
  if(!GameState.multiTeam || typeof GameState.multiTeam !== 'object'){
    GameState.multiTeam = { enabled: true, teamCount: 10, colors: defaultTeamColors.slice(0, 10) };
  }
  if(!Array.isArray(GameState.multiTeam.colors) || GameState.multiTeam.colors.length < GameState.multiTeam.teamCount){
    GameState.multiTeam.colors = defaultTeamColors.slice(0, GameState.multiTeam.teamCount || 10);
  }
  GameState.multiTeam.teamCount = Math.max(2, Math.min(10, Math.round(GameState.multiTeam.teamCount || 10)));
  if(GameState.multiTeam.teamCount % 2 === 1){
    GameState.multiTeam.teamCount += 1; // ensure even for pairing
  }
  function clampMultiTeamCount(value){
    let count = Math.max(2, Math.min(10, Math.round(Number(value) || GameState.multiTeam.teamCount || 10)));
    if(count % 2 === 1) count += 1;
    return count;
  }
  const activePings = Array.isArray(pingState.active) ? pingState.active : (pingState.active = []);
  const PING_VISUALS = {
    onMyWay: '#7fe3ff',
    enemyMissing: '#ffd166',
    assistMe: '#ff7bb0',
    target: '#ff5577'
  };
  const abilityBarState = hudState.abilityBar;
  const timerState = hudState.timer;
  const waveState = hudState.waves;
  const goldState = hudState.gold;
  const scoreState = hudState.score;
  const scoreModeSelect = document.getElementById('scoreMode');
  const multiTeamEnabledInput = document.getElementById('multiTeamEnabled');
  const multiTeamCountInput = document.getElementById('multiTeamCount');
  const multiTeamColorsWrap = document.getElementById('multiTeamColors');
  if(!scoreState || typeof scoreState !== 'object'){
    hudState.score = { mode: 'lastNexus' };
  }
  scoreState.mode = typeof scoreState.mode === 'string' ? scoreState.mode : 'lastNexus';
  const portalState = hudState.portal;
  const TURRET_MIN_COUNT = 0;
  const TURRET_MAX_COUNT = 6;
  const TURRET_MIN_RANGE = 100;
  const TURRET_MAX_RANGE = 4000;
  const TURRET_MIN_DAMAGE = 0;
  const TURRET_MAX_DAMAGE = 10000;
  const TURRET_MIN_INTERVAL = 0.25;
  const TURRET_MAX_INTERVAL = 10;
  const TURRET_MIN_FOCUS = 0;
  const TURRET_MAX_FOCUS = 5;
  const TURRET_MIN_OFFSET = -2000;
  const TURRET_MAX_OFFSET = 2000;
  function darkenHex(color, amount = 0.25){
    const base = sanitizeHexColor(color, '#5bc357');
    const amt = Math.max(0, Math.min(1, amount));
    const toChan = (hex)=> Math.max(0, Math.min(255, Math.round(parseInt(hex, 16) * (1 - amt))));
    const r = toChan(base.slice(1,3)).toString(16).padStart(2, '0');
    const g = toChan(base.slice(3,5)).toString(16).padStart(2, '0');
    const b = toChan(base.slice(5,7)).toString(16).padStart(2, '0');
    return `#${r}${g}${b}`;
  }
  const turretState = normalizeTurretState(GameState.turrets);
  GameState.turrets = turretState;
  const playerFloatState = hudState.playerFloat;
  const prayerState = ensurePrayerState();
  clearPrayerBindings(); // leave prayer hotkeys unbound for now
  const monsterState = normalizeMonsterState(GameState.monster);
  GameState.monster = monsterState;
  const monsterDragState = (GameState.monsterDrag && typeof GameState.monsterDrag === 'object')
    ? GameState.monsterDrag
    : (GameState.monsterDrag = {});
  const playerInventoryState = Array.isArray(GameState.player.inventory)
    ? GameState.player.inventory
    : (GameState.player.inventory = []);
  const playerShopState = (GameState.player.shop && typeof GameState.player.shop === 'object')
    ? GameState.player.shop
    : (GameState.player.shop = { stayTimer: 0, undoStack: [], transactionSeq: 1 });
  if(!Array.isArray(playerShopState.undoStack)){ playerShopState.undoStack = []; }
  playerShopState.stayTimer = Number.isFinite(playerShopState.stayTimer) ? Math.max(0, playerShopState.stayTimer) : 0;
  playerShopState.transactionSeq = Number.isFinite(playerShopState.transactionSeq)
    ? Math.max(1, Math.floor(playerShopState.transactionSeq))
    : 1;

  if(!GameState.bases || typeof GameState.bases !== 'object'){
    GameState.bases = { blue: null, red: null };
  }
  const baseState = GameState.bases;
  const clampBaseValue = (value, fallback) => {
    const numeric = Number(value);
    return Number.isFinite(numeric) ? numeric : fallback;
  };
  function createDefaultBaseState(side){
    const width = clampBaseValue(mapState.width, 5000);
    const height = clampBaseValue(mapState.height, 5000);
    const margin = Math.max(420, Math.min(width, height) * 0.12);
    const baseRadius = Math.max(520, Math.min(width, height) * 0.18);
    const fountainRadius = Math.max(220, Math.min(width, height) * 0.085);
    const cx = side === 'red' ? width - margin : margin;
    const cy = side === 'red' ? margin : height - margin;
    return {
      side,
      baseZone: { x: cx, y: cy, radius: baseRadius },
      fountain: { x: cx, y: cy, radius: fountainRadius },
      nexus: { x: cx, y: cy, hp: 5000, maxHp: 5000 },
      regenPerSecond: { hp: 180, mp: 120 },
      regenInterval: 0.25,
      invulnerabilityDuration: 1.5,
      homeguardDuration: 4,
      lethalRadius: fountainRadius + 180,
      lethalDamagePerSecond: 6000
    };
  }
  if(!baseState.blue){ baseState.blue = createDefaultBaseState('blue'); }
  if(!baseState.red){ baseState.red = createDefaultBaseState('red'); }
  function ensureNexusPosition(side, x, y){
    if(!side || !baseState || !baseState[side]) return;
    const base = baseState[side];
    const existing = base.nexus || {};
    const maxHp = Number.isFinite(existing.maxHp) ? existing.maxHp : 5000;
    const hp = Number.isFinite(existing.hp) ? Math.min(existing.hp, maxHp) : maxHp;
    base.nexus = { x, y, hp, maxHp, side };
  }
  function ensureBaseNexus(base, side){
    if(!base || base.nexus){
      return;
    }
    const cx = (base.baseZone && Number.isFinite(base.baseZone.x)) ? base.baseZone.x
      : ((base.fountain && Number.isFinite(base.fountain.x)) ? base.fountain.x : (mapState.width / 2));
    const cy = (base.baseZone && Number.isFinite(base.baseZone.y)) ? base.baseZone.y
      : ((base.fountain && Number.isFinite(base.fountain.y)) ? base.fountain.y : (mapState.height / 2));
    const hp = (base.nexus && Number.isFinite(base.nexus.maxHp)) ? base.nexus.maxHp : 5000;
    base.nexus = { x: cx, y: cy, hp, maxHp: hp, side };
  }
  ensureBaseNexus(baseState.blue, 'blue');
  ensureBaseNexus(baseState.red, 'red');
  if(!GameState.multiTeamBases || !Array.isArray(GameState.multiTeamBases)){
    GameState.multiTeamBases = [];
  }
  const multiTeamState = GameState.multiTeam;
  if(multiTeamState.enabled){
    ensureMultiTeamBases();
  }
  function setMultiTeamCount(count){
    const next = clampMultiTeamCount(count);
    multiTeamState.teamCount = next;
    if(!Array.isArray(multiTeamState.colors)){
      multiTeamState.colors = defaultTeamColors.slice(0, next);
    }
    if(multiTeamState.colors.length < next){
      const missing = next - multiTeamState.colors.length;
      for(let i=0;i<missing;i++){
        multiTeamState.colors.push(defaultTeamColors[(multiTeamState.colors.length + i) % defaultTeamColors.length]);
      }
    }
    multiTeamState.colors.length = next;
    ensureMultiTeamBases();
  }
  function ensureMultiTeamBases(){
    const teams = Math.max(2, Math.min(10, Math.round(multiTeamState.teamCount || 10)));
    const evenTeams = teams % 2 === 0 ? teams : teams + 1;
    const width = clampBaseValue(mapState.width, 5000);
    const height = clampBaseValue(mapState.height, 5000);
    const cx = width / 2;
    const cy = height / 2;
    const radius = Math.min(width, height) * 0.38;
    const bases = [];
    for(let i=0;i<evenTeams;i++){
      const angle = (Math.PI * 2 * i) / evenTeams - Math.PI / 2;
      const bx = cx + Math.cos(angle) * radius;
      const by = cy + Math.sin(angle) * radius;
      const baseRadius = Math.max(520, Math.min(width, height) * 0.18);
      const fountainRadius = Math.max(220, Math.min(width, height) * 0.085);
      const id = `team${i}`;
      bases.push({
        id,
        side: id,
        color: multiTeamState.colors[i % multiTeamState.colors.length] || defaultTeamColors[i % defaultTeamColors.length],
        baseZone: { x: bx, y: by, radius: baseRadius },
        fountain: { x: bx, y: by, radius: fountainRadius },
        nexus: { x: bx, y: by, hp: 5000, maxHp: 5000 },
        regenPerSecond: { hp: 180, mp: 120 },
        regenInterval: 0.25,
        invulnerabilityDuration: 1.5,
        homeguardDuration: 4,
        lethalRadius: fountainRadius + 180,
        lethalDamagePerSecond: 6000
      });
      if(scoreState.mode === 'lastNexus'){
        ensureNexusPosition(id, bx, by);
      }
    }
    GameState.multiTeamBases = bases;
    return bases;
  }
  const cursorRuntime = { hoverTarget: null };
  monsterDragState.active = false;
  monsterDragState.dragging = false;
  monsterDragState.pointerId = null;
  monsterDragState.offsetX = 0;
  monsterDragState.offsetY = 0;
  monsterDragState.moved = false;
  monsterDragState.messageActive = false;
  const hudMessageState = hudState.hudMessage;
  const sidebarState = hudState.sidebar;
  const customColliders = mapState.colliders.list;
  const colliderDefaults = mapState.colliders.defaults;
  const customVisionSources = GameState.player.vision.sources;
  GameState.player.vision.dummy = GameState.practiceDummy;
  if(typeof GameState.player.vision.fullReveal !== 'boolean'){
    GameState.player.vision.fullReveal = true;
  }
  const visionDefaults = GameState.player.vision.defaults;
  const visionDummy = GameState.player.vision.dummy;
  const practiceDummy = GameState.practiceDummy;
  const practiceDummyState = GameState.player.vision.dummyState;
  const practiceDummyStatusNodes = new Map();
  const turrets = [];
  let turretsDirty = true;
  let turretLayoutVersion = null;
  let turretConfigRevision = 1;
  let lastAppliedTurretConfigRevision = 0;
  let minionDiameter = GameState.lanes.minion.diameter;
  let minionRadius = GameState.lanes.minion.radius;
  let laneFanSpacing = GameState.lanes.minion.fanSpacing;
  laneDragState.dragging = false;
  laneDragState.pointerId = null;
  laneDragState.laneIndex = null;
  laneDragState.breakIndex = null;
  laneDragState.mode = null;
  portalDragState.dragging = false;
  portalDragState.pointerId = null;
  portalDragState.side = null;
  portalDragState.offsetX = 0;
  portalDragState.offsetY = 0;
  turretDragState.dragging = false;
  turretDragState.pointerId = null;
  turretDragState.turretId = null;
  let practiceDummyMoveButton;
  let practiceDummyResetButton;
  let practiceDummyRemoveButton;
  let practiceDummySizeInput;
  let practiceDummySizeDisplay;
  let practiceDummyDeathResponseSelect;
  Object.defineProperty(GameState.meta, 'lastUpdate', {
    value: typeof performance !== 'undefined' ? performance.now() : Date.now(),
    writable: true,
    enumerable: false
  });
  function refreshPracticeDummyAnchors(){
    if(!practiceDummy){
      return;
    }
    const baseX = Number(practiceDummy.x) || 0;
    const baseY = Number(practiceDummy.y) || 0;
    practiceDummy.spawn = { x: baseX, y: baseY };
    practiceDummy.to = { x: baseX, y: baseY };
    practiceDummy.neutralPoint = { x: baseX, y: baseY };
    practiceDummy.neutralProj = 0;
    practiceDummy.laneDir = { x: 1, y: 0 };
    practiceDummy.laneFacing = 0;
    practiceDummy.laneNormal = { x: 0, y: -1 };
    practiceDummy.laneLength = 0;
    practiceDummy.offsideLimit = 0;
    practiceDummy.pathDistance = 0;
    practiceDummy.laneProjection = null;
    practiceDummy.laneProgress = 0;
    practiceDummy.offLaneDistance = 0;
    practiceDummy.facing = 0;
    practiceDummy.nav = null;
    practiceDummy.navGoal = null;
  }

  function attachPracticeDummy(){
    if(!practiceDummy || !Array.isArray(minions)){
      return;
    }
    refreshPracticeDummyAnchors();
    if(!minions.includes(practiceDummy)){
      minions.push(practiceDummy);
    }
  }

  attachPracticeDummy();
  normalizePracticeDummyState();
  updatePracticeDummyUiState();

  const PRACTICE_DUMMY_RESPAWN_SECONDS = 2.5;

  function resetPracticeDummyStatuses(target = practiceDummy){
    if(!target){
      return;
    }
    target.slowTimer = 0;
    target.slowPct = 0;
    target.stunTimer = 0;
    target.knockupTimer = 0;
    target.silenceTimer = 0;
    target.disarmTimer = 0;
    target.polymorphTimer = 0;
    target.tauntTimer = 0;
    target.damageReductionTimer = 0;
    target.damageReductionFraction = 0;
    target.hasteTimer = 0;
    target.hastePct = 0;
    target.portalizing = 0;
    target.beingPulledBy = null;
    target.chillTimer = 0;
    target.dirgeCurseTimer = 0;
    target.dirgeCurseTick = 0;
    target.dirgeCurseDps = 0;
    target.dirgeCurseMax = 0;
  }

  function removePracticeDummy(){
    if(!practiceDummy){
      return;
    }
    practiceDummy.hp = 0;
    practiceDummy.active = false;
    practiceDummy.respawnTimer = 0;
    practiceDummyState.placing = false;
    practiceDummyState.selected = false;
    stopVisionDummyDrag();
    resetPracticeDummyStatuses();
    updatePracticeDummyStatusIcons();
    updatePracticeDummyHud();
    updatePracticeDummyUiState();
    renderMinimap(true);
  }

  function beginPracticeDummyRespawn(){
    if(!practiceDummy){
      return;
    }
    if(practiceDummy.deathResponse === 'despawn'){
      removePracticeDummy();
      return;
    }
    practiceDummy.hp = 0;
    practiceDummy.active = false;
    practiceDummy.respawnTimer = PRACTICE_DUMMY_RESPAWN_SECONDS;
    resetPracticeDummyStatuses();
    practiceDummyState.placing = false;
    practiceDummyState.selected = false;
    stopVisionDummyDrag();
    updatePracticeDummyStatusIcons();
    updatePracticeDummyHud();
    updatePracticeDummyUiState();
    renderMinimap(true);
  }

  function respawnPracticeDummy(options = {}){
    if(!practiceDummy){
      return;
    }
    const { resetPosition = false, resetSize = false, resetStats = false } = options || {};
    if(resetPosition){
      practiceDummy.x = practiceDummyDefaults.x;
      practiceDummy.y = practiceDummyDefaults.y;
    }
    if(resetSize){
      practiceDummy.size = practiceDummyDefaults.size;
    } else {
      practiceDummy.size = clampPracticeDummySize(practiceDummy.size, practiceDummyDefaults.size);
    }
    if(resetStats){
      practiceDummy.maxHp = practiceDummyDefaults.maxHp;
      practiceDummy.radius = practiceDummyDefaults.radius;
    }
    practiceDummy.radius = Number.isFinite(practiceDummy.radius) ? Math.max(0, practiceDummy.radius) : practiceDummyDefaults.radius;
    practiceDummy.maxHp = Math.max(1, Number(practiceDummy.maxHp) || practiceDummyDefaults.maxHp);
    practiceDummy.hp = practiceDummy.maxHp;
    practiceDummy.side = practiceDummy.side === 'blue' ? 'blue' : practiceDummyDefaults.side;
    practiceDummy.active = true;
    practiceDummy.respawnTimer = 0;
    resetPracticeDummyStatuses();
    if(!practiceDummy.statuses || typeof practiceDummy.statuses !== 'object'){
      practiceDummy.statuses = buildDefaultPlayerStatusConfig();
    }
    practiceDummyState.placing = false;
    practiceDummyState.selected = false;
    refreshPracticeDummyAnchors();
    updatePracticeDummyUiState();
    updatePracticeDummyHud();
    updatePracticeDummyStatusIcons();
    positionPracticeDummyHud();
    renderMinimap(true);
  }

  function handlePracticeDummyDamage(target, prevHp){
    if(!target || !target.isPracticeDummy){
      return;
    }
    const before = Number(prevHp);
    const after = Math.max(0, Number(target.hp) || 0);
    if(after <= 0){
      if(!(practiceDummy.respawnTimer > 0)){
        beginPracticeDummyRespawn();
      }
      return;
    }
    if(!Number.isFinite(before) || before !== after){
      updatePracticeDummyHud();
    }
  }

  function tickPracticeDummy(dt){
    if(!practiceDummy){
      return;
    }
    if(practiceDummy.respawnTimer > 0){
      practiceDummy.respawnTimer = Math.max(0, practiceDummy.respawnTimer - dt);
      if(practiceDummy.respawnTimer <= 0){
        respawnPracticeDummy();
      }
    }
  }

  function practiceDummyDragThreshold(){
    const size = clampPracticeDummySize(practiceDummy && practiceDummy.size, 120);
    return Math.max(28, size * 0.6);
  }

  function isPointerInsidePracticeDummy(x, y){
    if(!practiceDummy || practiceDummy.active === false){
      return false;
    }
    const px = Number(practiceDummy.x) || 0;
    const py = Number(practiceDummy.y) || 0;
    const threshold = practiceDummyDragThreshold();
    const dx = x - px;
    const dy = y - py;
    return dx * dx + dy * dy <= threshold * threshold;
  }

  function placePracticeDummyAt(x, y){
    if(!practiceDummy){
      return;
    }
    const clampedX = Math.max(0, Math.min(mapState.width, Number(x) || 0));
    const clampedY = Math.max(0, Math.min(mapState.height, Number(y) || 0));
    const needsRevive = practiceDummy.active === false || (practiceDummy.respawnTimer > 0)
      || !(Number(practiceDummy.hp) > 0);
    practiceDummy.x = clampedX;
    practiceDummy.y = clampedY;
    practiceDummy.active = true;
    practiceDummy.respawnTimer = 0;
    if(needsRevive){
      practiceDummy.maxHp = Math.max(1, Number(practiceDummy.maxHp) || practiceDummyDefaults.maxHp);
      practiceDummy.hp = practiceDummy.maxHp;
      if(!practiceDummy.statuses || typeof practiceDummy.statuses !== 'object'){
        practiceDummy.statuses = buildDefaultPlayerStatusConfig();
      }
      resetPracticeDummyStatuses();
    }
    practiceDummyState.selected = false;
    refreshPracticeDummyAnchors();
    updatePracticeDummyHud();
    updatePracticeDummyStatusIcons();
    positionPracticeDummyHud();
    renderMinimap(true);
  }
  const playerRuntime = {
    animationController: null,
    lastAnimationState: 'idle',
    model: null,
    mixamoState: { baseFile: null },
    mixamoBusy: false,
    shadowPursuitMoveMult: 1,
    shadowPursuitActive: false
  };
  Object.defineProperty(GameState.player, 'runtime', {
    value: playerRuntime,
    writable: true,
    enumerable: false
  });

  const SETTINGS_RANGE_MIN = 0;
  const SETTINGS_RANGE_MAX = 10000;
  function clampSettingValue(value, fallback = SETTINGS_RANGE_MIN){
    let numeric = Number(value);
    if(!Number.isFinite(numeric)) numeric = fallback;
    return Math.max(SETTINGS_RANGE_MIN, Math.min(SETTINGS_RANGE_MAX, numeric));
  }
  function playerCollisionRadius(){
    return Math.max(0, Number(player.r) || 0);
  }
  function getPlayerHurtboxDims(){
    const shape = typeof player.hurtboxShape === 'string' ? player.hurtboxShape : 'capsule';
    const length = Math.max(0, Number(player.hurtboxLength) || 0);
    const width = Math.max(0, Number(player.hurtboxWidth) || 0);
    return { shape, length, width };
  }
  function getPlayerHurtRadius(){
    const { length, width } = getPlayerHurtboxDims();
    const inferred = Math.max(width > 0 ? width / 2 : 0, length > 0 ? length / 2 : 0);
    return Math.max(1, inferred || playerCollisionRadius());
  }
  function setPlayerHurtboxShape(value){
    const shape = value === 'circle' ? 'circle' : (value === 'rectangle' ? 'rectangle' : 'capsule');
    player.hurtboxShape = shape;
    if(playerHurtboxShapeSelect){
      playerHurtboxShapeSelect.value = shape;
    }
    return shape;
  }
  function setPlayerHurtboxLength(value){
    const clampMin = 0;
    const clampMax = SETTINGS_RANGE_MAX;
    let length = clampSettingValue(value, clampMin);
    length = Math.min(clampMax, Math.max(clampMin, length));
    player.hurtboxLength = length;
    if(playerHurtboxLengthInput){
      playerHurtboxLengthInput.value = String(length);
    }
    if(playerHurtboxLengthDisplay){
      playerHurtboxLengthDisplay.textContent = `${Math.round(length)}px`;
    }
    return length;
  }
  function setPlayerHurtboxWidth(value){
    const clampMin = 0;
    const clampMax = SETTINGS_RANGE_MAX;
    let width = clampSettingValue(value, clampMin);
    width = Math.min(clampMax, Math.max(clampMin, width));
    player.hurtboxWidth = width;
    if(playerHurtboxWidthInput){
      playerHurtboxWidthInput.value = String(width);
    }
    if(playerHurtboxWidthDisplay){
      playerHurtboxWidthDisplay.textContent = `${Math.round(width)}px`;
    }
    return width;
  }
  function clampTurretCount(value){
    const numeric = Math.floor(Number(value));
    if(!Number.isFinite(numeric)) return 0;
    return Math.max(TURRET_MIN_COUNT, Math.min(TURRET_MAX_COUNT, numeric));
  }
  function clampTurretRange(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) return 200;
    return Math.max(TURRET_MIN_RANGE, Math.min(TURRET_MAX_RANGE, numeric));
  }
  function clampTurretDamage(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) return 150;
    return Math.max(TURRET_MIN_DAMAGE, Math.min(TURRET_MAX_DAMAGE, numeric));
  }
  function clampTurretInterval(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) return 1.25;
    return Math.max(TURRET_MIN_INTERVAL, Math.min(TURRET_MAX_INTERVAL, numeric));
  }
  function clampTurretFocus(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) return 2;
    return Math.max(TURRET_MIN_FOCUS, Math.min(TURRET_MAX_FOCUS, numeric));
  }
  function clampTurretOffset(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) return 0;
    return Math.max(TURRET_MIN_OFFSET, Math.min(TURRET_MAX_OFFSET, Math.round(numeric)));
  }
  function normalizeTurretState(state){
    const target = state && typeof state === 'object' ? state : {};
    target.hasCustomOffsets = target.hasCustomOffsets === true;
    target.perLane = clampTurretCount(target.perLane ?? 1);
    target.range = clampTurretRange(target.range ?? 200);
    target.damage = clampTurretDamage(target.damage ?? 150);
    target.attackInterval = clampTurretInterval(target.attackInterval ?? 1.25);
    target.playerFocusSeconds = clampTurretFocus(target.playerFocusSeconds ?? 2);
    if(!Array.isArray(target.offsets)){
      target.offsets = [];
    }
    while(target.offsets.length < target.perLane){
      target.offsets.push({ x: 0, y: 0 });
    }
    if(target.offsets.length > target.perLane){
      target.offsets.length = target.perLane;
    }
    const hasNonZeroOffset = target.offsets.some(entry => {
      if(!entry || typeof entry !== 'object') return false;
      return (Number(entry.x) || 0) !== 0 || (Number(entry.y) || 0) !== 0;
    });
    target.hasCustomOffsets = target.hasCustomOffsets && hasNonZeroOffset ? true : hasNonZeroOffset;
    return target;
  }

  function deepClone(value){
    if(typeof structuredClone === 'function'){
      try {
        return structuredClone(value);
      } catch {
        // fall through to JSON
      }
    }
    return JSON.parse(JSON.stringify(value));
  }

  function normalizePlayerFloatState(state){
    const defaults = createDefaultPlayerFloatState();
    if(!state || typeof state !== 'object'){
      return defaults;
    }
    const normalized = state;
    const toNumber = (value, fallback)=>{
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : fallback;
    };
    normalized.width = toNumber(normalized.width, defaults.width);
    normalized.gap = toNumber(normalized.gap, defaults.gap);
    normalized.height = toNumber(normalized.height, defaults.height);
    const attack = normalized.attack && typeof normalized.attack === 'object' ? normalized.attack : {};
    normalized.attack = attack;
    attack.width = toNumber(attack.width, defaults.attack.width);
    attack.height = toNumber(attack.height, defaults.attack.height);
    attack.offsetX = toNumber(attack.offsetX, defaults.attack.offsetX);
    attack.offsetY = toNumber(attack.offsetY, defaults.attack.offsetY);
    if(typeof normalized.color !== 'string' || !normalized.color.trim()){
      normalized.color = defaults.color;
    } else {
      normalized.color = sanitizeHexColor(normalized.color, defaults.color);
    }
    const icons = normalized.icons && typeof normalized.icons === 'object' ? normalized.icons : {};
    normalized.icons = icons;
    icons.width = toNumber(icons.width, defaults.icons.width);
    icons.height = toNumber(icons.height, defaults.icons.height);
    icons.offsetX = toNumber(icons.offsetX, defaults.icons.offsetX);
    icons.offsetY = toNumber(icons.offsetY, defaults.icons.offsetY);
    if(!normalized.statuses || typeof normalized.statuses !== 'object'){
      normalized.statuses = buildDefaultPlayerStatusConfig();
    }
    for(const def of PLAYER_STATUS_DEFS){
      const entry = normalized.statuses[def.id];
      if(!entry || typeof entry !== 'object'){
        normalized.statuses[def.id] = { emoji: def.defaultEmoji, color: def.defaultColor };
        continue;
      }
      if(typeof entry.emoji !== 'string' || !entry.emoji.trim()){
        entry.emoji = def.defaultEmoji;
      }
      if(typeof entry.color !== 'string' || !entry.color.trim()){
        entry.color = def.defaultColor;
      } else {
        entry.color = sanitizeHexColor(entry.color, def.defaultColor);
      }
    }
    return normalized;
  }

  function normalizePlayerControlState(target){
    if(!target || typeof target !== 'object'){
      return;
    }
    const timers = ['slowTimer', 'stunTimer', 'knockupTimer', 'silenceTimer', 'disarmTimer', 'polymorphTimer', 'tauntTimer', 'chillTimer'];
    for(const key of timers){
      const numeric = Number(target[key]);
      target[key] = Number.isFinite(numeric) ? Math.max(0, numeric) : 0;
    }
    const dmgTimer = Number(target.damageReductionTimer);
    target.damageReductionTimer = Number.isFinite(dmgTimer) ? Math.max(0, dmgTimer) : 0;
    const dmgFraction = Number(target.damageReductionFraction);
    target.damageReductionFraction = Number.isFinite(dmgFraction) ? Math.max(0, Math.min(1, dmgFraction)) : 0;
    const slowPct = Number(target.slowPct);
    target.slowPct = Number.isFinite(slowPct) ? Math.max(0, slowPct) : 0;
    const hasteTimer = Number(target.hasteTimer);
    target.hasteTimer = Number.isFinite(hasteTimer) ? Math.max(0, hasteTimer) : 0;
    const hastePct = Number(target.hastePct);
    target.hastePct = Number.isFinite(hastePct) ? Math.max(0, hastePct) : 0;
    const hasteDecay = Number(target.hasteDecayRate);
    target.hasteDecayRate = Number.isFinite(hasteDecay) ? Math.max(0, hasteDecay) : 0;
    const hasteMin = Number(target.hasteMinPct);
    target.hasteMinPct = Number.isFinite(hasteMin) ? Math.max(0, hasteMin) : 0;
  }

  function clampPracticeDummySize(value, fallback){
    const numeric = Number(value);
    if(Number.isFinite(numeric)){
      return Math.max(20, Math.min(400, numeric));
    }
    return Number.isFinite(fallback) ? fallback : 120;
  }

  function normalizePracticeDummyState(){
    if(!practiceDummy || typeof practiceDummy !== 'object'){
      return;
    }
    practiceDummy.size = clampPracticeDummySize(practiceDummy.size, 120);
    practiceDummy.maxHp = Math.max(1, Number(practiceDummy.maxHp) || 1);
    const hpValue = Number(practiceDummy.hp);
    practiceDummy.hp = Number.isFinite(hpValue) ? Math.max(0, Math.min(practiceDummy.maxHp, hpValue)) : practiceDummy.maxHp;
    practiceDummy.side = practiceDummy.side === 'blue' ? 'blue' : 'red';
    practiceDummy.radius = Number.isFinite(practiceDummy.radius) ? Math.max(0, practiceDummy.radius) : 900;
    practiceDummy.active = practiceDummy.active === false ? false : true;
    practiceDummy.respawnTimer = Math.max(0, Number(practiceDummy.respawnTimer) || 0);
    const response = practiceDummy.deathResponse === 'despawn' ? 'despawn' : 'respawn';
    practiceDummy.deathResponse = response;
    normalizePlayerControlState(practiceDummy);
    if(!practiceDummy.statuses || typeof practiceDummy.statuses !== 'object'){
      practiceDummy.statuses = buildDefaultPlayerStatusConfig();
    }
  }

  function sanitizeEmojiInput(value, fallback = 'ðŸŽ¯'){
    if(typeof value !== 'string'){
      return fallback;
    }
    const trimmed = value.trim();
    if(!trimmed){
      return fallback;
    }
    const glyphs = Array.from(trimmed);
    if(!glyphs.length){
      return fallback;
    }
    return glyphs.slice(0, 2).join('');
  }

  function normalizeCursorState(state){
    const defaults = { enabled: false, outlineEnabled: true, emoji: 'ðŸŽ¯', hoverColor: '#7fe3ff' };
    const normalized = {
      enabled: defaults.enabled,
      outlineEnabled: defaults.outlineEnabled,
      emoji: defaults.emoji,
      hoverColor: defaults.hoverColor
    };
    if(state && typeof state === 'object'){
      normalized.enabled = typeof state.enabled === 'boolean' ? state.enabled : defaults.enabled;
      normalized.outlineEnabled = typeof state.outlineEnabled === 'boolean' ? state.outlineEnabled : defaults.outlineEnabled;
      normalized.emoji = sanitizeEmojiInput(state.emoji, defaults.emoji);
      normalized.hoverColor = sanitizeHexColor(state.hoverColor, defaults.hoverColor);
    }
    return normalized;
  }

  function normalizePingState(state){
    const defaults = { onMyWay: 'ðŸƒ', enemyMissing: 'â“', assistMe: 'ðŸ†˜', target: 'ðŸŽ¯' };
    const types = {
      onMyWay: defaults.onMyWay,
      enemyMissing: defaults.enemyMissing,
      assistMe: defaults.assistMe,
      target: defaults.target
    };
    if(state && typeof state === 'object' && state.types && typeof state.types === 'object'){
      types.onMyWay = sanitizeEmojiInput(state.types.onMyWay, defaults.onMyWay);
      types.enemyMissing = sanitizeEmojiInput(state.types.enemyMissing, defaults.enemyMissing);
      types.assistMe = sanitizeEmojiInput(state.types.assistMe, defaults.assistMe);
      types.target = sanitizeEmojiInput(state.types.target, defaults.target);
    }
    const active = state && Array.isArray(state.active) ? state.active : [];
    return { types, active };
  }

  function normalizeKeybindState(state){
    const attackDefaults = { key: '', code: '' };
    const pingDefaults = { key: 'g', code: 'KeyG' };
    const attackRaw = state && typeof state === 'object' ? state.attackMove : null;
    const pingRaw = state && typeof state === 'object' ? state.pingWheel : null;
    const attackKey = attackRaw && typeof attackRaw.key === 'string' ? attackRaw.key : attackDefaults.key;
    const attackCode = attackRaw && typeof attackRaw.code === 'string' ? attackRaw.code : attackDefaults.code;
    const pingKey = pingRaw && typeof pingRaw.key === 'string' ? pingRaw.key : pingDefaults.key;
    const pingCode = pingRaw && typeof pingRaw.code === 'string' ? pingRaw.code : pingDefaults.code;
    return {
      attackMove: {
        key: attackKey,
        code: attackCode,
        label: formatAbilityKeyLabel(attackKey, attackCode)
      },
      pingWheel: {
        key: pingKey,
        code: pingCode,
        label: formatAbilityKeyLabel(pingKey, pingCode)
      }
    };
  }

  function replaceRefs(original, clone, context){
    if(!original || !clone || typeof original !== 'object' || typeof clone !== 'object'){
      return;
    }
    if(Array.isArray(clone)){
      const originalArray = Array.isArray(original) ? original : [];
      clone.forEach((item, index)=>{
        replaceRefs(originalArray[index], item, context);
      });
      return;
    }
    for(const key of Object.keys(clone)){
      const originalValue = original[key];
      const clonedValue = clone[key];
      if(!originalValue || typeof originalValue !== 'object'){
        continue;
      }
      if(context.minionIndexMap.has(originalValue)){
        clone[key] = null;
        clone[`${key}Id`] = context.minionIndexMap.get(originalValue);
        continue;
      }
      if(originalValue === context.player){
        clone[key] = null;
        clone[`${key}RefType`] = 'player';
        continue;
      }
      replaceRefs(originalValue, clonedValue, context);
    }
  }

  function restoreRefs(target, context){
    if(!target || typeof target !== 'object'){
      return;
    }
    if(Array.isArray(target)){
      target.forEach(item => restoreRefs(item, context));
      return;
    }
    for(const key of Object.keys(target)){
      if(key.endsWith('Id')){
        const base = key.slice(0, -2);
        const id = target[key];
        if(Number.isInteger(id) && id >= 0 && id < context.minions.length){
          target[base] = context.minions[id];
        } else {
          target[base] = null;
        }
        delete target[key];
        continue;
      }
      if(key.endsWith('RefType')){
        const base = key.slice(0, -7);
        target[base] = target[key] === 'player' ? context.player : null;
        delete target[key];
        continue;
      }
      restoreRefs(target[key], context);
    }
  }

  function assignArray(target, source){
    if(!Array.isArray(target)){
      return;
    }
    target.length = 0;
    if(!Array.isArray(source)){
      return;
    }
    source.forEach(item => {
      target.push(deepClone(item));
    });
  }

  function assignDeep(target, source){
    if(!target || typeof target !== 'object' || !source || typeof source !== 'object'){
      return;
    }
    for(const [key, value] of Object.entries(source)){
      if(Array.isArray(value)){
        if(!Array.isArray(target[key])){
          target[key] = [];
        }
        assignArray(target[key], value);
        continue;
      }
      if(value && typeof value === 'object'){
        if(!target[key] || typeof target[key] !== 'object'){
          target[key] = {};
        }
        assignDeep(target[key], value);
        continue;
      }
      target[key] = value;
    }
  }

  function buildExportSnapshot(){
    const minionIndexMap = new Map();
    GameState.minions.forEach((minion, index) => {
      minionIndexMap.set(minion, index);
    });
    const context = { minionIndexMap, player };

    const metaClone = deepClone(GameState.meta);
    if(metaClone && Object.prototype.hasOwnProperty.call(metaClone, 'lastUpdate')){
      delete metaClone.lastUpdate;
    }

    const mapClone = deepClone(GameState.map);
    const cameraClone = deepClone(cameraState);
    if(cameraClone && cameraClone.drag){
      cameraClone.drag.last = null;
    }
    const hudClone = deepClone(hudState);
    if(hudClone && hudClone.hudMessage){
      hudClone.hudMessage.timer = null;
    }

    const spawnsClone = deepClone(GameState.spawns);
    const lanesClone = deepClone(GameState.lanes);
    const itemsClone = deepClone(GameState.items);
    const effectsClone = deepClone(GameState.effects);

    replaceRefs(GameState.spawns, spawnsClone, context);
    replaceRefs(GameState.lanes, lanesClone, context);
    replaceRefs(GameState.items, itemsClone, context);
    replaceRefs(GameState.effects, effectsClone, context);

    const minionSnapshots = GameState.minions.map((minion, index) => {
      const clone = deepClone(minion);
      clone.__id = index;
      replaceRefs(minion, clone, context);
      return clone;
    });

    const playerClone = deepClone(player);
    replaceRefs(player, playerClone, context);

    const prayersSnapshot = (()=>{
      const snapshot = { active: null, bindings: buildDefaultPrayerBindings() };
      if(prayerState && typeof prayerState === 'object'){
        const activeId = typeof prayerState.active === 'string' ? prayerState.active : null;
        snapshot.active = PRAYER_DEFS.some(def => def.id === activeId) ? activeId : null;
        if(prayerState.bindings && typeof prayerState.bindings === 'object'){
          snapshot.bindings = deepClone(prayerState.bindings);
        }
      }
      return snapshot;
    })();

    const monsterSnapshot = (()=>{
      const source = monsterState && typeof monsterState === 'object' ? monsterState : createDefaultMonsterState();
      const snapshot = deepClone(source);
      if(!Array.isArray(snapshot.abilityQueue)){
        snapshot.abilityQueue = [];
      }
      if(!snapshot.projectileIcons || typeof snapshot.projectileIcons !== 'object'){
        snapshot.projectileIcons = { ...DEFAULT_MONSTER_ICONS };
      }
      return snapshot;
    })();

    const practiceDummySnapshot = practiceDummy ? (()=>{
      const maxHpValue = Math.max(1, Number(practiceDummy.maxHp) || practiceDummyDefaults.maxHp);
      const hpValue = Math.max(0, Math.min(maxHpValue, Number(practiceDummy.hp) || 0));
      const snapshot = {
        active: practiceDummy.active !== false && !(practiceDummy.respawnTimer > 0),
        x: Number(practiceDummy.x) || 0,
        y: Number(practiceDummy.y) || 0,
        size: clampPracticeDummySize(practiceDummy.size, practiceDummyDefaults.size),
        maxHp: maxHpValue,
        hp: hpValue,
        side: practiceDummy.side === 'blue' ? 'blue' : 'red',
        deathResponse: practiceDummy.deathResponse === 'despawn' ? 'despawn' : 'respawn'
      };
      if(practiceDummy.statuses && typeof practiceDummy.statuses === 'object'){
        snapshot.statuses = deepClone(practiceDummy.statuses);
      }
      return snapshot;
    })() : null;
    const turretsSnapshot = deepClone(normalizeTurretState(GameState.turrets));

    return {
      meta: metaClone,
      map: mapClone,
      player: playerClone,
      camera: cameraClone,
      hud: hudClone,
      prayers: prayersSnapshot,
      monster: monsterSnapshot,
      practiceDummy: practiceDummySnapshot,
      turrets: turretsSnapshot,
      spawns: spawnsClone,
      lanes: lanesClone,
      minions: minionSnapshots,
      items: itemsClone,
      effects: effectsClone
    };
  }

  function exportGameState(){
    try {
      const snapshot = buildExportSnapshot();
      return JSON.stringify(snapshot, null, 2);
    } catch (err){
      console.error('exportGameState failed', err);
      return '';
    }
  }

  function importGameState(json){
    const errors = [];
    let snapshot = null;
    if(typeof json === 'string'){
      if(json.trim().length === 0){
        errors.push('Snapshot JSON is empty.');
      } else {
        try {
          snapshot = JSON.parse(json);
        } catch (err){
          errors.push(`Invalid JSON: ${err && err.message ? err.message : err}`);
        }
      }
    } else if(json && typeof json === 'object'){
      snapshot = deepClone(json);
    } else {
      errors.push('Snapshot must be provided as a JSON string or plain object.');
    }

    if(!snapshot || typeof snapshot !== 'object'){
      errors.push('Snapshot root must be an object.');
    }

    if(errors.length){
      return { ok: false, errors };
    }

    const requiredSections = ['meta', 'map', 'player', 'camera', 'hud', 'spawns', 'lanes', 'minions', 'items', 'effects'];
    for(const key of requiredSections){
      if(!Object.prototype.hasOwnProperty.call(snapshot, key)){
        errors.push(`Snapshot missing required section "${key}".`);
      }
    }

    const isObject = (value) => value && typeof value === 'object' && !Array.isArray(value);
    const isFiniteNumber = (value) => Number.isFinite(Number(value));

    if(!isObject(snapshot.map)) errors.push('Snapshot map section must be an object.');
    if(!isObject(snapshot.player)) errors.push('Snapshot player section must be an object.');
    if(!isObject(snapshot.camera)) errors.push('Snapshot camera section must be an object.');
    if(!isObject(snapshot.hud)) errors.push('Snapshot hud section must be an object.');
    if(!isObject(snapshot.spawns)) errors.push('Snapshot spawns section must be an object.');
    if(!isObject(snapshot.lanes)) errors.push('Snapshot lanes section must be an object.');
    if(!isObject(snapshot.items)) errors.push('Snapshot items section must be an object.');
    if(!isObject(snapshot.effects)) errors.push('Snapshot effects section must be an object.');
    if(!Array.isArray(snapshot.minions)) errors.push('Snapshot minions section must be an array.');

    if(isObject(snapshot.map)){
      if(!isFiniteNumber(snapshot.map.width)) errors.push('map.width must be a finite number.');
      if(!isFiniteNumber(snapshot.map.height)) errors.push('map.height must be a finite number.');
    }
    if(isObject(snapshot.camera)){
      if(!isFiniteNumber(snapshot.camera.width)) errors.push('camera.width must be a finite number.');
      if(!isFiniteNumber(snapshot.camera.height)) errors.push('camera.height must be a finite number.');
    }

    if(errors.length){
      return { ok: false, errors };
    }

    try {
      assignDeep(GameState.meta, snapshot.meta || {});
      if(typeof GameState.meta.version !== 'string'){
        GameState.meta.version = '0.1.0';
      }

      assignDeep(mapState, snapshot.map || {});
      const hitboxState = mapState.hitbox;
      if(hitboxState && hitboxState.data && !(hitboxState.data instanceof Uint8Array)){
        if(Array.isArray(hitboxState.data)){
          hitboxState.data = Uint8Array.from(hitboxState.data);
        } else if(typeof hitboxState.data === 'object' && hitboxState.data !== null && Number.isFinite(hitboxState.data.length)){
          try {
            hitboxState.data = Uint8Array.from(hitboxState.data);
          } catch (err){
            console.warn('Unable to normalize hitbox data during import.', err);
          }
        }
      }

      assignDeep(cameraState, snapshot.camera || {});
      assignDeep(hudState, snapshot.hud || {});
      if(snapshot.prayers && typeof snapshot.prayers === 'object'){
        const snapshotPrayers = snapshot.prayers;
        if(snapshotPrayers.bindings && typeof snapshotPrayers.bindings === 'object'){
          prayerState.bindings = deepClone(snapshotPrayers.bindings);
        } else {
          prayerState.bindings = buildDefaultPrayerBindings();
        }
        rebuildPrayerBindingLookup(prayerState);
        const candidateActive = typeof snapshotPrayers.active === 'string' ? snapshotPrayers.active : null;
        prayerState.active = PRAYER_DEFS.some(def => def.id === candidateActive) ? candidateActive : null;
      } else {
        prayerState.bindings = buildDefaultPrayerBindings();
        prayerState.active = null;
        rebuildPrayerBindingLookup(prayerState);
      }
      ensurePrayerState();
      rebuildPrayerBindingLookup(prayerState);

      if(snapshot.monster && typeof snapshot.monster === 'object'){
        Object.assign(monsterState, createDefaultMonsterState());
        Object.assign(monsterState, deepClone(snapshot.monster));
      } else {
        Object.assign(monsterState, createDefaultMonsterState());
      }
      normalizeMonsterState(monsterState);
      ensureMonsterQueue(monsterState);
      if(practiceDummy){
        const snapshotPracticeDummy = snapshot.practiceDummy;
        const clampDummyCoord = (value, max) => {
          const numeric = Number(value);
          if(!Number.isFinite(numeric)){
            return null;
          }
          if(!(max > 0)){
            return Math.max(0, numeric);
          }
          return Math.max(0, Math.min(max, numeric));
        };
        if(snapshotPracticeDummy && typeof snapshotPracticeDummy === 'object'){
          const nextX = clampDummyCoord(snapshotPracticeDummy.x, mapState.width);
          if(nextX !== null){
            practiceDummy.x = nextX;
          }
          const nextY = clampDummyCoord(snapshotPracticeDummy.y, mapState.height);
          if(nextY !== null){
            practiceDummy.y = nextY;
          }
          if(Number.isFinite(Number(snapshotPracticeDummy.size))){
            practiceDummy.size = clampPracticeDummySize(snapshotPracticeDummy.size, practiceDummyDefaults.size);
          }
          if(Number.isFinite(Number(snapshotPracticeDummy.maxHp))){
            practiceDummy.maxHp = Math.max(1, Number(snapshotPracticeDummy.maxHp));
          }
          if(Number.isFinite(Number(snapshotPracticeDummy.hp))){
            practiceDummy.hp = Math.max(0, Math.min(practiceDummy.maxHp, Number(snapshotPracticeDummy.hp)));
          }
          if(typeof snapshotPracticeDummy.deathResponse === 'string'){
            practiceDummy.deathResponse = snapshotPracticeDummy.deathResponse === 'despawn' ? 'despawn' : 'respawn';
          }
          practiceDummy.active = snapshotPracticeDummy.active === false ? false : true;
          practiceDummy.respawnTimer = 0;
          if(practiceDummy.active === false){
            practiceDummy.hp = 0;
          }
          if(snapshotPracticeDummy.statuses && typeof snapshotPracticeDummy.statuses === 'object'){
            practiceDummy.statuses = deepClone(snapshotPracticeDummy.statuses);
          }
        } else {
          Object.assign(practiceDummy, createDefaultPracticeDummy());
        }
        normalizePracticeDummyState();
        practiceDummyState.placing = false;
        practiceDummyState.selected = false;
        practiceDummyState.dragging = false;
        practiceDummyState.pointerId = null;
        if(practiceDummyState.dragOffset){
          practiceDummyState.dragOffset.x = 0;
          practiceDummyState.dragOffset.y = 0;
        } else {
          practiceDummyState.dragOffset = { x: 0, y: 0 };
        }
      }
      hudState.playerFloat = normalizePlayerFloatState(hudState.playerFloat);
      assignDeep(GameState.turrets, snapshot.turrets || {});
      normalizeTurretState(GameState.turrets);
      markTurretsDirty();
      assignDeep(GameState.spawns, snapshot.spawns || {});
      assignDeep(GameState.lanes, snapshot.lanes || {});
      assignDeep(GameState.items, snapshot.items || {});
      assignDeep(GameState.effects, snapshot.effects || {});

      GameState.spawns.blue = Array.isArray(GameState.spawns.blue) ? GameState.spawns.blue : [];
      GameState.spawns.red = Array.isArray(GameState.spawns.red) ? GameState.spawns.red : [];
      GameState.spawns.pending = Array.isArray(GameState.spawns.pending) ? GameState.spawns.pending : [];
      GameState.lanes.configs = Array.isArray(GameState.lanes.configs) ? GameState.lanes.configs : [];
      GameState.items.abilityDefinitions = GameState.items.abilityDefinitions || {};
      const importedAbilityDefs = GameState.items.abilityDefinitions;
      if(importedAbilityDefs && typeof importedAbilityDefs === 'object'){
        Object.values(importedAbilityDefs).forEach(def => {
          if(!def || typeof def !== 'object') return;
          def.castType = normalizeAbilityCastType(def, def.castType);
        });
      }

      const runtime = player.runtime;
      assignDeep(player, snapshot.player || {});
      if(player.runtime !== runtime){
        Object.defineProperty(player, 'runtime', { value: runtime, writable: true, enumerable: false });
      }
      normalizePlayerControlState(player);
      setActivePrayer(prayerState.active);

      const minionSnapshots = Array.isArray(snapshot.minions) ? snapshot.minions : [];
      const minionClones = new Array(minionSnapshots.length);
      for(let i = 0; i < minionSnapshots.length; i++){
        const entry = minionSnapshots[i];
        if(!entry || typeof entry !== 'object'){
          errors.push(`Minion entry at index ${i} is not an object.`);
          continue;
        }
        const clone = deepClone(entry);
        const targetIndex = Number.isInteger(clone.__id) && clone.__id >= 0 ? clone.__id : i;
        delete clone.__id;
        minionClones[targetIndex] = clone;
      }
      minions.length = 0;
      for(let i = 0; i < minionClones.length; i++){
        if(minionClones[i]){
          minions.push(minionClones[i]);
        } else {
          minions.push({ side: 'neutral', x: 0, y: 0, hp: 0, maxHp: 0, dmg: 0 });
          errors.push(`Minion data missing for index ${i}.`);
        }
      }

      attachPracticeDummy();
      updatePracticeDummyHud();
      updatePracticeDummyStatusIcons();
      updatePracticeDummyUiState();
      positionPracticeDummyHud();

      syncMonsterInputs();
      updateMonsterAbilityQueueDisplay();
      updateMonsterHud();
      positionMonsterHud();

      updatePrayerButtons();
      updatePrayerHud();

      const restoreContext = { minions, player };
      minions.forEach((minion) => restoreRefs(minion, restoreContext));
      restoreRefs(GameState.spawns, restoreContext);
      restoreRefs(GameState.lanes, restoreContext);
      restoreRefs(GameState.items, restoreContext);
      restoreRefs(GameState.effects, restoreContext);
      restoreRefs(mapState, restoreContext);
      restoreRefs(hudState, restoreContext);
      restoreRefs(player, restoreContext);

      minionDiameter = Number(GameState.lanes.minion && GameState.lanes.minion.diameter) || 0;
      minionRadius = Number(GameState.lanes.minion && GameState.lanes.minion.radius) || (minionDiameter / 2);
      laneFanSpacing = Number(GameState.lanes.minion && GameState.lanes.minion.fanSpacing) || (minionDiameter > 0 ? minionDiameter * 1.35 : laneFanSpacing);

      cameraFollowLagMs = Number(camera.followLagMs) || 0;
      cameraLeadDistance = Number(camera.leadDistance) || 0;
      cameraHorizontalOffsetPercent = Number(camera.horizontalOffsetPercent) || 0;
      cameraVerticalOffsetPercent = Number(camera.verticalOffsetPercent) || 0;
      cameraEdgeScrollMargin = Number(camera.edgeScrollMargin) || 0;
      cameraEdgeScrollSpeed = Number(camera.edgeScrollSpeed) || 0;
      cameraRecenterDelayMs = Number(camera.recenterDelayMs) || 0;
      cameraManualLeash = Number(camera.manualLeash) || 0;
      cameraWheelSensitivity = Number(camera.wheelSensitivity) || 0;
      cameraZoomInLocked = !!camera.zoomInLocked;
      cameraZoomInLimit = camera.zoomInLimit != null && Number.isFinite(Number(camera.zoomInLimit)) ? Number(camera.zoomInLimit) : null;
      cameraZoomOutLocked = !!camera.zoomOutLocked;
      cameraZoomOutLimit = camera.zoomOutLimit != null && Number.isFinite(Number(camera.zoomOutLimit)) ? Number(camera.zoomOutLimit) : null;
      cameraLockBinding = camera.lockBinding ? { ...camera.lockBinding } : { key: ' ', code: 'Space', label: 'Space' };
      cameraLockCapture = !!camera.lockCapture;
      lastUnlockedCameraMode = typeof camera.lastUnlockedMode === 'string' ? camera.lastUnlockedMode : 'semi';
      cameraLastManualMoveAt = Number.isFinite(camera.lastManualMoveAt) ? camera.lastManualMoveAt : (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now());
      cameraDragActive = !!(camera.drag && camera.drag.active);
      cameraDragPointerId = camera.drag && Number.isFinite(camera.drag.pointerId) ? camera.drag.pointerId : null;
      cameraDragLast = camera.drag && camera.drag.last ? { ...camera.drag.last } : null;
      lastPlayerVelocityX = Number(camera.lastPlayerVelocity && camera.lastPlayerVelocity.x) || 0;
      lastPlayerVelocityY = Number(camera.lastPlayerVelocity && camera.lastPlayerVelocity.y) || 0;
      lastCameraTransformX = camera.lastTransform ? (camera.lastTransform.x ?? null) : null;
      lastCameraTransformY = camera.lastTransform ? (camera.lastTransform.y ?? null) : null;
      lastCameraTransformScale = camera.lastTransform ? (camera.lastTransform.scale ?? null) : null;
    } catch (err){
      console.error('importGameState failed', err);
      errors.push(err && err.message ? err.message : String(err));
    }

    if(img){
      const nextSrc = mapState.image && typeof mapState.image.src === 'string' ? mapState.image.src : '';
      if(nextSrc){
        if(img.src !== nextSrc){
          useArtImage(nextSrc, mapState.image.displayName);
        } else {
          setVars();
        }
      } else {
        img.removeAttribute('src');
        setVars();
      }
    } else {
      setVars();
    }

    if(fileName && mapState.image && typeof mapState.image.displayName === 'string' && mapState.image.displayName){
      fileName.textContent = mapState.image.displayName;
    }
    if(fileNameWrap){
      markFileLoaded(fileNameWrap, !!mapState.loaded);
    }
    if(hitboxImg){
      const nextHitboxSrc = mapState.image && typeof mapState.image.hitboxSrc === 'string' ? mapState.image.hitboxSrc : '';
      if(nextHitboxSrc){
        if(hitboxImg.src !== nextHitboxSrc){
          hitboxImg.src = nextHitboxSrc;
        }
      } else {
        hitboxImg.removeAttribute('src');
      }
    }
    if(hitboxName && mapState.hitbox){
      if(mapState.hitbox.displayName){
        hitboxName.textContent = mapState.hitbox.displayName;
      }
    }
    if(hitboxNameWrap){
      markFileLoaded(hitboxNameWrap, !!(mapState.hitbox && mapState.hitbox.loaded));
    }

    if(minionSizeInput){
      minionSizeInput.value = String(Math.round(minionDiameter));
    }

    setPlayerTeam(player.team);
    updateHudStats();
    updateHudHealth();
    positionPlayerFloatingHud();
    positionPracticeDummyHud();
    updateGoldUI();
    updateScoreUI();
    setAbilityBar(abilityBarState.count, abilityBarState.scale, true);
    setMinimapUserScale(minimapState.userScale, { syncInput: true });
    setMinimapClickToMove(minimapState.clickToMoveEnabled, { syncInput: true });
    setMinimapClickThrough(minimapState.clickThroughEnabled, { syncInput: true });
    setCameraMode(camera.mode, { syncInput: true, silent: true });
    setCameraFollowLag(cameraFollowLagMs, { syncInput: true });
    setCameraLead(cameraLeadDistance, { syncInput: true });
    setCameraHorizontalOffset(cameraHorizontalOffsetPercent, { syncInput: true });
    setCameraVerticalOffset(cameraVerticalOffsetPercent, { syncInput: true });
    setCameraEdgeMargin(cameraEdgeScrollMargin, { syncInput: true });
    setCameraEdgeSpeed(cameraEdgeScrollSpeed, { syncInput: true });
    setCameraRecenterDelay(cameraRecenterDelayMs, { syncInput: true });
    setCameraManualLeash(cameraManualLeash, { syncInput: true });
    setCameraWheelSensitivity(cameraWheelSensitivity, { syncInput: true });
    setCameraZoomInLock(cameraZoomInLocked, cameraZoomInLimit);
    setCameraZoomOutLock(cameraZoomOutLocked, cameraZoomOutLimit);
    updateCameraLockBindingDisplay();
    setDefaultSpellCastType(spellCastingConfig.defaultCastType, { syncInput: true });
    refreshSpellCastBindingDisplays();
    updateColliderUiState();
    updateVisionUiState();
    ensureDefaultSpawns(true);
    renderMinimap(true);
    scheduleHudFit();
    updateCamera(true, 0, { force: true });
    updateStagePointerState();

    return { ok: errors.length === 0, errors };
  }

  const sbHide = document.getElementById('sbHide');
  const sbFab = document.getElementById('sbFab');
  const sidebarEl = document.querySelector('.sidebar');
  const sbHeader = document.querySelector('.sb-header');
  const sbContent = document.querySelector('.sb-content');
  const settingsGenreSelect = document.getElementById('settingsGenre');

  const btnPlay = document.getElementById('btnPlay');
  const btnMap  = document.getElementById('btnMap');
  const btnHitbox = document.getElementById('btnHitbox');
  const btnGameState = document.getElementById('btnGameState');
  const fileInput = document.getElementById('file');
  const hitboxInput = document.getElementById('fileHitbox');
  const fileName  = document.getElementById('fileName');
  const fileNameWrap = document.getElementById('fileNameWrap');
  const hitboxName = document.getElementById('hitboxName');
  const hitboxNameWrap = document.getElementById('hitboxNameWrap');
  const gameStatePane = document.getElementById('gameStatePane');
  const gameStateImportButton = document.getElementById('gameStateImport');
  const gameStateExportButton = document.getElementById('gameStateExport');
  const gameStateImportInput = document.getElementById('gameStateImportFile');
  const btnColliders = document.getElementById('btnColliders');
  const colliderPane = document.getElementById('colliderPane');
  const colliderEditToggle = document.getElementById('colliderEditToggle');
  const colliderShapeSelect = document.getElementById('colliderShape');
  const colliderRadiusRange = document.getElementById('colliderRadius');
  const colliderRadiusDisplay = document.getElementById('colliderRadiusDisplay');
  const colliderInnerRadiusRow = document.getElementById('colliderInnerRadiusRow');
  const colliderInnerRadiusRange = document.getElementById('colliderInnerRadius');
  const colliderInnerRadiusDisplay = document.getElementById('colliderInnerRadiusDisplay');
  const colliderOffsetRow = document.getElementById('colliderOffsetRow');
  const colliderOffsetRange = document.getElementById('colliderOffset');
  const colliderOffsetDisplay = document.getElementById('colliderOffsetDisplay');
  const colliderLengthRow = document.getElementById('colliderLengthRow');
  const colliderLengthRange = document.getElementById('colliderLength');
  const colliderLengthDisplay = document.getElementById('colliderLengthDisplay');
  const colliderRotationRow = document.getElementById('colliderRotationRow');
  const colliderRotationRange = document.getElementById('colliderRotation');
  const colliderRotationDisplay = document.getElementById('colliderRotationDisplay');
  const colliderPlaceButton = document.getElementById('colliderPlace');
  const colliderToggleVisibilityButton = document.getElementById('colliderToggleVisibility');
  const colliderDeleteButton = document.getElementById('colliderDelete');
  const colliderLoadButton = document.getElementById('colliderLoad');
  const colliderSaveButton = document.getElementById('colliderSave');
  const colliderImportInput = document.getElementById('colliderImport');
  const colliderListEl = document.getElementById('colliderList');

  const btnVision = document.getElementById('btnVision');
  const visionPane = document.getElementById('visionPane');
  const visionEditToggle = document.getElementById('visionEditToggle');
  const visionShapeSelect = document.getElementById('visionShape');
  const visionRadiusRange = document.getElementById('visionRadius');
  const visionRadiusDisplay = document.getElementById('visionRadiusDisplay');
  const visionInnerRadiusRow = document.getElementById('visionInnerRadiusRow');
  const visionInnerRadiusRange = document.getElementById('visionInnerRadius');
  const visionInnerRadiusDisplay = document.getElementById('visionInnerRadiusDisplay');
  const visionOffsetRow = document.getElementById('visionOffsetRow');
  const visionOffsetRange = document.getElementById('visionOffset');
  const visionOffsetDisplay = document.getElementById('visionOffsetDisplay');
  const visionLengthRow = document.getElementById('visionLengthRow');
  const visionLengthRange = document.getElementById('visionLength');
  const visionLengthDisplay = document.getElementById('visionLengthDisplay');
  const visionRotationRow = document.getElementById('visionRotationRow');
  const visionRotationRange = document.getElementById('visionRotation');
  const visionRotationDisplay = document.getElementById('visionRotationDisplay');
  const visionFullRevealInput = document.getElementById('visionFullReveal');
  const visionModeInput = document.getElementById('visionMode');
  const visionPlaceButton = document.getElementById('visionPlace');
  const visionToggleVisibilityButton = document.getElementById('visionToggleVisibility');
  const visionDeleteButton = document.getElementById('visionDelete');
  const visionListEl = document.getElementById('visionList');
  const playerVisionRadiusInput = document.getElementById('GameState.player.vision.radius');
  const playerVisionRadiusDisplay = document.getElementById('playerVisionRadiusDisplay');
  const visionDummyPlaceButton = document.getElementById('visionDummyPlace');
  const visionDummyRadiusInput = document.getElementById('visionDummyRadius');
  practiceDummyMoveButton = document.getElementById('practiceDummyMove');
  practiceDummyResetButton = document.getElementById('practiceDummyReset');
  practiceDummyRemoveButton = document.getElementById('practiceDummyRemove');
  practiceDummySizeInput = document.getElementById('practiceDummySize');
  practiceDummySizeDisplay = document.getElementById('practiceDummySizeDisplay');
  practiceDummyDeathResponseSelect = document.getElementById('practiceDummyDeathResponse');
  const btnPracticeDummy = document.getElementById('btnPracticeDummy');
  const practiceDummyPane = document.getElementById('practiceDummyPane');
  const btnPrayers = document.getElementById('btnPrayers');
  const prayerPane = document.getElementById('prayerPane');
  const prayerListEl = document.getElementById('prayerList');
  const btnMonsters = document.getElementById('btnMonsters');
  const monsterPane = document.getElementById('monsterPane');
  const monsterMoveButton = document.getElementById('monsterMove');
  const monsterAggroRadiusInput = document.getElementById('monsterAggroRadius');
  const monsterSizeInput = document.getElementById('monsterSize');
  const monsterMaxHpInput = document.getElementById('monsterMaxHp');
  const monsterProjectileDamageInput = document.getElementById('monsterProjectileDamage');
  const monsterCastIntervalInput = document.getElementById('monsterCastInterval');
  const monsterQueueSizeInput = document.getElementById('monsterQueueSize');
  const monsterSlotSpinInput = document.getElementById('monsterSlotSpin');
  const monsterSlotRevealInput = document.getElementById('monsterSlotReveal');
  const monsterFreezeDurationInput = document.getElementById('monsterFreezeDuration');
  const monsterSpeedBoostPctInput = document.getElementById('monsterSpeedBoostPct');
  const monsterHealAmountInput = document.getElementById('monsterHealAmount');
  const monsterIconGreenInput = document.getElementById('monsterIconGreen');
  const monsterIconBlueInput = document.getElementById('monsterIconBlue');
  const monsterIconRedInput = document.getElementById('monsterIconRed');

  const btnMinions= document.getElementById('btnMinions');
  const minionsPane = document.getElementById('minionsPane');
  const btnSpawnBlue = document.getElementById('btnSpawnBlue');
  const btnSpawnRed  = document.getElementById('btnSpawnRed');
  const btnPlayer = document.getElementById('btnPlayer');
  const playerPane = document.getElementById('playerPane');
  const btnHealth = document.getElementById('btnHealth');
  const healthPane = document.getElementById('healthPane');
  const btnAnimation = document.getElementById('btnAnimation');
  const animationPane = document.getElementById('animationPane');
  const btnPlayerAnimation = document.getElementById('btnPlayerAnimation');
  const playerAnimationSection = document.getElementById('playerAnimationSection');
  const playerAnimationFileInput = document.getElementById('playerAnimationFile');
  const defaultPlayerAnimationAccept = playerAnimationFileInput ? (playerAnimationFileInput.getAttribute('accept') || '') : '';
  const btnPlayerAnimationLoad = document.getElementById('btnPlayerAnimationLoad');
  const btnPlayerAnimationLoadGlb = document.getElementById('btnPlayerAnimationLoadGlb');
  const btnPlayerAnimationMixamoCombine = document.getElementById('btnPlayerAnimationMixamoCombine');
  const btnPlayerAnimationLoadSetup = document.getElementById('btnPlayerAnimationLoadSetup');
  const btnPlayerAnimationSave = document.getElementById('btnPlayerAnimationSave');
  const btnPlayerAnimationClear = document.getElementById('btnPlayerAnimationClear');
  const playerAnimationStatus = document.getElementById('playerAnimationStatus');
  const playerAnimationCanvas = document.getElementById('playerAnimationCanvas');
  const playerAnimationStage = document.getElementById('playerAnimationStage');
  const playerAnimationDrop = document.getElementById('playerAnimationDrop');
  const playerAnimationMaterialsEl = document.getElementById('playerAnimationMaterials');
  const playerAnimationConfigInput = document.getElementById('playerAnimationConfigFile');
  const playerMixamoBaseInput = document.getElementById('playerMixamoBaseFile');
  const playerMixamoAnimationInput = document.getElementById('playerMixamoAnimationFiles');
  const playerAnimationScaleRange = document.getElementById('playerAnimationScaleRange');
  const playerAnimationScaleInput = document.getElementById('playerAnimationScaleInput');
  const playerAnimationLightAngleRange = document.getElementById('playerAnimationLightAngleRange');
  const playerAnimationLightAngleInput = document.getElementById('playerAnimationLightAngleInput');
  const playerAnimationOffsetHorizontalInput = document.getElementById('playerAnimationOffsetHorizontalInput');
  const playerAnimationOffsetVerticalInput = document.getElementById('playerAnimationOffsetVerticalInput');
  const playerModelAnchor = document.getElementById('playerModelAnchor');
  const playerModelCanvas = document.getElementById('playerModelCanvas');
  const playerAnimationActionSelects = {
    idle: document.getElementById('playerAnimationAction-idle'),
    move: document.getElementById('playerAnimationAction-move'),
    autoAttack: document.getElementById('playerAnimationAction-attack'),
    cast: document.getElementById('playerAnimationAction-cast'),
    death: document.getElementById('playerAnimationAction-death'),
    taunt: document.getElementById('playerAnimationAction-taunt')
  };
  const playerAnimationActionInputs = {
    idle: {
      speed: document.getElementById('playerAnimationAction-idle-speed'),
      startFrame: document.getElementById('playerAnimationAction-idle-start'),
      endFrame: document.getElementById('playerAnimationAction-idle-end')
    },
    move: {
      speed: document.getElementById('playerAnimationAction-move-speed'),
      startFrame: document.getElementById('playerAnimationAction-move-start'),
      endFrame: document.getElementById('playerAnimationAction-move-end')
    },
    autoAttack: {
      speed: document.getElementById('playerAnimationAction-attack-speed'),
      startFrame: document.getElementById('playerAnimationAction-attack-start'),
      endFrame: document.getElementById('playerAnimationAction-attack-end')
    },
    cast: {
      speed: document.getElementById('playerAnimationAction-cast-speed'),
      startFrame: document.getElementById('playerAnimationAction-cast-start'),
      endFrame: document.getElementById('playerAnimationAction-cast-end')
    },
    death: {
      speed: document.getElementById('playerAnimationAction-death-speed'),
      startFrame: document.getElementById('playerAnimationAction-death-start'),
      endFrame: document.getElementById('playerAnimationAction-death-end')
    },
    taunt: {
      speed: document.getElementById('playerAnimationAction-taunt-speed'),
      startFrame: document.getElementById('playerAnimationAction-taunt-start'),
      endFrame: document.getElementById('playerAnimationAction-taunt-end')
    }
  };

  const PLAYER_ANIMATION_ACTIONS = ['idle', 'move', 'autoAttack', 'cast', 'death', 'taunt'];
  const PLAYER_MODEL_OFFSET_MIN = -1000;
  const PLAYER_MODEL_OFFSET_MAX = 1000;
  const PLAYER_MODEL_DEFAULT_PX_PER_WORLD = 28;
  const PLAYER_ANIMATION_STORAGE_KEY = 'maka-player-animation-configs';
  const SECTION_STORAGE_PREFIX = 'maka-section-config:';

  function formatSectionConfigFilename(prefix = 'section'){
    const baseLabel = typeof prefix === 'string' && prefix.trim() ? prefix.trim() : 'section';
    const sanitized = baseLabel.replace(/[^a-z0-9_\-]+/gi, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    const safeBase = (sanitized || 'section').toLowerCase();
    const now = new Date();
    const pad = (value)=> String(value).padStart(2, '0');
    const stamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    return `${safeBase}-setup-${stamp}.json`;
  }

  function downloadJson(data, filename){
    try {
      const json = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename || formatSectionConfigFilename();
      const parent = document.body || document.documentElement;
      if(parent){
        parent.appendChild(link);
        link.click();
        parent.removeChild(link);
      } else {
        link.click();
      }
      setTimeout(()=> URL.revokeObjectURL(url), 0);
      return true;
    } catch (err){
      console.error('Failed to export configuration', err);
      return false;
    }
  }

  function getStoredSectionConfig(storageKey){
    if(!storageKey || typeof localStorage === 'undefined'){ return null; }
    try {
      const raw = localStorage.getItem(storageKey);
      if(!raw){ return null; }
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === 'object' ? parsed : null;
    } catch (err){
      console.warn('Failed to read stored section configuration', err);
      return null;
    }
  }

  function setStoredSectionConfig(storageKey, snapshot){
    if(!storageKey || typeof localStorage === 'undefined'){ return false; }
    try {
      localStorage.setItem(storageKey, JSON.stringify(snapshot));
      return true;
    } catch (err){
      console.warn('Failed to persist section configuration', err);
      return false;
    }
  }

  function defaultBuildSectionSnapshot(pane){
    if(!pane){
      return null;
    }
    const controls = Array.from(pane.querySelectorAll('input, select, textarea')).filter(control => control && control.id && control.type !== 'file');
    if(!controls.length){
      return null;
    }
    const values = {};
    controls.forEach(control => {
      const type = (control.type || '').toLowerCase();
      if(type === 'radio'){ return; }
      if(type === 'checkbox'){
        values[control.id] = { kind: 'checked', value: !!control.checked };
      } else {
        values[control.id] = { kind: 'value', value: control.value };
      }
    });
    return {
      version: 1,
      savedAt: new Date().toISOString(),
      values
    };
  }

  function defaultApplySectionSnapshot(pane, snapshot){
    if(!pane || !snapshot || typeof snapshot !== 'object'){ return false; }
    const values = snapshot.values;
    if(!values || typeof values !== 'object'){ return false; }
    let applied = false;
    for(const [id, entry] of Object.entries(values)){
      if(!entry || typeof entry !== 'object'){ continue; }
      const control = document.getElementById(id);
      if(!control){ continue; }
      const type = (control.type || '').toLowerCase();
      if(entry.kind === 'checked'){
        if(type === 'checkbox'){
          control.checked = !!entry.value;
          control.dispatchEvent(new Event('change', { bubbles: true }));
          applied = true;
        }
        continue;
      }
      if('value' in control){
        control.value = entry.value;
        if(control.tagName === 'SELECT'){
          control.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          control.dispatchEvent(new Event('input', { bubbles: true }));
          control.dispatchEvent(new Event('change', { bubbles: true }));
        }
        applied = true;
      }
    }
    return applied;
  }

  function triggerFileInputPicker(input){
    if(!input){
      return false;
    }
    try {
      if(typeof input.showPicker === 'function'){
        const maybePromise = input.showPicker();
        if(maybePromise && typeof maybePromise.catch === 'function'){
          maybePromise.catch(()=>{
            try {
              input.click();
            } catch (clickErr){
              console.error('File picker click() fallback failed', clickErr);
            }
          });
        }
        return true;
      }
    } catch (err){
      console.warn('File picker showPicker() failed, falling back to click()', err);
    }
    try {
      input.click();
      return true;
    } catch (err){
      console.error('File picker click() failed', err);
      return false;
    }
  }

  function setupSectionPersistence({
    paneId,
    saveButtonId,
    loadButtonId,
    fileInputId,
    storageKey,
    label = 'Section',
    filePrefix,
    buildSnapshot,
    applySnapshot
  }){
    const pane = paneId ? document.getElementById(paneId) : null;
    const saveButton = saveButtonId ? document.getElementById(saveButtonId) : null;
    const loadButton = loadButtonId ? document.getElementById(loadButtonId) : null;
    const fileInput = fileInputId ? document.getElementById(fileInputId) : null;
    if(!pane){
      return;
    }
    const sectionLabel = label;
    const build = typeof buildSnapshot === 'function'
      ? ()=> buildSnapshot({ pane })
      : ()=> defaultBuildSectionSnapshot(pane);
    const apply = typeof applySnapshot === 'function'
      ? (snapshot)=> applySnapshot(snapshot, { pane })
      : (snapshot)=> defaultApplySectionSnapshot(pane, snapshot);

    if(saveButton){
      saveButton.addEventListener('click', ()=>{
        const snapshot = build();
        if(!snapshot){
          if(typeof setHudMessage === 'function'){
            setHudMessage(`No ${sectionLabel.toLowerCase()} settings to save yet.`);
          }
          return;
        }
        if(storageKey){
          setStoredSectionConfig(storageKey, snapshot);
        }
        const filename = formatSectionConfigFilename(filePrefix || sectionLabel);
        const exported = downloadJson(snapshot, filename);
        if(exported && typeof setHudMessage === 'function'){
          setHudMessage(`${sectionLabel} setup saved.`);
        }
      });
    }

    if(loadButton){
      loadButton.addEventListener('click', ()=>{
        if(fileInput){
          fileInput.value = '';
          if(!triggerFileInputPicker(fileInput)){
            alert('Unable to open file picker.');
          }
          return;
        }
        if(!storageKey){
          return;
        }
        const stored = getStoredSectionConfig(storageKey);
        if(stored && apply(stored)){
          if(typeof setHudMessage === 'function'){
            setHudMessage(`${sectionLabel} setup loaded.`);
          }
        } else if(typeof setHudMessage === 'function'){
          setHudMessage(`No ${sectionLabel.toLowerCase()} setup found to load.`);
        }
      });
    }

    if(fileInput){
      fileInput.addEventListener('change', ()=>{
        const file = fileInput.files && fileInput.files[0];
        if(!file){
          return;
        }
        const reader = new FileReader();
        reader.addEventListener('load', ()=>{
          try {
            const text = typeof reader.result === 'string' ? reader.result : '';
            const parsed = JSON.parse(text);
            if(apply(parsed)){
              if(storageKey){
                setStoredSectionConfig(storageKey, parsed);
              }
              if(typeof setHudMessage === 'function'){
                setHudMessage(`${sectionLabel} setup imported.`);
              }
            } else {
              alert(`Unable to apply ${sectionLabel.toLowerCase()} setup.`);
            }
          } catch (err){
            console.error(`Failed to parse ${sectionLabel} configuration`, err);
            alert(`Unable to parse ${sectionLabel.toLowerCase()} setup file.`);
          }
        });
        reader.addEventListener('error', ()=>{
          alert(`Unable to read ${sectionLabel.toLowerCase()} setup file.`);
        });
        reader.readAsText(file);
        fileInput.value = '';
      });
    }

    if(storageKey){
      try {
        const stored = getStoredSectionConfig(storageKey);
        if(stored){
          apply(stored);
        }
      } catch (err){
        console.warn(`Failed to restore ${sectionLabel} configuration`, err);
      }
    }
  }

  function normalizeVisionType(value){
    const raw = typeof value === 'string' ? value.trim().toLowerCase() : '';
    if(raw === 'capsule' || raw === 'crescent'){ return raw; }
    return 'circle';
  }

  function normalizeVisionMode(value){
    if(value === null || value === undefined){
      return 1;
    }
    if(typeof value === 'string'){
      const raw = value.trim().toLowerCase();
      if(raw === 'hiding' || raw === 'hide'){ return 2; }
      if(raw === 'vision'){ return 1; }
      const numeric = Number(raw);
      if(Number.isFinite(numeric) && numeric === 2){ return 2; }
      if(Number.isFinite(numeric) && numeric === 1){ return 1; }
      return 1;
    }
    const num = Number(value);
    if(Number.isFinite(num) && num === 2){ return 2; }
    return 1;
  }
  function visionModeToOption(mode){
    return mode === 2 ? 'hiding' : 'vision';
  }

  function setVisionFullReveal(value, { syncInput = true } = {}){
    const enabled = value === true || value === 'true' || value === 'on' || value === '1';
    GameState.player.vision.fullReveal = !!enabled;
    if(syncInput && visionFullRevealInput){
      visionFullRevealInput.checked = enabled;
    }
    renderMinimap(true);
  }

  function buildVisionSnapshot(){
    const sources = customVisionSources.map(source => {
      const entry = {
        id: Number.isFinite(source && source.id) ? Number(source.id) : 0,
        type: normalizeVisionType(source && source.type),
        mode: normalizeVisionMode(source && source.mode),
        x: Number(source && source.x) || 0,
        y: Number(source && source.y) || 0,
        radius: Number(source && source.radius) || 0,
        innerRadius: Number(source && source.innerRadius) || 0,
        offset: Number(source && source.offset) || 0,
        length: Number(source && source.length) || 0,
        angle: Number(source && source.angle) || 0,
        angleDeg: Number.isFinite(source && source.angleDeg) ? Number(source.angleDeg) : radToDeg(Number(source && source.angle) || 0)
      };
      return entry;
    });
    return {
      version: 1,
      savedAt: new Date().toISOString(),
      sequence: GameState.player.vision.nextId,
      fullReveal: GameState.player.vision.fullReveal !== false,
      visionRadius: Number(GameState.player.vision.radius) || 0,
      dummy: {
        active: practiceDummy && practiceDummy.active !== false,
        x: Number(practiceDummy && practiceDummy.x) || 0,
        y: Number(practiceDummy && practiceDummy.y) || 0,
        size: clampPracticeDummySize(practiceDummy && practiceDummy.size, practiceDummyDefaults.size),
        hp: Math.max(0, Number(practiceDummy && practiceDummy.hp) || 0),
        maxHp: Math.max(1, Number(practiceDummy && practiceDummy.maxHp) || practiceDummyDefaults.maxHp),
        radius: Number(practiceDummy && practiceDummy.radius) || 0,
        deathResponse: practiceDummy && practiceDummy.deathResponse === 'despawn' ? 'despawn' : 'respawn'
      },
      defaults: {
        type: normalizeVisionType(visionDefaults.type),
        mode: normalizeVisionMode(visionDefaults.mode),
        radius: Number(visionDefaults.radius) || 0,
        innerRadius: Number(visionDefaults.innerRadius) || 0,
        offset: Number(visionDefaults.offset) || 0,
        length: Number(visionDefaults.length) || 0,
        angleDeg: Number(visionDefaults.angleDeg) || 0
      },
      sources
    };
  }

  function applyVisionSnapshot(snapshot){
    if(!snapshot || typeof snapshot !== 'object'){ return false; }
    const sources = Array.isArray(snapshot.sources) ? snapshot.sources : [];
    customVisionSources.length = 0;
    let maxId = 0;
    sources.forEach(item => {
      if(!item || typeof item !== 'object'){ return; }
      const entryId = Number.isFinite(item.id) ? Number(item.id) : null;
      const entry = {
        id: entryId !== null ? entryId : GameState.player.vision.nextId++,
        type: normalizeVisionType(item.type),
        mode: normalizeVisionMode(item.mode),
        x: Number(item.x) || 0,
        y: Number(item.y) || 0,
        radius: Number(item.radius) || 0,
        innerRadius: Number(item.innerRadius),
        offset: Number(item.offset),
        length: Number(item.length),
        angle: Number(item.angle)
      };
      if(!Number.isFinite(entry.angle)){
        const fallbackDeg = Number.isFinite(item.angleDeg) ? Number(item.angleDeg) : 0;
        entry.angle = degToRad(fallbackDeg);
      }
      if(!Number.isFinite(entry.innerRadius)){
        delete entry.innerRadius;
      }
      if(!Number.isFinite(entry.offset)){
        delete entry.offset;
      }
      if(!Number.isFinite(entry.length)){
        delete entry.length;
      }
      ensureVisionConsistency(entry);
      customVisionSources.push(entry);
      if(Number.isFinite(entry.id) && entry.id > maxId){
        maxId = entry.id;
      }
    });
    const sequenceValue = Number(snapshot.sequence);
    if(Number.isFinite(sequenceValue) && sequenceValue >= 0){
      GameState.player.vision.nextId = Math.max(sequenceValue, maxId + 1);
    } else {
      GameState.player.vision.nextId = maxId + 1;
    }

    const radiusValue = Number(snapshot.visionRadius);
    if(Number.isFinite(radiusValue)){
      GameState.player.vision.radius = clampSettingValue(radiusValue, SETTINGS_RANGE_MIN);
    }
    setVisionFullReveal(snapshot.fullReveal !== false, { syncInput: true });

    const dummy = snapshot.dummy || {};
    if(practiceDummy){
      practiceDummy.active = dummy.active !== false;
      const clampCoord = (value, max) => Math.max(0, Math.min(max, Number.isFinite(value) ? value : 0));
      if(Number.isFinite(Number(dummy.x))){
        practiceDummy.x = clampCoord(Number(dummy.x), mapState.width);
      }
      if(Number.isFinite(Number(dummy.y))){
        practiceDummy.y = clampCoord(Number(dummy.y), mapState.height);
      }
      const sizeValue = Number(dummy.size);
      if(Number.isFinite(sizeValue)){
        practiceDummy.size = clampPracticeDummySize(sizeValue, practiceDummyDefaults.size);
      } else {
        const legacyRadius = Number(dummy.radius);
        if(Number.isFinite(legacyRadius)){
          practiceDummy.size = clampPracticeDummySize(legacyRadius * 2, practiceDummyDefaults.size);
          practiceDummy.radius = clampSettingValue(legacyRadius, SETTINGS_RANGE_MIN);
        }
      }
      const maxHpValue = Number(dummy.maxHp);
      if(Number.isFinite(maxHpValue)){
        practiceDummy.maxHp = Math.max(1, maxHpValue);
      }
      const hpValue = Number(dummy.hp);
      if(Number.isFinite(hpValue)){
        practiceDummy.hp = Math.max(0, Math.min(practiceDummy.maxHp, hpValue));
      } else {
        practiceDummy.hp = Math.max(0, Math.min(practiceDummy.maxHp, Number(practiceDummy.hp) || practiceDummy.maxHp));
      }
      if(!Number.isFinite(sizeValue) && Number.isFinite(Number(dummy.radius))){
        practiceDummy.radius = clampSettingValue(Number(dummy.radius), SETTINGS_RANGE_MIN);
      }
      if(typeof dummy.deathResponse === 'string'){
        practiceDummy.deathResponse = dummy.deathResponse === 'despawn' ? 'despawn' : 'respawn';
      }
      practiceDummy.respawnTimer = 0;
      practiceDummyState.selected = false;
      normalizePracticeDummyState();
      refreshPracticeDummyAnchors();
      updatePracticeDummyUiState();
      updatePracticeDummyHud();
      updatePracticeDummyStatusIcons();
      positionPracticeDummyHud();
      renderMinimap(true);
    }

    const defaults = snapshot.defaults || {};
    visionDefaults.type = normalizeVisionType(defaults.type);
    visionDefaults.mode = normalizeVisionMode(defaults.mode);
    const defaultRadius = Number(defaults.radius);
    if(Number.isFinite(defaultRadius)){
      visionDefaults.radius = clampSettingValue(defaultRadius, SETTINGS_RANGE_MIN);
    }
    const defaultInnerRadius = Number(defaults.innerRadius);
    if(Number.isFinite(defaultInnerRadius)){
      visionDefaults.innerRadius = clampSettingValue(defaultInnerRadius, SETTINGS_RANGE_MIN);
    }
    const defaultOffset = Number(defaults.offset);
    if(Number.isFinite(defaultOffset)){
      visionDefaults.offset = clampSettingValue(defaultOffset, SETTINGS_RANGE_MIN);
    }
    const defaultLength = Number(defaults.length);
    if(Number.isFinite(defaultLength)){
      visionDefaults.length = clampSettingValue(defaultLength, SETTINGS_RANGE_MIN);
    }
    const defaultAngle = Number(defaults.angleDeg);
    if(Number.isFinite(defaultAngle)){
      visionDefaults.angleDeg = defaultAngle;
    }
    ensureVisionConsistency(visionDefaults);

    GameState.player.vision.selectedId = null;
    GameState.player.vision.placing = false;
    GameState.player.vision.editMode = false;
    GameState.player.vision.draggingId = null;
    GameState.player.vision.dummyState.placing = false;
    GameState.player.vision.dummyState.dragging = false;
    GameState.player.vision.dummyState.pointerId = null;

    updateVisionUiState();
    onVisionsChanged();
    renderMinimap(true);
    return true;
  }

  function normalizeLabel(value){
    return typeof value === 'string' ? value.trim().toLowerCase() : '';
  }

  function loadPlayerAnimationConfigurations(){
    if(typeof localStorage === 'undefined'){ return {}; }
    try {
      const raw = localStorage.getItem(PLAYER_ANIMATION_STORAGE_KEY);
      if(!raw){ return {}; }
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === 'object' ? parsed : {};
    } catch (err){
      console.warn('Failed to parse saved animation setup', err);
      return {};
    }
  }

  function savePlayerAnimationConfigurations(data){
    if(typeof localStorage === 'undefined'){ return false; }
    try {
      localStorage.setItem(PLAYER_ANIMATION_STORAGE_KEY, JSON.stringify(data));
      return true;
    } catch (err){
      console.warn('Failed to persist animation setup', err);
      return false;
    }
  }

  function formatPlayerAnimationConfigFilename(modelLabel = ''){
    const baseLabel = typeof modelLabel === 'string' && modelLabel.trim()
      ? modelLabel.trim()
      : 'player-animation';
    const sanitized = baseLabel.replace(/[^a-z0-9_\-]+/gi, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    const safeBase = (sanitized || 'player-animation').toLowerCase();
    const now = new Date();
    const pad = (value)=> String(value).padStart(2, '0');
    const stamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    return `${safeBase}-setup-${stamp}.json`;
  }

  function cloneSkinnedModel(source){
    if(!source){
      return null;
    }
    const clone = source.clone(true);
    const boneMap = new Map();
    const nodeMap = new Map();
    const skinnedPairs = [];

    const queue = [[source, clone]];
    while(queue.length){
      const [srcNode, cloneNode] = queue.shift();
      if(!srcNode || !cloneNode){
        continue;
      }
      nodeMap.set(srcNode, cloneNode);
      if(srcNode.isBone){
        boneMap.set(srcNode, cloneNode);
      }
      if(srcNode.isSkinnedMesh){
        skinnedPairs.push([srcNode, cloneNode]);
      }
      const srcChildren = srcNode.children || [];
      const cloneChildren = cloneNode.children || [];
      const childCount = Math.min(srcChildren.length, cloneChildren.length);
      for(let i = 0; i < childCount; i += 1){
        queue.push([srcChildren[i], cloneChildren[i]]);
      }
    }

    skinnedPairs.forEach(([sourceMesh, cloneMesh]) => {
      if(!cloneMesh || !sourceMesh.skeleton){
        return;
      }
      const sourceSkeleton = sourceMesh.skeleton;
      const orderedBones = sourceSkeleton.bones.map(bone => boneMap.get(bone) || null);
      const hasAllBones = orderedBones.every(Boolean);
      if(!hasAllBones){
        return;
      }
      const boneInverses = sourceSkeleton.boneInverses.map(inv => inv.clone());
      const skeleton = new THREE.Skeleton(orderedBones, boneInverses);
      const bindMatrix = sourceMesh.bindMatrix ? sourceMesh.bindMatrix.clone() : cloneMesh.matrixWorld.clone();
      cloneMesh.bind(skeleton, bindMatrix);
      if(sourceMesh.bindMatrixInverse){
        cloneMesh.bindMatrixInverse.copy(sourceMesh.bindMatrixInverse);
      }
    });

    clone.animations = source.animations ? source.animations.slice() : [];
    nodeMap.forEach((cloneNode, srcNode) => {
      if(srcNode !== source && srcNode.animations && srcNode.animations.length){
        cloneNode.animations = srcNode.animations.slice();
      }
    });
    return clone;
  }

  class PlayerAnimationController {
    constructor({ canvas, stage, dropEl, statusEl, materialsEl, selects, actionInputs, scaleRange, scaleInput, offsetHorizontalInput, offsetVerticalInput, lightAngleRange, lightAngleInput } = {}){
      this.canvas = canvas || null;
      this.stage = stage || null;
      this.dropEl = dropEl || null;
      this.statusEl = statusEl || null;
      this.materialsEl = materialsEl || null;
      this.selects = selects || {};
      this.actionInputs = actionInputs || {};
      this.scaleRange = scaleRange || null;
      this.scaleInput = scaleInput || null;
      this.offsetHorizontalInput = offsetHorizontalInput || null;
      this.offsetVerticalInput = offsetVerticalInput || null;
      this.lightAngleRange = lightAngleRange || null;
      this.lightAngleInput = lightAngleInput || null;
      this.assignments = {};
      PLAYER_ANIMATION_ACTIONS.forEach(action => {
        this.assignments[action] = this.createDefaultAssignment();
      });
      this.fbxLoader = new FBXLoader();
      this.gltfLoader = new GLTFLoader();
      this.dracoLoader = new DRACOLoader();
      this.dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
      this.dracoLoader.preload();
      this.gltfLoader.setDRACOLoader(this.dracoLoader);
      if(MeshoptDecoder){
        this.gltfLoader.setMeshoptDecoder(MeshoptDecoder);
      }
      this.clipLibrary = [];
      this.clipMap = new Map();
      this.assignmentClipCache = new Map();
      this.materialEntries = [];
      this.modelLabel = '';
      this.lastAppliedSignature = null;
      this.lastSavedSignature = null;
      this.currentRoot = null;
      this.mixer = null;
      this.currentAction = null;
      this.currentClipKey = null;
      this.currentState = 'idle';
      this.lastContext = {};
      this.modelScale = 1;
      this.modelRadius = 0;
      this.modelHeight = 0;
      this.modelBasePosition = { x: 0, y: 0, z: 0 };
      this.modelOffsetHorizontalPx = 0;
      this.modelOffsetVerticalPx = 0;
      this.lightAzimuthDegrees = 45;
      this.directionalLight = null;
      this.directionalLightTarget = null;
      this.directionalLightRadius = 3.6;
      this.directionalLightHeight = 4;
      this.renderer = null;
      this.scene = null;
      this.camera = null;
      this.controls = null;
      this.clock = null;
      this.resizeObserver = null;
      this.placeholder = null;
      this.trimSupportWarned = false;
      this.enabled = !!(this.canvas && this.canvas.getContext);
      this.onModelLoaded = null;
      this.onModelCleared = null;
      this.onAssignmentsChanged = null;
      this.onMaterialsUpdated = null;
      this.onModelScaleChanged = null;
      this.onModelOffsetChanged = null;
      this.init();
    }

    init(){
      if(!this.enabled){
        this.setStatus('Preview unavailable.');
        return;
      }
      this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
      this.renderer.outputColorSpace = THREE.SRGBColorSpace;
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      this.scene = new THREE.Scene();
      this.scene.background = null;
      if(this.renderer && typeof this.renderer.setClearColor === 'function'){
        this.renderer.setClearColor(0x000000, 0);
      }
      this.clock = new THREE.Clock();
      this.camera = new THREE.PerspectiveCamera(55, 1, 0.1, 2000);
      this.camera.position.set(0, 1.2, 3.2);
      this.controls = new OrbitControls(this.camera, this.canvas);
      this.controls.enableDamping = true;
      this.controls.enablePan = false;
      this.controls.target.set(0, 1, 0);
      const hemi = new THREE.HemisphereLight(0xffffff, 0x202020, 0.9);
      this.scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.castShadow = true;
      this.directionalLight = dir;
      this.directionalLightTarget = new THREE.Object3D();
      this.directionalLightTarget.position.set(0, 1, 0);
      this.scene.add(this.directionalLightTarget);
      dir.target = this.directionalLightTarget;
      this.scene.add(dir);
      this.placeholder = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.4, 0.4),
        new THREE.MeshStandardMaterial({ color: 0x3b82f6 })
      );
      this.placeholder.position.y = 0.2;
      this.placeholder.castShadow = true;
      this.scene.add(this.placeholder);
      this.placeholderBasePosition = {
        x: this.placeholder.position.x,
        y: this.placeholder.position.y,
        z: this.placeholder.position.z
      };
      this.updateRendererSize();
      this.animate();
      this.bindSelects();
      this.bindActionInputs();
      this.syncAllActionInputs();
      this.bindScaleControls();
      this.bindOffsetControls();
      this.bindLightControls();
      this.setLightAzimuth(this.lightAzimuthDegrees, { force: true });
      if(this.stage){
        this.stage.addEventListener('dragenter', (ev)=> this.handleDragEnter(ev));
        this.stage.addEventListener('dragover', (ev)=> this.handleDragOver(ev));
        this.stage.addEventListener('dragleave', (ev)=> this.handleDragLeave(ev));
        this.stage.addEventListener('drop', (ev)=> this.handleDrop(ev));
        this.stage.dataset.drop = 'false';
        if('ResizeObserver' in window){
          this.resizeObserver = new ResizeObserver(()=> this.updateRendererSize());
          this.resizeObserver.observe(this.stage);
        }
      } else {
        window.addEventListener('resize', ()=> this.updateRendererSize());
      }
    }

    createDefaultAssignment(){
      return { clipId: '', speed: 1, startFrame: null, endFrame: null };
    }

    normalizeSpeed(value){
      if(value === undefined || value === null || value === ''){
        return 1;
      }
      const numeric = Number(value);
      if(!Number.isFinite(numeric)){
        return 1;
      }
      const clamped = Math.min(5, Math.max(0, numeric));
      return Math.round(clamped * 1000) / 1000;
    }

    normalizeFrame(value){
      if(value === undefined || value === null || value === ''){
        return null;
      }
      const numeric = Number(value);
      if(!Number.isFinite(numeric)){
        return null;
      }
      return Math.max(0, Math.round(numeric));
    }

    formatSpeed(value){
      const numeric = Number(value);
      if(!Number.isFinite(numeric)){
        return '1';
      }
      const rounded = Math.round(numeric * 100) / 100;
      if(Math.abs(rounded - Math.round(rounded)) < 1e-6){
        return `${Math.round(rounded)}`;
      }
      return rounded.toFixed(2).replace(/\.?0+$/, '');
    }

    getAssignment(action){
      if(!PLAYER_ANIMATION_ACTIONS.includes(action)){
        return this.createDefaultAssignment();
      }
      const stored = this.assignments[action];
      if(stored && typeof stored === 'object'){
        const normalized = {
          clipId: typeof stored.clipId === 'string' ? stored.clipId : '',
          speed: this.normalizeSpeed(stored.speed),
          startFrame: this.normalizeFrame(stored.startFrame),
          endFrame: this.normalizeFrame(stored.endFrame)
        };
        this.assignments[action] = normalized;
        return { ...normalized };
      }
      if(typeof stored === 'string'){
        const normalized = { clipId: stored, speed: 1, startFrame: null, endFrame: null };
        this.assignments[action] = normalized;
        return { ...normalized };
      }
      const fallback = this.createDefaultAssignment();
      this.assignments[action] = fallback;
      return { ...fallback };
    }

    setAssignment(action, updates = {}, { emit = true, reapply = true, syncInputs = true } = {}){
      if(!PLAYER_ANIMATION_ACTIONS.includes(action)){
        return false;
      }
      const previous = this.getAssignment(action);
      const next = { ...previous };
      let changed = false;
      let clipChanged = false;
      let framesChanged = false;

      if('clipId' in updates){
        const clipId = typeof updates.clipId === 'string' ? updates.clipId : '';
        if(clipId !== previous.clipId){
          next.clipId = clipId;
          changed = true;
          clipChanged = true;
          if(!('startFrame' in updates)){
            next.startFrame = null;
          }
          if(!('endFrame' in updates)){
            next.endFrame = null;
          }
          if(!('speed' in updates)){
            next.speed = 1;
          }
        }
      }
      if('speed' in updates){
        const speed = this.normalizeSpeed(updates.speed);
        if(Math.abs(speed - previous.speed) > 0.0001){
          next.speed = speed;
          changed = true;
        }
      }
      if('startFrame' in updates){
        const startFrame = this.normalizeFrame(updates.startFrame);
        if(startFrame !== previous.startFrame){
          next.startFrame = startFrame;
          changed = true;
          framesChanged = true;
        }
      }
      if('endFrame' in updates){
        const endFrame = this.normalizeFrame(updates.endFrame);
        if(endFrame !== previous.endFrame){
          next.endFrame = endFrame;
          changed = true;
          framesChanged = true;
        }
      }

      this.assignments[action] = next;

      if(syncInputs){
        this.syncActionInputs(action);
      }

      if(changed){
        if(clipChanged || framesChanged){
          this.assignmentClipCache.clear();
        }
        if(reapply && this.currentState === action){
          this.applyState(this.currentState, this.lastContext, { force: true });
        }
        if(emit){
          this.emitAssignmentsChanged();
        }
      }

      return changed;
    }

    syncActionInputs(action){
      const inputs = this.actionInputs[action];
      if(!inputs) return;
      const assignment = this.getAssignment(action);
      const hasClip = !!(assignment.clipId && this.clipMap.has(assignment.clipId));
      if(inputs.speed && document.activeElement !== inputs.speed){
        inputs.speed.value = this.formatSpeed(assignment.speed);
      }
      if(inputs.speed){
        inputs.speed.disabled = !hasClip;
      }
      if(inputs.startFrame && document.activeElement !== inputs.startFrame){
        inputs.startFrame.value = assignment.startFrame === null ? '' : `${assignment.startFrame}`;
      }
      if(inputs.startFrame){
        inputs.startFrame.disabled = !hasClip;
      }
      if(inputs.endFrame && document.activeElement !== inputs.endFrame){
        inputs.endFrame.value = assignment.endFrame === null ? '' : `${assignment.endFrame}`;
      }
      if(inputs.endFrame){
        inputs.endFrame.disabled = !hasClip;
      }
    }

    syncAllActionInputs(){
      for(const action of PLAYER_ANIMATION_ACTIONS){
        this.syncActionInputs(action);
      }
    }

    bindSelects(){
      for(const [action, select] of Object.entries(this.selects)){
        if(!select) continue;
        select.disabled = true;
        select.addEventListener('change', ()=>{
          this.setAssignment(action, { clipId: select.value || '' });
        });
      }
    }

    bindActionInputs(){
      for(const action of PLAYER_ANIMATION_ACTIONS){
        const inputs = this.actionInputs[action];
        if(!inputs) continue;
        if(inputs.speed){
          const commitSpeed = ()=>{
            const raw = inputs.speed.value;
            const parsed = raw === '' ? 1 : Number(raw);
            this.setAssignment(action, { speed: parsed }, { reapply: true });
            this.syncActionInputs(action);
          };
          inputs.speed.addEventListener('change', commitSpeed);
          inputs.speed.addEventListener('blur', commitSpeed);
        }
        if(inputs.startFrame){
          const commitStart = ()=>{
            const raw = inputs.startFrame.value;
            const parsed = raw === '' ? null : Number(raw);
            this.setAssignment(action, { startFrame: parsed }, { reapply: true });
            this.syncActionInputs(action);
          };
          inputs.startFrame.addEventListener('change', commitStart);
          inputs.startFrame.addEventListener('blur', commitStart);
        }
        if(inputs.endFrame){
          const commitEnd = ()=>{
            const raw = inputs.endFrame.value;
            const parsed = raw === '' ? null : Number(raw);
            this.setAssignment(action, { endFrame: parsed }, { reapply: true });
            this.syncActionInputs(action);
          };
          inputs.endFrame.addEventListener('change', commitEnd);
          inputs.endFrame.addEventListener('blur', commitEnd);
        }
      }
    }

    bindScaleControls(){
      if(this.scaleRange){
        this.scaleRange.value = `${this.modelScale}`;
        this.scaleRange.addEventListener('input', ()=>{
          const value = parseFloat(this.scaleRange.value);
          if(Number.isFinite(value)){
            this.setModelScale(value);
          }
        });
      }
      if(this.scaleInput){
        this.scaleInput.value = this.modelScale.toFixed(2);
        const commit = ()=>{
          if(this.scaleInput.value === ''){
            return;
          }
          const value = parseFloat(this.scaleInput.value);
          if(Number.isFinite(value)){
            this.setModelScale(value);
          }
        };
        this.scaleInput.addEventListener('change', commit);
        this.scaleInput.addEventListener('blur', commit);
      }
    }

    bindOffsetControls(){
      if(this.offsetHorizontalInput){
        this.offsetHorizontalInput.value = String(Math.round(this.modelOffsetHorizontalPx));
        const commitHorizontal = ()=>{
          if(this.offsetHorizontalInput.value === ''){
            this.setModelOffset({ horizontal: 0 });
            return;
          }
          const value = this.clampModelOffset(this.offsetHorizontalInput.value);
          this.setModelOffset({ horizontal: value });
        };
        this.offsetHorizontalInput.addEventListener('change', commitHorizontal);
        this.offsetHorizontalInput.addEventListener('blur', commitHorizontal);
      }
      if(this.offsetVerticalInput){
        this.offsetVerticalInput.value = String(Math.round(this.modelOffsetVerticalPx));
        const commitVertical = ()=>{
          if(this.offsetVerticalInput.value === ''){
            this.setModelOffset({ vertical: 0 });
            return;
          }
          const value = this.clampModelOffset(this.offsetVerticalInput.value);
          this.setModelOffset({ vertical: value });
        };
        this.offsetVerticalInput.addEventListener('change', commitVertical);
        this.offsetVerticalInput.addEventListener('blur', commitVertical);
      }
      this.syncOffsetInputs();
    }

    clampModelOffset(value){
      const numeric = Number(value);
      if(!Number.isFinite(numeric)){
        return 0;
      }
      return Math.max(PLAYER_MODEL_OFFSET_MIN, Math.min(PLAYER_MODEL_OFFSET_MAX, numeric));
    }

    syncOffsetInputs(axis = null){
      const sync = (inputEl, value)=>{
        if(inputEl && document.activeElement !== inputEl){
          const formatted = String(Math.round(value));
          if(inputEl.value !== formatted){
            inputEl.value = formatted;
          }
        }
      };
      if(axis === null || axis === 'horizontal'){
        const horizontal = this.clampModelOffset(this.modelOffsetHorizontalPx);
        sync(this.offsetHorizontalInput, horizontal);
      }
      if(axis === null || axis === 'vertical'){
        const vertical = this.clampModelOffset(this.modelOffsetVerticalPx);
        sync(this.offsetVerticalInput, vertical);
      }
    }

    setModelOffset({ horizontal = null, vertical = null } = {}, { syncInputs = true, force = false, emit = true } = {}){
      let changed = false;
      if(horizontal !== null){
        const clamped = this.clampModelOffset(horizontal);
        if(force || Math.abs(clamped - this.modelOffsetHorizontalPx) > 0.0001){
          this.modelOffsetHorizontalPx = clamped;
          changed = true;
        }
      }
      if(vertical !== null){
        const clamped = this.clampModelOffset(vertical);
        if(force || Math.abs(clamped - this.modelOffsetVerticalPx) > 0.0001){
          this.modelOffsetVerticalPx = clamped;
          changed = true;
        }
      }
      if(syncInputs){
        this.syncOffsetInputs();
      }
      if(changed || force){
        this.applyModelOffsetToScene();
        if(emit){
          this.emitModelOffsetChanged();
        }
      }
    }

    getModelOffset(){
      return {
        horizontal: this.modelOffsetHorizontalPx,
        vertical: this.modelOffsetVerticalPx
      };
    }

    estimatePixelsPerWorldUnit(){
      if(typeof playerRuntime.model !== 'undefined' && playerRuntime.model && Number.isFinite(playerRuntime.model.playerRadius) && Number.isFinite(playerRuntime.model.modelRadius) && playerRuntime.model.modelRadius > 0){
        const ratio = playerRuntime.model.playerRadius / playerRuntime.model.modelRadius;
        if(ratio > 0){
          return ratio;
        }
      }
      if(typeof player !== 'undefined' && player && Number.isFinite(player.r) && this.modelRadius > 0){
        const ratio = player.r / this.modelRadius;
        if(ratio > 0){
          return ratio;
        }
      }
      return PLAYER_MODEL_DEFAULT_PX_PER_WORLD;
    }

    applyModelOffsetToScene(){
      const pxPerWorld = this.estimatePixelsPerWorldUnit();
      if(!(pxPerWorld > 0)){
        return;
      }
      const offsetXWorld = this.modelOffsetHorizontalPx / pxPerWorld;
      const offsetYWorld = this.modelOffsetVerticalPx / pxPerWorld;
      if(this.currentRoot){
        if(!this.modelBasePosition){
          this.modelBasePosition = { x: this.currentRoot.position.x, y: this.currentRoot.position.y, z: this.currentRoot.position.z };
        }
        this.currentRoot.position.set(
          this.modelBasePosition.x + offsetXWorld,
          this.modelBasePosition.y + offsetYWorld,
          this.modelBasePosition.z
        );
        this.currentRoot.updateMatrixWorld(true);
      } else if(this.placeholder){
        if(!this.placeholderBasePosition){
          this.placeholderBasePosition = { x: this.placeholder.position.x, y: this.placeholder.position.y, z: this.placeholder.position.z };
        }
        this.placeholder.position.set(
          this.placeholderBasePosition.x + offsetXWorld,
          this.placeholderBasePosition.y + offsetYWorld,
          this.placeholderBasePosition.z
        );
        this.placeholder.updateMatrixWorld(true);
      }
    }

    bindLightControls(){
      if(this.lightAngleRange){
        this.lightAngleRange.value = `${Math.round(this.lightAzimuthDegrees)}`;
        this.lightAngleRange.addEventListener('input', ()=>{
          const raw = parseFloat(this.lightAngleRange.value);
          if(Number.isFinite(raw)){
            this.setLightAzimuth(raw, { syncInputs: false });
          }
        });
        this.lightAngleRange.addEventListener('change', ()=>{
          const raw = parseFloat(this.lightAngleRange.value);
          if(Number.isFinite(raw)){
            this.setLightAzimuth(raw);
          }
        });
      }
      if(this.lightAngleInput){
        this.lightAngleInput.value = `${Math.round(this.lightAzimuthDegrees)}`;
        const commit = ()=>{
          const raw = parseFloat(this.lightAngleInput.value);
          if(Number.isFinite(raw)){
            this.setLightAzimuth(raw);
          }
        };
        this.lightAngleInput.addEventListener('change', commit);
        this.lightAngleInput.addEventListener('blur', commit);
      }
      this.syncLightAngleInputs();
    }

    syncLightAngleInputs(){
      const normalized = ((this.lightAzimuthDegrees % 360) + 360) % 360;
      const rounded = Math.round(normalized);
      if(this.lightAngleRange && this.lightAngleRange.value !== `${rounded}`){
        this.lightAngleRange.value = `${rounded}`;
      }
      if(this.lightAngleInput && document.activeElement !== this.lightAngleInput){
        const formatted = `${rounded}`;
        if(this.lightAngleInput.value !== formatted){
          this.lightAngleInput.value = formatted;
        }
      }
    }

    setLightAzimuth(value, { syncInputs = true, force = false } = {}){
      let numeric = Number(value);
      if(!Number.isFinite(numeric)){
        numeric = 0;
      }
      numeric = ((numeric % 360) + 360) % 360;
      if(!force && Math.abs(numeric - this.lightAzimuthDegrees) < 0.0001){
        if(syncInputs){
          this.syncLightAngleInputs();
        }
        return;
      }
      this.lightAzimuthDegrees = numeric;
      this.updateDirectionalLightPosition();
      if(syncInputs){
        this.syncLightAngleInputs();
      }
    }

    updateDirectionalLightPosition(){
      if(!this.directionalLight){
        return;
      }
      const radius = Number.isFinite(this.directionalLightRadius) && this.directionalLightRadius > 0 ? this.directionalLightRadius : 3.6;
      const height = Number.isFinite(this.directionalLightHeight) ? this.directionalLightHeight : 4;
      const radians = THREE.MathUtils.degToRad(this.lightAzimuthDegrees);
      const x = Math.cos(radians) * radius;
      const z = Math.sin(radians) * radius;
      this.directionalLight.position.set(x, height, z);
      if(this.directionalLightTarget){
        this.directionalLightTarget.position.set(0, Math.max(0.5, height * 0.25), 0);
        this.directionalLightTarget.updateMatrixWorld(true);
      }
      this.directionalLight.updateMatrixWorld(true);
    }

    clampScale(value){
      const defaultMin = 0.001;
      const defaultMax = 1000;
      const numberMin = this.scaleInput ? Number(this.scaleInput.min) || defaultMin : defaultMin;
      const numberMax = this.scaleInput ? Number(this.scaleInput.max) || defaultMax : defaultMax;
      const sliderMin = this.scaleRange ? Number(this.scaleRange.min) || numberMin : numberMin;
      const sliderMax = this.scaleRange ? Number(this.scaleRange.max) || numberMax : numberMax;
      const numericValue = Number.isFinite(value) ? value : this.modelScale;
      const clampedNumber = Math.min(Math.max(numericValue, numberMin), numberMax);
      return { value: clampedNumber, sliderMin, sliderMax };
    }

    setModelScale(value, { force = false } = {}){
      const { value: numeric, sliderMin, sliderMax } = this.clampScale(value);
      const previous = this.modelScale;
      const changed = force || Math.abs(previous - numeric) > 0.0001;
      this.modelScale = numeric;
      if(this.scaleRange){
        const sliderValue = Math.min(Math.max(numeric, sliderMin), sliderMax);
        if(Math.abs(parseFloat(this.scaleRange.value) - sliderValue) > 0.0001){
          this.scaleRange.value = sliderValue.toFixed(2);
        }
      }
      if(this.scaleInput && document.activeElement !== this.scaleInput){
        const formatted = numeric.toFixed(2);
        if(this.scaleInput.value !== formatted){
          this.scaleInput.value = formatted;
        }
      }
      if(this.currentRoot && (changed || force)){
        this.applyModelScale({ emit: false });
      }
      if(changed && this.hasModel()){
        this.emitModelScaleChanged();
      }
    }

    getModelScale(){
      return this.modelScale;
    }

    applyModelScale({ refit = true, emit = false } = {}){
      if(!this.currentRoot){
        if(emit){
          this.emitModelScaleChanged();
        }
        return;
      }
      this.currentRoot.scale.setScalar(this.modelScale);
      this.currentRoot.updateMatrixWorld(true);
      if(refit){
        this.fitToObject(this.currentRoot);
      }
      this.applyModelOffsetToScene();
      if(emit){
        this.emitModelScaleChanged();
      }
    }

    updateRendererSize(){
      if(!this.renderer){
        return;
      }
      let width = 220;
      let height = 220;
      if(this.stage){
        const rect = this.stage.getBoundingClientRect();
        const fallbackWidth = rect && rect.width ? rect.width : (this.stage.clientWidth || width);
        const fallbackHeight = rect && rect.height ? rect.height : (this.stage.clientHeight || height);
        width = fallbackWidth;
        height = fallbackHeight;
      } else if(this.canvas){
        const fallbackWidth = this.canvas.clientWidth || width;
        const fallbackHeight = this.canvas.clientHeight || height;
        width = fallbackWidth;
        height = fallbackHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      width = Math.max(120, width);
      height = Math.max(140, height);
      this.renderer.setSize(width, height, false);
      if(this.camera){
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
      }
    }

    refreshSize(){
      this.updateRendererSize();
    }

    animate(){
      if(!this.renderer) return;
      requestAnimationFrame(()=> this.animate());
      const delta = this.clock ? this.clock.getDelta() : 0;
      if(this.controls){
        this.controls.update();
      }
      if(this.mixer && delta){
        this.mixer.update(delta);
      }
      this.renderer.render(this.scene, this.camera);
    }

    handleDragEnter(ev){
      if(ev && typeof ev.preventDefault === 'function') ev.preventDefault();
      if(this.stage){
        this.stage.dataset.drop = 'true';
      }
    }

    handleDragOver(ev){
      if(ev && typeof ev.preventDefault === 'function') ev.preventDefault();
      if(ev && ev.dataTransfer){
        ev.dataTransfer.dropEffect = 'copy';
      }
      if(this.stage){
        this.stage.dataset.drop = 'true';
      }
    }

    handleDragLeave(ev){
      if(ev && typeof ev.preventDefault === 'function') ev.preventDefault();
      if(this.stage){
        this.stage.dataset.drop = 'false';
      }
    }

    handleDrop(ev){
      if(ev && typeof ev.preventDefault === 'function') ev.preventDefault();
      if(this.stage){
        this.stage.dataset.drop = 'false';
      }
      const file = ev && ev.dataTransfer && ev.dataTransfer.files ? ev.dataTransfer.files[0] : null;
      if(file){
        this.loadFile(file);
      }
    }

    async loadFile(file){
      if(!file) return;
      this.setStatus(`Loading ${file.name}â€¦`);
      try {
        const buffer = await file.arrayBuffer();
        await this.loadFromArrayBuffer(buffer, file.name);
      } catch(err){
        this.handleError(err);
      }
    }

    async loadFromArrayBuffer(buffer, name = 'model'){
      const label = typeof name === 'string' && name ? name : 'model';
      if(buffer && buffer.byteLength){
        try {
          const packResult = loadMixamoPack(buffer);
          if(packResult){
            this.onModel(packResult.object, packResult.fileName || label);
            const count = Number(packResult.animationCount) || 0;
            if(count > 0){
              this.setStatus(`Loaded Mixamo combination pack with ${count} animation${count === 1 ? '' : 's'}.`);
            }
            return;
          }
        } catch (packError){
          throw packError;
        }
      }
      const extension = label.includes('.') ? label.split('.').pop().toLowerCase() : '';
      if(extension === 'fbx'){
        const object = this.fbxLoader.parse(buffer, './');
        this.onModel(object, label);
        return;
      }
      if(extension === 'glb' || extension === 'gltf'){
        const data = extension === 'gltf'
          ? new TextDecoder().decode(buffer)
          : buffer;
        const gltf = await new Promise((resolve, reject) => {
          this.gltfLoader.parse(data, './', resolve, reject);
        });
        const root = gltf && (gltf.scene || (Array.isArray(gltf.scenes) ? gltf.scenes[0] : null));
        if(!root){
          throw new Error('Invalid GLTF scene.');
        }
        if(Array.isArray(gltf.animations) && gltf.animations.length){
          root.animations = gltf.animations.slice();
        }
        this.onModel(root, label);
        return;
      }
      throw new Error('Unsupported model format. Please load an .fbx, .glb, or .gltf file.');
    }

    onModel(object, name){
      if(!object){
        this.handleError(new Error('Invalid model.'));
        return;
      }
      this.clearModel();
      this.currentRoot = object;
      this.modelLabel = typeof name === 'string' && name ? name : 'Player model';
      object.traverse(node => {
        if(node.isMesh){
          node.castShadow = true;
          node.receiveShadow = true;
        }
      });
      this.scene.add(object);
      if(this.placeholder){
        this.placeholder.visible = false;
      }
      this.applyModelScale({ refit: true, emit: false });
      this.setModelOffset({ horizontal: this.modelOffsetHorizontalPx, vertical: this.modelOffsetVerticalPx }, { syncInputs: true, force: true, emit: false });
      this.applyModelOffsetToScene();
      this.mixer = new THREE.AnimationMixer(object);
      this.collectClips(object);
      this.collectMaterials(object);
      const restored = this.tryRestoreConfiguration();
      const autoScaled = restored ? false : this.autoScaleModel({ silent: true });
      if(!restored){
        this.emitModelOffsetChanged();
      }
      const displayName = this.modelLabel || (typeof name === 'string' && name ? name : 'model');
      let statusMessage = `Loaded ${displayName}`;
      if(restored){
        statusMessage += ' and restored saved setup.';
      } else if(autoScaled){
        statusMessage += ' (auto-scaled to match player).';
      }
      this.setStatus(statusMessage);
      this.applyState(this.currentState, this.lastContext, { force: true });
      this.emitModelLoaded();
    }

    fitToObject(object){
      if(!object || !this.camera || !this.controls) return;
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);
      object.position.sub(center);
      this.modelBasePosition = { x: object.position.x, y: object.position.y, z: object.position.z };
      const sphere = box.getBoundingSphere(new THREE.Sphere());
      if(sphere && Number.isFinite(sphere.radius)){
        this.modelRadius = sphere.radius;
      } else {
        this.modelRadius = Math.max(size.x, size.y, size.z) * 0.5 || 1;
      }
      this.modelHeight = size.y || this.modelHeight;
      const radius = Math.max(size.x, size.y, size.z) || 1;
      const distance = radius * 1.6 / Math.tan((this.camera.fov * Math.PI / 180) / 2);
      this.camera.position.set(radius * 0.6, Math.max(radius * 0.6, 1.1), distance);
      this.controls.target.set(0, Math.max(0.5, size.y * 0.5), 0);
      this.controls.update();
    }

    collectClips(object){
      this.clipLibrary = [];
      this.clipMap = new Map();
      this.assignmentClipCache.clear();
      const clips = [];
      if(object.animations && object.animations.length){
        clips.push(...object.animations);
      }
      object.traverse(node => {
        if(node.animations && node.animations.length){
          clips.push(...node.animations);
        }
      });
      clips.forEach((clip, index) => {
        if(!clip) return;
        const label = clip.name && clip.name.trim() ? clip.name.trim() : `Clip ${index + 1}`;
        const id = `${index}-${clip.uuid || label}`;
        this.clipLibrary.push({ id, label, clip });
        this.clipMap.set(id, { clip, label });
      });
      for(const [action, select] of Object.entries(this.selects)){
        if(!select) continue;
        const previous = this.getAssignment(action);
        select.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'â€”';
        select.appendChild(placeholder);
        if(!this.clipLibrary.length){
          select.disabled = true;
          select.value = '';
          this.setAssignment(action, { clipId: '' }, { emit: false, reapply: false });
          this.syncActionInputs(action);
          continue;
        }
        select.disabled = false;
        this.clipLibrary.forEach(info => {
          const opt = document.createElement('option');
          opt.value = info.id;
          opt.textContent = info.label;
          select.appendChild(opt);
        });
        if(previous.clipId && this.clipMap.has(previous.clipId)){
          select.value = previous.clipId;
          this.setAssignment(action, { clipId: previous.clipId }, { emit: false, reapply: false, syncInputs: false });
        } else {
          select.value = '';
          this.setAssignment(action, { clipId: '' }, { emit: false, reapply: false, syncInputs: false });
        }
        this.syncActionInputs(action);
      }
      this.emitAssignmentsChanged();
    }

    buildClipCacheKey(clipId, startFrame, endFrame){
      const start = Number.isFinite(startFrame) ? Math.round(startFrame) : '';
      const end = Number.isFinite(endFrame) ? Math.round(endFrame) : '';
      return `${clipId || ''}|${start}|${end}`;
    }

    createTrimmedClip(baseClip, clipId, startFrame, endFrame, fps){
      const utils = THREE && THREE.AnimationUtils ? THREE.AnimationUtils : null;
      if(utils && typeof utils.subclip === 'function'){
        const trimmed = utils.subclip(baseClip, `${clipId}-trim-${startFrame}-${endFrame}`, startFrame, endFrame, fps);
        if(trimmed && typeof trimmed.resetDuration === 'function'){
          trimmed.resetDuration();
        }
        return trimmed;
      }
      if(!this.trimSupportWarned){
        console.warn('Animation trimming unavailable: THREE.AnimationUtils.subclip not found. Falling back to original clip.');
        this.trimSupportWarned = true;
      }
      if(baseClip && typeof baseClip.clone === 'function'){
        const clone = baseClip.clone();
        if(clone && typeof clone.resetDuration === 'function'){
          clone.resetDuration();
        }
        return clone;
      }
      return baseClip;
    }

    estimateClipFps(clip){
      if(!clip || !Array.isArray(clip.tracks) || !clip.tracks.length){
        return 30;
      }
      let minDelta = Infinity;
      let maxTime = Number.isFinite(clip.duration) ? clip.duration : 0;
      clip.tracks.forEach(track => {
        if(!track || !track.times || track.times.length < 2){
          if(track && track.times && track.times.length === 1){
            maxTime = Math.max(maxTime, track.times[0]);
          }
          return;
        }
        const times = track.times;
        maxTime = Math.max(maxTime, times[times.length - 1]);
        for(let i = 1; i < times.length; i += 1){
          const delta = times[i] - times[i - 1];
          if(delta > 0 && delta < minDelta){
            minDelta = delta;
          }
        }
      });
      if(Number.isFinite(minDelta) && minDelta > 0){
        const fps = Math.round(1 / minDelta);
        return Math.min(240, Math.max(1, fps));
      }
      if(Number.isFinite(maxTime) && maxTime > 0){
        const firstTrack = clip.tracks.find(track => track && track.times && track.times.length > 1);
        if(firstTrack){
          const approx = (firstTrack.times.length - 1) / maxTime;
          if(Number.isFinite(approx) && approx > 0){
            return Math.min(240, Math.max(1, Math.round(approx)));
          }
        }
      }
      return 30;
    }

    getProcessedClip(clipId, startFrame, endFrame){
      if(!clipId || !this.clipMap.has(clipId)){
        return null;
      }
      const info = this.clipMap.get(clipId);
      if(!info || !info.clip){
        return null;
      }
      const baseClip = info.clip;
      const hasStart = Number.isFinite(startFrame);
      const hasEnd = Number.isFinite(endFrame);
      if(!hasStart && !hasEnd){
        return baseClip;
      }
      const fps = this.estimateClipFps(baseClip);
      let maxTime = Number.isFinite(baseClip.duration) ? baseClip.duration : 0;
      baseClip.tracks.forEach(track => {
        if(track && track.times && track.times.length){
          maxTime = Math.max(maxTime, track.times[track.times.length - 1]);
        }
      });
      const maxFrame = Math.max(1, Math.round(maxTime * fps));
      let start = hasStart ? Math.max(0, Math.round(startFrame)) : 0;
      if(start >= maxFrame){
        start = Math.max(0, maxFrame - 1);
      }
      let end = hasEnd ? Math.max(0, Math.round(endFrame)) : maxFrame;
      if(end > maxFrame){
        end = maxFrame;
      }
      if(end <= start){
        end = Math.min(maxFrame, start + 1);
      }
      if(end <= start){
        end = start + 1;
      }
      const key = this.buildClipCacheKey(clipId, start, end);
      if(this.assignmentClipCache.has(key)){
        return this.assignmentClipCache.get(key);
      }
      const trimmed = this.createTrimmedClip(baseClip, clipId, start, end, fps);
      this.assignmentClipCache.set(key, trimmed);
      return trimmed;
    }

    getAssignmentDetails(action){
      const assignment = this.getAssignment(action);
      const clipId = assignment.clipId;
      if(!clipId || !this.clipMap.has(clipId)){
        return {
          clip: null,
          clipId: '',
          clipKey: '',
          speed: assignment.speed,
          startFrame: assignment.startFrame,
          endFrame: assignment.endFrame,
          label: ''
        };
      }
      const hasStart = Number.isFinite(assignment.startFrame);
      const hasEnd = Number.isFinite(assignment.endFrame);
      const clip = this.getProcessedClip(clipId, assignment.startFrame, assignment.endFrame);
      const clipKey = this.buildClipCacheKey(clipId, hasStart ? Math.round(assignment.startFrame) : null, hasEnd ? Math.round(assignment.endFrame) : null);
      const info = this.clipMap.get(clipId) || {};
      return {
        clip,
        clipId,
        clipKey,
        speed: assignment.speed,
        startFrame: assignment.startFrame,
        endFrame: assignment.endFrame,
        label: info.label || ''
      };
    }

    collectMaterials(object){
      const map = new Map();
      object.traverse(node => {
        if(!node.isMesh) return;
        const mats = Array.isArray(node.material) ? node.material : [node.material];
        mats.forEach(mat => {
          if(!mat || !mat.color || typeof mat.color.getHexString !== 'function') return;
          if(!map.has(mat.uuid)){
            map.set(mat.uuid, { material: mat, name: mat.name || node.name || 'Material', uses: 0 });
          }
          const entry = map.get(mat.uuid);
          entry.uses += 1;
        });
      });
      this.materialEntries = Array.from(map.values());
      this.renderMaterials();
    }

    renderMaterials(){
      if(!this.materialsEl) return;
      this.materialsEl.innerHTML = '';
      if(!this.materialEntries.length){
        const empty = document.createElement('div');
        empty.className = 'playerAnimationStatus';
        empty.textContent = 'No color-editable materials found.';
        this.materialsEl.appendChild(empty);
        return;
      }
      this.materialEntries.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
      this.materialEntries.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'playerAnimationMat';
        const label = document.createElement('label');
        label.textContent = `${entry.name} (${entry.uses})`;
        const picker = document.createElement('input');
        picker.type = 'color';
        try {
          picker.value = `#${entry.material.color.getHexString()}`;
        } catch {
          picker.value = '#000000';
        }
        picker.addEventListener('input', ()=>{
          try {
            entry.material.color.set(picker.value);
            entry.material.needsUpdate = true;
            this.setStatus(`Material "${entry.name}" â†’ ${picker.value}`);
            this.emitMaterialsUpdated();
          } catch(err){
            console.warn('Failed to update material color', err);
          }
        });
        row.appendChild(label);
        row.appendChild(picker);
        this.materialsEl.appendChild(row);
      });
    }

    handleError(err){
      console.error(err);
      const detail = err && typeof err.message === 'string' && err.message
        ? `: ${err.message}`
        : '.';
      this.setStatus(`Failed to load model${detail}`);
    }

    clearModel(){
      if(this.currentRoot){
        this.scene.remove(this.currentRoot);
        this.currentRoot.traverse(node => {
          if(node.isMesh){
            if(node.geometry && typeof node.geometry.dispose === 'function'){
              node.geometry.dispose();
            }
            const mats = Array.isArray(node.material) ? node.material : [node.material];
            mats.forEach(mat => {
              if(mat && typeof mat.dispose === 'function'){
                mat.dispose();
              }
            });
          }
        });
      }
      this.currentRoot = null;
      if(this.mixer){
        this.mixer.stopAllAction();
      }
      this.mixer = null;
      this.currentAction = null;
      this.currentClipKey = null;
      this.modelRadius = 0;
      this.modelHeight = 0;
      this.modelBasePosition = { x: 0, y: 0, z: 0 };
      this.clipLibrary = [];
      this.clipMap = new Map();
      this.assignmentClipCache.clear();
      this.materialEntries = [];
      if(this.materialsEl){
        this.materialsEl.innerHTML = '';
      }
      for(const [action, select] of Object.entries(this.selects)){
        if(!select) continue;
        select.innerHTML = '<option value="">â€”</option>';
        select.disabled = true;
        this.assignments[action] = this.createDefaultAssignment();
        this.syncActionInputs(action);
      }
      this.setModelScale(1, { force: true });
      this.currentState = 'idle';
      this.lastContext = {};
      if(this.placeholder){
        this.placeholder.visible = true;
        if(this.placeholderBasePosition){
          this.placeholder.position.set(
            this.placeholderBasePosition.x,
            this.placeholderBasePosition.y,
            this.placeholderBasePosition.z
          );
        }
      }
      this.applyModelOffsetToScene();
      this.emitAssignmentsChanged();
      this.emitModelCleared();
      this.modelLabel = '';
      this.lastAppliedSignature = null;
    }

    setStatus(message){
      if(this.statusEl){
        this.statusEl.textContent = message;
      }
    }

    setState(state, context = {}){
      this.currentState = state;
      this.lastContext = context || {};
      if(!this.mixer){
        return;
      }
      const details = this.getAssignmentDetails(state);
      const clip = details && details.clip;
      if(!clip){
        if(this.currentAction){
          this.currentAction.stop();
          this.currentAction = null;
          this.currentClipKey = null;
        }
        return;
      }
      const clipKey = details && details.clipKey ? details.clipKey : (details && details.clipId ? details.clipId : '');
      if(this.currentClipKey !== clipKey){
        if(this.currentAction){
          this.currentAction.stop();
        }
        const action = this.mixer.clipAction(clip);
        if(state === 'death'){
          action.setLoop(THREE.LoopOnce, 0);
          action.clampWhenFinished = true;
        } else {
          action.setLoop(THREE.LoopRepeat, Infinity);
          action.clampWhenFinished = false;
        }
        action.reset();
        action.play();
        this.currentAction = action;
        this.currentClipKey = clipKey;
      }
      const assignmentSpeed = details && Number.isFinite(details.speed) ? details.speed : 1;
      const contextSpeed = typeof context.speedFactor === 'number' && Number.isFinite(context.speedFactor) ? context.speedFactor : 1;
      const speedFactor = Math.max(0, assignmentSpeed) * contextSpeed;
      if(this.currentAction){
        this.currentAction.setEffectiveTimeScale(Math.max(0.001, speedFactor));
      }
    }

    applyState(state, context = {}, { force = false } = {}){
      if(force && this.currentAction){
        this.currentAction.stop();
        this.currentAction = null;
        this.currentClipKey = null;
      }
      this.setState(state, context);
    }

    emitModelLoaded(){
      if(typeof this.onModelLoaded === 'function'){
        try { this.onModelLoaded(this); } catch (err) { console.error(err); }
      }
    }

    emitModelCleared(){
      if(typeof this.onModelCleared === 'function'){
        try { this.onModelCleared(this); } catch (err) { console.error(err); }
      }
    }

    emitAssignmentsChanged(){
      if(typeof this.onAssignmentsChanged === 'function'){
        try { this.onAssignmentsChanged(this); } catch (err) { console.error(err); }
      }
    }

    emitMaterialsUpdated(){
      if(typeof this.onMaterialsUpdated === 'function'){
        try { this.onMaterialsUpdated(this); } catch (err) { console.error(err); }
      }
    }

    emitModelScaleChanged(){
      if(typeof this.onModelScaleChanged === 'function'){
        try { this.onModelScaleChanged(this); } catch (err) { console.error(err); }
      }
    }

    emitModelOffsetChanged(){
      if(typeof this.onModelOffsetChanged === 'function'){
        try { this.onModelOffsetChanged(this); } catch (err) { console.error(err); }
      }
    }

    getTargetPlayerRadius(){
      if(typeof playerRuntime.model !== 'undefined' && playerRuntime.model && Number.isFinite(playerRuntime.model.playerRadius) && playerRuntime.model.playerRadius > 0){
        return playerRuntime.model.playerRadius;
      }
      if(typeof player !== 'undefined' && player && Number.isFinite(player.r) && player.r > 0){
        return player.r;
      }
      return 10;
    }

    getModelSignature(){
      const base = normalizeLabel(this.modelLabel);
      const clipSignature = this.clipLibrary
        .map(info => normalizeLabel(info && info.label))
        .filter(Boolean)
        .sort()
        .join('|');
      const materialSignature = this.materialEntries
        .map(entry => normalizeLabel(entry && entry.name))
        .filter(Boolean)
        .sort()
        .join('|');
      return `${base}::${clipSignature}::${materialSignature}`;
    }

    buildConfigurationSnapshot(){
      if(!this.hasModel()){
        return null;
      }
      const assignments = {};
      for(const action of PLAYER_ANIMATION_ACTIONS){
        const assignment = this.getAssignment(action);
        const id = assignment.clipId || '';
        if(!id){
          continue;
        }
        const info = this.clipMap.get(id);
        assignments[action] = {
          clipId: id,
          clipLabel: info && info.label ? info.label : '',
          speed: assignment.speed,
          startFrame: assignment.startFrame,
          endFrame: assignment.endFrame
        };
      }
      const materials = this.materialEntries.map(entry => {
        let color = null;
        if(entry && entry.material && entry.material.color && typeof entry.material.color.getHexString === 'function'){
          try {
            color = `#${entry.material.color.getHexString()}`;
          } catch (err){
            color = null;
          }
        }
        return {
          name: entry && entry.name ? entry.name : '',
          color
        };
      });
      const snapshot = {
        version: 1,
        savedAt: new Date().toISOString(),
        modelLabel: this.modelLabel || '',
        signature: this.getModelSignature(),
        scale: this.modelScale,
        offset: {
          horizontal: this.modelOffsetHorizontalPx,
          vertical: this.modelOffsetVerticalPx
        },
        lightAzimuthDegrees: this.lightAzimuthDegrees,
        assignments,
        clipLibrary: this.clipLibrary.map(info => ({
          id: info && info.id ? info.id : '',
          label: info && info.label ? info.label : ''
        })),
        materials
      };
      return snapshot;
    }

    downloadConfigurationSnapshot(snapshot){
      if(!snapshot){
        return false;
      }
      try {
        const json = JSON.stringify(snapshot, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = formatPlayerAnimationConfigFilename(this.modelLabel);
        const parent = document.body || document.documentElement;
        if(parent){
          parent.appendChild(link);
          link.click();
          parent.removeChild(link);
        } else {
          link.click();
        }
        setTimeout(()=> URL.revokeObjectURL(url), 0);
        return true;
      } catch (err){
        console.error('Failed to export animation setup', err);
        return false;
      }
    }

    persistConfigurationSnapshot(signature, snapshot){
      if(!signature || !snapshot){
        return false;
      }
      const stored = loadPlayerAnimationConfigurations();
      stored[signature] = snapshot;
      const success = savePlayerAnimationConfigurations(stored);
      if(success){
        this.lastSavedSignature = signature;
      }
      return success;
    }

    saveConfiguration({ download = true } = {}){
      if(!this.hasModel()){
        this.setStatus('Load a model before saving the animation setup.');
        return false;
      }
      const snapshot = this.buildConfigurationSnapshot();
      if(!snapshot){
        this.setStatus('Nothing to save yet.');
        return false;
      }
      const signature = snapshot.signature || this.getModelSignature();
      this.persistConfigurationSnapshot(signature, snapshot);
      if(download){
        this.downloadConfigurationSnapshot(snapshot);
      }
      this.setStatus('Saved player animation setup.');
      return true;
    }

    applyConfigurationSnapshot(snapshot, { silent = false } = {}){
      if(!snapshot || !this.hasModel()){
        return false;
      }
      let applied = false;
      const scale = Number(snapshot.scale);
      if(Number.isFinite(scale) && scale > 0){
        this.setModelScale(scale, { force: true });
        this.applyModelScale({ refit: true, emit: true });
        applied = true;
      }
      const offsetSource = snapshot.offset || snapshot.offsets || snapshot.modelOffset || {};
      const horizontal = Number(offsetSource.horizontal ?? offsetSource.x ?? snapshot.modelOffsetHorizontalPx);
      const vertical = Number(offsetSource.vertical ?? offsetSource.y ?? snapshot.modelOffsetVerticalPx);
      if(Number.isFinite(horizontal) || Number.isFinite(vertical)){
        this.setModelOffset({
          horizontal: Number.isFinite(horizontal) ? horizontal : this.modelOffsetHorizontalPx,
          vertical: Number.isFinite(vertical) ? vertical : this.modelOffsetVerticalPx
        }, { syncInputs: true, force: true, emit: true });
        applied = true;
      }
      const light = Number(snapshot.lightAzimuthDegrees);
      if(Number.isFinite(light)){
        this.setLightAzimuth(light, { syncInputs: true, force: true });
        applied = true;
      }
      if(snapshot.assignments && typeof snapshot.assignments === 'object'){
        const idMap = new Map();
        const labelMap = new Map();
        this.clipLibrary.forEach(info => {
          if(!info) return;
          if(info.id){
            idMap.set(info.id, info.id);
          }
          if(info.label){
            const key = normalizeLabel(info.label);
            if(key && !labelMap.has(key)){
              labelMap.set(key, info.id);
            }
          }
        });
        let assignmentChanged = false;
        for(const action of PLAYER_ANIMATION_ACTIONS){
          const entry = snapshot.assignments[action];
          let targetId = '';
          let desiredSpeed;
          let desiredStart;
          let desiredEnd;
          if(entry){
            if(typeof entry === 'string'){
              targetId = labelMap.get(normalizeLabel(entry)) || '';
            } else if(typeof entry === 'object'){
              if(entry.clipId && idMap.has(entry.clipId)){
                targetId = entry.clipId;
              } else if(entry.clipLabel){
                targetId = labelMap.get(normalizeLabel(entry.clipLabel)) || '';
              }
              if('speed' in entry){
                desiredSpeed = entry.speed;
              }
              if('startFrame' in entry){
                desiredStart = entry.startFrame;
              }
              if('endFrame' in entry){
                desiredEnd = entry.endFrame;
              }
            }
          }
          const updates = { clipId: targetId };
          if(desiredSpeed !== undefined){
            updates.speed = desiredSpeed;
          }
          if(desiredStart !== undefined){
            updates.startFrame = desiredStart;
          }
          if(desiredEnd !== undefined){
            updates.endFrame = desiredEnd;
          }
          const changed = this.setAssignment(action, updates, { emit: false, reapply: false });
          const select = this.selects[action];
          if(select){
            select.disabled = !this.clipLibrary.length;
            select.value = targetId || '';
          }
          this.syncActionInputs(action);
          if(changed){
            assignmentChanged = true;
          }
        }
        if(assignmentChanged){
          this.applyState(this.currentState, this.lastContext, { force: true });
        }
        this.emitAssignmentsChanged();
        applied = assignmentChanged || applied;
      }
      if(Array.isArray(snapshot.materials) && snapshot.materials.length){
        const materialMap = new Map();
        this.materialEntries.forEach(entry => {
          const key = normalizeLabel(entry && entry.name);
          if(key && !materialMap.has(key)){
            materialMap.set(key, entry);
          }
        });
        let materialsApplied = false;
        snapshot.materials.forEach(item => {
          if(!item) return;
          const nameKey = normalizeLabel(item.name || item.label);
          const colorValue = typeof item.color === 'string' ? item.color : (typeof item.hex === 'string' ? item.hex : null);
          if(!nameKey || !colorValue) return;
          const entry = materialMap.get(nameKey);
          if(entry && entry.material && entry.material.color){
            try {
              entry.material.color.set(colorValue);
              entry.material.needsUpdate = true;
              materialsApplied = true;
            } catch (err){
              console.warn('Failed to restore material color', err);
            }
          }
        });
        if(materialsApplied){
          this.renderMaterials();
          this.emitMaterialsUpdated();
          applied = true;
        }
      }
      if(!silent){
        this.setStatus('Restored saved animation setup.');
      }
      this.lastAppliedSignature = snapshot.signature || this.getModelSignature();
      return applied;
    }

    tryRestoreConfiguration(){
      const signature = this.getModelSignature();
      if(!signature){
        return false;
      }
      const stored = loadPlayerAnimationConfigurations();
      const snapshot = stored[signature];
      if(snapshot){
        return this.applyConfigurationSnapshot(snapshot, { silent: true });
      }
      return false;
    }

    autoScaleModel({ silent = false } = {}){
      if(!this.currentRoot){
        return false;
      }
      const targetRadius = this.getTargetPlayerRadius();
      const baseScale = Math.max(this.modelScale || 1, 0.0001);
      const baseRadius = this.modelRadius / baseScale;
      if(!(targetRadius > 0) || !(baseRadius > 0)){
        return false;
      }
      const recommended = targetRadius / baseRadius;
      if(!Number.isFinite(recommended) || recommended <= 0){
        return false;
      }
      this.setModelScale(recommended, { force: true });
      this.applyModelScale({ refit: true, emit: true });
      if(!silent){
        this.setStatus(`Auto-scaled model to ${recommended.toFixed(2)}Ã— to match player.`);
      }
      return true;
    }

    getAssignmentsSnapshot(){
      const snapshot = {};
      for(const action of PLAYER_ANIMATION_ACTIONS){
        snapshot[action] = this.getAssignment(action);
      }
      return snapshot;
    }

    getClipForAction(action){
      if(!action || !this.clipMap){
        return null;
      }
      const details = this.getAssignmentDetails(action);
      return details ? details.clip : null;
    }

    createRuntimeClone(){
      if(!this.currentRoot){
        return null;
      }
      const clone = cloneSkinnedModel(this.currentRoot);
      if(!clone){
        return null;
      }
      const scale = Math.max(0.01, this.modelScale || 1);
      clone.scale.setScalar(scale);
      clone.updateMatrixWorld(true);
      const box = new THREE.Box3().setFromObject(clone);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);
      clone.position.sub(center);
      box.setFromObject(clone);
      if(Number.isFinite(box.min.y)){
        clone.position.y -= box.min.y;
      }
      clone.traverse(node => {
        if(node.isMesh){
          node.castShadow = true;
          node.receiveShadow = true;
        }
      });
      return clone;
    }

    hasModel(){
      return !!this.currentRoot;
    }
  }

  class PlayerModelRuntime {
    constructor({ anchor, canvas } = {}){
      this.anchor = anchor || null;
      this.canvas = canvas || null;
      this.renderer = null;
      this.scene = null;
      this.camera = null;
      this.clock = null;
      this.ground = null;
      this.mixer = null;
      this.modelRoot = null;
      this.currentAction = null;
      this.currentClip = null;
      this.currentState = 'idle';
      this.lastContext = {};
      this.controller = null;
      this.playerRadius = 10;
      this.lastSizePx = 0;
      this.visible = false;
      this.assignments = {};
      this.modelRadius = 0;
      this.modelHeight = 0;
      this.modelScale = 1;
      this.facingRadians = 0;
      this.modelBasePosition = { x: 0, y: 0, z: 0 };
      this.modelOffsetHorizontalPx = 0;
      this.modelOffsetVerticalPx = 0;
      this.init();
      this.applyAnchorOffset();
    }

    init(){
      if(!this.canvas){
        return;
      }
      this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
      this.renderer.outputColorSpace = THREE.SRGBColorSpace;
      this.renderer.shadowMap.enabled = true;
      this.scene = new THREE.Scene();
      this.scene.background = null;
      this.camera = new THREE.PerspectiveCamera(55, 1, 0.1, 2000);
      this.camera.position.set(0, 1.35, 3.2);
      this.clock = new THREE.Clock();
      const hemi = new THREE.HemisphereLight(0xffffff, 0x202020, 0.85);
      this.scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.1);
      dir.position.set(2.6, 4.2, 2.4);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024, 1024);
      this.scene.add(dir);
      const groundGeo = new THREE.CircleGeometry(3.2, 48);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x0f1a2a, transparent: true, opacity: 0.0 });
      this.ground = new THREE.Mesh(groundGeo, groundMat);
      this.ground.rotation.x = -Math.PI / 2;
      this.ground.receiveShadow = true;
      this.scene.add(this.ground);
      this.updateRendererSize(true);
      if(this.anchor){
        this.anchor.dataset.active = 'false';
      }
      window.addEventListener('resize', ()=> this.updateRendererSize());
    }

    updateRendererSize(force = false){
      if(!this.renderer || !this.canvas){
        return;
      }
      const radius = Math.max(1, Number(this.playerRadius) || 1);
      const modelTarget = this.modelRadius > 0 ? this.modelRadius * 28 : 0;
      const target = Math.max(80, radius * 12, modelTarget);
      if(!force && Math.abs(target - this.lastSizePx) < 0.5){
        return;
      }
      this.lastSizePx = target;
      const size = Math.round(target);
      const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
      this.renderer.setPixelRatio(pixelRatio);
      this.renderer.setSize(size, size, false);
      this.canvas.style.width = `${size}px`;
      this.canvas.style.height = `${size}px`;
      if(this.anchor){
        this.anchor.style.width = `${size}px`;
        this.anchor.style.height = `${size}px`;
      }
      if(this.camera){
        this.camera.aspect = 1;
        this.camera.updateProjectionMatrix();
      }
    }

    setPlayerRadius(radius){
      const numeric = Math.max(0, Number(radius) || 0);
      if(numeric === this.playerRadius){
        return;
      }
      this.playerRadius = numeric;
      this.updateRendererSize();
    }

    clampModelOffsetPx(value){
      const numeric = Number(value);
      if(!Number.isFinite(numeric)){
        return 0;
      }
      return Math.max(PLAYER_MODEL_OFFSET_MIN, Math.min(PLAYER_MODEL_OFFSET_MAX, numeric));
    }

    setModelOffsets(horizontal, vertical, { force = false } = {}){
      let changed = false;
      if(horizontal !== undefined && horizontal !== null){
        const clamped = this.clampModelOffsetPx(horizontal);
        if(force || Math.abs(clamped - this.modelOffsetHorizontalPx) > 0.0001){
          this.modelOffsetHorizontalPx = clamped;
          changed = true;
        }
      }
      if(vertical !== undefined && vertical !== null){
        const clamped = this.clampModelOffsetPx(vertical);
        if(force || Math.abs(clamped - this.modelOffsetVerticalPx) > 0.0001){
          this.modelOffsetVerticalPx = clamped;
          changed = true;
        }
      }
      if(changed || force){
        this.applyAnchorOffset();
      }
    }

    applyAnchorOffset(){
      if(!this.anchor){
        return;
      }
      const offsetX = Math.round(this.modelOffsetHorizontalPx);
      const offsetY = Math.round(this.modelOffsetVerticalPx);
      const baseTransform = 'translate(-50%, -100%)';
      this.anchor.style.transform = `${baseTransform} translate(${offsetX}px, ${offsetY}px)`;
      this.anchor.dataset.offsetX = `${offsetX}`;
      this.anchor.dataset.offsetY = `${offsetY}`;
    }

    updateOffsetFromController({ force = false } = {}){
      if(!this.controller || typeof this.controller.getModelOffset !== 'function'){
        return;
      }
      const offsets = this.controller.getModelOffset();
      if(!offsets){
        return;
      }
      this.setModelOffsets(offsets.horizontal, offsets.vertical, { force });
    }

    setPosition(x, y, radius = null){
      if(Number.isFinite(radius)){
        this.setPlayerRadius(radius);
      }
      if(!this.anchor){
        return;
      }
      const px = Number.isFinite(x) ? x : 0;
      const py = Number.isFinite(y) ? y : 0;
      this.anchor.style.left = `${px}px`;
      this.anchor.style.top = `${py}px`;
    }

    attachController(controller){
      this.controller = controller || null;
      this.refreshModel();
      this.updateAssignmentsFromController();
      this.updateOffsetFromController({ force: true });
    }

    refreshModel(){
      if(!this.controller || !this.controller.hasModel()){
        this.clearModel();
        return;
      }
      const scale = this.controller && typeof this.controller.getModelScale === 'function'
        ? this.controller.getModelScale()
        : 1;
      if(Number.isFinite(scale) && scale > 0){
        this.modelScale = scale;
      }
      const clone = this.controller.createRuntimeClone();
      if(!clone){
        this.clearModel();
        return;
      }
      this.setModel(clone);
      this.updateOffsetFromController({ force: true });
    }

    disposeModel(root){
      // Runtime clones share buffers with the editor preview; avoid disposing to keep materials intact.
      void root;
    }

    setModel(root){
      if(this.modelRoot){
        this.scene.remove(this.modelRoot);
        this.disposeModel(this.modelRoot);
      }
      this.modelRoot = root;
      if(!root){
        if(this.mixer){
          this.mixer.stopAllAction();
        }
        this.mixer = null;
        this.currentAction = null;
        this.currentClip = null;
        this.visible = false;
        this.modelRadius = 0;
        this.modelHeight = 0;
        if(this.anchor){
          this.anchor.dataset.active = 'false';
        }
        return;
      }
      if(root && Number.isFinite(this.modelScale)){
        root.scale.setScalar(this.modelScale);
        root.updateMatrixWorld(true);
      }
      this.scene.add(root);
      root.rotation.y = 0;
      this.frameModel();
      this.setFacingRadians(this.facingRadians);
      this.mixer = new THREE.AnimationMixer(root);
      this.currentAction = null;
      this.currentClip = null;
      this.visible = true;
      if(this.anchor){
        this.anchor.dataset.active = 'true';
      }
      this.updateRendererSize(true);
      this.applyState(this.currentState, this.lastContext, { force: true });
    }

    clearModel(){
      if(this.modelRoot){
        this.scene.remove(this.modelRoot);
        this.disposeModel(this.modelRoot);
        this.modelRoot = null;
      }
      if(this.mixer){
        this.mixer.stopAllAction();
      }
      this.mixer = null;
      this.currentAction = null;
      this.currentClip = null;
      this.visible = false;
      this.modelRadius = 0;
      this.modelHeight = 0;
      this.modelBasePosition = { x: 0, y: 0, z: 0 };
      if(this.anchor){
        this.anchor.dataset.active = 'false';
      }
    }

    updateAssignmentsFromController(){
      if(!this.controller){
        this.assignments = {};
        return;
      }
      this.assignments = this.controller.getAssignmentsSnapshot();
      this.updateScaleFromController();
      this.updateOffsetFromController({ force: true });
      this.applyState(this.currentState, this.lastContext, { force: true });
    }

    updateScaleFromController({ force = false } = {}){
      if(!this.controller){
        return;
      }
      const scale = typeof this.controller.getModelScale === 'function'
        ? this.controller.getModelScale()
        : 1;
      if(!Number.isFinite(scale) || scale <= 0){
        return;
      }
      const changed = force || Math.abs(scale - this.modelScale) > 0.0001;
      this.modelScale = scale;
      if(changed && this.modelRoot){
        this.modelRoot.scale.setScalar(this.modelScale);
        this.modelRoot.updateMatrixWorld(true);
        this.frameModel();
        this.updateRendererSize(true);
        this.updateOffsetFromController({ force: true });
      }
    }

    setState(state, context = {}){
      this.applyState(state, context);
    }

    applyState(state, context = {}, { force = false } = {}){
      this.currentState = state;
      this.lastContext = context || {};
      if(force && this.currentAction){
        this.currentAction.stop();
        this.currentAction = null;
        this.currentClip = null;
      }
      if(!this.mixer || !this.controller){
        return;
      }
      const details = typeof this.controller.getAssignmentDetails === 'function'
        ? this.controller.getAssignmentDetails(state)
        : null;
      const clip = details && details.clip ? details.clip : null;
      if(!clip){
        if(this.currentAction){
          this.currentAction.stop();
          this.currentAction = null;
          this.currentClip = null;
        }
        return;
      }
      if(force || this.currentClip !== clip){
        if(this.currentAction){
          this.currentAction.stop();
        }
        const action = this.mixer.clipAction(clip);
        if(state === 'death'){
          action.setLoop(THREE.LoopOnce, 0);
          action.clampWhenFinished = true;
        } else {
          action.setLoop(THREE.LoopRepeat, Infinity);
          action.clampWhenFinished = false;
        }
        action.reset();
        action.play();
        this.currentAction = action;
        this.currentClip = clip;
      }
      const assignmentSpeed = details && Number.isFinite(details.speed) ? details.speed : 1;
      const contextSpeed = typeof context.speedFactor === 'number' && Number.isFinite(context.speedFactor) ? context.speedFactor : 1;
      const speedFactor = Math.max(0, assignmentSpeed) * contextSpeed;
      if(this.currentAction){
        this.currentAction.setEffectiveTimeScale(Math.max(0.001, speedFactor));
      }
      const facing = Number.isFinite(context.facingRadians) ? context.facingRadians : this.facingRadians;
      if(Number.isFinite(facing)){
        this.setFacingRadians(facing);
      }
    }

    update(dt = 0){
      if(!this.visible || !this.renderer){
        return;
      }
      const delta = Number.isFinite(dt) && dt > 0 ? dt : (this.clock ? this.clock.getDelta() : 0);
      if(this.mixer && delta >= 0){
        this.mixer.update(delta);
      }
      this.renderer.render(this.scene, this.camera);
    }

    refreshMaterials(){
      this.refreshModel();
    }

    isActive(){
      return this.visible && !!this.modelRoot;
    }

    setFacingRadians(angle){
      if(!Number.isFinite(angle)){
        return;
      }
      this.facingRadians = angle;
      if(this.modelRoot){
        this.modelRoot.rotation.y = angle;
        this.modelRoot.updateMatrixWorld(true);
      }
    }

    frameModel(){
      if(!this.modelRoot || !this.camera){
        return;
      }
      const initialBox = new THREE.Box3().setFromObject(this.modelRoot);
      if(!Number.isFinite(initialBox.min.x) || !Number.isFinite(initialBox.max.x)){
        return;
      }
      const centerOffset = new THREE.Vector3(
        (initialBox.min.x + initialBox.max.x) * 0.5,
        0,
        (initialBox.min.z + initialBox.max.z) * 0.5
      );
      this.modelRoot.position.sub(centerOffset);
      this.modelRoot.updateMatrixWorld(true);

      const groundedBox = new THREE.Box3().setFromObject(this.modelRoot);
      if(Number.isFinite(groundedBox.min.y)){
        this.modelRoot.position.y -= groundedBox.min.y;
        this.modelRoot.updateMatrixWorld(true);
      }

      const finalBox = new THREE.Box3().setFromObject(this.modelRoot);
      const size = new THREE.Vector3();
      finalBox.getSize(size);
      const height = size.y || 1;
      const sphere = finalBox.getBoundingSphere(new THREE.Sphere());
      const radius = sphere && Number.isFinite(sphere.radius) && sphere.radius > 0
        ? sphere.radius
        : Math.max(size.length() / Math.sqrt(3), 1);

      this.modelRadius = radius;
      this.modelHeight = height;
      this.modelBasePosition = {
        x: this.modelRoot.position.x,
        y: this.modelRoot.position.y,
        z: this.modelRoot.position.z
      };
      this.applyAnchorOffset();

      const viewSize = Math.max(height, radius * 2);
      const halfFov = THREE.MathUtils.degToRad(this.camera.fov * 0.5);
      const distance = (viewSize * 0.5) / Math.tan(halfFov);
      const finalDistance = distance * 1.2;

      this.camera.position.set(0, height * 0.55 + radius * 0.1, finalDistance);
      this.camera.near = Math.max(0.05, finalDistance / 20);
      this.camera.far = Math.max(10, finalDistance * 4 + radius * 2);
      this.camera.lookAt(0, Math.max(0.4, height * 0.5), 0);
      this.camera.updateProjectionMatrix();

      if(this.ground){
        const groundScale = Math.max(1.5, radius * 1.4);
        this.ground.scale.set(groundScale, groundScale, 1);
        this.ground.position.set(0, 0, 0);
      }
    }
  }

  if(playerAnimationCanvas && playerAnimationStage){
    playerRuntime.animationController = new PlayerAnimationController({
      canvas: playerAnimationCanvas,
      stage: playerAnimationStage,
      dropEl: playerAnimationDrop,
      statusEl: playerAnimationStatus,
      materialsEl: playerAnimationMaterialsEl,
      selects: playerAnimationActionSelects,
      actionInputs: playerAnimationActionInputs,
      scaleRange: playerAnimationScaleRange,
      scaleInput: playerAnimationScaleInput,
      offsetHorizontalInput: playerAnimationOffsetHorizontalInput,
      offsetVerticalInput: playerAnimationOffsetVerticalInput,
      lightAngleRange: playerAnimationLightAngleRange,
      lightAngleInput: playerAnimationLightAngleInput
    });
    playerRuntime.animationController.setStatus('No player model loaded.');
  }

  if(playerModelAnchor && playerModelCanvas){
    playerRuntime.model = new PlayerModelRuntime({
      anchor: playerModelAnchor,
      canvas: playerModelCanvas
    });
  }

  function updatePlayerAnimationSaveState(){
    if(!btnPlayerAnimationSave && !btnPlayerAnimationLoadSetup){
      return;
    }
    const canSave = !!(playerRuntime.animationController && typeof playerRuntime.animationController.hasModel === 'function' && playerRuntime.animationController.hasModel());
    if(btnPlayerAnimationSave){
      btnPlayerAnimationSave.disabled = !canSave;
    }
    if(btnPlayerAnimationLoadSetup){
      btnPlayerAnimationLoadSetup.disabled = !canSave;
    }
  }

  function sanitizeFileStem(filename){
    if(typeof filename !== 'string' || !filename){
      return 'mixamo_character';
    }
    const stem = filename.replace(/\.[^/.]+$/, '');
    const normalized = typeof stem.normalize === 'function'
      ? stem.normalize('NFKD').replace(/[\u0300-\u036f]/g, '')
      : stem;
    const sanitized = normalized.replace(/[^a-zA-Z0-9_-]+/g, '_').replace(/_+/g, '_').replace(/^_+|_+$/g, '');
    return sanitized || 'mixamo_character';
  }

  function sanitizeClipLabel(label){
    if(typeof label !== 'string' || !label){
      return 'clip';
    }
    const normalized = typeof label.normalize === 'function'
      ? label.normalize('NFKD').replace(/[\u0300-\u036f]/g, '')
      : label;
    const sanitized = normalized.replace(/[^a-zA-Z0-9_-]+/g, '_').replace(/_+/g, '_').replace(/^_+|_+$/g, '');
    return sanitized || 'clip';
  }

  function extractAnimationsFromObject(object){
    const clips = [];
    const seen = new Set();
    if(!object){
      return clips;
    }
    if(Array.isArray(object.animations)){
      object.animations.forEach(clip => {
        if(clip && !seen.has(clip)){
          clips.push(clip);
          seen.add(clip);
        }
      });
    }
    if(typeof object.traverse === 'function'){
      object.traverse(child => {
        if(child === object){
          return;
        }
        if(Array.isArray(child.animations)){
          child.animations.forEach(clip => {
            if(clip && !seen.has(clip)){
              clips.push(clip);
              seen.add(clip);
            }
          });
        }
      });
    }
    return clips;
  }

  function arrayBufferToBase64(buffer){
    if(!buffer || buffer.byteLength === 0){
      return '';
    }
    const bytes = new Uint8Array(buffer);
    const chunkSize = 0x8000;
    let binary = '';
    for(let i = 0; i < bytes.length; i += chunkSize){
      const chunk = bytes.subarray(i, i + chunkSize);
      let chunkString = '';
      for(let j = 0; j < chunk.length; j++){
        chunkString += String.fromCharCode(chunk[j]);
      }
      binary += chunkString;
    }
    return btoa(binary);
  }

  function base64ToArrayBuffer(base64){
    if(typeof base64 !== 'string' || !base64){
      return new ArrayBuffer(0);
    }
    const normalized = base64.replace(/[^A-Za-z0-9+/=]+/g, '');
    const binary = atob(normalized);
    const length = binary.length;
    const bytes = new Uint8Array(length);
    for(let i = 0; i < length; i++){
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }

  function createUniqueClipName(fileName, variantIndex, variantCount, existingNames, preferredName){
    const stem = sanitizeFileStem(fileName);
    const preferred = typeof preferredName === 'string' && preferredName.trim() ? preferredName.trim() : null;
    const baseLabel = preferred ? preferred : (variantCount > 1 ? `${stem}_${variantIndex + 1}` : stem);
    const sanitized = sanitizeClipLabel(baseLabel);
    let candidate = sanitized;
    if(existingNames.has(candidate)){
      let suffix = 2;
      while(existingNames.has(`${candidate}_${suffix}`)){
        suffix += 1;
      }
      candidate = `${candidate}_${suffix}`;
    }
    existingNames.add(candidate);
    return candidate;
  }

  function combineMixamoBuffers(baseBuffer, baseName, animationSources){
    if(!baseBuffer){
      throw new Error('Select a Mixamo character in T-pose first.');
    }
    const baseLoader = new FBXLoader();
    const baseObject = baseLoader.parse(baseBuffer, './');
    if(!baseObject){
      throw new Error('Unable to parse Mixamo character .fbx file.');
    }
    const combinedClips = extractAnimationsFromObject(baseObject).map(clip => (clip && typeof clip.clone === 'function') ? clip.clone() : clip).filter(Boolean);
    const existingNames = new Set(combinedClips.map(clip => (clip && typeof clip.name === 'string') ? clip.name : '').filter(name => !!name));
    const animationLoader = new FBXLoader();
    let importedCount = 0;
    const metadata = [];
    for(const source of animationSources){
      const entry = {
        fileName: source && typeof source.fileName === 'string' ? source.fileName : 'animation.fbx',
        clipNames: []
      };
      metadata.push(entry);
      if(!source || !source.buffer){
        continue;
      }
      const animObject = animationLoader.parse(source.buffer, './');
      const clips = extractAnimationsFromObject(animObject);
      if(!clips.length){
        console.warn('No animation clips found in Mixamo file:', entry.fileName);
        continue;
      }
      clips.forEach((clip, index) => {
        if(!clip){
          return;
        }
        const renamed = typeof clip.clone === 'function' ? clip.clone() : clip;
        const preferred = source && Array.isArray(source.preferredNames) ? source.preferredNames[index] : null;
        renamed.name = createUniqueClipName(entry.fileName, index, clips.length, existingNames, preferred);
        entry.clipNames.push(renamed.name);
        combinedClips.push(renamed);
        importedCount += 1;
      });
    }
    if(importedCount === 0){
      throw new Error('No animations were imported from the selected files.');
    }
    baseObject.animations = combinedClips;
    const clipNames = combinedClips.map(clip => (clip && typeof clip.name === 'string') ? clip.name : '').filter(name => !!name);
    return {
      baseObject,
      animationCount: importedCount,
      clipNames,
      metadata,
      baseName: typeof baseName === 'string' && baseName ? baseName : 'mixamo_character'
    };
  }

  function isLikelyMixamoPack(buffer){
    if(!buffer || buffer.byteLength < 2){
      return false;
    }
    const view = new Uint8Array(buffer, 0, 1);
    const first = view[0];
    return first === 123 || first === 91; // '{' or '['
  }

  function parseMixamoPackBuffer(buffer){
    const text = new TextDecoder().decode(buffer);
    const data = JSON.parse(text);
    if(!data || data.format !== 'MakaMobaMixamoPack'){
      return null;
    }
    return data;
  }

  function loadMixamoPack(buffer){
    if(!isLikelyMixamoPack(buffer)){
      return null;
    }
    let pack;
    try {
      pack = parseMixamoPackBuffer(buffer);
    } catch (err){
      throw new Error('Invalid Mixamo combination pack.');
    }
    if(!pack){
      return null;
    }
    if(!pack.base || typeof pack.base.data !== 'string' || !pack.base.data){
      throw new Error('Mixamo combination pack is missing character data.');
    }
    const baseBuffer = base64ToArrayBuffer(pack.base.data);
    const animationEntries = Array.isArray(pack.animations) ? pack.animations : [];
    const animationSources = animationEntries.map(entry => ({
      fileName: entry && typeof entry.name === 'string' ? entry.name : 'animation.fbx',
      buffer: entry && typeof entry.data === 'string' ? base64ToArrayBuffer(entry.data) : null,
      preferredNames: entry && Array.isArray(entry.clipNames) ? entry.clipNames : []
    }));
    const baseLabel = pack.base && pack.base.name ? pack.base.name : 'mixamo_character';
    const combined = combineMixamoBuffers(baseBuffer, baseLabel, animationSources);
    const labelSource = (typeof pack.fileName === 'string' && pack.fileName) ? pack.fileName : baseLabel;
    const fileStem = sanitizeFileStem(labelSource);
    const fileName = (typeof pack.fileName === 'string' && pack.fileName) ? pack.fileName : `${fileStem}_mixamo_combined.fbx`;
    return {
      object: combined.baseObject,
      animationCount: combined.animationCount,
      clipNames: combined.clipNames,
      fileName
    };
  }

  async function combineMixamoAnimations(baseFile, animationFiles){
    if(!baseFile){
      throw new Error('Select a Mixamo character in T-pose first.');
    }
    if(!animationFiles || !animationFiles.length){
      throw new Error('Select one or more Mixamo animation files.');
    }
    const baseBuffer = await baseFile.arrayBuffer();
    const animationBuffers = [];
    const animationSources = [];
    for(const file of animationFiles){
      if(!file){
        continue;
      }
      const buffer = await file.arrayBuffer();
      animationBuffers.push(buffer);
      animationSources.push({ fileName: file.name, buffer });
    }
    const combined = combineMixamoBuffers(baseBuffer, baseFile.name, animationSources);
    const pack = {
      format: 'MakaMobaMixamoPack',
      version: 1,
      createdAt: new Date().toISOString(),
      fileName: `${sanitizeFileStem(baseFile.name)}_mixamo_combined.fbx`,
      base: {
        name: baseFile.name,
        size: baseBuffer.byteLength,
        data: arrayBufferToBase64(baseBuffer)
      },
      animations: animationSources.map((source, index) => ({
        name: source.fileName,
        size: animationBuffers[index] ? animationBuffers[index].byteLength : 0,
        clipNames: combined.metadata[index] ? combined.metadata[index].clipNames : [],
        data: animationBuffers[index] ? arrayBufferToBase64(animationBuffers[index]) : ''
      })),
      summary: {
        animationCount: combined.animationCount,
        clipNames: combined.clipNames
      }
    };
    const json = JSON.stringify(pack);
    const blob = new Blob([json], { type: 'application/json' });
    const arrayBuffer = await blob.arrayBuffer();
    return {
      blob,
      fileName: pack.fileName,
      animationCount: combined.animationCount,
      clipNames: combined.clipNames,
      arrayBuffer
    };
  }

  function downloadBlob(blob, filename){
    if(!blob){
      return;
    }
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || 'combined.fbx';
    document.body.appendChild(link);
    link.click();
    requestAnimationFrame(()=>{
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });
  }

  if(playerRuntime.animationController && playerRuntime.model){
    const controller = playerRuntime.animationController;
    controller.onModelLoaded = ()=>{
      playerRuntime.model.attachController(controller);
    };
    controller.onModelCleared = ()=>{
      playerRuntime.model.clearModel();
    };
    controller.onAssignmentsChanged = ()=>{
      playerRuntime.model.updateAssignmentsFromController();
    };
    controller.onMaterialsUpdated = ()=>{
      playerRuntime.model.refreshMaterials();
    };
    controller.onModelScaleChanged = ()=>{
      playerRuntime.model.updateScaleFromController({ force: true });
    };
    controller.onModelOffsetChanged = ()=>{
      playerRuntime.model.updateOffsetFromController({ force: true });
    };
    playerRuntime.model.attachController(controller);
    updatePlayerAnimationSaveState();
  }

  if(playerRuntime.animationController){
    const controller = playerRuntime.animationController;
    const previousOnModelLoaded = controller.onModelLoaded;
    controller.onModelLoaded = ()=>{
      if(typeof previousOnModelLoaded === 'function'){
        try { previousOnModelLoaded(); } catch (err) { console.error(err); }
      }
      updatePlayerAnimationSaveState();
    };
    const previousOnModelCleared = controller.onModelCleared;
    controller.onModelCleared = ()=>{
      if(typeof previousOnModelCleared === 'function'){
        try { previousOnModelCleared(); } catch (err) { console.error(err); }
      }
      updatePlayerAnimationSaveState();
    };
  }

  if(btnPlayerAnimation && playerAnimationSection){
    btnPlayerAnimation.setAttribute('aria-expanded', 'false');
    btnPlayerAnimation.addEventListener('click', ()=>{
      const hidden = playerAnimationSection.hasAttribute('hidden');
      if(hidden){
        playerAnimationSection.removeAttribute('hidden');
        btnPlayerAnimation.setAttribute('aria-expanded', 'true');
        if(playerRuntime.animationController){
          requestAnimationFrame(()=> playerRuntime.animationController.refreshSize());
        }
      } else {
        playerAnimationSection.setAttribute('hidden', '');
        btnPlayerAnimation.setAttribute('aria-expanded', 'false');
      }
    });
  }

  if(btnPlayerAnimationLoad && playerAnimationFileInput){
    btnPlayerAnimationLoad.addEventListener('click', ()=>{
      if(playerAnimationFileInput){
        playerAnimationFileInput.accept = '.fbx';
        playerAnimationFileInput.click();
        if(defaultPlayerAnimationAccept){
          setTimeout(()=>{ playerAnimationFileInput.accept = defaultPlayerAnimationAccept; }, 0);
        }
      }
    });
  }

  if(btnPlayerAnimationLoadGlb && playerAnimationFileInput){
    btnPlayerAnimationLoadGlb.addEventListener('click', ()=>{
      if(playerAnimationFileInput){
        playerAnimationFileInput.accept = '.glb';
        playerAnimationFileInput.click();
        if(defaultPlayerAnimationAccept){
          setTimeout(()=>{ playerAnimationFileInput.accept = defaultPlayerAnimationAccept; }, 0);
        }
      }
    });
  }

  if(btnPlayerAnimationMixamoCombine && playerMixamoBaseInput && playerMixamoAnimationInput){
    btnPlayerAnimationMixamoCombine.addEventListener('click', ()=>{
      if(playerRuntime.mixamoBusy){
        return;
      }
      playerRuntime.mixamoState.baseFile = null;
      playerMixamoBaseInput.value = '';
      playerMixamoAnimationInput.value = '';
      playerMixamoBaseInput.click();
    });

    playerMixamoBaseInput.addEventListener('change', ()=>{
      if(playerRuntime.mixamoBusy){
        playerMixamoBaseInput.value = '';
        return;
      }
      const file = playerMixamoBaseInput.files && playerMixamoBaseInput.files[0];
      if(!file){
        playerRuntime.mixamoState.baseFile = null;
        if(playerRuntime.animationController){
          playerRuntime.animationController.setStatus('Mixamo character selection canceled.');
        }
        return;
      }
      playerRuntime.mixamoState.baseFile = file;
      playerMixamoAnimationInput.value = '';
      playerMixamoAnimationInput.click();
    });

    playerMixamoAnimationInput.addEventListener('change', async ()=>{
      if(playerRuntime.mixamoBusy){
        playerMixamoAnimationInput.value = '';
        playerRuntime.mixamoState.baseFile = null;
        return;
      }
      const baseFile = playerRuntime.mixamoState.baseFile;
      const files = playerMixamoAnimationInput.files ? Array.from(playerMixamoAnimationInput.files) : [];
      playerRuntime.mixamoState.baseFile = null;
      playerMixamoBaseInput.value = '';
      playerMixamoAnimationInput.value = '';
      if(!baseFile){
        if(playerRuntime.animationController){
          playerRuntime.animationController.setStatus('Select a Mixamo character in T-pose first.');
        }
        return;
      }
      if(!files.length){
        if(playerRuntime.animationController){
          playerRuntime.animationController.setStatus('No Mixamo animations selected.');
        }
        return;
      }
      try {
        playerRuntime.mixamoBusy = true;
        if(btnPlayerAnimationMixamoCombine){
          btnPlayerAnimationMixamoCombine.disabled = true;
        }
        if(playerRuntime.animationController){
          playerRuntime.animationController.setStatus('Combining Mixamo animationsâ€¦');
        }
        const result = await combineMixamoAnimations(baseFile, files);
        downloadBlob(result.blob, result.fileName);
        if(playerRuntime.animationController){
          try {
            await playerRuntime.animationController.loadFromArrayBuffer(result.arrayBuffer, result.fileName);
            playerRuntime.animationController.setStatus(`Combined ${result.animationCount} Mixamo animation${result.animationCount === 1 ? '' : 's'} and loaded result pack.`);
          } catch (err){
            console.warn('Unable to auto-load combined Mixamo FBX', err);
            playerRuntime.animationController.setStatus(`Combined ${result.animationCount} Mixamo animation${result.animationCount === 1 ? '' : 's'}. Pack download started.`);
          }
        }
      } catch (err){
        console.error('Mixamo combination error', err);
        const message = err && err.message ? err.message : 'Unable to combine Mixamo animations.';
        if(playerRuntime.animationController){
          playerRuntime.animationController.setStatus(message);
        } else {
          alert(message);
        }
      } finally {
        playerRuntime.mixamoBusy = false;
        if(btnPlayerAnimationMixamoCombine){
          btnPlayerAnimationMixamoCombine.disabled = false;
        }
      }
    });
  }

  if(btnPlayerAnimationLoadSetup){
    btnPlayerAnimationLoadSetup.addEventListener('click', ()=>{
      if(!playerRuntime.animationController){
        return;
      }
      if(typeof playerRuntime.animationController.hasModel === 'function' && !playerRuntime.animationController.hasModel()){
        playerRuntime.animationController.setStatus('Load a player model before applying a saved setup.');
        if(playerAnimationConfigInput){
          playerAnimationConfigInput.click();
        }
        return;
      }
      let storedSnapshot = null;
      try {
        const signature = typeof playerRuntime.animationController.getModelSignature === 'function'
          ? playerRuntime.animationController.getModelSignature()
          : null;
        if(signature){
          const stored = loadPlayerAnimationConfigurations();
          storedSnapshot = stored && stored[signature] ? stored[signature] : null;
        }
      } catch (err){
        console.warn('Unable to retrieve stored animation configuration', err);
      }
      if(playerAnimationConfigInput){
        playerAnimationConfigInput.value = '';
        playerAnimationConfigInput.click();
        return;
      }
      if(storedSnapshot){
        const applied = playerRuntime.animationController.applyConfigurationSnapshot(storedSnapshot);
        if(!applied){
          playerRuntime.animationController.setStatus('Unable to apply saved setup. Ensure the matching model is loaded.');
        }
      } else {
        playerRuntime.animationController.setStatus('No setup file input available.');
      }
    });
  }

  if(btnPlayerAnimationSave){
    btnPlayerAnimationSave.addEventListener('click', ()=>{
      if(playerRuntime.animationController){
        playerRuntime.animationController.saveConfiguration();
        updatePlayerAnimationSaveState();
      }
    });
    updatePlayerAnimationSaveState();
  }

  if(playerAnimationConfigInput){
    playerAnimationConfigInput.addEventListener('change', ()=>{
      const file = playerAnimationConfigInput.files && playerAnimationConfigInput.files[0];
      if(!file){
        return;
      }
      const reader = new FileReader();
      reader.addEventListener('load', ()=>{
        const text = typeof reader.result === 'string' ? reader.result : '';
        try {
          const parsed = JSON.parse(text);
          if(!playerRuntime.animationController){
            alert('Load a player model before importing an animation setup.');
            return;
          }
          if(typeof playerRuntime.animationController.hasModel === 'function' && !playerRuntime.animationController.hasModel()){
            playerRuntime.animationController.setStatus('Load a player model before importing a setup.');
            return;
          }
          const applied = playerRuntime.animationController.applyConfigurationSnapshot(parsed);
          if(applied){
            const signature = typeof playerRuntime.animationController.getModelSignature === 'function'
              ? playerRuntime.animationController.getModelSignature()
              : null;
            if(signature && typeof playerRuntime.animationController.persistConfigurationSnapshot === 'function'){
              playerRuntime.animationController.persistConfigurationSnapshot(signature, parsed);
            }
            playerRuntime.animationController.setStatus('Imported animation setup.');
          } else {
            playerRuntime.animationController.setStatus('Unable to apply imported setup to this model.');
          }
        } catch (err){
          console.error('Failed to parse animation setup file', err);
          alert('Unable to parse animation setup file.');
        }
      });
      reader.addEventListener('error', ()=>{
        alert('Unable to read animation setup file.');
      });
      reader.readAsText(file);
      playerAnimationConfigInput.value = '';
    });
  }

  if(btnPlayerAnimationClear){
    btnPlayerAnimationClear.addEventListener('click', ()=>{
      if(playerRuntime.animationController){
        playerRuntime.animationController.clearModel();
        playerRuntime.animationController.setStatus('Model cleared.');
        setPlayerAnimationState('idle');
      }
    });
  }

  if(playerAnimationFileInput){
    playerAnimationFileInput.addEventListener('change', async (ev)=>{
      const file = ev.target && ev.target.files ? ev.target.files[0] : null;
      if(file && playerRuntime.animationController){
        if(playerAnimationSection && playerAnimationSection.hasAttribute('hidden')){
          playerAnimationSection.removeAttribute('hidden');
          if(btnPlayerAnimation){
            btnPlayerAnimation.setAttribute('aria-expanded', 'true');
          }
        }
        await playerRuntime.animationController.loadFile(file);
        playerRuntime.animationController.refreshSize();
      }
      if(playerAnimationFileInput){
        if(defaultPlayerAnimationAccept){
          playerAnimationFileInput.accept = defaultPlayerAnimationAccept;
        }
        playerAnimationFileInput.value = '';
      }
    });
  }

  function setPlayerAnimationState(state, context = {}){
    if(!PLAYER_ANIMATION_ACTIONS.includes(state)){
      return;
    }
    playerRuntime.lastAnimationState = state;
    const finalContext = { ...context };
    if(!Number.isFinite(finalContext.facingRadians)){
      finalContext.facingRadians = GameState.player.facingRadians;
    }
    if(playerRuntime.animationController){
      playerRuntime.animationController.setState(state, finalContext);
    }
    if(playerRuntime.model){
      playerRuntime.model.setState(state, finalContext);
    }
  }

  setPlayerAnimationState('idle');
  const playerSpeedInput = document.getElementById('playerSpeed');
  const playerSizeInput = document.getElementById('playerSize');
  const playerTeamSelect = document.getElementById('playerTeam');
  const playerHpInput = document.getElementById('playerHP');
  const playerAttackRangeInput = document.getElementById('playerAttackRange');
  const playerAttackRangeOpacityInput = document.getElementById('playerAttackRangeOpacity');
  const playerAttackRangeOpacityDisplay = document.getElementById('playerAttackRangeOpacityDisplay');
  const playerAttackSpeedInput = document.getElementById('playerAttackSpeed');
  const playerAttackWindupInput = document.getElementById('playerAttackWindup');
  const playerAttackDamageInput = document.getElementById('playerAttackDamage');
  const playerHitSplatSizeInput = document.getElementById('playerHitSplatSize');
  const playerMoveCircleStartInput = document.getElementById('playerMoveCircleStart');
  const playerMoveCircleEndInput = document.getElementById('playerMoveCircleEnd');
  const playerMoveCircleColorInput = document.getElementById('playerMoveCircleColor');
  const playerHitboxToggleButton = document.getElementById('playerHitboxToggle');
  const playerHitboxLengthInput = document.getElementById('playerHitboxLength');
  const playerHitboxLengthDisplay = document.getElementById('playerHitboxLengthDisplay');
  const playerHitboxWidthInput = document.getElementById('playerHitboxWidth');
  const playerHitboxWidthDisplay = document.getElementById('playerHitboxWidthDisplay');
  const playerHitboxShapeSelect = document.getElementById('playerHitboxShape');
  const playerHurtboxToggleButton = document.getElementById('playerHurtboxToggle');
  const playerHurtboxShapeSelect = document.getElementById('playerHurtboxShape');
  const playerHurtboxLengthInput = document.getElementById('playerHurtboxLength');
  const playerHurtboxLengthDisplay = document.getElementById('playerHurtboxLengthDisplay');
  const playerHurtboxWidthInput = document.getElementById('playerHurtboxWidth');
  const playerHurtboxWidthDisplay = document.getElementById('playerHurtboxWidthDisplay');
  const playerSpellOriginLengthInput = document.getElementById('playerSpellOriginLength');
  const playerSpellOriginLengthDisplay = document.getElementById('playerSpellOriginLengthDisplay');
  const playerSpellOriginWidthInput = document.getElementById('playerSpellOriginWidth');
  const playerSpellOriginWidthDisplay = document.getElementById('playerSpellOriginWidthDisplay');

  const btnCamera = document.getElementById('btnCamera');
  const cameraPane = document.getElementById('cameraPane');
  const cameraModeSelect = document.getElementById('cameraMode');
  const cameraFollowLagInput = document.getElementById('cameraFollowLag');
  const cameraFollowLagDisplay = document.getElementById('cameraFollowLagDisplay');
  const cameraLeadInput = document.getElementById('cameraLead');
  const cameraLeadDisplay = document.getElementById('cameraLeadDisplay');
  const cameraHorizontalOffsetInput = document.getElementById('cameraHorizontalOffset');
  const cameraHorizontalOffsetDisplay = document.getElementById('cameraHorizontalOffsetDisplay');
  const cameraVerticalOffsetInput = document.getElementById('cameraVerticalOffset');
  const cameraVerticalOffsetDisplay = document.getElementById('cameraVerticalOffsetDisplay');
  const cameraEdgeMarginInput = document.getElementById('cameraEdgeMargin');
  const cameraEdgeMarginDisplay = document.getElementById('cameraEdgeMarginDisplay');
  const cameraEdgeSpeedInput = document.getElementById('cameraEdgeSpeed');
  const cameraEdgeSpeedDisplay = document.getElementById('cameraEdgeSpeedDisplay');
  const cameraRecenterDelayInput = document.getElementById('cameraRecenterDelay');
  const cameraRecenterDelayDisplay = document.getElementById('cameraRecenterDelayDisplay');
  const cameraZoomInput = document.getElementById('cameraZoom');
  const cameraZoomDisplay = document.getElementById('cameraZoomDisplay');
  const cameraZoomInLockBtn = document.getElementById('cameraZoomInLock');
  const cameraZoomOutLockBtn = document.getElementById('cameraZoomOutLock');
  const cameraManualLeashInput = document.getElementById('cameraManualLeash');
  const cameraManualLeashDisplay = document.getElementById('cameraManualLeashDisplay');
  const cameraWheelSensitivityInput = document.getElementById('cameraWheelSensitivity');
  const cameraWheelSensitivityDisplay = document.getElementById('cameraWheelSensitivityDisplay');
  const cameraLockBindBtn = document.getElementById('cameraLockBind');
  const cameraRecenterBtn = document.getElementById('cameraRecenterBtn');

  const btnPerf = document.getElementById('btnPerf');
  const perfPane = document.getElementById('perfPane');
  const perfFpsValue = document.getElementById('perfFpsValue');
  const perfFrameValue = document.getElementById('perfFrameValue');
  const perfMinionsValue = document.getElementById('perfMinionsValue');
  const perfProjectilesValue = document.getElementById('perfProjectilesValue');
  const perfCollidersValue = document.getElementById('perfCollidersValue');
  const perfVisionValue = document.getElementById('perfVisionValue');
  const perfSpikeValue = document.getElementById('perfSpikeValue');
  const perfCollLoadValue = document.getElementById('perfCollLoadValue');
  const perfPathLoadValue = document.getElementById('perfPathLoadValue');
  const perfDensityValue = document.getElementById('perfDensityValue');
  const perfCopyLogBtn = document.getElementById('perfCopyLog');
  const perfDownloadLogBtn = document.getElementById('perfDownloadLog');
  const perfStressTestBtn = document.getElementById('perfStressTest');

  const NAV_COARSE_CELL = 96;

  const settingHelpEl = document.getElementById('settingHelp');
  const settingHelpTitle = document.getElementById('settingHelpTitle');
  const settingHelpBody = document.getElementById('settingHelpBody');
  const settingHelpApi = createSettingHelp({
    settingHelpEl,
    settingHelpTitle,
    settingHelpBody,
    sidebarEl
  });
  const {
    showSettingHelp,
    hideSettingHelp,
    deriveSettingHelp,
    initializeSettingHelp,
    setActiveSettingHelpSource,
    getActiveSettingHelpSource
  } = settingHelpApi;

  const btnCursor = document.getElementById('btnCursor');
  const cursorPane = document.getElementById('cursorPane');
  const cursorToggleBtn = document.getElementById('cursorToggle');
  const cursorEmojiInput = document.getElementById('cursorEmoji');
  const cursorOutlineToggle = document.getElementById('cursorOutlineToggle');
  const cursorHoverColorInput = document.getElementById('cursorHoverColor');
  const stageCursorEl = document.getElementById('stageCursor');
  const stageCursorIcon = document.getElementById('stageCursorIcon');
  const btnPings = document.getElementById('btnPings');
  const pingPane = document.getElementById('pingPane');
  const pingOnMyWayInput = document.getElementById('pingOnMyWay');
  const pingEnemyMissingInput = document.getElementById('pingEnemyMissing');
  const pingAssistMeInput = document.getElementById('pingAssistMe');
  const pingTargetInput = document.getElementById('pingTarget');
  const pingOnMyWayTrigger = document.getElementById('pingOnMyWayTrigger');
  const pingEnemyMissingTrigger = document.getElementById('pingEnemyMissingTrigger');
  const pingAssistMeTrigger = document.getElementById('pingAssistMeTrigger');
  const pingTargetTrigger = document.getElementById('pingTargetTrigger');
  const pingInputs = {
    onMyWay: pingOnMyWayInput,
    enemyMissing: pingEnemyMissingInput,
    assistMe: pingAssistMeInput,
    target: pingTargetInput
  };
  const pingButtons = {
    onMyWay: pingOnMyWayTrigger,
    enemyMissing: pingEnemyMissingTrigger,
    assistMe: pingAssistMeTrigger,
    target: pingTargetTrigger
  };

  const btnKeybinds = document.getElementById('btnKeybinds');
  const keybindPane = document.getElementById('keybindPane');
  const spellCastDefaultSelect = document.getElementById('spellCastDefault');
  const spellCastNormalBindBtn = document.getElementById('spellCastNormalBind');
  const spellCastQuickBindBtn = document.getElementById('spellCastQuickBind');
  const spellCastIndicatorBindBtn = document.getElementById('spellCastIndicatorBind');
  const attackMoveBindBtn = document.getElementById('attackMoveBind');
  const pingWheelBindBtn = document.getElementById('pingWheelBind');

  const btnAbilityBar = document.getElementById('btnAbilityBar');
  const abilityPane = document.getElementById('abilityPane');
  const abilityCountInput = document.getElementById('abilityBarState.count');
  const abilityScaleInput = document.getElementById('abilityBarState.scale');
  const abilityOrientationSelect = document.getElementById('abilityBarState.orientation');
  const abilityHealthHorizontalSelect = document.getElementById('abilityBarState.healthPlacement.horizontal');
  const abilityHealthVerticalSelect = document.getElementById('abilityBarState.healthPlacement.vertical');
  const abilityHealthVerticalTextSelect = document.getElementById('abilityBarState.healthPlacement.textVertical');
  const abilityStatsVerticalSelect = document.getElementById('abilityBarState.statsPlacementVertical');
  const spellSpeedScaleInput = document.getElementById('abilityTunables.spellSpeedScale');
  const spellSizeScaleInput = document.getElementById('abilityTunables.spellSizeScale');
  const btnSaveSpells = document.getElementById('btnSaveSpells');

  const btnMinimap = document.getElementById('btnMinimap');
  const minimapPane = document.getElementById('minimapPane');
  const minimapScaleInput = document.getElementById('minimapScale');
  const minimapClickToMoveSelect = document.getElementById('minimapClickToMove');
  const minimapClickThroughSelect = document.getElementById('minimapClickThrough');

  const btnGold = document.getElementById('btnGold');
  const goldPane = document.getElementById('goldPane');
  const goldPerSecondInput = document.getElementById('goldState.perSecond');
  const goldPerKillInput = document.getElementById('goldState.perKill');
  const goldDisplay = document.getElementById('goldValue');

  const laneCountInput = document.getElementById('GameState.lanes.count');
  const laneOffsetList = document.getElementById('laneOffsets');

  const waveCountInput = document.getElementById('waveState.waveCount');
  const waveIntervalInput = document.getElementById('waveInterval');
  const spawnSpacingInput = document.getElementById('spawnSpacing');
  const minionSizeInput = document.getElementById('minionSize');
  const minionHPInput = document.getElementById('minionHP');
  const minionDMGInput = document.getElementById('minionDMG');
  const scalePctInput = document.getElementById('portalState.scalePct');
  const btnTurrets = document.getElementById('btnTurrets');
  const turretPane = document.getElementById('turretPane');
  const turretCountInput = document.getElementById('turretCount');
  const turretRangeInput = document.getElementById('turretRange');
  const turretDamageInput = document.getElementById('turretDamage');
  const turretIntervalInput = document.getElementById('turretInterval');
  const turretFocusInput = document.getElementById('turretFocus');
  const turretOffsetList = document.getElementById('turretOffsets');
  const turretResetOffsetsBtn = document.getElementById('turretResetOffsets');
  const turretConfigLoadBtn = document.getElementById('turretConfigLoad');
  const turretConfigSaveBtn = document.getElementById('turretConfigSave');
  const turretConfigFileInput = document.getElementById('turretConfigFile');
  const btnScoring = document.getElementById('btnScoring');
  const scoringPane = document.getElementById('scoringPane');

  const btnScore   = document.getElementById('btnScore');
  const scorePane  = document.getElementById('scorePane');
  const scoreBlueEl= document.getElementById('scoreBlue');
  const scoreRedEl = document.getElementById('scoreRed');
  const pointsPerInput = document.getElementById('scoreState.pointsPer');
  const winTargetInput = document.getElementById('scoreState.winTarget');
  const resetScoreBtn  = document.getElementById('resetScore');

  const btnUiLayout = document.getElementById('btnUiLayout');
  const uiLayoutPane = document.getElementById('uiLayoutPane');
  const uiSlotGoldSelect = document.getElementById('uiSlotGold');
  const uiSlotScoreSelect = document.getElementById('uiSlotScore');
  const uiSlotTimerSelect = document.getElementById('uiSlotTimer');
  const uiSlotAbilitySelect = document.getElementById('uiSlotAbility');
  const uiSlotMinimapSelect = document.getElementById('uiSlotMinimap');
  const uiOffsetInputs = {
    'top-left': { x: document.getElementById('uiOffsetTopLeftX'), y: document.getElementById('uiOffsetTopLeftY') },
    'top-middle': { x: document.getElementById('uiOffsetTopMiddleX'), y: document.getElementById('uiOffsetTopMiddleY') },
    'top-right': { x: document.getElementById('uiOffsetTopRightX'), y: document.getElementById('uiOffsetTopRightY') },
    'center-left': { x: document.getElementById('uiOffsetCenterLeftX'), y: document.getElementById('uiOffsetCenterLeftY') },
    'center-middle': { x: document.getElementById('uiOffsetCenterMiddleX'), y: document.getElementById('uiOffsetCenterMiddleY') },
    'center-right': { x: document.getElementById('uiOffsetCenterRightX'), y: document.getElementById('uiOffsetCenterRightY') },
    'bottom-left': { x: document.getElementById('uiOffsetBottomLeftX'), y: document.getElementById('uiOffsetBottomLeftY') },
    'bottom-middle': { x: document.getElementById('uiOffsetBottomMiddleX'), y: document.getElementById('uiOffsetBottomMiddleY') },
    'bottom-right': { x: document.getElementById('uiOffsetBottomRightX'), y: document.getElementById('uiOffsetBottomRightY') }
  };

  const hudCornerGroup = document.getElementById('hudCornerGroup');
  const hudStatsAnchor = document.getElementById('hudStatsAnchor');
  const scoreOverlayEl = document.getElementById('scoreOverlay');
  const hudStatsDock = document.getElementById('hudStatsDock');
  const hudStatsToggle = document.getElementById('hudStatsToggle');
  const hudStatsToggleIcon = hudStatsToggle ? hudStatsToggle.querySelector('.hudStatsToggleIcon') : null;
  const hudStatsPanel = document.getElementById('hudStatsPanel');
  const hudStatsContent = document.getElementById('hudStatsContent');
  const hudHpText = document.getElementById('hudHpText');
  const hudHpTextDefaultParent = hudHpText ? hudHpText.parentElement : null;
  const hudHpTextDefaultNextSibling = hudHpText ? hudHpText.nextSibling : null;
  const hudHpFill = document.getElementById('hudHpFill');
  const hudVitals = document.getElementById('hudVitals');
  const hudVitalsBar = document.getElementById('hudVitalsBar');
  const hudAbilityStackEl = document.getElementById('hudAbilityStack');
  const hudAbilityBarWrapEl = document.getElementById('hudAbilityBarWrap');
  const hudAbilityVitalsWrap = document.getElementById('hudAbilityVitalsWrap');
  const hudStatAs = document.getElementById('hudAs');
  const hudStatAw = document.getElementById('hudAw');
  const hudStatAr = document.getElementById('hudAr');
  const hudStatDmg = document.getElementById('hudDmg');
  const hudStatMs = document.getElementById('hudMs');
  const playerFloatHud = document.getElementById('playerFloatHud');
  const playerFloatTrack = document.getElementById('playerFloatTrack');
  const practiceDummyHud = document.getElementById('practiceDummyHud');
  const practiceDummyFill = document.getElementById('practiceDummyFill');
  const practiceDummyText = document.getElementById('practiceDummyText');
  const practiceDummyIcons = document.getElementById('practiceDummyIcons');
  const playerFloatFill = document.getElementById('playerFloatFill');
  const playerFloatText = document.getElementById('playerFloatText');
  const playerHpBadge = document.getElementById('playerHpBadge');
  const playerHpValue = document.getElementById('playerHpValue');
  const playerAttackReadyBar = document.getElementById('playerAttackReadyBar');
  const playerAttackReadyFill = document.getElementById('playerAttackReadyFill');
  const playerStateIcons = document.getElementById('playerStateIcons');
  const playerPrayerIcons = document.getElementById('playerPrayerIcons');
  const monsterHud = document.getElementById('monsterHud');
  const monsterFill = document.getElementById('monsterFill');
  const monsterText = document.getElementById('monsterText');
  const monsterAbilityQueueEl = document.getElementById('monsterAbilityQueue');
  const playerFloatSizeInput = document.getElementById('playerFloatSize');
  const playerFloatSizeDisplay = document.getElementById('playerFloatSizeDisplay');
  const playerFloatHeightInput = document.getElementById('playerFloatHeight');
  const playerFloatHeightDisplay = document.getElementById('playerFloatHeightDisplay');
  const playerFloatOffsetInput = document.getElementById('playerFloatOffset');
  const playerFloatOffsetDisplay = document.getElementById('playerFloatOffsetDisplay');
  const playerHealthColorInput = document.getElementById('playerHealthColor');
  const playerAttackBarWidthInput = document.getElementById('playerAttackBarWidth');
  const playerAttackBarWidthDisplay = document.getElementById('playerAttackBarWidthDisplay');
  const playerAttackBarHeightInput = document.getElementById('playerAttackBarHeight');
  const playerAttackBarHeightDisplay = document.getElementById('playerAttackBarHeightDisplay');
  const playerAttackBarOffsetXInput = document.getElementById('playerAttackBarOffsetX');
  const playerAttackBarOffsetYInput = document.getElementById('playerAttackBarOffsetY');
  const playerIconWidthInput = document.getElementById('playerIconWidth');
  const playerIconWidthDisplay = document.getElementById('playerIconWidthDisplay');
  const playerIconHeightInput = document.getElementById('playerIconHeight');
  const playerIconHeightDisplay = document.getElementById('playerIconHeightDisplay');
  const playerIconOffsetXInput = document.getElementById('playerIconOffsetX');
  const playerIconOffsetYInput = document.getElementById('playerIconOffsetY');
  const playerStateConfigList = document.getElementById('playerStateConfig');
  const playerStatusEmojiInputs = new Map();
  const playerStatusColorInputs = new Map();
  const playerStatusNodes = new Map();
  // Ensure a live dummy is available on load so hits register immediately, after HUD/status nodes exist
  setTimeout(() => {
    if(practiceDummy && (practiceDummy.active === false || !(Number(practiceDummy.hp) > 0)) && !(practiceDummy.respawnTimer > 0)){
      respawnPracticeDummy({ resetPosition: true, resetSize: true, resetStats: true });
    }
  }, 0);
  const prayerBindingButtons = new Map();
  const prayerActivateButtons = new Map();
  const prayerEmojiDisplays = new Map();
  let prayerKeyCaptureId = null;
  const timerEl = document.getElementById('timer');
  const abilityBarEl = document.getElementById('abilityBar');
  const abilityRepoEl = document.getElementById('abilityRepo');
  const abilityRepoClose = document.getElementById('abilityRepoClose');
  const abilityRepoSubtitle = document.getElementById('abilityRepoSubtitle');
  const spellListEl = document.getElementById('spellList');
  const spellEditorPlaceholder = document.getElementById('spellEditorPlaceholder');
  const spellEditorForm = document.getElementById('spellEditorForm');
  const winBanner = document.getElementById('winBanner');

  const UI_LAYOUT_SLOTS = {
    'top-left': { label: 'Top Left', anchorX: 0, anchorY: 0, anchorTranslateX: '0%', anchorTranslateY: '0%' },
    'top-middle': { label: 'Top Middle', anchorX: 0.5, anchorY: 0, anchorTranslateX: '-50%', anchorTranslateY: '0%' },
    'top-right': { label: 'Top Right', anchorX: 1, anchorY: 0, anchorTranslateX: '-100%', anchorTranslateY: '0%' },
    'center-left': { label: 'Center Left', anchorX: 0, anchorY: 0.5, anchorTranslateX: '0%', anchorTranslateY: '-50%' },
    'center-middle': { label: 'Center Middle', anchorX: 0.5, anchorY: 0.5, anchorTranslateX: '-50%', anchorTranslateY: '-50%' },
    'center-right': { label: 'Center Right', anchorX: 1, anchorY: 0.5, anchorTranslateX: '-100%', anchorTranslateY: '-50%' },
    'bottom-left': { label: 'Bottom Left', anchorX: 0, anchorY: 1, anchorTranslateX: '0%', anchorTranslateY: '-100%' },
    'bottom-middle': { label: 'Bottom Middle', anchorX: 0.5, anchorY: 1, anchorTranslateX: '-50%', anchorTranslateY: '-100%' },
    'bottom-right': { label: 'Bottom Right', anchorX: 1, anchorY: 1, anchorTranslateX: '-100%', anchorTranslateY: '-100%' }
  };
  const UI_LAYOUT_COMPONENTS = {
    gold: { element: hudCornerGroup, label: 'Gold counter' },
    score: { element: scoreOverlayEl, label: 'Score display' },
    timer: { element: timerEl, label: 'Game timer' },
    ability: { element: hudStatsAnchor, label: 'Ability & stats dock' },
    minimap: { element: minimapCanvas, label: 'Minimap' }
  };
  const uiSlotSelects = {
    gold: uiSlotGoldSelect,
    score: uiSlotScoreSelect,
    timer: uiSlotTimerSelect,
    ability: uiSlotAbilitySelect,
    minimap: uiSlotMinimapSelect
  };
  const DEFAULT_UI_SLOT_OFFSETS = {
    'top-left': { x: 16, y: 16 },
    'top-middle': { x: 0, y: 16 },
    'top-right': { x: 16, y: 16 },
    'center-left': { x: 16, y: 0 },
    'center-middle': { x: 0, y: 0 },
    'center-right': { x: 16, y: 0 },
    'bottom-left': { x: 16, y: 16 },
    'bottom-middle': { x: 0, y: 16 },
    'bottom-right': { x: 16, y: 16 }
  };
  function clampUiOffsetValue(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)){
      return 0;
    }
    return Math.max(-500, Math.min(500, numeric));
  }
  const uiSlotOffsets = {};
  for(const [slot, offsets] of Object.entries(DEFAULT_UI_SLOT_OFFSETS)){
    uiSlotOffsets[slot] = { x: offsets.x, y: offsets.y };
  }
  const uiLayoutAssignments = {
    gold: 'top-left',
    score: 'top-middle',
    timer: 'top-right',
    ability: 'bottom-middle',
    minimap: 'bottom-right'
  };

  function sanitizeSlotId(value){
    if(typeof value !== 'string'){
      return 'hidden';
    }
    const trimmed = value.trim().toLowerCase();
    if(trimmed === 'hidden' || trimmed === 'none'){
      return 'hidden';
    }
    return UI_LAYOUT_SLOTS[trimmed] ? trimmed : 'hidden';
  }

  function populateUiLayoutOptions(){
    const slotEntries = Object.entries(UI_LAYOUT_SLOTS);
    for(const select of Object.values(uiSlotSelects)){
      if(!select) continue;
      select.innerHTML = '';
      const hiddenOption = document.createElement('option');
      hiddenOption.value = 'hidden';
      hiddenOption.textContent = 'None';
      select.appendChild(hiddenOption);
      for(const [slotId, slotDef] of slotEntries){
        const option = document.createElement('option');
        option.value = slotId;
        option.textContent = slotDef.label;
        select.appendChild(option);
      }
    }
  }

  function syncUiLayoutSelects(){
    for(const [key, select] of Object.entries(uiSlotSelects)){
      if(!select) continue;
      const assigned = sanitizeSlotId(uiLayoutAssignments[key]);
      select.value = assigned;
    }
  }

  function syncUiOffsetInputs(){
    for(const [slot, inputs] of Object.entries(uiOffsetInputs)){
      if(!inputs) continue;
      const offsets = uiSlotOffsets[slot] || { x: 0, y: 0 };
      if(inputs.x){
        const safeX = Math.round(clampUiOffsetValue(offsets.x));
        inputs.x.value = String(safeX);
      }
      if(inputs.y){
        const safeY = Math.round(clampUiOffsetValue(offsets.y));
        inputs.y.value = String(safeY);
      }
    }
  }

  function setUiComponentSlot(key, slotId, { syncInput = true } = {}){
    if(!UI_LAYOUT_COMPONENTS[key]){
      return;
    }
    const sanitized = sanitizeSlotId(slotId);
    const current = sanitizeSlotId(uiLayoutAssignments[key]);
    if(current === sanitized && syncInput){
      const select = uiSlotSelects[key];
      if(select){ select.value = sanitized; }
      return;
    }
    if(sanitized !== 'hidden'){
      for(const [otherKey, otherSlot] of Object.entries(uiLayoutAssignments)){
        if(otherKey !== key && sanitizeSlotId(otherSlot) === sanitized){
          uiLayoutAssignments[otherKey] = 'hidden';
          const otherSelect = uiSlotSelects[otherKey];
          if(otherSelect){ otherSelect.value = 'hidden'; }
        }
      }
    }
    uiLayoutAssignments[key] = sanitized;
    if(syncInput){
      const select = uiSlotSelects[key];
      if(select){ select.value = sanitized; }
    }
    scheduleHudFit();
  }

  function setUiSlotOffset(slotId, axis, value, { syncInput = true } = {}){
    const slot = UI_LAYOUT_SLOTS[slotId];
    if(!slot){
      return;
    }
    const numeric = clampUiOffsetValue(value);
    const rounded = Math.round(numeric);
    if(!uiSlotOffsets[slotId]){
      uiSlotOffsets[slotId] = { x: 0, y: 0 };
    }
    uiSlotOffsets[slotId][axis] = rounded;
    if(syncInput){
      const inputs = uiOffsetInputs[slotId];
      if(inputs){
        const inputEl = axis === 'x' ? inputs.x : inputs.y;
        if(inputEl){ inputEl.value = String(rounded); }
      }
    }
    scheduleHudFit();
  }

  function initUiLayoutControls(){
    populateUiLayoutOptions();
    syncUiLayoutSelects();
    syncUiOffsetInputs();
    for(const [key, select] of Object.entries(uiSlotSelects)){
      if(!select) continue;
      select.addEventListener('change', () => {
        setUiComponentSlot(key, select.value, { syncInput: false });
      });
    }
    for(const [slot, inputs] of Object.entries(uiOffsetInputs)){
      if(!inputs) continue;
      if(inputs.x){
        const handleX = () => setUiSlotOffset(slot, 'x', inputs.x.value, { syncInput: false });
        inputs.x.addEventListener('input', handleX);
        inputs.x.addEventListener('change', handleX);
      }
      if(inputs.y){
        const handleY = () => setUiSlotOffset(slot, 'y', inputs.y.value, { syncInput: false });
        inputs.y.addEventListener('input', handleY);
        inputs.y.addEventListener('change', handleY);
      }
    }
  }

  hudMessageState.timer = null;

  function setHudMessage(message){
    if(hudMessageState.timer){
      clearTimeout(hudMessageState.timer);
      hudMessageState.timer = null;
    }
    if(!settingHelpEl){
      return;
    }
    if(!message){
      hideSettingHelp('hud-message');
      return;
    }
    setActiveSettingHelpSource('hud-message');
    showSettingHelp('Status', message);
    hudMessageState.timer = setTimeout(()=>{
      if(getActiveSettingHelpSource() === 'hud-message'){
        hideSettingHelp('hud-message');
      }
      hudMessageState.timer = null;
    }, 4000);
  }
  function formatSeconds(ms){
    const raw = Number(ms);
    if(!Number.isFinite(raw) || raw <= 0){
      return '0s';
    }
    const seconds = raw / 1000;
    const precision = seconds >= 10 ? 1 : 2;
    return `${seconds.toFixed(precision)}s`;
  }
  function formatStatNumber(value){
    const raw = Number(value);
    if(!Number.isFinite(raw)){
      return '0';
    }
    return String(Math.max(0, Math.round(raw)));
  }
  const rootStyle = document.documentElement.style;
  const SIDEBAR_MIN_WIDTH = 280;
  const SIDEBAR_COLLAPSED_WIDTH = 60;

  function measureViewport(){
    let layoutMenuWidth = 0;
    let measuredWidth = sidebarState.lastMeasuredWidth === null ? SIDEBAR_MIN_WIDTH : sidebarState.lastMeasuredWidth;
    const hidden = !app || app.getAttribute('data-hidden') === 'true';
    const collapsed = app && app.getAttribute('data-collapsed') === 'true';
    if(app && sidebarEl && !hidden){
      if(collapsed){
        measuredWidth = SIDEBAR_COLLAPSED_WIDTH;
      } else {
        const headerWidth = sbHeader ? sbHeader.scrollWidth : 0;
        const contentWidth = sbContent ? sbContent.scrollWidth : 0;
        const rect = sidebarEl.getBoundingClientRect();
        const visibleWidth = rect && Number.isFinite(rect.width) ? rect.width : 0;
        const rawWidth = Math.max(headerWidth, contentWidth, sidebarEl.scrollWidth || 0, visibleWidth);
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth || rawWidth;
        const maxAllowed = Math.max(SIDEBAR_MIN_WIDTH, viewportWidth);
        measuredWidth = Math.min(maxAllowed, Math.max(SIDEBAR_MIN_WIDTH, Math.ceil(rawWidth)));
      }
      layoutMenuWidth = measuredWidth;
    }
    if(!hidden && (sidebarState.lastMeasuredWidth === null || Math.abs(measuredWidth - sidebarState.lastMeasuredWidth) >= 0.5)){
      rootStyle.setProperty('--sidebar-w', `${measuredWidth}px`);
      sidebarState.lastMeasuredWidth = measuredWidth;
    }
    rootStyle.setProperty('--menu-width-px', `${layoutMenuWidth}px`);
    const viewportWidth = Math.max(0, (window.innerWidth || 0) - layoutMenuWidth);
    const viewportHeight = window.innerHeight || 0;
    return { menuWidth: layoutMenuWidth, width: viewportWidth, height: viewportHeight };
  }

  function applyUiLayout(viewport){
    const metrics = viewport || measureViewport();
    const menuWidth = Math.max(0, Number(metrics && metrics.menuWidth) || 0);
    const viewportWidth = Math.max(0, Number(metrics && metrics.width) || 0);
    const viewportHeight = Math.max(0, Number(metrics && metrics.height) || 0);

    const slotPositions = {};
    for(const [slotId, slotDef] of Object.entries(UI_LAYOUT_SLOTS)){
      let posX = menuWidth + viewportWidth * slotDef.anchorX;
      let posY = viewportHeight * slotDef.anchorY;
      const offsets = uiSlotOffsets[slotId] || { x: 0, y: 0 };
      const offsetX = clampUiOffsetValue(offsets.x);
      const offsetY = clampUiOffsetValue(offsets.y);
      if(slotDef.anchorX === 1){
        posX -= offsetX;
      } else {
        posX += offsetX;
      }
      if(slotDef.anchorY === 1){
        posY -= offsetY;
      } else {
        posY += offsetY;
      }
      slotPositions[slotId] = {
        x: posX,
        y: posY,
        anchorX: slotDef.anchorTranslateX,
        anchorY: slotDef.anchorTranslateY
      };
    }

    let layoutShowsMinimap = false;

    for(const [key, component] of Object.entries(UI_LAYOUT_COMPONENTS)){
      const element = component.element;
      if(!element) continue;
      const slotId = sanitizeSlotId(uiLayoutAssignments[key]);
      const hidden = !slotId || slotId === 'hidden';
      element.hidden = hidden;
      element.setAttribute('aria-hidden', hidden ? 'true' : 'false');
      if(hidden){
        continue;
      }
      const slotPosition = slotPositions[slotId];
      if(!slotPosition){
        element.hidden = true;
        element.setAttribute('aria-hidden', 'true');
        continue;
      }
      element.style.setProperty('--ui-pos-x', `${slotPosition.x}px`);
      element.style.setProperty('--ui-pos-y', `${slotPosition.y}px`);
      element.style.setProperty('--ui-anchor-x', slotPosition.anchorX);
      element.style.setProperty('--ui-anchor-y', slotPosition.anchorY);
      if(key === 'minimap'){
        layoutShowsMinimap = true;
      }
    }

    minimapState.layoutVisible = layoutShowsMinimap;
    applyMinimapScale();
  }

  let hudFitScheduled = false;
  function scheduleHudFit(){
    if(hudFitScheduled){
      return;
    }
    hudFitScheduled = true;
    requestAnimationFrame(() => {
      hudFitScheduled = false;
      fitHudToViewport();
    });
  }
  function fitHudToViewport(){
    const viewport = measureViewport();
    applyUiLayout(viewport);
    fitTopOverlays(viewport);
  }

  function applyOverlayScale(element, varName, maxWidth, maxHeight, minScale = 0.55){
    if(!element || !element.isConnected){
      return;
    }
    rootStyle.setProperty(varName, '1');
    const rect = element.getBoundingClientRect();
    let scale = 1;
    if(Number.isFinite(maxWidth) && maxWidth > 0 && rect.width > maxWidth){
      scale = Math.min(scale, maxWidth / rect.width);
    }
    if(Number.isFinite(maxHeight) && maxHeight > 0 && rect.height > maxHeight){
      scale = Math.min(scale, maxHeight / rect.height);
    }
    scale = Math.max(minScale, scale);
    rootStyle.setProperty(varName, scale.toFixed(3));
  }

  function fitTopOverlays(viewport){
    const metrics = viewport || measureViewport();
    const margin = 24;
    if(scoreOverlayEl){
      const maxWidth = Math.max(140, metrics.width - margin * 2);
      const maxHeight = Math.max(40, metrics.height - margin * 2);
      applyOverlayScale(scoreOverlayEl, '--hud-score-scale', maxWidth, maxHeight);
    }
    if(hudCornerGroup){
      const maxWidth = Math.max(220, metrics.width - margin);
      const maxHeight = Math.max(200, metrics.height - margin);
      applyOverlayScale(hudCornerGroup, '--hud-corner-scale', maxWidth, maxHeight);
    }
    if(hudStatsAnchor){
      const maxWidth = Math.max(220, metrics.width - margin);
      const maxHeight = Math.max(240, metrics.height - margin);
      applyOverlayScale(hudStatsAnchor, '--hud-stats-scale', maxWidth, maxHeight);
    }
    if(timerEl){
      const maxWidth = Math.max(96, metrics.width - margin);
      const maxHeight = Math.max(40, metrics.height - margin);
      applyOverlayScale(timerEl, '--hud-timer-scale', maxWidth, maxHeight);
    }
  }

  if(hudStatsPanel){
    const initialCollapsed = hudStatsDock && hudStatsDock.getAttribute('data-collapsed') === 'true';
    if(hudStatsContent){
      hudStatsContent.setAttribute('aria-hidden', initialCollapsed ? 'true' : 'false');
      if(hudStatsToggle){
        hudStatsToggle.setAttribute('aria-controls', hudStatsContent.id);
      }
    }
    if(hudStatsToggle){
      hudStatsToggle.setAttribute('aria-expanded', String(!initialCollapsed));
      hudStatsToggle.setAttribute('aria-label', initialCollapsed ? 'Expand stats' : 'Collapse stats');
    }
    updateHudStatsToggleIcon(initialCollapsed);
  }
  if(hudStatsToggle && hudStatsDock){
    hudStatsToggle.addEventListener('click', () => {
      const collapsed = hudStatsDock.getAttribute('data-collapsed') === 'true';
      const next = !collapsed;
      hudStatsDock.setAttribute('data-collapsed', String(next));
      hudStatsToggle.setAttribute('aria-expanded', String(!next));
      hudStatsToggle.setAttribute('aria-label', next ? 'Expand stats' : 'Collapse stats');
      if(hudStatsContent){
        hudStatsContent.setAttribute('aria-hidden', next ? 'true' : 'false');
      }
      updateHudStatsToggleIcon(next);
      scheduleHudFit();
    });
  }
  function syncMenuMeasurements(){
    const viewport = measureViewport();
    fitCameraStageToViewport(viewport);
    scheduleHudFit();
    updateStagePointerState();
  }

  function handleViewportResize(){
    syncMenuMeasurements();
  }
  window.addEventListener('resize', handleViewportResize, { passive: true });

  if('ResizeObserver' in window && sidebarEl){
    const observer = new ResizeObserver(() => {
      syncMenuMeasurements();
    });
    observer.observe(sidebarEl);
    if(sbContent){
      observer.observe(sbContent);
    }
  }

  function updateHudStats(){
    if(hudStatAs){
      hudStatAs.textContent = formatSeconds(player.attackSpeedMs);
    }
    if(hudStatAw){
      hudStatAw.textContent = formatSeconds(player.attackWindupMs);
    }
    if(hudStatAr){
      hudStatAr.textContent = formatStatNumber(player.attackRange);
    }
    if(hudStatDmg){
      hudStatDmg.textContent = formatStatNumber(player.attackDamage);
    }
    if(hudStatMs){
      hudStatMs.textContent = formatStatNumber(player.speed);
    }
    scheduleHudFit();
  }
  let lastHudHealthText = '';
  function updateHudHealth(){
    const maxHpRaw = Number(player.maxHp) || 0;
    const maxHp = Math.max(0, maxHpRaw);
    const currentHpRaw = Number(player.hp) || 0;
    const currentHp = Math.max(0, Math.min(maxHp > 0 ? maxHp : currentHpRaw, currentHpRaw));
    const pct = maxHp > 0 ? currentHp / maxHp : 0;
    const clampedPct = Math.max(0, Math.min(1, pct));
    const hudOrientation = abilityBarState.orientation === 'vertical' ? 'vertical' : 'horizontal';
  if(playerFloatHud){
    const segments = Math.max(0, Math.floor(maxHp / 100));
    const showNotches = segments > 0 && currentHp >= 100;
    if(showNotches){
      const trackWidth = playerFloatTrack && playerFloatTrack.clientWidth
        ? playerFloatTrack.clientWidth
        : Math.max(1, Number(playerFloatState.width) || 1);
      const usable = Math.max(4, trackWidth);
      const spacing = usable / segments;
      const notchWidth = Math.max(1, spacing * 0.12);
      const notchMargin = Math.max(4, spacing * 0.65); // keep a clean gap from edges
      const offset = spacing; // start at first 100hp mark inside margin
      playerFloatHud.style.setProperty('--hp-notch-spacing', `${spacing}px`);
      playerFloatHud.style.setProperty('--hp-notch-width', `${notchWidth}px`);
      playerFloatHud.style.setProperty('--hp-notch-offset', `${offset}px`);
      playerFloatHud.style.setProperty('--hp-notch-margin', `${notchMargin}px`);
    } else {
      playerFloatHud.style.removeProperty('--hp-notch-spacing');
      playerFloatHud.style.removeProperty('--hp-notch-width');
      playerFloatHud.style.removeProperty('--hp-notch-offset');
      playerFloatHud.style.removeProperty('--hp-notch-margin');
      }
    }
    if(hudHpFill){
      if(hudOrientation === 'vertical'){
        hudHpFill.style.height = `${clampedPct * 100}%`;
        hudHpFill.style.width = '100%';
        hudHpFill.style.bottom = '0';
        hudHpFill.style.top = '';
      } else {
        hudHpFill.style.width = `${clampedPct * 100}%`;
        hudHpFill.style.height = '100%';
        hudHpFill.style.top = '';
        hudHpFill.style.bottom = '';
      }
    }
    if(hudHpText){
      const nextText = `${currentHp|0} / ${maxHp|0}`;
      if(nextText !== lastHudHealthText){
        hudHpText.textContent = nextText;
        lastHudHealthText = nextText;
        scheduleHudFit();
      }
    }
    if(playerFloatFill){
      playerFloatFill.style.width = `${clampedPct * 100}%`;
    }
    if(playerFloatText){
      playerFloatText.textContent = '';
    }
    if(playerHpValue){
      playerHpValue.textContent = `${currentHp|0}`;
    }
    if(playerFloatHud){
      const visible = maxHp > 0;
      playerFloatHud.style.opacity = visible ? '1' : '0';
      playerFloatHud.setAttribute('aria-hidden', visible ? 'false' : 'true');
    }
    updatePracticeDummyHud();
  }

  function updatePracticeDummyHud(){
    if(!practiceDummyHud){
      return;
    }
    const active = practiceDummy && practiceDummy.active !== false && !(practiceDummy.respawnTimer > 0);
    const maxHpRaw = Number(practiceDummy && practiceDummy.maxHp);
    const maxHp = Math.max(0, Number.isFinite(maxHpRaw) ? maxHpRaw : 0);
    const hpRaw = Number(practiceDummy && practiceDummy.hp);
    const hpValue = Math.max(0, Number.isFinite(hpRaw) ? hpRaw : maxHp);
    const cappedHp = maxHp > 0 ? Math.min(maxHp, hpValue) : hpValue;
    const pct = maxHp > 0 ? Math.max(0, Math.min(1, cappedHp / maxHp)) : 0;
    const visible = active && maxHp > 0;
    practiceDummyHud.style.opacity = visible ? '1' : '0';
    practiceDummyHud.setAttribute('aria-hidden', visible ? 'false' : 'true');
    if(practiceDummyFill){
      practiceDummyFill.style.width = `${pct * 100}%`;
    }
    if(practiceDummyText){
      practiceDummyText.textContent = `${Math.round(cappedHp)}`;
    }
  }

  function updatePracticeDummyUiState(){
    if(practiceDummySizeInput){
      const size = Math.round(clampPracticeDummySize(practiceDummy && practiceDummy.size, 120));
      practiceDummySizeInput.value = String(size);
      if(practiceDummySizeDisplay){
        practiceDummySizeDisplay.textContent = `${size}px`;
      }
    }
    if(practiceDummyMoveButton){
      const placing = !!(practiceDummyState && practiceDummyState.placing);
      const respawning = !!(practiceDummy && practiceDummy.respawnTimer > 0);
      const active = practiceDummy && practiceDummy.active !== false && !respawning;
      if(respawning){
        practiceDummyMoveButton.textContent = 'Respawning dummyâ€¦';
      } else if(active){
        practiceDummyMoveButton.textContent = placing ? 'Cancel dummy move' : 'Move dummy';
      } else {
        practiceDummyMoveButton.textContent = placing ? 'Cancel dummy placement' : 'Add dummy';
      }
      practiceDummyMoveButton.disabled = !!respawning;
    }
    if(practiceDummyRemoveButton){
      const active = practiceDummy && practiceDummy.active !== false && !(practiceDummy && practiceDummy.respawnTimer > 0);
      const selected = !!(practiceDummyState && practiceDummyState.selected);
      practiceDummyRemoveButton.disabled = !(active && selected);
    }
    if(practiceDummyDeathResponseSelect){
      const value = practiceDummy && practiceDummy.deathResponse === 'despawn' ? 'despawn' : 'respawn';
      practiceDummyDeathResponseSelect.value = value;
    }
  }
  let lastPlayerAttackReadyProgress = 0;
  function setPlayerAttackReadyState(progress, ready, enabled){
    if(playerAttackReadyFill){
      const clamped = Math.max(0, Math.min(1, Number(progress) || 0));
      const pctWidth = `${clamped * 100}%`;
      if(clamped <= 0 && lastPlayerAttackReadyProgress > 0){
        playerAttackReadyFill.style.transition = 'none';
        playerAttackReadyFill.style.width = pctWidth;
        void playerAttackReadyFill.offsetWidth;
        playerAttackReadyFill.style.transition = '';
      } else {
        playerAttackReadyFill.style.width = pctWidth;
      }
      playerAttackReadyFill.classList.toggle('is-ready', !!ready);
      lastPlayerAttackReadyProgress = clamped;
    }
    if(playerAttackReadyBar){
      playerAttackReadyBar.classList.toggle('is-ready', !!ready);
      playerAttackReadyBar.classList.toggle('is-disabled', !enabled);
      playerAttackReadyBar.setAttribute('aria-hidden', enabled ? 'false' : 'true');
    }
  }
  function applyPlayerFloatHudSizing(){
    if(playerFloatHud){
      playerFloatHud.style.setProperty('--player-float-width', String(playerFloatState.width));
      playerFloatHud.style.setProperty('--player-float-height', String(playerFloatState.height));
      const hpColor = sanitizeHexColor(playerFloatState.color, '#5bc357');
      playerFloatHud.style.setProperty('--player-float-color', hpColor);
      playerFloatHud.style.setProperty('--player-float-color-dark', darkenHex(hpColor, 0.25));
      if(playerFloatState.attack){
        playerFloatHud.style.setProperty('--player-attack-width', String(playerFloatState.attack.width));
        playerFloatHud.style.setProperty('--player-attack-height', String(playerFloatState.attack.height));
        playerFloatHud.style.setProperty('--player-attack-offset-x', String(playerFloatState.attack.offsetX));
        playerFloatHud.style.setProperty('--player-attack-offset-y', String(playerFloatState.attack.offsetY));
      }
      if(playerFloatState.icons){
        playerFloatHud.style.setProperty('--player-icon-width', String(playerFloatState.icons.width));
        playerFloatHud.style.setProperty('--player-icon-height', String(playerFloatState.icons.height));
        playerFloatHud.style.setProperty('--player-icon-offset-x', String(playerFloatState.icons.offsetX));
        playerFloatHud.style.setProperty('--player-icon-offset-y', String(playerFloatState.icons.offsetY));
      }
    }
    if(practiceDummyHud){
      practiceDummyHud.style.setProperty('--player-float-width', String(playerFloatState.width));
      practiceDummyHud.style.setProperty('--player-float-height', String(playerFloatState.height));
      if(playerFloatState.attack){
        practiceDummyHud.style.setProperty('--player-attack-width', String(playerFloatState.attack.width));
        practiceDummyHud.style.setProperty('--player-attack-height', String(playerFloatState.attack.height));
        practiceDummyHud.style.setProperty('--player-attack-offset-x', String(playerFloatState.attack.offsetX));
        practiceDummyHud.style.setProperty('--player-attack-offset-y', String(playerFloatState.attack.offsetY));
      }
      if(playerFloatState.icons){
        practiceDummyHud.style.setProperty('--player-icon-width', String(playerFloatState.icons.width));
        practiceDummyHud.style.setProperty('--player-icon-height', String(playerFloatState.icons.height));
        practiceDummyHud.style.setProperty('--player-icon-offset-x', String(playerFloatState.icons.offsetX));
        practiceDummyHud.style.setProperty('--player-icon-offset-y', String(playerFloatState.icons.offsetY));
      }
    }
    if(playerFloatSizeDisplay){
      playerFloatSizeDisplay.textContent = `${Math.round(playerFloatState.width)}px`;
    }
    if(playerFloatHeightDisplay){
      playerFloatHeightDisplay.textContent = `${Math.round(playerFloatState.height)}px`;
    }
    if(playerFloatOffsetDisplay){
      playerFloatOffsetDisplay.textContent = `${Math.round(playerFloatState.gap)}px`;
    }
    if(playerAttackBarWidthDisplay && playerFloatState.attack){
      playerAttackBarWidthDisplay.textContent = `${Math.round(playerFloatState.attack.width)}px`;
    }
    if(playerAttackBarHeightDisplay && playerFloatState.attack){
      playerAttackBarHeightDisplay.textContent = `${Math.round(playerFloatState.attack.height)}px`;
    }
    if(playerIconWidthDisplay && playerFloatState.icons){
      playerIconWidthDisplay.textContent = `${Math.round(playerFloatState.icons.width)}px`;
    }
    if(playerIconHeightDisplay && playerFloatState.icons){
      playerIconHeightDisplay.textContent = `${Math.round(playerFloatState.icons.height)}px`;
    }
  }

  function buildPlayerStatusConfigRows(){
    if(!playerStateConfigList){
      return;
    }
    playerStateConfigList.innerHTML = '';
    playerStatusEmojiInputs.clear();
    playerStatusColorInputs.clear();
    for(const def of PLAYER_STATUS_DEFS){
      const row = document.createElement('div');
      row.className = 'playerStateConfigRow';
      row.dataset.state = def.id;

      const header = document.createElement('div');
      header.className = 'playerStateConfigHeader';
      header.textContent = def.label;
      row.appendChild(header);

      const controls = document.createElement('div');
      controls.className = 'playerStateConfigInputs';

      const emojiLabel = document.createElement('label');
      emojiLabel.innerHTML = '<span>Emoji</span>';
      const emojiInput = document.createElement('input');
      emojiInput.type = 'text';
      emojiInput.id = `playerState.${def.id}.emoji`;
      emojiInput.maxLength = 6;
      emojiInput.inputMode = 'text';
      emojiInput.autocomplete = 'off';
      emojiLabel.appendChild(emojiInput);

      const colorLabel = document.createElement('label');
      colorLabel.innerHTML = '<span>Text color</span>';
      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.id = `playerState.${def.id}.color`;
      colorLabel.appendChild(colorInput);

      controls.appendChild(emojiLabel);
      controls.appendChild(colorLabel);
      row.appendChild(controls);
      playerStateConfigList.appendChild(row);

      playerStatusEmojiInputs.set(def.id, emojiInput);
      playerStatusColorInputs.set(def.id, colorInput);

      emojiInput.addEventListener('input', ()=>{
        if(!playerFloatState.statuses || typeof playerFloatState.statuses !== 'object'){
          playerFloatState.statuses = buildDefaultPlayerStatusConfig();
        }
        const entry = playerFloatState.statuses[def.id] || (playerFloatState.statuses[def.id] = { emoji: def.defaultEmoji, color: def.defaultColor });
        const trimmed = emojiInput.value.trim();
        entry.emoji = trimmed || def.defaultEmoji;
        if(emojiInput.value !== entry.emoji){
          emojiInput.value = entry.emoji;
        }
        updatePlayerStatusIcons();
      });

      colorInput.addEventListener('input', ()=>{
        if(!playerFloatState.statuses || typeof playerFloatState.statuses !== 'object'){
          playerFloatState.statuses = buildDefaultPlayerStatusConfig();
        }
        const entry = playerFloatState.statuses[def.id] || (playerFloatState.statuses[def.id] = { emoji: def.defaultEmoji, color: def.defaultColor });
        const sanitized = sanitizeHexColor(colorInput.value, def.defaultColor);
        entry.color = sanitized;
        if(colorInput.value !== sanitized){
          colorInput.value = sanitized;
        }
        updatePlayerStatusIcons();
      });
    }
    syncPlayerStatusConfigInputs();
  }

  function syncPlayerStatusConfigInputs(){
    if(!playerFloatState.statuses || typeof playerFloatState.statuses !== 'object'){
      playerFloatState.statuses = buildDefaultPlayerStatusConfig();
    }
    for(const def of PLAYER_STATUS_DEFS){
      const entry = playerFloatState.statuses[def.id] || (playerFloatState.statuses[def.id] = { emoji: def.defaultEmoji, color: def.defaultColor });
      const emojiInput = playerStatusEmojiInputs.get(def.id);
      if(emojiInput){
        emojiInput.value = entry.emoji || def.defaultEmoji;
      }
      const colorInput = playerStatusColorInputs.get(def.id);
      if(colorInput){
        const sanitized = sanitizeHexColor(entry.color, def.defaultColor);
        colorInput.value = sanitized;
        entry.color = sanitized;
      }
    }
    updatePlayerStatusIcons();
  }

  function resolveMonsterAbilityEmoji(monster, abilityId){
    if(!abilityId){
      return 'ðŸ›¡ï¸';
    }
    if(monster && monster.projectileIcons && typeof monster.projectileIcons === 'object'){
      const custom = monster.projectileIcons[abilityId];
      if(typeof custom === 'string' && custom.trim()){
        return custom.trim();
      }
    }
    if(typeof DEFAULT_MONSTER_ICONS[abilityId] === 'string'){
      return DEFAULT_MONSTER_ICONS[abilityId];
    }
    return 'ðŸ›¡ï¸';
  }

  function getPrayerEmoji(prayerId){
    return resolveMonsterAbilityEmoji(monsterState, prayerId);
  }

  function setMonsterProjectileIcon(abilityId, emoji){
    if(!abilityId){
      return;
    }
    if(!monsterState.projectileIcons || typeof monsterState.projectileIcons !== 'object'){
      monsterState.projectileIcons = { ...DEFAULT_MONSTER_ICONS };
    }
    const sanitized = typeof emoji === 'string' && emoji.trim() ? emoji.trim() : resolveMonsterAbilityEmoji(null, abilityId);
    monsterState.projectileIcons[abilityId] = sanitized;
  }

  function clearPrayerBindings(){
    if(!prayerState || !prayerState.bindings){
      return;
    }
    const emptyLabel = formatAbilityKeyLabel('', '');
    for(const def of PRAYER_DEFS){
      prayerState.bindings[def.id] = { key: '', code: '', label: emptyLabel };
    }
    rebuildPrayerBindingLookup(prayerState);
  }

  function syncPrayerBindingButton(prayerId){
    const button = prayerBindingButtons.get(prayerId);
    const binding = prayerState.bindings[prayerId];
    if(button){
      if(prayerKeyCaptureId === prayerId){
        button.textContent = 'Press a keyâ€¦';
      } else {
        button.textContent = binding && binding.label ? binding.label : 'â€”';
      }
    }
  }

  function updatePrayerButtons(){
    for(const def of PRAYER_DEFS){
      syncPrayerBindingButton(def.id);
      const toggle = prayerActivateButtons.get(def.id);
      if(toggle){
        const active = prayerState.active === def.id;
        toggle.textContent = active ? 'Deactivate' : 'Activate';
        toggle.setAttribute('aria-pressed', active ? 'true' : 'false');
      }
      const emojiDisplay = prayerEmojiDisplays.get(def.id);
      if(emojiDisplay){
        emojiDisplay.textContent = `Emoji: ${getPrayerEmoji(def.id)}`;
      }
    }
  }

  function updatePrayerHud(){
    if(!playerPrayerIcons){
      return;
    }
    const active = prayerState.active;
    player.activePrayer = active || null;
    playerPrayerIcons.innerHTML = '';
    if(!active){
      playerPrayerIcons.setAttribute('aria-hidden', 'true');
      return;
    }
    const icon = document.createElement('div');
    icon.className = 'playerPrayerIcon';
    icon.textContent = getPrayerEmoji(active);
    playerPrayerIcons.appendChild(icon);
    playerPrayerIcons.setAttribute('aria-hidden', 'false');
  }

  function buildPrayerUi(){
    if(!prayerListEl){
      return;
    }
    prayerListEl.innerHTML = '';
    prayerBindingButtons.clear();
    prayerActivateButtons.clear();
    prayerEmojiDisplays.clear();
    for(const def of PRAYER_DEFS){
      const row = document.createElement('div');
      row.className = 'playerStateConfigRow';
      row.dataset.prayer = def.id;

      const header = document.createElement('div');
      header.className = 'playerStateConfigHeader';
      header.textContent = def.label;

      const toggle = document.createElement('button');
      toggle.type = 'button';
      toggle.className = 'formButton';
      toggle.dataset.prayer = def.id;
      toggle.addEventListener('click', ()=>{
        togglePrayer(def.id);
      });
      header.appendChild(toggle);
      row.appendChild(header);

      const controls = document.createElement('div');
      controls.className = 'playerStateConfigInputs';

      const bindLabel = document.createElement('label');
      bindLabel.innerHTML = '<span>Key bind</span>';
      const bindButton = document.createElement('button');
      bindButton.type = 'button';
      bindButton.className = 'formButton';
      bindButton.dataset.prayer = def.id;
      bindButton.addEventListener('click', ()=> startPrayerKeyCapture(def.id));
      bindLabel.appendChild(bindButton);
      controls.appendChild(bindLabel);

      const emojiPreview = document.createElement('div');
      emojiPreview.className = 'hint';
      emojiPreview.dataset.prayer = def.id;
      controls.appendChild(emojiPreview);
      prayerEmojiDisplays.set(def.id, emojiPreview);

      row.appendChild(controls);
      prayerListEl.appendChild(row);

      prayerBindingButtons.set(def.id, bindButton);
      prayerActivateButtons.set(def.id, toggle);
    }
    updatePrayerButtons();
  }

  function stopPrayerKeyCapture(options = {}){
    if(prayerKeyCaptureId){
      const current = prayerKeyCaptureId;
      prayerKeyCaptureId = null;
      if(!options.silent){
        const binding = prayerState.bindings[current];
        const def = PRAYER_DEFS.find(d => d.id === current);
        if(def){
          const label = binding && binding.label ? binding.label : 'â€”';
          setHudMessage(`${def.label} set to ${label}.`);
        }
      }
      syncPrayerBindingButton(current);
    }
  }

  function startPrayerKeyCapture(prayerId){
    if(!PRAYER_DEFS.some(def => def.id === prayerId)){
      return;
    }
    if(prayerKeyCaptureId === prayerId){
      stopPrayerKeyCapture({ silent: true });
      return;
    }
    if(prayerKeyCaptureId){
      syncPrayerBindingButton(prayerKeyCaptureId);
    }
    prayerKeyCaptureId = prayerId;
    syncPrayerBindingButton(prayerId);
    setHudMessage('Press a key to bind this prayer.');
  }

  function setPrayerBinding(prayerId, key, code){
    if(!PRAYER_DEFS.some(def => def.id === prayerId)){
      return;
    }
    const normalizedKey = typeof key === 'string' ? key : '';
    const normalizedCode = typeof code === 'string' ? code : '';
    const label = formatAbilityKeyLabel(normalizedKey, normalizedCode);
    prayerState.bindings[prayerId] = { key: normalizedKey, code: normalizedCode, label };
    rebuildPrayerBindingLookup(prayerState);
    syncPrayerBindingButton(prayerId);
  }

  function setActivePrayer(prayerId){
    const valid = PRAYER_DEFS.some(def => def.id === prayerId);
    prayerState.active = valid ? prayerId : null;
    player.activePrayer = prayerState.active;
    updatePrayerButtons();
    updatePrayerHud();
  }

  function togglePrayer(prayerId){
    const def = PRAYER_DEFS.find(d => d.id === prayerId);
    if(!def){
      return;
    }
    const next = prayerState.active === prayerId ? null : prayerId;
    setActivePrayer(next);
    if(next){
      setHudMessage(`${def.label} activated.`);
    } else {
      setHudMessage('All protection prayers deactivated.');
    }
  }

  function findPrayerForEvent(ev){
    if(!ev){
      return null;
    }
    const code = typeof ev.code === 'string' ? ev.code : '';
    if(code){
      const byCode = prayerBindingLookup.get(`code:${code}`);
      if(byCode){
        return byCode;
      }
    }
    const key = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
    if(key){
      const byKey = prayerBindingLookup.get(`key:${key}`);
      if(byKey){
        return byKey;
      }
    }
    return null;
  }

  function sanitizeMonsterCoordinate(value, limit){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)){
      return Math.max(0, Math.min(limit, limit / 2));
    }
    return Math.max(0, Math.min(limit, numeric));
  }

  function moveMonsterTo(x, y){
    if(!monsterState){
      return;
    }
    const clampedX = sanitizeMonsterCoordinate(x, mapState.width);
    const clampedY = sanitizeMonsterCoordinate(y, mapState.height);
    monsterState.x = clampedX;
    monsterState.y = clampedY;
    positionMonsterHud();
    renderMinimap(true);
  }

  function updateMonsterUiState(){
    if(!monsterMoveButton){
      return;
    }
    const active = monsterDragState.active || monsterDragState.dragging;
    monsterMoveButton.textContent = active ? 'Click map to placeâ€¦' : 'Move monster';
    monsterMoveButton.classList.toggle('is-active', active);
    monsterMoveButton.setAttribute('aria-pressed', active ? 'true' : 'false');
  }

  function updateMonsterDragPosition(x, y){
    if(!monsterDragState.dragging){
      return;
    }
    const nextX = x + monsterDragState.offsetX;
    const nextY = y + monsterDragState.offsetY;
    moveMonsterTo(nextX, nextY);
    monsterDragState.moved = true;
  }

  function beginMonsterDrag(pointerId, x, y){
    if(!monsterState){
      return false;
    }
    const bodyRadius = Math.max(10, Math.min(400, Number(monsterState.size) || 140)) * 0.5;
    const dx = monsterState.x - x;
    const dy = monsterState.y - y;
    const inside = dx * dx + dy * dy <= bodyRadius * bodyRadius;
    monsterDragState.pointerId = pointerId;
    monsterDragState.offsetX = inside ? monsterState.x - x : 0;
    monsterDragState.offsetY = inside ? monsterState.y - y : 0;
    monsterDragState.dragging = true;
    monsterDragState.moved = false;
    updateMonsterDragPosition(x, y);
    updateMonsterUiState();
    return true;
  }

  function endMonsterDrag({ commit = true } = {}){
    if(monsterDragState.pointerId !== null && stage){
      try { stage.releasePointerCapture(monsterDragState.pointerId); } catch (err) { /* ignore */ }
    }
    monsterDragState.pointerId = null;
    monsterDragState.dragging = false;
    monsterDragState.offsetX = 0;
    monsterDragState.offsetY = 0;
    monsterDragState.moved = false;
    if(commit){
      monsterDragState.active = false;
      if(monsterDragState.messageActive){
        setHudMessage();
        monsterDragState.messageActive = false;
      }
    }
    updateMonsterUiState();
  }

  function cancelMonsterDrag(){
    endMonsterDrag({ commit: false });
    monsterDragState.active = false;
    if(monsterDragState.messageActive){
      setHudMessage();
      monsterDragState.messageActive = false;
    }
    updateMonsterUiState();
  }

  function syncMonsterInputs(){
    if(!monsterState){
      return;
    }
    if(monsterAggroRadiusInput){
      monsterAggroRadiusInput.value = String(Math.round(monsterState.aggroRadius));
    }
    if(monsterSizeInput){
      monsterSizeInput.value = String(Math.round(monsterState.size));
    }
    if(monsterMaxHpInput){
      monsterMaxHpInput.value = String(Math.round(monsterState.maxHp));
    }
    if(monsterProjectileDamageInput){
      monsterProjectileDamageInput.value = String(Math.round(monsterState.projectileDamage));
    }
    if(monsterCastIntervalInput){
      monsterCastIntervalInput.value = String(Number(monsterState.castInterval).toFixed(2));
    }
    if(monsterQueueSizeInput){
      monsterQueueSizeInput.value = String(Math.round(monsterState.queueSize));
    }
    if(monsterSlotSpinInput){
      monsterSlotSpinInput.value = String(Number(monsterState.slotMachineSpinDuration).toFixed(2));
    }
    if(monsterSlotRevealInput){
      monsterSlotRevealInput.value = String(Number(monsterState.slotMachineRevealDuration).toFixed(2));
    }
    if(monsterFreezeDurationInput){
      monsterFreezeDurationInput.value = String(Number(monsterState.freezeDuration).toFixed(2));
    }
    if(monsterSpeedBoostPctInput){
      monsterSpeedBoostPctInput.value = String(Math.round(monsterState.speedBoostPct));
    }
    if(monsterHealAmountInput){
      monsterHealAmountInput.value = String(Math.round(monsterState.healAmount));
    }
    if(monsterIconGreenInput){
      monsterIconGreenInput.value = getPrayerEmoji('green');
    }
    if(monsterIconBlueInput){
      monsterIconBlueInput.value = getPrayerEmoji('blue');
    }
    if(monsterIconRedInput){
      monsterIconRedInput.value = getPrayerEmoji('red');
    }
    updateMonsterUiState();
  }

  function updateMonsterAbilityQueueDisplay(){
    if(!monsterAbilityQueueEl){
      return;
    }
    const monster = monsterState;
    monsterAbilityQueueEl.innerHTML = '';
    if(!monster || monster.active === false){
      monsterAbilityQueueEl.setAttribute('aria-hidden', 'true');
      return;
    }
    const engaged = monster.engaged === true;
    const faces = Array.isArray(monster.slotMachineFaces) ? monster.slotMachineFaces : [];
    const revealTimer = Math.max(0, Number(monster.slotMachineRevealTimer) || 0);
    const isSpinning = monster.slotMachineActive === true;
    const hasPending = !!monster.pendingAbility;
    if(!engaged && !isSpinning && !hasPending){
      monsterAbilityQueueEl.setAttribute('aria-hidden', 'true');
      return;
    }
    const hasCountdown = engaged && hasPending && !isSpinning && revealTimer > 0;
    const state = isSpinning ? 'spinning' : hasCountdown ? 'countdown' : 'idle';
    const machine = document.createElement('div');
    machine.className = 'monsterSlotMachine';
    machine.dataset.state = state;
    const windowWrap = document.createElement('div');
    windowWrap.className = 'monsterSlotWindow';
    for(let i = 0; i < MONSTER_SLOT_MACHINE_COLUMNS; i++){
      const abilityId = faces[i] && MONSTER_ABILITY_IDS.includes(faces[i]) ? faces[i] : randomMonsterAbility();
      const reel = document.createElement('div');
      reel.className = 'monsterSlotReel';
      if(i === 0){
        reel.dataset.focus = 'true';
      }
      if(isSpinning){
        reel.dataset.spinning = 'true';
      }
      const symbol = document.createElement('div');
      symbol.className = 'monsterSlotSymbol';
      symbol.textContent = getPrayerEmoji(abilityId);
      reel.appendChild(symbol);
      windowWrap.appendChild(reel);
    }
    machine.appendChild(windowWrap);
    const readoutText = isSpinning
      ? 'Spinningâ€¦'
      : hasCountdown
        ? `${revealTimer.toFixed(1)}s`
        : '';
    if(readoutText){
      const readout = document.createElement('div');
      readout.className = 'monsterSlotReadout';
      readout.textContent = readoutText;
      machine.appendChild(readout);
    }
    monsterAbilityQueueEl.appendChild(machine);
    monsterAbilityQueueEl.setAttribute('aria-hidden', 'false');
  }

  function updateMonsterHud(){
    if(!monsterHud){
      return;
    }
    const monster = monsterState;
    if(!monster || monster.active === false){
      monsterHud.setAttribute('aria-hidden', 'true');
      return;
    }
    monsterHud.style.opacity = '1';
    monsterHud.setAttribute('aria-hidden', 'false');
    const width = Math.max(60, Number(monster.size) || 140);
    monsterHud.style.setProperty('--player-float-width', String(width));
    monsterHud.style.setProperty('--player-float-height', '18');
    const hp = Math.max(0, Number(monster.hp) || 0);
    const maxHp = Math.max(1, Number(monster.maxHp) || 1);
    const pct = Math.max(0, Math.min(1, hp / maxHp));
    if(monsterFill){
      monsterFill.style.width = `${pct * 100}%`;
    }
    if(monsterText){
      monsterText.textContent = `${Math.round(hp)} / ${Math.round(maxHp)}`;
    }
    updateMonsterAbilityQueueDisplay();
  }

  function positionMonsterHud(){
    if(!monsterHud || !monsterState || monsterState.active === false){
      return;
    }
    const hudHalfWidth = monsterHud.offsetWidth / 2;
    const minEdge = Math.max(32, hudHalfWidth + 4);
    const width = Math.max(0, Number(mapState.width) || 0);
    const height = Math.max(0, Number(mapState.height) || 0);
    const left = Math.max(minEdge, Math.min(width - minEdge, monsterState.x));
    const offsetHeight = Math.max(20, Number(monsterState.size) || 140) * 0.6 + 28;
    const topBase = monsterState.y - offsetHeight;
    const top = Math.max(28, Math.min(height - 12, topBase));
    monsterHud.style.left = `${left}px`;
    monsterHud.style.top = `${top}px`;
  }

  function setMonsterSlotFaces(monster, abilityId){
    if(!monster){
      return;
    }
    if(!Array.isArray(monster.slotMachineFaces)){
      monster.slotMachineFaces = new Array(MONSTER_SLOT_MACHINE_COLUMNS).fill(null);
    }
    const resolvedAbility = MONSTER_ABILITY_IDS.includes(abilityId) ? abilityId : randomMonsterAbility();
    monster.slotMachineFaces.length = MONSTER_SLOT_MACHINE_COLUMNS;
    for(let i = 0; i < MONSTER_SLOT_MACHINE_COLUMNS; i++){
      monster.slotMachineFaces[i] = resolvedAbility;
    }
  }

  function ensureMonsterQueue(monster){
    if(!monster){
      return;
    }
    if(!Array.isArray(monster.abilityQueue)){
      monster.abilityQueue = [];
    }
    const desired = Math.max(1, Math.min(6, Number(monster.queueSize) || 1));
    while(monster.abilityQueue.length < desired){
      monster.abilityQueue.push(randomMonsterAbility());
    }
    if(monster.abilityQueue.length > desired){
      monster.abilityQueue.length = desired;
    }
  }

  function collectMonsterParticipants(monster){
    const participants = [];
    if(!monster){
      return participants;
    }
    const radius = Math.max(0, Number(monster.aggroRadius) || 0);
    const radiusSq = radius * radius;
    const consider = (entity)=>{
      if(!entity){
        return;
      }
      if(entity !== player && entity.isPracticeDummy !== true && entity.isPlayer !== true){
        return;
      }
      if(typeof entity.hp === 'number' && entity.hp <= 0){
        return;
      }
      const dx = entity.x - monster.x;
      const dy = entity.y - monster.y;
      if(radius <= 0 || (dx * dx + dy * dy) <= radiusSq){
        participants.push(entity);
      }
    };
    consider(player);
    if(practiceDummy && practiceDummy.active !== false && !(practiceDummy.respawnTimer > 0)){
      consider(practiceDummy);
    }
    return participants;
  }

  function spawnMonsterProjectile(monster, abilityId, target){
    if(!monster || !target){
      return;
    }
    const startX = monster.x;
    const startY = monster.y - Math.max(10, Number(monster.size) || 0) * 0.35;
    const targetX = target.x;
    const targetY = target.y;
    const dx = targetX - startX;
    const dy = targetY - startY;
    const distance = Math.hypot(dx, dy) || 1;
    const speed = Math.max(60, Number(monster.projectileSpeed) || 520);
    const duration = Math.max(0.12, distance / speed);
    projectiles.push({
      startX,
      startY,
      targetRef: target,
      targetX,
      targetY,
      progress: 0,
      duration,
      monsterAbility: abilityId,
      monsterRef: monster,
      onImpact: () => resolveMonsterProjectileImpact(monster, target, abilityId)
    });
  }

  function healEntity(target, amount){
    const heal = Math.max(0, Number(amount) || 0);
    if(!(heal > 0) || !target){
      return;
    }
    if(target === player){
      const prev = Math.max(0, Number(player.hp) || 0);
      const maxHp = Math.max(1, Number(player.maxHp) || 1);
      const next = Math.min(maxHp, prev + heal);
      if(next !== prev){
        player.hp = next;
        updateHudHealth();
      }
      return;
    }
    if(target.isPracticeDummy){
      const prev = Math.max(0, Number(target.hp) || 0);
      const maxHp = Math.max(1, Number(target.maxHp) || 1);
      const next = Math.min(maxHp, prev + heal);
      if(next !== prev){
        target.hp = next;
        updatePracticeDummyHud();
      }
      return;
    }
    if(typeof target.hp === 'number'){
      const prev = Number(target.hp) || 0;
      const maxHp = Math.max(prev, Number(target.maxHp) || prev);
      target.hp = Math.min(maxHp, prev + heal);
    }
  }

  function resolveMonsterProjectileImpact(monster, target, abilityId){
    if(!target){
      return;
    }
    const damage = Math.max(0, Number(monster && monster.projectileDamage) || 0);
    const isPlayerTarget = target === player;
    const protectedHit = isPlayerTarget && prayerState.active === abilityId;
    if(!protectedHit && damage > 0){
      if(target === player){
        damagePlayer(damage, { attacker: monster });
      } else if(target.isPracticeDummy){
        const prevHp = Number(target.hp) || 0;
        const maxHp = Math.max(1, Number(target.maxHp) || prevHp);
        const applied = applyDamageMitigation(target, damage);
        if(applied > 0){
          const nextHp = Math.max(0, Math.min(maxHp, prevHp - applied));
          target.hp = nextHp;
          spawnHitSplat(target.x, target.y - clampPracticeDummySize(target.size, 120) * 0.5, applied);
          handlePracticeDummyDamage(target, prevHp);
        }
      } else if(typeof target.hp === 'number'){
        target.hp = Math.max(0, Number(target.hp) - damage);
      }
    }
    const freezeDuration = Math.max(0, Number(monster && monster.freezeDuration) || 0);
    if(abilityId === 'blue' && freezeDuration > 0){
      const existing = Number(target.stunTimer) || 0;
      target.stunTimer = Math.max(existing, freezeDuration);
      if(target === player){
        updatePlayerStatusIcons();
      } else if(target.isPracticeDummy){
        updatePracticeDummyStatusIcons();
      }
    }
    if(abilityId === 'red'){
      const hastePct = Math.max(0, Number(monster && monster.speedBoostPct) || 0);
      if(hastePct > 0){
        if(target && Object.prototype.hasOwnProperty.call(target, 'hasteMinPct')){
          target.hasteMinPct = 0;
          target.hasteDecayRate = 0;
        }
        target.hasteTimer = Math.max(Number(target.hasteTimer) || 0, MONSTER_SPEED_BOOST_DURATION);
        target.hastePct = hastePct;
        if(target === player){
          updatePlayerStatusIcons();
        } else if(target.isPracticeDummy){
          updatePracticeDummyStatusIcons();
        }
      }
    }
    if(abilityId === 'green'){
      const healAmount = Math.max(0, Number(monster && monster.healAmount) || 0);
      if(healAmount > 0){
        healEntity(target, healAmount);
      }
    }
    updateMonsterHud();
  }

  function castMonsterAbility(monster, abilityId, participants){
    if(!monster || !participants || !participants.length){
      return;
    }
    for(const target of participants){
      const isPlayerEntity = target === player || target.isPracticeDummy || target.isPlayer === true;
      if(!isPlayerEntity){
        continue;
      }
      spawnMonsterProjectile(monster, abilityId, target);
    }
  }

  function finalizeMonsterPendingCast(monster){
    if(!monster || !monster.pendingAbility){
      return;
    }
    const targets = collectMonsterParticipants(monster);
    monster.lastTargetCount = targets.length;
    monster.engaged = targets.length > 0;
    if(targets.length){
      castMonsterAbility(monster, monster.pendingAbility, targets);
    }
    monster.pendingAbility = null;
    monster.castTimer = 0;
    monster.slotMachineRevealTimer = 0;
    monster.slotMachineActive = false;
    monster.slotMachineSpinTimer = 0;
    monster.slotMachineFaceTimer = 0;
    monster.slotMachineImpactReady = false;
  }

  function updateMonsterState(dt){
    if(!monsterState){
      return;
    }
    if(monsterState.plasmaTimer > 0){
      monsterState.plasmaTimer = Math.max(0, monsterState.plasmaTimer - dt);
      if(monsterState.plasmaTimer <= 0){
        monsterState.plasmaTimer = 0;
        monsterState.plasmaStacks = 0;
      }
    }
    if(monsterState.active === false){
      updateMonsterAbilityQueueDisplay();
      if(monsterHud){
        monsterHud.setAttribute('aria-hidden', 'true');
      }
      return;
    }
    ensureMonsterQueue(monsterState);
    monsterState.x = sanitizeMonsterCoordinate(monsterState.x, mapState.width);
    monsterState.y = sanitizeMonsterCoordinate(monsterState.y, mapState.height);
    monsterState.hp = Math.max(0, Math.min(monsterState.maxHp, Number(monsterState.hp) || monsterState.maxHp));
    if(!Array.isArray(monsterState.slotMachineFaces)){
      monsterState.slotMachineFaces = [];
    }
    for(let i = 0; i < MONSTER_SLOT_MACHINE_COLUMNS; i++){
      if(!MONSTER_ABILITY_IDS.includes(monsterState.slotMachineFaces[i])){
        monsterState.slotMachineFaces[i] = randomMonsterAbility();
      }
    }
    const interval = Math.max(0.1, Number(monsterState.castInterval) || 1);
    const participants = collectMonsterParticipants(monsterState);
    monsterState.lastTargetCount = participants.length;
    const engaged = participants.length > 0;
    monsterState.engaged = engaged;
    if(!engaged){
      monsterState.castTimer = Math.max(interval, Number(monsterState.castTimer) || interval);
      monsterState.pendingAbility = null;
      monsterState.slotMachineActive = false;
      monsterState.slotMachineSpinTimer = 0;
      monsterState.slotMachineRevealTimer = 0;
      monsterState.slotMachineFaceTimer = 0;
      monsterState.slotMachineImpactReady = false;
      updateMonsterAbilityQueueDisplay();
      return;
    }

    const shouldSpinFaces = monsterState.slotMachineActive === true;
    const refreshInterval = monsterState.slotMachineActive ? MONSTER_SLOT_MACHINE_SPIN_REFRESH : MONSTER_SLOT_MACHINE_IDLE_REFRESH;
    if(shouldSpinFaces){
      monsterState.slotMachineFaceTimer = Math.max(0, (Number(monsterState.slotMachineFaceTimer) || 0) - dt);
      if(monsterState.slotMachineFaceTimer <= 0){
        monsterState.slotMachineFaceTimer += refreshInterval;
        for(let i = 0; i < MONSTER_SLOT_MACHINE_COLUMNS; i++){
          monsterState.slotMachineFaces[i] = randomMonsterAbility();
        }
      }
    }

    if(monsterState.pendingAbility && !monsterState.slotMachineActive){
      setMonsterSlotFaces(monsterState, monsterState.pendingAbility);
    }

    monsterState.castTimer = Math.max(0, (Number(monsterState.castTimer) || interval) - dt);

    if(monsterState.pendingAbility){
      if(monsterState.slotMachineActive){
        monsterState.slotMachineImpactReady = false;
        const configuredSpin = Math.max(0, Number(monsterState.slotMachineSpinDuration) || 0);
        const activeSpinTimer = Number(monsterState.slotMachineSpinTimer);
        const currentSpinTimer = Number.isFinite(activeSpinTimer) ? activeSpinTimer : configuredSpin;
        monsterState.slotMachineSpinTimer = Math.max(0, currentSpinTimer - dt);
        if(monsterState.slotMachineSpinTimer <= 0){
          monsterState.slotMachineActive = false;
          monsterState.slotMachineSpinTimer = 0;
          const revealDuration = Math.max(0, Number(monsterState.slotMachineRevealDuration) || 0);
          const pendingAbility = monsterState.pendingAbility;
          if(pendingAbility){
            setMonsterSlotFaces(monsterState, pendingAbility);
          }
          if(revealDuration <= 0){
            finalizeMonsterPendingCast(monsterState);
          } else {
            monsterState.slotMachineRevealTimer = revealDuration;
            monsterState.slotMachineImpactReady = false;
          }
        }
      } else {
        const previousReveal = Math.max(0, Number(monsterState.slotMachineRevealTimer) || 0);
        const nextReveal = Math.max(0, previousReveal - dt);
        const reachedImpact = previousReveal > 0 && nextReveal <= 0;
        monsterState.slotMachineRevealTimer = nextReveal;
        if(monsterState.pendingAbility){
          setMonsterSlotFaces(monsterState, monsterState.pendingAbility);
        }
        if(reachedImpact){
          monsterState.slotMachineImpactReady = true;
          finalizeMonsterPendingCast(monsterState);
        } else if(nextReveal > 0){
          monsterState.slotMachineImpactReady = false;
        }
      }
    }

    if(!monsterState.pendingAbility && monsterState.castTimer <= 0){
      const abilityId = monsterState.abilityQueue.shift() || randomMonsterAbility();
      monsterState.pendingAbility = abilityId;
      const configuredSpin = Math.max(0, Number(monsterState.slotMachineSpinDuration) || 0);
      monsterState.slotMachineActive = true;
      monsterState.slotMachineSpinTimer = configuredSpin;
      monsterState.slotMachineRevealTimer = 0;
      monsterState.slotMachineFaceTimer = 0;
      monsterState.slotMachineImpactReady = false;
      monsterState.castTimer += interval;
      ensureMonsterQueue(monsterState);
    }
    updateMonsterAbilityQueueDisplay();
  }

  function updatePlayerStatusIcons(){
    if(!playerStateIcons){
      return;
    }
    if(!playerFloatState.statuses || typeof playerFloatState.statuses !== 'object'){
      playerFloatState.statuses = buildDefaultPlayerStatusConfig();
    }
    const activeStates = new Set();
    for(const def of PLAYER_STATUS_DEFS){
      let timerValue = Math.max(0, Number(player[def.timerKey]) || 0);
      if(def.id === 'slowed' && !(Number(player.slowPct) > 0)){
        timerValue = 0;
      }
      if(!(timerValue > 0)){ continue; }
      const entry = playerFloatState.statuses[def.id] || (playerFloatState.statuses[def.id] = { emoji: def.defaultEmoji, color: def.defaultColor });
      const emoji = entry.emoji && typeof entry.emoji === 'string' && entry.emoji.trim() ? entry.emoji.trim() : def.defaultEmoji;
      const color = sanitizeHexColor(entry.color, def.defaultColor);
      entry.emoji = emoji;
      entry.color = color;
      let node = playerStatusNodes.get(def.id);
      if(!node){
        node = document.createElement('div');
        node.className = 'playerStateIcon';
        node.dataset.state = def.id;
        node.title = def.label;
        const emojiSpan = document.createElement('span');
        emojiSpan.className = 'playerStateEmoji';
        const timerSpan = document.createElement('span');
        timerSpan.className = 'playerStateTimer';
        node.appendChild(emojiSpan);
        node.appendChild(timerSpan);
        playerStateIcons.appendChild(node);
        playerStatusNodes.set(def.id, node);
      } else {
        playerStateIcons.appendChild(node);
      }
      node.style.setProperty('--state-color', color);
      node.style.color = color;
      const emojiSpan = node.querySelector('.playerStateEmoji');
      if(emojiSpan && emojiSpan.textContent !== emoji){
        emojiSpan.textContent = emoji;
      }
      const timerSpan = node.querySelector('.playerStateTimer');
      if(timerSpan){
        const timerText = `${timerValue.toFixed(1)}s`;
        if(timerSpan.textContent !== timerText){
          timerSpan.textContent = timerText;
        }
      }
      activeStates.add(def.id);
    }
    for(const [stateId, node] of playerStatusNodes.entries()){
      if(!activeStates.has(stateId)){
        if(node && node.parentElement){
          node.parentElement.removeChild(node);
        }
        playerStatusNodes.delete(stateId);
      }
    }
    playerStateIcons.setAttribute('aria-hidden', activeStates.size ? 'false' : 'true');
  }

  function updatePracticeDummyStatusIcons(){
    if(!practiceDummyIcons){
      return;
    }
    if(!practiceDummy || practiceDummy.active === false || practiceDummy.respawnTimer > 0){
      for(const [, node] of practiceDummyStatusNodes.entries()){
        if(node && node.parentElement){
          node.parentElement.removeChild(node);
        }
      }
      practiceDummyStatusNodes.clear();
      practiceDummyIcons.setAttribute('aria-hidden', 'true');
      return;
    }
    if(!playerFloatState.statuses || typeof playerFloatState.statuses !== 'object'){
      playerFloatState.statuses = buildDefaultPlayerStatusConfig();
    }
    const activeStates = new Set();
    for(const def of PLAYER_STATUS_DEFS){
      let timerValue = Math.max(0, Number(practiceDummy && practiceDummy[def.timerKey]) || 0);
      if(def.id === 'slowed' && !(Number(practiceDummy && practiceDummy.slowPct) > 0)){
        timerValue = 0;
      }
      if(!(timerValue > 0)){ continue; }
      const entry = playerFloatState.statuses[def.id] || (playerFloatState.statuses[def.id] = { emoji: def.defaultEmoji, color: def.defaultColor });
      const emoji = entry.emoji && typeof entry.emoji === 'string' && entry.emoji.trim() ? entry.emoji.trim() : def.defaultEmoji;
      const color = sanitizeHexColor(entry.color, def.defaultColor);
      entry.emoji = emoji;
      entry.color = color;
      let node = practiceDummyStatusNodes.get(def.id);
      if(!node){
        node = document.createElement('div');
        node.className = 'playerStateIcon';
        node.dataset.state = def.id;
        node.title = def.label;
        const emojiSpan = document.createElement('span');
        emojiSpan.className = 'playerStateEmoji';
        const timerSpan = document.createElement('span');
        timerSpan.className = 'playerStateTimer';
        node.appendChild(emojiSpan);
        node.appendChild(timerSpan);
        practiceDummyIcons.appendChild(node);
        practiceDummyStatusNodes.set(def.id, node);
      } else {
        practiceDummyIcons.appendChild(node);
      }
      node.style.setProperty('--state-color', color);
      node.style.color = color;
      const emojiSpan = node.querySelector('.playerStateEmoji');
      if(emojiSpan && emojiSpan.textContent !== emoji){
        emojiSpan.textContent = emoji;
      }
      const timerSpan = node.querySelector('.playerStateTimer');
      if(timerSpan){
        const timerText = `${timerValue.toFixed(1)}s`;
        if(timerSpan.textContent !== timerText){
          timerSpan.textContent = timerText;
        }
      }
      activeStates.add(def.id);
    }
    for(const [stateId, node] of practiceDummyStatusNodes.entries()){
      if(!activeStates.has(stateId)){
        if(node && node.parentElement){
          node.parentElement.removeChild(node);
        }
        practiceDummyStatusNodes.delete(stateId);
      }
    }
    practiceDummyIcons.setAttribute('aria-hidden', activeStates.size ? 'false' : 'true');
  }
  function positionPlayerFloatingHud(){
    if(!playerFloatHud) return;
    const hudHalfWidth = playerFloatHud.offsetWidth / 2;
    const minEdge = Math.max(32, hudHalfWidth + 4);
    const width = mapState.width;
    const height = mapState.height;
    const left = Math.max(minEdge, Math.min(width - minEdge, player.x));
    const baseTop = player.y - player.r - playerFloatState.gap;
    const top = Math.max(28, Math.min(height - 12, baseTop));
    playerFloatHud.style.left = `${left}px`;
    playerFloatHud.style.top = `${top}px`;
  }

  function positionPracticeDummyHud(){
    if(!practiceDummyHud || !practiceDummy || practiceDummy.active === false || practiceDummy.respawnTimer > 0){
      return;
    }
    const hudHalfWidth = practiceDummyHud.offsetWidth / 2;
    const minEdge = Math.max(32, hudHalfWidth + 4);
    const width = mapState.width;
    const height = mapState.height;
    const px = Number(practiceDummy.x) || 0;
    const py = Number(practiceDummy.y) || 0;
    const left = Math.max(minEdge, Math.min(width - minEdge, px));
    const size = clampPracticeDummySize(practiceDummy.size, 120);
    const radius = size * 0.5;
    const span = Math.max(size * 2.2, size + 20);
    const gap = Number(playerFloatState.gap) || 0;
    const topBase = py - radius - span * 0.5 - gap;
    const top = Math.max(28, Math.min(height - 12, topBase));
    practiceDummyHud.style.left = `${left}px`;
    practiceDummyHud.style.top = `${top}px`;
  }

  const abilityAssignments = abilityBarState.assignments;
  const abilityHotkeys = abilityBarState.hotkeys;
  const abilitySlotStates = abilityBarState.slotStates;
  const spellCastingRuntime = {
    captureMode: null,
    activeIndicator: null,
    modifiers: {
      normal: false,
      quick: false,
      quickIndicator: false
    }
  };
  const activeBeams = GameState.effects.activeBeams;
  const beamCasts = GameState.effects.beamCasts;
  const laserConeCasts = GameState.effects.laserConeCasts;
  GameState.effects.cleaveCrushCasts = GameState.effects.cleaveCrushCasts || [];
  const cleaveCrushCasts = GameState.effects.cleaveCrushCasts;
  GameState.effects.bulletStormCasts = GameState.effects.bulletStormCasts || [];
  GameState.effects.bulletStorms = GameState.effects.bulletStorms || [];
  const bulletStormCasts = GameState.effects.bulletStormCasts;
  const bulletStorms = GameState.effects.bulletStorms;
  GameState.effects.reapingMaelstromCasts = GameState.effects.reapingMaelstromCasts || [];
  const reapingMaelstromCasts = GameState.effects.reapingMaelstromCasts;
  GameState.effects.driftingVeilCasts = GameState.effects.driftingVeilCasts || [];
  GameState.effects.driftingVeils = GameState.effects.driftingVeils || [];
  const driftingVeilCasts = GameState.effects.driftingVeilCasts;
  const driftingVeils = GameState.effects.driftingVeils;
  GameState.effects.duskwaveCasts = GameState.effects.duskwaveCasts || [];
  const duskwaveCasts = GameState.effects.duskwaveCasts;
  GameState.effects.duskwaveVolleys = GameState.effects.duskwaveVolleys || [];
  const duskwaveVolleys = GameState.effects.duskwaveVolleys;
  GameState.effects.dawnfallBarrageCasts = GameState.effects.dawnfallBarrageCasts || [];
  const dawnfallBarrageCasts = GameState.effects.dawnfallBarrageCasts;
  GameState.effects.scarecrowStormCasts = GameState.effects.scarecrowStormCasts || [];
  const scarecrowStormCasts = GameState.effects.scarecrowStormCasts;
  GameState.effects.scarecrowStormZones = GameState.effects.scarecrowStormZones || [];
  const scarecrowStormZones = GameState.effects.scarecrowStormZones;
  GameState.effects.sirensKissCasts = GameState.effects.sirensKissCasts || [];
  const sirensKissCasts = GameState.effects.sirensKissCasts;
  GameState.effects.shiverSpikeCasts = GameState.effects.shiverSpikeCasts || [];
  const shiverSpikeCasts = GameState.effects.shiverSpikeCasts;
  GameState.effects.skullRushCasts = GameState.effects.skullRushCasts || [];
  const skullRushCasts = GameState.effects.skullRushCasts;
  GameState.effects.riptideLungeCasts = GameState.effects.riptideLungeCasts || [];
  const riptideLungeCasts = GameState.effects.riptideLungeCasts;
  GameState.effects.luminousDartCasts = GameState.effects.luminousDartCasts || [];
  const luminousDartCasts = GameState.effects.luminousDartCasts;
  GameState.effects.plunderShotCasts = GameState.effects.plunderShotCasts || [];
  const plunderShotCasts = GameState.effects.plunderShotCasts;
  GameState.effects.shadowTalonCasts = GameState.effects.shadowTalonCasts || [];
  const shadowTalonCasts = GameState.effects.shadowTalonCasts;
  GameState.effects.shadowTalonRecasts = GameState.effects.shadowTalonRecasts || [];
  const shadowTalonRecasts = GameState.effects.shadowTalonRecasts;
  GameState.effects.shadowTalonMarks = GameState.effects.shadowTalonMarks || [];
  const shadowTalonMarks = GameState.effects.shadowTalonMarks;
  GameState.effects.pestilentTossCasts = GameState.effects.pestilentTossCasts || [];
  const pestilentTossCasts = GameState.effects.pestilentTossCasts;
  GameState.effects.voidTrackCasts = GameState.effects.voidTrackCasts || [];
  const voidTrackCasts = GameState.effects.voidTrackCasts;
  const grabCasts = GameState.effects.grabCasts;
  GameState.effects.backlineSeizureCasts = GameState.effects.backlineSeizureCasts || [];
  const backlineSeizureCasts = GameState.effects.backlineSeizureCasts;
  const boneSkewerCasts = GameState.effects.boneSkewerCasts;
  GameState.effects.astralSnareCasts = GameState.effects.astralSnareCasts || [];
  const astralSnareCasts = GameState.effects.astralSnareCasts;
  const piercingArrowCasts = GameState.effects.piercingArrowCasts;
  GameState.effects.focusedLockshotCasts = GameState.effects.focusedLockshotCasts || [];
  const focusedLockshotCasts = GameState.effects.focusedLockshotCasts;
  GameState.effects.focusedLockshotProjectiles = GameState.effects.focusedLockshotProjectiles || [];
  const focusedLockshotProjectiles = GameState.effects.focusedLockshotProjectiles;
  const plasmaFissionCasts = GameState.effects.plasmaFissionCasts;
  const skyScoutFlights = GameState.effects.skyScoutFlights;
  const skyScoutVisionSources = GameState.effects.skyScoutVisionSources;
  GameState.effects.spinningAxesInHand = GameState.effects.spinningAxesInHand || [];
  const spinningAxesInHand = GameState.effects.spinningAxesInHand;
  GameState.effects.spinningAxeFlights = GameState.effects.spinningAxeFlights || [];
  const spinningAxeFlights = GameState.effects.spinningAxeFlights;
  GameState.effects.spinningAxeMarkers = GameState.effects.spinningAxeMarkers || [];
  const spinningAxeMarkers = GameState.effects.spinningAxeMarkers;
  GameState.effects.scoutflareBombCasts = GameState.effects.scoutflareBombCasts || [];
  const scoutflareBombCasts = GameState.effects.scoutflareBombCasts;
  GameState.effects.scoutflareProjectiles = GameState.effects.scoutflareProjectiles || [];
  const scoutflareProjectiles = GameState.effects.scoutflareProjectiles;
  GameState.effects.scoutflareVisionSources = GameState.effects.scoutflareVisionSources || [];
  const scoutflareVisionSources = GameState.effects.scoutflareVisionSources;
  GameState.effects.scoutflareRevealRecords = GameState.effects.scoutflareRevealRecords || [];
  const scoutflareRevealRecords = GameState.effects.scoutflareRevealRecords;
  const skyScoutChargeState = GameState.effects.skyScoutState || (GameState.effects.skyScoutState = { charges: 2, maxCharges: 2, rechargeTimer: 0 });
  GameState.effects.trapVisionSources = GameState.effects.trapVisionSources || [];
  const trapVisionSources = GameState.effects.trapVisionSources;
  GameState.effects.temporalVeilCasts = GameState.effects.temporalVeilCasts || [];
  const temporalVeilCasts = GameState.effects.temporalVeilCasts;
  GameState.effects.temporalVeilVisionSources = GameState.effects.temporalVeilVisionSources || [];
  const temporalVeilVisionSources = GameState.effects.temporalVeilVisionSources;
  GameState.effects.moonlitArcCasts = GameState.effects.moonlitArcCasts || [];
  const moonlitArcCasts = GameState.effects.moonlitArcCasts;
  GameState.effects.slingshotCrashCasts = GameState.effects.slingshotCrashCasts || [];
  GameState.effects.slingshotCrashLeaps = GameState.effects.slingshotCrashLeaps || [];
  GameState.effects.springquakeCasts = GameState.effects.springquakeCasts || [];
  const chargingGaleCasts = GameState.effects.chargingGaleCasts;
  GameState.effects.snowballRollCasts = GameState.effects.snowballRollCasts || [];
  const snowballRollCasts = GameState.effects.snowballRollCasts;
  GameState.effects.snowballRollProjectiles = GameState.effects.snowballRollProjectiles || [];
  const snowballRollProjectiles = GameState.effects.snowballRollProjectiles;
  const slingshotCrashCasts = GameState.effects.slingshotCrashCasts;
  const slingshotCrashLeaps = GameState.effects.slingshotCrashLeaps;
  const springquakeCasts = GameState.effects.springquakeCasts;
  const cullingBarrageChannels = GameState.effects.cullingBarrageChannels;
  const cullingBarrageProjectiles = GameState.effects.cullingBarrageProjectiles;
  GameState.effects.verdictSalvoCasts = GameState.effects.verdictSalvoCasts || [];
  GameState.effects.verdictSalvoProjectiles = GameState.effects.verdictSalvoProjectiles || [];
  const verdictSalvoCasts = GameState.effects.verdictSalvoCasts;
  const verdictSalvoProjectiles = GameState.effects.verdictSalvoProjectiles;
  const arcaneRiteModes = GameState.effects.arcaneRiteModes;
  const arcaneRiteExplosions = GameState.effects.arcaneRiteExplosions;
  GameState.effects.horizonRocketCasts = GameState.effects.horizonRocketCasts || [];
  const horizonRocketCasts = GameState.effects.horizonRocketCasts;
  GameState.effects.celestialCrashCasts = GameState.effects.celestialCrashCasts || [];
  const celestialCrashCasts = GameState.effects.celestialCrashCasts;
  GameState.effects.celestialShockwaves = GameState.effects.celestialShockwaves || [];
  const celestialShockwaves = GameState.effects.celestialShockwaves;
  GameState.effects.celestialStardust = GameState.effects.celestialStardust || { points: 0, ready: false };
  const celestialStardust = GameState.effects.celestialStardust;
  GameState.effects.convergingGaleCasts = GameState.effects.convergingGaleCasts || [];
  GameState.effects.convergingGaleBlasts = GameState.effects.convergingGaleBlasts || [];
  GameState.effects.convergingGaleTornadoes = GameState.effects.convergingGaleTornadoes || [];
  const convergingGaleCasts = GameState.effects.convergingGaleCasts;
  const convergingGaleBlasts = GameState.effects.convergingGaleBlasts;
  const convergingGaleTornadoes = GameState.effects.convergingGaleTornadoes;
  GameState.effects.dirgeBloomCasts = GameState.effects.dirgeBloomCasts || [];
  const dirgeBloomCasts = GameState.effects.dirgeBloomCasts;
  GameState.effects.eventHorizonCasts = GameState.effects.eventHorizonCasts || [];
  GameState.effects.eventHorizons = GameState.effects.eventHorizons || [];
  const eventHorizonCasts = GameState.effects.eventHorizonCasts;
  const eventHorizons = GameState.effects.eventHorizons;
  GameState.effects.quiverstormBuffs = GameState.effects.quiverstormBuffs || [];
  GameState.effects.frenziedSurgeAttackBuffs = GameState.effects.frenziedSurgeAttackBuffs || [];
  GameState.effects.frenziedSurgeMoveBuffs = GameState.effects.frenziedSurgeMoveBuffs || [];
  GameState.effects.royalOnslaughtBuffs = GameState.effects.royalOnslaughtBuffs || [];
  GameState.effects.phantomOverdriveCasts = GameState.effects.phantomOverdriveCasts || [];
  GameState.effects.phantomOverdriveAttackBuffs = GameState.effects.phantomOverdriveAttackBuffs || [];
  GameState.effects.phantomOverdriveMoveBuffs = GameState.effects.phantomOverdriveMoveBuffs || [];
  const quiverstormBuffs = GameState.effects.quiverstormBuffs;
  const frenziedSurgeAttackBuffs = GameState.effects.frenziedSurgeAttackBuffs;
  const frenziedSurgeMoveBuffs = GameState.effects.frenziedSurgeMoveBuffs;
  const royalOnslaughtBuffs = GameState.effects.royalOnslaughtBuffs;
  const phantomOverdriveCasts = GameState.effects.phantomOverdriveCasts;
  const phantomOverdriveAttackBuffs = GameState.effects.phantomOverdriveAttackBuffs;
  const phantomOverdriveMoveBuffs = GameState.effects.phantomOverdriveMoveBuffs;
  GameState.effects.hailboundTempestCasts = GameState.effects.hailboundTempestCasts || [];
  GameState.effects.hailboundTempests = GameState.effects.hailboundTempests || [];
  const hailboundTempestCasts = GameState.effects.hailboundTempestCasts;
  const hailboundTempests = GameState.effects.hailboundTempests;
  GameState.effects.reboundOrbCasts = GameState.effects.reboundOrbCasts || [];
  const reboundOrbCasts = GameState.effects.reboundOrbCasts;
  const piercingArrowProjectiles = GameState.effects.piercingArrowProjectiles;
  const plasmaFissionProjectiles = GameState.effects.plasmaFissionProjectiles;
  GameState.effects.expandingShotCasts = GameState.effects.expandingShotCasts || [];
  GameState.effects.expandingShotProjectiles = GameState.effects.expandingShotProjectiles || [];
  const expandingShotCasts = GameState.effects.expandingShotCasts;
  const expandingShotProjectiles = GameState.effects.expandingShotProjectiles;
  GameState.effects.reboundOrbProjectiles = GameState.effects.reboundOrbProjectiles || [];
  const reboundOrbProjectiles = GameState.effects.reboundOrbProjectiles;
  GameState.effects.cycloneCasts = GameState.effects.cycloneCasts || [];
  GameState.effects.cycloneAxes = GameState.effects.cycloneAxes || [];
  const cycloneCasts = GameState.effects.cycloneCasts;
  const cycloneAxes = GameState.effects.cycloneAxes;
  GameState.effects.orbitChakramCasts = GameState.effects.orbitChakramCasts || [];
  GameState.effects.orbitChakrams = GameState.effects.orbitChakrams || [];
  GameState.effects.orbitSentryCasts = GameState.effects.orbitSentryCasts || [];
  GameState.effects.orbitSentries = GameState.effects.orbitSentries || [];
  GameState.effects.orbitStackState = GameState.effects.orbitStackState || { count: 0, remaining: 0, max: 20, lastDuration: 0, lastAnnounce: 0 };
  const orbitChakramCasts = GameState.effects.orbitChakramCasts;
  const orbitChakrams = GameState.effects.orbitChakrams;
  const orbitSentryCasts = GameState.effects.orbitSentryCasts;
  const orbitSentries = GameState.effects.orbitSentries;
  const orbitStackState = GameState.effects.orbitStackState;
  GameState.effects.shatterburstOrbCasts = GameState.effects.shatterburstOrbCasts || [];
  const shatterburstOrbCasts = GameState.effects.shatterburstOrbCasts;
  GameState.effects.shatterburstOrbProjectiles = GameState.effects.shatterburstOrbProjectiles || [];
  const shatterburstOrbProjectiles = GameState.effects.shatterburstOrbProjectiles;
  GameState.effects.ricochetBombCasts = GameState.effects.ricochetBombCasts || [];
  GameState.effects.ricochetBombProjectiles = GameState.effects.ricochetBombProjectiles || [];
  const ricochetBombCasts = GameState.effects.ricochetBombCasts;
  const ricochetBombProjectiles = GameState.effects.ricochetBombProjectiles;
  const scatterChargeCasts = GameState.effects.scatterChargeCasts || (GameState.effects.scatterChargeCasts = []);
  const scatterCharges = GameState.effects.scatterCharges || (GameState.effects.scatterCharges = []);
  GameState.effects.skyhookSwingCasts = GameState.effects.skyhookSwingCasts || [];
  const skyhookSwingCasts = GameState.effects.skyhookSwingCasts;
  GameState.effects.flipbladeCasts = GameState.effects.flipbladeCasts || [];
  GameState.effects.flipbladeProjectiles = GameState.effects.flipbladeProjectiles || [];
  GameState.effects.flipbladeMarks = GameState.effects.flipbladeMarks || [];
  GameState.effects.flipbladeDashes = GameState.effects.flipbladeDashes || [];
  const flipbladeCasts = GameState.effects.flipbladeCasts;
  const flipbladeProjectiles = GameState.effects.flipbladeProjectiles;
  const flipbladeMarks = GameState.effects.flipbladeMarks;
  const flipbladeDashes = GameState.effects.flipbladeDashes;
  GameState.effects.emberWaltzCasts = GameState.effects.emberWaltzCasts || [];
  GameState.effects.emberWaltzFlames = GameState.effects.emberWaltzFlames || [];
  const emberWaltzCasts = GameState.effects.emberWaltzCasts;
  const emberWaltzFlames = GameState.effects.emberWaltzFlames;
  GameState.effects.trailblazeDashes = GameState.effects.trailblazeDashes || [];
  GameState.effects.trailblazePatches = GameState.effects.trailblazePatches || [];
  const trailblazeDashes = GameState.effects.trailblazeDashes;
  const trailblazePatches = GameState.effects.trailblazePatches;
  GameState.effects.sandRushDashes = GameState.effects.sandRushDashes || [];
  const sandRushDashes = GameState.effects.sandRushDashes;
  GameState.effects.shadowPursuitCasts = GameState.effects.shadowPursuitCasts || [];
  const shadowPursuitCasts = GameState.effects.shadowPursuitCasts;
  GameState.effects.linkLashCasts = GameState.effects.linkLashCasts || [];
  GameState.effects.linkLashTethers = GameState.effects.linkLashTethers || [];
  const linkLashCasts = GameState.effects.linkLashCasts;
  const linkLashTethers = GameState.effects.linkLashTethers;
  const flameChomperTraps = GameState.effects.flameChomperTraps;
  GameState.effects.mourningMarchCasts = GameState.effects.mourningMarchCasts || [];
  const mourningMarchCasts = GameState.effects.mourningMarchCasts;
  GameState.effects.emberGuardianCasts = GameState.effects.emberGuardianCasts || [];
  const emberGuardianCasts = GameState.effects.emberGuardianCasts;
  GameState.effects.spectralStockadeCasts = GameState.effects.spectralStockadeCasts || [];
  GameState.effects.spectralStockades = GameState.effects.spectralStockades || [];
  const spectralStockadeCasts = GameState.effects.spectralStockadeCasts;
  const spectralStockades = GameState.effects.spectralStockades;
  GameState.effects.glacialUpliftCasts = GameState.effects.glacialUpliftCasts || [];
  GameState.effects.glacialUpliftWalls = GameState.effects.glacialUpliftWalls || [];
  const glacialUpliftCasts = GameState.effects.glacialUpliftCasts;
  const glacialUpliftWalls = GameState.effects.glacialUpliftWalls;
  GameState.effects.boltburstRushCasts = GameState.effects.boltburstRushCasts || [];
  const boltburstRushCasts = GameState.effects.boltburstRushCasts;
  GameState.effects.chronoLoopGrenades = GameState.effects.chronoLoopGrenades || (GameState.effects.chronoLoopGrenades = []);
  const chronoLoopGrenades = GameState.effects.chronoLoopGrenades;
  const snapbackEchoes = GameState.effects.snapbackEchoes || (GameState.effects.snapbackEchoes = []);
  GameState.effects.twinstrikeCasts = GameState.effects.twinstrikeCasts || [];
  GameState.effects.twinstrikeTrails = GameState.effects.twinstrikeTrails || [];
  const twinstrikeCasts = GameState.effects.twinstrikeCasts;
  const twinstrikeTrails = GameState.effects.twinstrikeTrails;
  GameState.effects.stormwingSequences = GameState.effects.stormwingSequences || [];
  const stormwingSequences = GameState.effects.stormwingSequences;
  GameState.effects.bulwarkCrashCasts = GameState.effects.bulwarkCrashCasts || [];
  const bulwarkCrashCasts = GameState.effects.bulwarkCrashCasts;
  GameState.effects.playerShields = GameState.effects.playerShields || [];
  const playerShields = GameState.effects.playerShields;
  GameState.effects.skyfireVolleyCasts = GameState.effects.skyfireVolleyCasts || [];
  GameState.effects.skyfireVolleyProjectiles = GameState.effects.skyfireVolleyProjectiles || [];
  GameState.effects.cascadeBarrageMissiles = GameState.effects.cascadeBarrageMissiles || [];
  GameState.effects.strideSurgeAttackBuffs = GameState.effects.strideSurgeAttackBuffs || [];
  GameState.effects.strideSurgeMoveBuffs = GameState.effects.strideSurgeMoveBuffs || [];
  GameState.effects.tranquilTorrentCasts = GameState.effects.tranquilTorrentCasts || [];
  GameState.effects.serenityFields = GameState.effects.serenityFields || [];
  GameState.effects.phantomBarrageCasts = GameState.effects.phantomBarrageCasts || [];
  const skyfireVolleyCasts = GameState.effects.skyfireVolleyCasts;
  const skyfireVolleyProjectiles = GameState.effects.skyfireVolleyProjectiles;
  const cascadeBarrageMissiles = GameState.effects.cascadeBarrageMissiles;
  const strideSurgeAttackBuffs = GameState.effects.strideSurgeAttackBuffs;
  const strideSurgeMoveBuffs = GameState.effects.strideSurgeMoveBuffs;
  const tranquilTorrentCasts = GameState.effects.tranquilTorrentCasts;
  const serenityFields = GameState.effects.serenityFields;
  const phantomBarrageCasts = GameState.effects.phantomBarrageCasts;
  GameState.effects.infernoBarrageCasts = GameState.effects.infernoBarrageCasts || [];
  const infernoBarrageCasts = GameState.effects.infernoBarrageCasts;
  GameState.effects.wildRushState = GameState.effects.wildRushState || {};
  GameState.effects.spiralRamRoll = GameState.effects.spiralRamRoll || null;
  const wildRushState = GameState.effects.wildRushState;
  GameState.effects.venomBloomCasts = GameState.effects.venomBloomCasts || [];
  GameState.effects.venomClouds = GameState.effects.venomClouds || [];
  GameState.effects.miasmaFieldCasts = GameState.effects.miasmaFieldCasts || [];
  GameState.effects.miasmaClouds = GameState.effects.miasmaClouds || [];
  GameState.effects.fangStrikeCasts = GameState.effects.fangStrikeCasts || [];
  GameState.effects.stoneGazeCasts = GameState.effects.stoneGazeCasts || [];
  GameState.effects.stoneGazeEffects = GameState.effects.stoneGazeEffects || [];
  const venomBloomCasts = GameState.effects.venomBloomCasts;
  const venomClouds = GameState.effects.venomClouds;
  const miasmaFieldCasts = GameState.effects.miasmaFieldCasts;
  const miasmaClouds = GameState.effects.miasmaClouds;
  const fangStrikeCasts = GameState.effects.fangStrikeCasts;
  const stoneGazeCasts = GameState.effects.stoneGazeCasts;
  const stoneGazeEffects = GameState.effects.stoneGazeEffects;
  wildRushState.ready = Boolean(wildRushState.ready);
  wildRushState.expiresAt = Math.max(0, Number(wildRushState.expiresAt) || 0);
  let frenziedSurgeMoveMultiplier = 1;
  let strideSurgeMoveMultiplier = 1;
  let phantomOverdriveMoveMultiplier = 1;
  let phantomOverdriveProjectileSpeedMultiplier = 1;
  let spiralRamMoveMultiplier = 1;
  const BEAM_SLOW_DURATION = 2.5;
  const DISALLOWED_HOTKEY_KEYS = new Set(['Shift','Control','Alt','Meta','CapsLock','Tab']);
  const SPELL_SCALE_MIN = 0;
  const SPELL_SCALE_MAX = 10;
  GameState.items.abilityDefinitions = GameState.items.abilityDefinitions || {};
  const abilityDefinitions = GameState.items.abilityDefinitions;
  Object.assign(abilityDefinitions, {
    beam: {
      id: 'beam',
      name: 'Aether Beam',
      shortName: 'Beam',
      description: 'Channel a beam of energy that damages and slows the target.',
      fields: [
        { key: 'beamWidth', label: 'Beam width', unit: 'px', min: 0, max: 1000, step: 1, value: 12 },
        { key: 'beamLength', label: 'Beam length', unit: 'px', min: 0, max: 1000, step: 10, value: 600 },
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 8000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 5000, step: 50, value: 600 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 120 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 35 }
      ]
    },
    serpents_bloom: {
      id: 'serpents_bloom',
      name: "Serpent's Bloom",
      shortName: 'Bloom',
      description: 'Punch a delayed burst of venom at a point. It poisons enemies, and champion hits grant a fading move speed bonus.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 40000, step: 50, value: 3500 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 400 },
        { key: 'targetRangePx', label: 'Target range', unit: 'px', min: 0, max: 2000, step: 5, value: 850, scale: 'size' },
        { key: 'radiusPx', label: 'Blast radius', unit: 'px', min: 0, max: 400, step: 5, value: 200, scale: 'size' },
        { key: 'damage', label: 'Total damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 180 },
        { key: 'cloudDurationMs', label: 'Cloud duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 3000 },
        { key: 'tickIntervalMs', label: 'Tick interval', unit: 'ms', min: 0, max: 1000, step: 1, value: 429 },
        { key: 'poisonDurationMs', label: 'Poison duration', unit: 'ms', min: 0, max: 5000, step: 50, value: 3000 },
        { key: 'bonusMoveSpeedPct', label: 'Champion move speed', unit: '%', min: 0, max: 100, step: 1, value: 40 },
        { key: 'bonusMoveDurationMs', label: 'Boost duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 3000 }
      ]
    },
    stone_gaze: {
      id: 'stone_gaze',
      name: 'Stone Gaze',
      shortName: 'Gaze',
      description: 'Fix your sight in a cone and slow every foe; those already facing you are stunned instead.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 200000, step: 50, value: 100000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 500 },
        { key: 'targetRangePx', label: 'Range', unit: 'px', min: 0, max: 2000, step: 5, value: 850, scale: 'size' },
        { key: 'coneWidthPx', label: 'Cone width', unit: 'px', min: 0, max: 1500, step: 5, value: 640, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 180 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 40 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 2000 },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 2000 }
      ]
    },
    reveal_shock: {
      id: 'reveal_shock',
      name: 'Revealing Shock',
      shortName: 'Shock',
      description: 'Hurl a lightning bolt that sprays vision on impact and slows the first enemy it touches.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 8000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 500 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 4000, step: 5, value: 1500, scale: 'size' },
        { key: 'projectileSpeedPxS', label: 'Bolt speed', unit: 'px/s', min: 0, max: 6000, step: 10, value: 3300, scale: 'speed' },
        { key: 'projectileWidthPx', label: 'Width', unit: 'px', min: 0, max: 400, step: 5, value: 120, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 800, step: 5, value: 220 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 40 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 5000, step: 50, value: 2000 },
        { key: 'revealRadiusPx', label: 'Reveal radius', unit: 'px', min: 0, max: 800, step: 5, value: 220, scale: 'size' },
        { key: 'revealDurationMs', label: 'Reveal duration', unit: 'ms', min: 0, max: 10000, step: 50, value: 2000 }
      ]
    },
    striding_surge: {
      id: 'striding_surge',
      name: 'Striding Surge',
      shortName: 'Stride',
      description: 'Explode into the fight with renewed speed and tempo, boosting both movement and attack cadence.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 40000, step: 50, value: 12000 },
        { key: 'durationMs', label: 'Duration', unit: 'ms', min: 0, max: 10000, step: 50, value: 4000 },
        { key: 'attackSpeedPct', label: 'Attack speed', unit: '%', min: 0, max: 150, step: 5, value: 40 },
        { key: 'moveSpeedPct', label: 'Movement speed', unit: '%', min: 0, max: 150, step: 5, value: 35 }
      ]
    },
    phantom_barrage: {
      id: 'phantom_barrage',
      name: 'Phantom Barrage',
      shortName: 'Barrage',
      description: 'Channel a cascade of waves that spray multiple projectiles in front of you for a short time.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 240000, step: 50, value: 120000 },
        { key: 'channelDurationMs', label: 'Channel duration', unit: 'ms', min: 0, max: 5000, step: 50, value: 3000 },
        { key: 'waveIntervalMs', label: 'Wave interval', unit: 'ms', min: 50, max: 1000, step: 10, value: 200 },
        { key: 'waveCount', label: 'Waves', unit: '', min: 1, max: 40, step: 1, value: 14 },
        { key: 'projectilesPerWave', label: 'Projectiles per wave', unit: '', min: 1, max: 12, step: 1, value: 6 },
        { key: 'spreadDeg', label: 'Spread angle', unit: 'deg', min: 0, max: 180, step: 5, value: 30 },
        { key: 'projectileRangePx', label: 'Projectile range', unit: 'px', min: 0, max: 2500, step: 5, value: 1450 },
        { key: 'projectileSpeedPxS', label: 'Projectile speed', unit: 'px/s', min: 0, max: 5000, step: 10, value: 2000, scale: 'speed' },
        { key: 'projectileWidthPx', label: 'Projectile width', unit: 'px', min: 0, max: 200, step: 1, value: 40 },
        { key: 'damage', label: 'Damage per projectile', unit: ' dmg', min: 0, max: 400, step: 5, value: 90 }
      ]
    },
    grab: {
      id: 'grab',
      name: 'Grasp of Nol-Tar',
      shortName: 'Grab',
      description: 'Launch a spectral hand that seizes the first enemy hit, stunning and pulling them toward you.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 16000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'grabRange', label: 'Range', unit: 'px', min: 0, max: 1000, step: 5, value: 1000 },
        { key: 'grabWidthCenter', label: 'Width (center)', unit: 'px', min: 0, max: 1000, step: 5, value: 60 },
        { key: 'grabWidthEdge', label: 'Width (edge)', unit: 'px', min: 0, max: 1000, step: 5, value: 140 },
        { key: 'grabSpeed', label: 'Projectile speed', unit: 'px/s', min: 0, max: 1000, step: 10, value: 900 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 350 },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 2000, step: 10, value: 650 },
        { key: 'pullDistance', label: 'Pull distance', unit: 'px', min: 0, max: 1000, step: 5, value: 75 },
        { key: 'postHitLockoutMs', label: 'Post-hit lockout', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 }
      ]
    },
    wrapdash: {
      id: 'wrapdash',
      name: 'Wrapdash',
      shortName: 'Wrapdash',
      description: 'Hurl a binding wrap that stuns the first enemy hit and slings you to them.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 14000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'grabRange', label: 'Range', unit: 'px', min: 0, max: 1300, step: 5, value: 1100 },
        { key: 'grabWidthCenter', label: 'Width (center)', unit: 'px', min: 0, max: 1000, step: 5, value: 80 },
        { key: 'grabWidthEdge', label: 'Width (edge)', unit: 'px', min: 0, max: 1000, step: 5, value: 160 },
        { key: 'grabSpeed', label: 'Projectile speed', unit: 'px/s', min: 0, max: 3000, step: 10, value: 1900, scale: 'speed' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 170 },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 3000, step: 10, value: 1000 },
        { key: 'dashSpeedPxS', label: 'Dash speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2400, scale: 'speed' },
        { key: 'postHitLockoutMs', label: 'Post-hit lockout', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 }
      ]
    },
    backline_seizure: {
      id: 'backline_seizure',
      name: 'Backline Abduction',
      shortName: 'Abduction',
      description: 'Blink behind the farthest enemy caught in your strike line, hoist them, then slam them down for damage and a stun.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 200000, step: 50, value: 115000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 5000, step: 25, value: 550 },
        { key: 'strikeRangePx', label: 'Strike range', unit: 'px', min: 0, max: 2000, step: 5, value: 1250, scale: 'size' },
        { key: 'strikeWidthPx', label: 'Strike width', unit: 'px', min: 0, max: 400, step: 1, value: 65, scale: 'size' },
        { key: 'suppressDurationMs', label: 'Lift duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 750 },
        { key: 'slamStunMs', label: 'Slam stun', unit: 'ms', min: 0, max: 3000, step: 25, value: 400 },
        { key: 'damage', label: 'Slam damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 250 },
        { key: 'blinkOvershootPx', label: 'Behind offset', unit: 'px', min: 0, max: 400, step: 1, value: 60, scale: 'size' },
        { key: 'postLockoutMs', label: 'Post-lockout', unit: 'ms', min: 0, max: 2000, step: 10, value: 100 }
      ]
    },
    link_lash: {
      id: 'link_lash',
      name: 'Link Lash',
      shortName: 'Link Lash',
      description: 'Stretch a binding lash that slows and tethers the first enemy hit, empowering your next strike to slam foes together.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 14000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'lashRange', label: 'Range', unit: 'px', min: 0, max: 1200, step: 5, value: 900 },
        { key: 'lashWidthStart', label: 'Width (start)', unit: 'px', min: 0, max: 500, step: 5, value: 70 },
        { key: 'lashWidthEnd', label: 'Width (end)', unit: 'px', min: 0, max: 500, step: 5, value: 140 },
        { key: 'lashSpeed', label: 'Projectile speed', unit: 'px/s', min: 0, max: 2400, step: 10, value: 1200, scale: 'speed' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 120 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 40 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 500 },
        { key: 'tetherDurationMs', label: 'Tether duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 2000 },
        { key: 'followupRangeBonus', label: 'Bonus range for follow-up', unit: 'px', min: 0, max: 300, step: 1, value: 25, scale: 'size' },
        { key: 'followupWindupMs', label: 'Follow-up windup', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 },
        { key: 'impactDelayMs', label: 'Impact delay', unit: 'ms', min: 0, max: 2000, step: 10, value: 400 },
        { key: 'displacementDistance', label: 'Pull distance', unit: 'px', min: 0, max: 1000, step: 5, value: 300, scale: 'size' },
        { key: 'slamRadiusPx', label: 'Slam radius', unit: 'px', min: 0, max: 800, step: 5, value: 200, scale: 'size' },
        { key: 'rootDurationMs', label: 'Root duration', unit: 'ms', min: 0, max: 3000, step: 25, value: 500 },
        { key: 'slamStunMs', label: 'Slam stun', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 }
      ]
    },
    bone_skewer: {
      id: 'bone_skewer',
      name: 'Bone Skewer',
      shortName: 'Bone Skewer',
      description: 'Charge to hurl a harpoon that pulls the first enemy hit, or tap quickly to thrust in front of you.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs',           label: 'Cooldown',             unit: 'ms',   min: 0,    max: 60000, step: 50,  value: 10000 },
        { key: 'castTimeMs',           label: 'Cast time',            unit: 'ms',   min: 0,    max: 2000,  step: 25,  value: 250 },
        { key: 'chargeMaxMs',          label: 'Max channel time',     unit: 'ms',   min: 0,    max: 4000,  step: 25,  value: 3000 },
        { key: 'rangeChargeTimeMs',    label: 'Time to max range',    unit: 'ms',   min: 0,    max: 2000,  step: 25,  value: 1000 },
        { key: 'quickReleaseMs',       label: 'Quick release window', unit: 'ms',   min: 0,    max: 1000,  step: 25,  value: 400 },
        { key: 'rangeMinPx',           label: 'Min harpoon range',    unit: 'px',   min: 0,    max: 1500,  step: 5,   value: 400 },
        { key: 'rangeMaxPx',           label: 'Max harpoon range',    unit: 'px',   min: 0,    max: 1500,  step: 5,   value: 1100 },
        { key: 'projectileSpeedPxPerMs', label: 'Harpoon speed',      unit: 'px/s', min: 0,    max: 2000,  step: 10,  value: 1300, scale: 'speed' },
        { key: 'widthStartPx',         label: 'Harpoon width (start)',unit: 'px',   min: 0,    max: 600,   step: 5,   value: 140 },
        { key: 'widthEndPx',           label: 'Harpoon width (end)',  unit: 'px',   min: 0,    max: 600,   step: 5,   value: 200 },
        { key: 'pullDistance',         label: 'Pull distance',        unit: 'px',   min: 0,    max: 800,   step: 5,   value: 240 },
        { key: 'damage',               label: 'Damage',               unit: ' dmg', min: 0,    max: 1000,  step: 5,   value: 180 },
        { key: 'slowPct',              label: 'Slow on hit',          unit: '%',    min: 0,    max: 100,   step: 1,   value: 90 },
        { key: 'slowDurationMs',       label: 'Slow duration',        unit: 'ms',   min: 0,    max: 5000,  step: 50,  value: 1000 },
        { key: 'selfSlowPct',          label: 'Self slow while channeling', unit: '%', min: 0, max: 100,   step: 1,   value: 20 },
        { key: 'postHitLockoutMs',     label: 'Post-hit lockout',     unit: 'ms',   min: 0,    max: 2000,  step: 10,  value: 400 },
        { key: 'thrustRangePx',        label: 'Thrust range',         unit: 'px',   min: 0,    max: 1000,  step: 5,   value: 550 },
        { key: 'thrustWidthPx',        label: 'Thrust width',         unit: 'px',   min: 0,    max: 600,   step: 5,   value: 180 }
      ]
    },
    kunai_fanburst: {
      id: 'kunai_fanburst',
      name: 'Kunai Fanburst',
      shortName: 'Fanburst',
      description: 'Flick five kunai in a tight fan. Hits near the edge briefly slow.',
      fields: [
        { key: 'laserSpeed', label: 'Kunai speed', unit: 'px/s', min: 0, max: 2500, step: 10, value: 1900, scale: 'speed' },
        { key: 'laserWidth', label: 'Fan width', unit: 'px', min: 0, max: 1000, step: 5, value: 350 },
        { key: 'laserProjectileWidth', label: 'Kunai width', unit: 'px', min: 0, max: 200, step: 1, value: 18 },
        { key: 'laserDistance', label: 'Fan distance', unit: 'px', min: 0, max: 1200, step: 5, value: 500 },
        { key: 'laserCount', label: 'Kunai count', unit: '', min: 0, max: 10, step: 1, value: 5 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 120 },
        { key: 'slowPct', label: 'Outer slow', unit: '%', min: 0, max: 100, step: 1, value: 50 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 500 },
        { key: 'slowMinRangePx', label: 'Slow triggers past', unit: 'px', min: 0, max: 1000, step: 5, value: 120, scale: 'size' },
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 25, value: 1500 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 1000, step: 5, value: 250 }
      ]
    },
    laserCone: {
      id: 'laserCone',
      name: 'Laser Cone',
      shortName: 'Laser Cone',
      description: 'Fire a cone of piercing lasers that slow the first enemy they strike.',
      fields: [
        { key: 'laserSpeed', label: 'Laser speed', unit: 'px/s', min: 0, max: 1000, step: 10, value: 900 },
        { key: 'laserWidth', label: 'Cone width', unit: 'px', min: 0, max: 1000, step: 10, value: 350 },
        { key: 'laserProjectileWidth', label: 'Laser width', unit: 'px', min: 0, max: 1000, step: 1, value: 15 },
        { key: 'baseDamage', label: 'Base damage', unit: ' dmg', min: 1, max: 1000, step: 5, value: 100 },
        { key: 'damageScalePct', label: 'Bonus from AD', unit: '%', min: 0, max: 1000, step: 5, value: 100 },
        { key: 'laserDistance', label: 'Laser distance', unit: 'px', min: 0, max: 1000, step: 25, value: 500 },
        { key: 'laserCount', label: 'Number of lasers', unit: '', min: 0, max: 10, step: 1, value: 5 },
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 10000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 1000, step: 5, value: 25 },
        { key: 'slowPct', label: 'Slow amount', unit: '%', min: 0, max: 100, step: 1, value: 15 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 5000, step: 50, value: 2500 }
      ]
    },
    duskwave_infernum: {
      id: 'duskwave_infernum',
      name: 'Duskwave Infernum',
      shortName: 'Infernum',
      description: 'Send a duskfire wave ahead of you that locks enemies and then sprays fiery bolts at each lock.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 25, value: 14000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'coneRangePx', label: 'Wave range', unit: 'px', min: 0, max: 1600, step: 5, value: 700, scale: 'size' },
        { key: 'coneWidthPx', label: 'Wave width', unit: 'px', min: 0, max: 2000, step: 5, value: 520, scale: 'size' },
        { key: 'waveDamage', label: 'Wave damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 180 },
        { key: 'volleyDamage', label: 'Volley damage', unit: ' dmg', min: 0, max: 1200, step: 5, value: 140 },
        { key: 'secondaryPct', label: 'Secondary damage %', unit: '%', min: 0, max: 100, step: 5, value: 75 },
        { key: 'delayMs', label: 'Volley delay', unit: 'ms', min: 0, max: 1000, step: 25, value: 250 },
        { key: 'volleySpeedPxS', label: 'Volley speed', unit: 'px/s', min: 0, max: 4000, step: 5, value: 1700, scale: 'speed' }
      ]
    },
    gravity_surge: {
      id: 'gravity_surge',
      name: 'Gravitic Surge',
      shortName: 'Surge',
      description: 'Launch a focused gravitic missile that slams through foes, slowing them heavily before rooting and damaging them in succession.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 12000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 10, value: 300 },
        { key: 'projectileSpeedPxS', label: 'Projectile speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1500, scale: 'speed' },
        { key: 'projectileRangePx', label: 'Projectile range', unit: 'px', min: 0, max: 6000, step: 25, value: 5000 },
        { key: 'projectileWidthPx', label: 'Projectile width', unit: 'px', min: 0, max: 300, step: 5, value: 48 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 140 },
        { key: 'slowPct', label: 'Strong slow', unit: '%', min: 0, max: 100, step: 1, value: 30 },
        { key: 'slowDurationMs', label: 'Strong slow duration', unit: 'ms', min: 0, max: 6000, step: 50, value: 2500 },
        { key: 'slowDecayDelayMs', label: 'Decay delay', unit: 'ms', min: 0, max: 5000, step: 50, value: 700 },
        { key: 'weakSlowPct', label: 'Weak slow', unit: '%', min: 0, max: 100, step: 1, value: 10 },
        { key: 'weakSlowDurationMs', label: 'Weak slow duration', unit: 'ms', min: 0, max: 5000, step: 50, value: 1800 },
        { key: 'rootDurationMs', label: 'Root duration', unit: 'ms', min: 0, max: 2000, step: 10, value: 1000 }
      ]
    },
    sirens_kiss: {
      id: 'sirens_kiss',
      name: 'Siren\'s Kiss',
      shortName: 'Kiss',
      description: 'Blow a beguiling kiss that charms the first enemy hit, knocking them down, slowing them, and dealing flat damage.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 12000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 5000, step: 25, value: 250 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 1600, step: 5, value: 1000 },
        { key: 'projectileWidthPx', label: 'Width', unit: 'px', min: 0, max: 400, step: 5, value: 120 },
        { key: 'projectileSpeedPxS', label: 'Projectile speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1550, scale: 'speed' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 200 },
        { key: 'stunDurationMs', label: 'Knockdown duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 1200 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 65 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 1500 }
      ]
    },
    shiver_spike: {
      id: 'shiver_spike',
      name: 'Shiver Spike',
      shortName: 'Shiver',
      description: 'Hurl an icy spike that chills enemies for a short time. Chilled foes take increased damage from the strike.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 4000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 5000, step: 25, value: 250 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 1600, step: 5, value: 600 },
        { key: 'projectileWidthPx', label: 'Width', unit: 'px', min: 0, max: 400, step: 5, value: 90 },
        { key: 'projectileSpeedPxS', label: 'Projectile speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1600, scale: 'speed' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 200 },
        { key: 'chillDurationMs', label: 'Chill duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 3000 },
        { key: 'chillDamageMultiplier', label: 'Damage vs chilled', unit: 'x', min: 1, max: 5, step: 0.1, value: 2 }
      ]
    },
    bedrock_burst: {
      id: 'bedrock_burst',
      name: 'Bedrock Burst',
      shortName: 'Burst',
      description: 'Stomp the ground to launch nearby foes upward, dealing flat damage and briefly stunning them.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 12000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 },
        { key: 'impactRadiusPx', label: 'Impact radius', unit: 'px', min: 0, max: 800, step: 5, value: 375, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 220 },
        { key: 'stunDurationMs', label: 'Airborne duration', unit: 'ms', min: 0, max: 3000, step: 25, value: 1000 }
      ]
    },
    rage_pulse: {
      id: 'rage_pulse',
      name: 'Rage Pulse',
      shortName: 'Pulse',
      description: 'After a brief windup, unleash a burst of frustration that damages nearby enemies around you.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 7000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 },
        { key: 'aoeRadiusPx', label: 'Pulse radius', unit: 'px', min: 0, max: 800, step: 5, value: 350, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1500, step: 5, value: 150 }
      ]
    },
    slam: {
      id: 'slam',
      name: 'Slam',
      shortName: 'Slam',
      description: 'Slam the ground to shatter foes with a shockwave and erupting fissure.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 120000, step: 100, value: 80000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 300, max: 800, step: 10, value: 500 },
        { key: 'impactRadius', label: 'Impact radius', unit: 'px', min: 200, max: 380, step: 5, value: 300 },
        { key: 'impactDamage', label: 'Impact damage', unit: ' dmg', min: 120, max: 600, step: 10, value: 300 },
        { key: 'impactKnockupMs', label: 'Impact knock-up', unit: 'ms', min: 300, max: 1000, step: 10, value: 600 },
        { key: 'fissureLength', label: 'Fissure length', unit: 'px', min: 0, max: 1000, step: 10, value: 900 },
        { key: 'fissureWidth', label: 'Fissure width', unit: 'px', min: 0, max: 1000, step: 5, value: 200 },
        { key: 'fissureSpeed', label: 'Fissure speed', unit: 'px/s', min: 0, max: 1000, step: 10, value: 900 },
        { key: 'fissureDamage', label: 'Fissure damage', unit: ' dmg', min: 120, max: 600, step: 10, value: 300 },
        { key: 'fissureFirstNearMs', label: 'First target knock-up (near)', unit: 'ms', min: 400, max: 1000, step: 10, value: 600 },
        { key: 'fissureFirstFarMs', label: 'First target knock-up (far)', unit: 'ms', min: 1000, max: 2500, step: 10, value: 2000 },
        { key: 'fissureOtherKnockupMs', label: 'Other targets knock-up', unit: 'ms', min: 300, max: 1000, step: 10, value: 600 },
        { key: 'iceFieldDurationMs', label: 'Ice field duration', unit: 'ms', min: 2000, max: 6000, step: 50, value: 4000 },
        { key: 'iceFieldTickMs', label: 'Ice field tick interval', unit: 'ms', min: 100, max: 330, step: 10, value: 250 },
        { key: 'iceFieldSlowPct', label: 'Ice field slow', unit: '%', min: 20, max: 70, step: 1, value: 50 }
      ]
    },
    blinkingBolt: {
      id: 'blinkingBolt',
      name: 'Blinking Bolt',
      shortName: 'Blink Bolt',
      description: 'Blink toward your aim, then unleash a homing bolt at the nearest foe.',
      fields: [
        { key: 'blinkDistance', label: 'Blink distance', unit: 'px', min: 0, max: 1000, step: 10, value: 500 },
        { key: 'damage', label: 'Bolt damage', unit: ' dmg', min: 0, max: 250, step: 5, value: 100 },
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 25000, step: 50, value: 12000 }
      ]
    },
    ember_snap: {
      id: 'ember_snap',
      name: 'Ember Snap',
      shortName: 'Snap',
      description: 'Snap a searing cinder at a target. If the ember deals the killing blow, half the cooldown is refunded.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 25, value: 4000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 1200, step: 5, value: 625, scale: 'size' },
        { key: 'projectileWidthPx', label: 'Projectile width', unit: 'px', min: 0, max: 400, step: 5, value: 70, scale: 'size' },
        { key: 'projectileSpeedPxS', label: 'Projectile speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1400, scale: 'speed' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 200 },
        { key: 'killRefundPct', label: 'Cooldown refund on kill', unit: '%', min: 0, max: 100, step: 1, value: 50 }
      ]
    },
    ember_waltz: {
      id: 'ember_waltz',
      name: 'Ember Waltz',
      shortName: 'Waltz',
      description: 'Whirl embers around you, gaining a burst of speed before they dart at nearby foes.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 10000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 3000, step: 25, value: 0 },
        { key: 'flameCount', label: 'Ember count', unit: '', min: 1, max: 7, step: 1, value: 3 },
        { key: 'damage', label: 'Ember damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 120 },
        { key: 'subsequentHitPct', label: 'Subsequent hit damage', unit: '%', min: 0, max: 100, step: 5, value: 40 },
        { key: 'seekRangePx', label: 'Seek range', unit: 'px', min: 0, max: 1500, step: 5, value: 725, scale: 'size' },
        { key: 'orbitRadiusPx', label: 'Orbit radius', unit: 'px', min: 0, max: 600, step: 1, value: 150, scale: 'size' },
        { key: 'flameSpeedPxS', label: 'Flame speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1400, scale: 'speed' },
        { key: 'orbitDurationMs', label: 'Orbit duration', unit: 'ms', min: 0, max: 6000, step: 25, value: 2500 },
        { key: 'seekDelayMs', label: 'Target delay', unit: 'ms', min: 0, max: 2000, step: 10, value: 250 },
        { key: 'hastePercent', label: 'Haste bonus', unit: '%', min: 0, max: 100, step: 1, value: 40 },
        { key: 'hasteDurationMs', label: 'Haste duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 2000 },
        { key: 'executeThresholdPct', label: 'Minion execute threshold', unit: '%', min: 0, max: 100, step: 1, value: 20 },
        { key: 'executeDamageMultiplier', label: 'Execute damage multiplier', unit: 'x', min: 1, max: 5, step: 0.1, value: 2 }
      ]
    },
    frenzied_surge: {
      id: 'frenzied_surge',
      name: 'Frenzied Surge',
      shortName: 'Frenzy',
      description: 'Shear into overdrive, gaining heavy attack speed, a decaying burst of movement, and a brief ghosted window.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 12000 },
        { key: 'durationMs', label: 'Surge duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 3000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 10, value: 0 },
        { key: 'attackSpeedPct', label: 'Attack speed bonus', unit: '%', min: 0, max: 200, step: 5, value: 45 },
        { key: 'moveSpeedStartPct', label: 'Move speed start', unit: '%', min: 0, max: 200, step: 5, value: 40 },
        { key: 'moveSpeedEndPct', label: 'Move speed end', unit: '%', min: 0, max: 200, step: 1, value: 10 },
        { key: 'ghostDurationMs', label: 'Ghost duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 1500 }
      ]
    },
    phantom_overdrive: {
      id: 'phantom_overdrive',
      name: 'Phantom Overdrive',
      shortName: 'Overdrive',
      description: 'Charge while ghosted, build momentum, then unleash a burst of attack speed with faster missiles.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 40000, step: 50, value: 14000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 3000, step: 10, value: 1200 },
        { key: 'minCastTimeMs', label: 'Min cast time', unit: 'ms', min: 0, max: 2000, step: 10, value: 600 },
        { key: 'bonusAttackSpeedCapPct', label: 'Bonus AS cap', unit: '%', min: 1, max: 200, step: 5, value: 100 },
        { key: 'moveSpeedMinPct', label: 'Movement boost min', unit: '%', min: 0, max: 200, step: 5, value: 55 },
        { key: 'moveSpeedMaxPct', label: 'Movement boost max', unit: '%', min: 0, max: 200, step: 5, value: 75 },
        { key: 'attackDurationMs', label: 'Attack buff duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 4000 },
        { key: 'attackSpeedPct', label: 'Attack speed bonus', unit: '%', min: 0, max: 200, step: 5, value: 60 },
        { key: 'windupReductionPct', label: 'Windup reduction', unit: '%', min: 0, max: 30, step: 0.1, value: 6.44 },
        { key: 'missileSpeedPct', label: 'Missile speed bonus', unit: '%', min: 0, max: 100, step: 5, value: 30 },
        { key: 'cooldownReductionMsOnAttack', label: 'Cooldown cut per attack', unit: 'ms', min: 0, max: 2000, step: 10, value: 500 },
        { key: 'ghostDurationMs', label: 'Ghost duration', unit: 'ms', min: 0, max: 2000, step: 25, value: 500 }
      ]
    },
    cascade_barrage: {
      id: 'cascade_barrage',
      name: 'Cascade Barrage',
      shortName: 'Cascade',
      description: 'Summon a rain of six delayed missiles that split between nearby foes, executing wounded minions and softening champions with weaker follow-ups.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 10000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 50, value: 0 },
        { key: 'targetRangePx', label: 'Target range', unit: 'px', min: 0, max: 1200, step: 5, value: 600, scale: 'size' },
        { key: 'missileCount', label: 'Missiles', unit: '', min: 1, max: 12, step: 1, value: 6 },
        { key: 'missileDelayMs', label: 'Impact delay', unit: 'ms', min: 0, max: 2000, step: 10, value: 400 },
        { key: 'damage', label: 'Missile damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 75 },
        { key: 'minionExecuteThresholdPct', label: 'Minion execute threshold', unit: '%', min: 0, max: 100, step: 1, value: 35 },
        { key: 'minionExecuteMultiplier', label: 'Execute multiplier', unit: 'x', min: 1, max: 5, step: 0.1, value: 2 },
        { key: 'nonMinionSubsequentPct', label: 'Champion follow-up damage', unit: '%', min: 0, max: 100, step: 1, value: 25 }
      ]
    },
    flipblade_pursuit: {
      id: 'flipblade_pursuit',
      name: 'Flipblade Pursuit',
      shortName: 'Flipblade',
      description: 'Backflip away, hurl a blade to mark the first enemy hit, then recast to dive back in and strike again.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 16000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'backstepDistancePx', label: 'Backflip distance', unit: 'px', min: 0, max: 1200, step: 5, value: 325, scale: 'size' },
        { key: 'backstepSpeedPxS', label: 'Backflip speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1800, scale: 'speed' },
        { key: 'projectileRangePx', label: 'Blade range', unit: 'px', min: 0, max: 1500, step: 5, value: 900, scale: 'size' },
        { key: 'projectileSpeedPxS', label: 'Blade speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1600, scale: 'speed' },
        { key: 'projectileWidthPx', label: 'Blade width', unit: 'px', min: 0, max: 400, step: 5, value: 120, scale: 'size' },
        { key: 'damage', label: 'Initial hit damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 110 },
        { key: 'impactDamage', label: 'Recast hit damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 170 },
        { key: 'markDurationMs', label: 'Mark duration', unit: 'ms', min: 0, max: 10000, step: 50, value: 3000 },
        { key: 'recastDashSpeedPxS', label: 'Recast dash speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2100, scale: 'speed' }
      ]
    },
    boltburst_rush: {
      id: 'boltburst_rush',
      name: 'Boltburst Rush',
      shortName: 'Boltburst',
      description: 'Dash up to three times, each dash firing homing bolts at nearby foes.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 200000, step: 100, value: 120000 },
        { key: 'dashDistancePx', label: 'Dash distance', unit: 'px', min: 0, max: 1200, step: 10, value: 500 },
        { key: 'boltSeekRadiusPx', label: 'Bolt seek radius', unit: 'px', min: 0, max: 1200, step: 10, value: 600, scale: 'size' },
        { key: 'boltSpeedPxS', label: 'Bolt speed', unit: 'px/s', min: 0, max: 4000, step: 25, value: 1400, scale: 'speed' },
        { key: 'boltCount', label: 'Bolts per dash', unit: '', min: 1, max: 6, step: 1, value: 3 },
        { key: 'damage', label: 'Bolt damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 150 },
        { key: 'maxDashes', label: 'Dash charges', unit: '', min: 1, max: 5, step: 1, value: 3 },
        { key: 'recastWindowMs', label: 'Recast window', unit: 'ms', min: 0, max: 30000, step: 100, value: 15000 },
        { key: 'recastLockoutMs', label: 'Delay between casts', unit: 'ms', min: 0, max: 5000, step: 50, value: 1000 }
      ]
    },
    skull_rush: {
      id: 'skull_rush',
      name: 'Skull Rush',
      shortName: 'Skull Rush',
      description: 'Barrel headfirst into a foe. If you collide, deal flat damage, knock them back, and briefly stun them.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 12000 },
        { key: 'dashDistancePx', label: 'Dash range', unit: 'px', min: 0, max: 1200, step: 5, value: 650, scale: 'size' },
        { key: 'impactRadius', label: 'Impact radius', unit: 'px', min: 0, max: 800, step: 5, value: 400, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1500, step: 5, value: 240 },
        { key: 'knockbackDistancePx', label: 'Knockback distance', unit: 'px', min: 0, max: 1200, step: 5, value: 700, scale: 'size' },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 3000, step: 25, value: 750 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 0 }
      ]
    },
    cyclone_axes: {
      id: 'cyclone_axes',
      name: 'Cyclone Axes',
      shortName: 'Cyclone',
      description: 'Hurl twin axes across the map; recast (or wait) to pull them back before they run out of space.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 300000, step: 50, value: 120000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 3000, step: 25, value: 500 },
        { key: 'projectileRangePx', label: 'Throw range', unit: 'px', min: 0, max: 10000, step: 5, value: 6200, scale: 'size' },
        { key: 'projectileSpeedPxS', label: 'Outbound speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2000, scale: 'speed' },
        { key: 'returnSpeedPxS', label: 'Return speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1500, scale: 'speed' },
        { key: 'projectileWidthPx', label: 'Axe width', unit: 'px', min: 0, max: 300, step: 1, value: 64, scale: 'size' },
        { key: 'damage', label: 'Damage per hit', unit: ' dmg', min: 0, max: 1000, step: 5, value: 320 },
        { key: 'returnDamagePct', label: 'Return damage %', unit: '%', min: 0, max: 200, step: 5, value: 100 },
        { key: 'recastDelayMs', label: 'Recast unlock', unit: 'ms', min: 0, max: 5000, step: 25, value: 1000 }
      ]
    },
    riptide_snapback: {
      id: 'riptide_snapback',
      name: 'Riptide Snapback',
      shortName: 'Snapback',
      description: 'Dash forward, leaving a phantom wake that snaps back to you and stuns whatever it crosses.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 13000 },
        { key: 'dashDistancePx', label: 'Dash distance', unit: 'px', min: 0, max: 1200, step: 10, value: 550 },
        { key: 'returnDelayMs', label: 'Return delay', unit: 'ms', min: 0, max: 5000, step: 25, value: 1000 },
        { key: 'returnSpeedPxS', label: 'Return speed', unit: 'px/s', min: 0, max: 4000, step: 25, value: 3000 },
        { key: 'phantomWidthPx', label: 'Return path width', unit: 'px', min: 0, max: 400, step: 5, value: 110 },
        { key: 'impactRadiusPx', label: 'Snapback impact radius', unit: 'px', min: 0, max: 600, step: 5, value: 140 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 220 },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 1250 }
      ]
    },
    chrono_loop: {
      id: 'chrono_loop',
      name: 'Chrono Loop',
      shortName: 'Chrono Loop',
      description: 'Hurl a temporal grenade that forms a slowing field before homing back for a second burst.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 40000, step: 50, value: 14000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'projectileRangePx', label: 'Outbound range', unit: 'px', min: 0, max: 1200, step: 5, value: 900, scale: 'size' },
        { key: 'projectileWidthPx', label: 'Grenade width', unit: 'px', min: 0, max: 200, step: 1, value: 120 },
        { key: 'projectileSpeedPxS', label: 'Outbound speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1650, scale: 'speed' },
        { key: 'fieldDistancePx', label: 'Field travel', unit: 'px', min: 0, max: 400, step: 5, value: 190, scale: 'size' },
        { key: 'fieldSpeedPxS', label: 'Field speed', unit: 'px/s', min: 0, max: 1000, step: 10, value: 220, scale: 'speed' },
        { key: 'fieldDurationMs', label: 'Field duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 1750 },
        { key: 'fieldRadiusPx', label: 'Field radius', unit: 'px', min: 0, max: 400, step: 5, value: 160, scale: 'size' },
        { key: 'fieldSlowPct', label: 'Field slow', unit: '%', min: 0, max: 100, step: 1, value: 45 },
        { key: 'fieldSlowDurationMs', label: 'Field slow duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 1750 },
        { key: 'damage', label: 'Outbound damage', unit: ' dmg', min: 0, max: 600, step: 5, value: 130 },
        { key: 'returnDamage', label: 'Return damage', unit: ' dmg', min: 0, max: 600, step: 5, value: 90 },
        { key: 'returnSpeedPxS', label: 'Return speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2300, scale: 'speed' }
      ]
    },
    skyhook_strafe: {
      id: 'skyhook_strafe',
      name: 'Skyhook Strafe',
      shortName: 'Skyhook',
      description: 'Fire a hook into terrain, swing around the anchor while spraying shots, then leap off for a final blast.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 18000 },
        { key: 'hookRangePx', label: 'Hook range', unit: 'px', min: 0, max: 1800, step: 5, value: 800, scale: 'size' },
        { key: 'hookSpeedPxS', label: 'Hook speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2200, scale: 'speed' },
        { key: 'hookWidthPx', label: 'Hook width', unit: 'px', min: 0, max: 300, step: 1, value: 60, scale: 'size' },
        { key: 'prepDurationMs', label: 'Prep window', unit: 'ms', min: 0, max: 4000, step: 25, value: 2100 },
        { key: 'swingDurationMs', label: 'Max swing duration', unit: 'ms', min: 0, max: 6000, step: 25, value: 1800 },
        { key: 'swingSpeedPxS', label: 'Swing speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1400, scale: 'speed' },
        { key: 'shotIntervalMs', label: 'Shot interval', unit: 'ms', min: 50, max: 2000, step: 10, value: 230 },
        { key: 'damagePerShot', label: 'Shot damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 45 },
        { key: 'shotRangePx', label: 'Shot range', unit: 'px', min: 0, max: 1400, step: 5, value: 700, scale: 'size' },
        { key: 'jumpRangePx', label: 'Leap distance', unit: 'px', min: 0, max: 1400, step: 5, value: 420, scale: 'size' },
        { key: 'recastUnlockMs', label: 'Third-cast unlock', unit: 'ms', min: 0, max: 4000, step: 10, value: 500 },
        { key: 'impactDamage', label: 'Final shot damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 90 }
      ]
    },
    twinstrike_pursuit: {
      id: 'twinstrike_pursuit',
      name: 'Twinstrike Pursuit',
      shortName: 'Twinstrike',
      description: 'Dash through foes, then recast within a brief window to carve through them again with an execution lunge.',
      fields: [
        { key: 'cooldownMs',          label: 'Cooldown',              unit: 'ms',   min: 0, max: 200000, step: 50,  value: 90000 },
        { key: 'firstCastTimeMs',     label: 'First cast time',       unit: 'ms',   min: 0, max: 2000,  step: 25,  value: 250 },
        { key: 'firstDashRangePx',    label: 'First dash range',      unit: 'px',   min: 0, max: 2000,  step: 10,  value: 675, scale: 'size' },
        { key: 'firstDashSpeedPxS',   label: 'First dash speed',      unit: 'px/s', min: 0, max: 4000,  step: 10,  value: 1500, scale: 'speed' },
        { key: 'dashWidthPx',         label: 'Dash collision width',  unit: 'px',   min: 0, max: 500,   step: 5,   value: 110, scale: 'size' },
        { key: 'minimumOvershootPx',  label: 'Min overshoot past hit',unit: 'px',   min: 0, max: 600,   step: 5,   value: 150, scale: 'size' },
        { key: 'firstDamage',         label: 'First dash damage',     unit: ' dmg', min: 0, max: 2000,  step: 5,   value: 220 },
        { key: 'recastLockoutMs',     label: 'Recast delay',          unit: 'ms',   min: 0, max: 10000, step: 50,  value: 2500 },
        { key: 'recastWindowMs',      label: 'Recast window',         unit: 'ms',   min: 0, max: 20000, step: 50,  value: 10000 },
        { key: 'secondDashRangePx',   label: 'Second dash range',     unit: 'px',   min: 0, max: 2000,  step: 10,  value: 800, scale: 'size' },
        { key: 'secondDashSpeedPxS',  label: 'Second dash speed',     unit: 'px/s', min: 0, max: 4000,  step: 10,  value: 3000, scale: 'speed' },
        { key: 'secondDamage',        label: 'Second dash damage',    unit: ' dmg', min: 0, max: 2000,  step: 5,   value: 260 }
      ]
    },
    ricochet_lob: {
      id: 'ricochet_lob',
      name: 'Ricochet Lob',
      shortName: 'Ricochet',
      description: 'Lob an explosive that hops forward up to two times, detonating when it nears foes or after the final bounce.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 6000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'maxRangePx', label: 'Max throw range', unit: 'px', min: 0, max: 2000, step: 10, value: 850, scale: 'size' },
        { key: 'projectileSpeedPxPerMs', label: 'Travel speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1700, scale: 'speed' },
        { key: 'explosionRadiusPx', label: 'Explosion radius', unit: 'px', min: 0, max: 800, step: 5, value: 240, scale: 'size' },
        { key: 'triggerRadiusPx', label: 'Proximity trigger radius', unit: 'px', min: 0, max: 800, step: 5, value: 180, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1500, step: 5, value: 220 },
        { key: 'bounceCount', label: 'Max bounces', unit: '', min: 0, max: 3, step: 1, value: 2 },
        { key: 'firstBounceScale', label: 'First bounce distance', unit: 'x cast distance', min: 0, max: 2, step: 0.05, value: 0.4 },
        { key: 'secondBounceScale', label: 'Second bounce distance', unit: 'x cast distance', min: 0, max: 2, step: 0.05, value: 0.3 }
      ]
    },
    dirge_bloom: {
      id: 'dirge_bloom',
      name: 'Dirge Bloom',
      shortName: 'Dirge Bloom',
      description: 'Lob a vial of mourning mist that bursts on impact, cursing and slowing enemies caught in the haze.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 12000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 5000, step: 25, value: 250 },
        { key: 'maxRangePx', label: 'Throw range', unit: 'px', min: 0, max: 2000, step: 10, value: 750, scale: 'size' },
        { key: 'projectileSpeedPxS', label: 'Travel speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1700, scale: 'speed' },
        { key: 'aoeRadiusPx', label: 'Burst radius', unit: 'px', min: 0, max: 800, step: 5, value: 240, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 160 },
        { key: 'slowPct', label: 'Slow percent', unit: '%', min: 0, max: 100, step: 1, value: 30 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 1500 },
        { key: 'curseDurationMs', label: 'Curse duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 4000 },
        { key: 'curseDps', label: 'Curse damage per sec', unit: ' dmg/s', min: 0, max: 500, step: 1, value: 20 }
      ]
    },
    shatterburst_orb: {
      id: 'shatterburst_orb',
      name: 'Shatterburst Orb',
      shortName: 'Shatterburst',
      description: 'Launch a frost orb that chills foes it passes through, then shatter it to stun nearby enemies.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 9000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 3000, step: 25, value: 250 },
        { key: 'projectileRangePx', label: 'Travel range', unit: 'px', min: 0, max: 2000, step: 5, value: 1100, scale: 'size' },
        { key: 'projectileWidthPx', label: 'Orb width', unit: 'px', min: 0, max: 600, step: 5, value: 220, scale: 'size' },
        { key: 'projectileSpeedPxS', label: 'Orb speed', unit: 'px/s', min: 0, max: 3000, step: 10, value: 950, scale: 'speed' },
        { key: 'damage', label: 'Pierce damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 130 },
        { key: 'slowPct', label: 'Chill slow', unit: '%', min: 0, max: 100, step: 1, value: 35 },
        { key: 'slowDurationMs', label: 'Chill duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 3000 },
        { key: 'impactDamage', label: 'Shatter damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 130 },
        { key: 'impactRadius', label: 'Shatter radius', unit: 'px', min: 0, max: 800, step: 5, value: 225, scale: 'size' },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 1000 }
      ]
    },
    rebound_orb: {
      id: 'rebound_orb',
      name: 'Rebound Orb',
      shortName: 'Rebound',
      description: 'Send an orb outward that pierces foes, then snaps back along the same path for a second true-damage hit.',
      fields: [
        { key: 'cooldownMs',          label: 'Cooldown',          unit: 'ms',  min: 0, max: 60000, step: 50,  value: 7000 },
        { key: 'castTimeMs',          label: 'Cast time',         unit: 'ms',  min: 0, max: 5000,  step: 25,  value: 250 },
        { key: 'projectileRangePx',   label: 'Travel range',      unit: 'px',  min: 0, max: 2000,  step: 5,   value: 900,  scale: 'size' },
        { key: 'projectileWidthPx',   label: 'Orb width',         unit: 'px',  min: 0, max: 600,   step: 5,   value: 200,  scale: 'size' },
        { key: 'projectileSpeedPxS',  label: 'Outbound speed',    unit: 'px/s',min: 0, max: 4000,  step: 10,  value: 1550, scale: 'speed' },
        { key: 'returnSpeedPxS',      label: 'Return speed',      unit: 'px/s',min: 0, max: 4000,  step: 10,  value: 2100, scale: 'speed' },
        { key: 'damage',              label: 'Damage per pass',   unit: ' dmg',min: 0, max: 2000,  step: 5,   value: 140 }
      ]
    },
    edgewatch_snare: {
      id: 'edgewatch_snare',
      name: 'Edgewatch Snare',
      shortName: 'Edgewatch',
      description: 'Lay a visible snap trap that roots and reveals the first foe to spring it.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 15000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'maxPlaceRangePx', label: 'Placement range', unit: 'px', min: 0, max: 1200, step: 5, value: 800 },
        { key: 'dropCount', label: 'Traps per cast', unit: '', min: 1, max: 5, step: 1, value: 1 },
        { key: 'placementMode', label: 'Placement mode (0=inline,1=cluster,2=free)', unit: '', min: 0, max: 2, step: 1, value: 2 },
        { key: 'placementSpacingPx', label: 'Placement spacing', unit: 'px', min: 0, max: 600, step: 5, value: 120 },
        { key: 'minTrapSpacingPx', label: 'Minimum trap spacing', unit: 'px', min: 0, max: 400, step: 5, value: 80 },
        { key: 'armDelayMs', label: 'Arm delay', unit: 'ms', min: 0, max: 5000, step: 25, value: 1000 },
        { key: 'lifetimeMs', label: 'Trap duration', unit: 'ms', min: 0, max: 90000, step: 100, value: 40000 },
        { key: 'triggerRadiusPx', label: 'Trigger radius', unit: 'px', min: 0, max: 400, step: 5, value: 150 },
        { key: 'aoeRadiusPx', label: 'Trigger area radius', unit: 'px', min: 0, max: 400, step: 5, value: 180 },
        { key: 'damage', label: 'Hero damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 140 },
        { key: 'immobilizeMs', label: 'Root duration', unit: 'ms', min: 0, max: 5000, step: 10, value: 1500 },
        { key: 'rootPrimaryOnly', label: 'Root only first target', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'maxActiveTraps', label: 'Max active traps', unit: '', min: 1, max: 10, step: 1, value: 3 },
        { key: 'showArmedRing', label: 'Show armed ring', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'showTriggerRadius', label: 'Show trigger radius', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'placementRevealMs', label: 'Placement reveal', unit: 'ms', min: 0, max: 10000, step: 100, value: 1000 },
        { key: 'triggerRevealMs', label: 'Trigger reveal', unit: 'ms', min: 0, max: 10000, step: 100, value: 3000 },
        { key: 'revealRadiusPx', label: 'Reveal radius', unit: 'px', min: 0, max: 400, step: 5, value: 200 },
        { key: 'hitMemoryMs', label: 'Trap immunity duration', unit: 'ms', min: 0, max: 10000, step: 100, value: 3000 }
      ]
    },
    proximity_traps: {
      id: 'proximity_traps',
      name: 'Flame Chompers',
      shortName: 'Chompers',
      description: 'Drop proximity snares that arm after a delay, rooting the first foe to enter and exploding for area damage.',
      fields: [
        { key: 'dropCount', label: 'Trap count', unit: '', min: 0, max: 6, step: 1, value: 3 },
        { key: 'placementMode', label: 'Placement mode (0=inline,1=cluster,2=free)', unit: '', min: 0, max: 2, step: 1, value: 0 },
        { key: 'placementSpacingPx', label: 'Placement spacing', unit: 'px', min: 0, max: 1000, step: 5, value: 120 },
        { key: 'maxPlaceRangePx', label: 'Max drop range', unit: 'px', min: 0, max: 1000, step: 10, value: 900 },
        { key: 'minTrapSpacingPx', label: 'Minimum trap spacing', unit: 'px', min: 0, max: 1000, step: 5, value: 80 },
        { key: 'armDelayMs', label: 'Arm delay', unit: 'ms', min: 0, max: 5000, step: 25, value: 450 },
        { key: 'lifetimeMs', label: 'Lifetime after arming', unit: 'ms', min: 0, max: 15000, step: 50, value: 5000 },
        { key: 'triggerRadiusPx', label: 'Trigger radius', unit: 'px', min: 0, max: 400, step: 5, value: 70 },
        { key: 'aoeRadiusPx', label: 'Explosion radius', unit: 'px', min: 0, max: 800, step: 5, value: 220 },
        { key: 'immobilizeMs', label: 'Root duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 1500 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 1000, step: 5, value: 90 },
        { key: 'rootPrimaryOnly', label: 'Root only primary', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'maxActiveTraps', label: 'Max active traps', unit: '', min: 1, max: 8, step: 1, value: 3 },
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 16000 },
        { key: 'canTriggerByMinions', label: 'Trigger on minions', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'showArmedRing', label: 'Show armed ring', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'showTriggerRadius', label: 'Show trigger radius', unit: '', min: 0, max: 1, step: 1, value: 1 }
      ]
    },
    scatter_minefield: {
      id: 'scatter_minefield',
      name: 'Scatter Minefield',
      shortName: 'Minefield',
      description: 'Scatter a cluster of proximity mines that arm quickly, slow on detonation, and hit subsequent targets for reduced damage.',
      fields: [
        { key: 'dropCount', label: 'Mine count', unit: '', min: 1, max: 20, step: 1, value: 11 },
        { key: 'placementMode', label: 'Placement mode (0=inline,1=cluster,2=free)', unit: '', min: 0, max: 2, step: 1, value: 2 },
        { key: 'placementSpacingPx', label: 'Placement spacing', unit: 'px', min: 0, max: 1000, step: 5, value: 100 },
        { key: 'maxPlaceRangePx', label: 'Max drop range', unit: 'px', min: 0, max: 1500, step: 10, value: 900 },
        { key: 'minTrapSpacingPx', label: 'Minimum trap spacing', unit: 'px', min: 0, max: 1000, step: 5, value: 75 },
        { key: 'armDelayMs', label: 'Arm delay', unit: 'ms', min: 0, max: 5000, step: 25, value: 500 },
        { key: 'lifetimeMs', label: 'Lifetime after arming', unit: 'ms', min: 0, max: 20000, step: 50, value: 10000 },
        { key: 'triggerRadiusPx', label: 'Trigger radius', unit: 'px', min: 0, max: 400, step: 5, value: 120 },
        { key: 'aoeRadiusPx', label: 'Explosion radius', unit: 'px', min: 0, max: 800, step: 5, value: 200 },
        { key: 'immobilizeMs', label: 'Root duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 0 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 140 },
        { key: 'tickDamage', label: 'Damage per tick', unit: ' dmg', min: 0, max: 2000, step: 1, value: 0 },
        { key: 'ticks', label: 'Tick count', unit: 'ticks', min: 1, max: 20, step: 1, value: 1 },
        { key: 'tickIntervalMs', label: 'Tick interval', unit: 'ms', min: 100, max: 5000, step: 50, value: 1000 },
        { key: 'slowPct', label: 'Slow percent', unit: '%', min: 0, max: 100, step: 1, value: 35 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 20000, step: 50, value: 1500 },
        { key: 'subsequentHitPct', label: 'Damage on subsequent hits', unit: '%', min: 0, max: 100, step: 5, value: 40 },
        { key: 'maxActiveTraps', label: 'Max active traps', unit: '', min: 1, max: 20, step: 1, value: 11 },
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 16000 },
        { key: 'canTriggerByMinions', label: 'Trigger on minions', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'showArmedRing', label: 'Show armed ring', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'showTriggerRadius', label: 'Show trigger radius', unit: '', min: 0, max: 1, step: 1, value: 1 }
      ]
    },
    toxic_mine: {
      id: 'toxic_mine',
      name: 'Toxic Mine',
      shortName: 'Mine',
      description: 'Toss a toxic mine that arms, then explodes on contact to poison and slow nearby foes. Pure damage, no mana or leveling.',
      fields: [
        { key: 'dropCount', label: 'Trap count', unit: '', min: 0, max: 6, step: 1, value: 1 },
        { key: 'placementMode', label: 'Placement mode (0=inline,1=cluster,2=free)', unit: '', min: 0, max: 2, step: 1, value: 0 },
        { key: 'placementSpacingPx', label: 'Placement spacing', unit: 'px', min: 0, max: 1000, step: 5, value: 140 },
        { key: 'maxPlaceRangePx', label: 'Max drop range', unit: 'px', min: 0, max: 1500, step: 10, value: 900 },
        { key: 'minTrapSpacingPx', label: 'Minimum trap spacing', unit: 'px', min: 0, max: 1000, step: 5, value: 100 },
        { key: 'armDelayMs', label: 'Arm delay', unit: 'ms', min: 0, max: 5000, step: 25, value: 1000 },
        { key: 'lifetimeMs', label: 'Lifetime after arming', unit: 'ms', min: 0, max: 600000, step: 1000, value: 300000 },
        { key: 'triggerRadiusPx', label: 'Trigger radius', unit: 'px', min: 0, max: 600, step: 5, value: 160 },
        { key: 'aoeRadiusPx', label: 'Explosion radius', unit: 'px', min: 0, max: 1000, step: 5, value: 450 },
        { key: 'immobilizeMs', label: 'Root duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 0 },
        { key: 'damage', label: 'Instant damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 0 },
        { key: 'tickDamage', label: 'Damage per tick', unit: ' dmg', min: 0, max: 2000, step: 1, value: 80 },
        { key: 'ticks', label: 'Tick count', unit: 'ticks', min: 1, max: 20, step: 1, value: 4 },
        { key: 'tickIntervalMs', label: 'Tick interval', unit: 'ms', min: 100, max: 5000, step: 50, value: 1000 },
        { key: 'slowPct', label: 'Slow percent', unit: '%', min: 0, max: 100, step: 1, value: 40 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 20000, step: 50, value: 4000 },
        { key: 'maxActiveTraps', label: 'Max active traps', unit: '', min: 1, max: 10, step: 1, value: 5 },
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 25, value: 250 },
        { key: 'canTriggerByMinions', label: 'Trigger on minions', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'showArmedRing', label: 'Show armed ring', unit: '', min: 0, max: 1, step: 1, value: 1 },
        { key: 'showTriggerRadius', label: 'Show trigger radius', unit: '', min: 0, max: 1, step: 1, value: 1 }
      ]
    },
    spectral_stockade: {
      id: 'spectral_stockade',
      name: 'Spectral Stockade',
      shortName: 'Stockade',
      description: 'Raise a ring of spirits after a short delay, shoving foes aside and caging them behind a temporary barrier.',
      fields: [
        { key: 'cooldownMs',         label: 'Cooldown',         unit: 'ms', min: 0, max: 60000, step: 50, value: 16000 },
        { key: 'castTimeMs',         label: 'Cast time',        unit: 'ms', min: 0, max: 2000,  step: 25, value: 0 },
        { key: 'maxRangePx',         label: 'Cast range',       unit: 'px', min: 0, max: 1200,  step: 5,  value: 600, scale: 'size' },
        { key: 'wallRadiusPx',       label: 'Ring radius',      unit: 'px', min: 40, max: 800,  step: 5,  value: 220, scale: 'size' },
        { key: 'wallThicknessPx',    label: 'Wall thickness',   unit: 'px', min: 10, max: 200,  step: 5,  value: 60,  scale: 'size' },
        { key: 'riseDelayMs',        label: 'Rise delay',       unit: 'ms', min: 0, max: 5000,  step: 25, value: 750 },
        { key: 'durationMs',         label: 'Wall duration',    unit: 'ms', min: 0, max: 10000, step: 50, value: 4000 },
        { key: 'shoveDistancePx',    label: 'Shove distance',   unit: 'px', min: 0, max: 600,  step: 5,  value: 160, scale: 'size' },
        { key: 'innerPullRadiusPx',  label: 'Inner pull radius',unit: 'px', min: 0, max: 600,  step: 5,  value: 210, scale: 'size' },
        { key: 'segmentCount',       label: 'Wall segments',    unit: '',   min: 3, max: 12,    step: 1,  value: 6 }
      ]
    },
    glacial_uplift: {
      id: 'glacial_uplift',
      name: 'Glacial Uplift',
      shortName: 'Uplift',
      description: 'Heave a wall of ice perpendicular to your aim, shoving units aside and blocking movement for a short duration.',
      fields: [
        { key: 'cooldownMs',        label: 'Cooldown',       unit: 'ms', min: 0, max: 60000, step: 50, value: 17000 },
        { key: 'castTimeMs',        label: 'Cast time',      unit: 'ms', min: 0, max: 2000,  step: 25, value: 250 },
        { key: 'maxRangePx',        label: 'Cast range',     unit: 'px', min: 0, max: 1400,  step: 5,  value: 1000, scale: 'size' },
        { key: 'wallLengthPx',      label: 'Wall length',    unit: 'px', min: 100, max: 1400,step: 5,  value: 700,  scale: 'size' },
        { key: 'wallThicknessPx',   label: 'Wall thickness', unit: 'px', min: 10,  max: 240, step: 5,  value: 80,   scale: 'size' },
        { key: 'wallDurationMs',    label: 'Wall duration',  unit: 'ms', min: 500, max: 10000,step: 25,value: 5000 },
        { key: 'shoveDistancePx',   label: 'Shove distance', unit: 'px', min: 0,  max: 600,  step: 5,  value: 160,  scale: 'size' },
        { key: 'segmentCount',      label: 'Wall segments',  unit: '',   min: 1,  max: 12,   step: 1,  value: 5 }
      ]
    },
    charging_gale: {
      id: 'charging_gale',
      name: 'Charging Gale',
      shortName: 'Gale',
      description: 'Start charging a gust at your position. Recast during the window or auto at the end to launch a line projectile toward your aim. Longer charge increases range, speed, damage, and knock-up.',
      fields: [
        { key: 'cooldownMs',        label: 'Cooldown',            unit: 'ms',   min: 0, max: 60000, step: 50,  value: 14000 },
        { key: 'castTimeMs',        label: 'Cast time',           unit: 'ms',   min: 0, max: 1000,  step: 25,  value: 0 },
        { key: 'chargeMaxMs',       label: 'Max charge time',     unit: 'ms',   min: 0, max: 5000,  step: 25,  value: 3000 },
        { key: 'allowManualRecast', label: 'Allow manual recast', unit: '',     min: 0, max: 1,     step: 1,   value: 1 },
        { key: 'widthPx',           label: 'Projectile width',    unit: 'px',   min: 0, max: 1000,  step: 5,   value: 240 },
        { key: 'minRangePx',        label: 'Min range',           unit: 'px',   min: 0, max: 1000,  step: 10,  value: 600 },
        { key: 'maxRangePx',        label: 'Max range',           unit: 'px',   min: 0, max: 1000,  step: 10,  value: 1000 },
        { key: 'minSpeedPxS',       label: 'Min speed',           unit: 'px/s', min: 0, max: 1000,  step: 10,  value: 880 },
        { key: 'maxSpeedPxS',       label: 'Max speed',           unit: 'px/s', min: 0, max: 1000,  step: 10,  value: 1000 },
        { key: 'stopAtTerrain',     label: 'Stop at terrain',     unit: '',     min: 0, max: 1,     step: 1,   value: 1 },
        { key: 'pierceUnits',       label: 'Pierce units',        unit: '',     min: 0, max: 1,     step: 1,   value: 1 },
        { key: 'minDamage',         label: 'Min damage',          unit: ' dmg', min: 0, max: 2000,  step: 10,  value: 160 },
        { key: 'bonusPerSecond',    label: 'Bonus per second',    unit: ' dmg', min: 0, max: 500,   step: 5,   value: 25 },
        { key: 'knockupMinMs',      label: 'Min knock-up',        unit: 'ms',   min: 0, max: 3000,  step: 25,  value: 500 },
        { key: 'knockupMaxMs',      label: 'Max knock-up',        unit: 'ms',   min: 0, max: 3000,  step: 25,  value: 1250 }
      ]
    },
    avalanche_roll: {
      id: 'avalanche_roll',
      name: 'Avalanche Roll',
      shortName: 'Avalanche',
      description: 'Channel a snowball that grows and can be steered before releasing it to burst in a shockwave.',
      fields: [
        { key: 'cooldownMs',          label: 'Cooldown',         unit: 'ms', min: 0, max: 60000, step: 50, value: 14000 },
        { key: 'castTimeMs',          label: 'Cast time',        unit: 'ms', min: 0, max: 1500,  step: 25, value: 200 },
        { key: 'chargeDurationMs',    label: 'Max charge time',  unit: 'ms', min: 0, max: 10000, step: 25, value: 8000 },
        { key: 'allowManualRecast',   label: 'Allow manual release', unit: '',  min: 0, max: 1, step: 1, value: 1 },
        { key: 'manualReleaseDelayMs', label: 'Manual release delay', unit: 'ms', min: 0, max: 2000, step: 25, value: 500 },
        { key: 'projectileRangePx',   label: 'Roll distance',    unit: 'px', min: 0, max: 2500, step: 5, value: 1700, scale: 'size' },
        { key: 'projectileSpeedPxS',  label: 'Roll speed',       unit: 'px/s', min: 0, max: 2000, step: 10, value: 700, scale: 'speed' },
        { key: 'projectileWidthPx',   label: 'Snowball width',   unit: 'px', min: 0, max: 420, step: 5, value: 220, scale: 'size' },
        { key: 'minRadiusPx',         label: 'Min radius',       unit: 'px', min: 0, max: 320, step: 5, value: 70, scale: 'size' },
        { key: 'maxRadiusPx',         label: 'Max radius',       unit: 'px', min: 0, max: 500, step: 5, value: 180, scale: 'size' },
        { key: 'explosionRadiusPx',   label: 'Explosion radius', unit: 'px', min: 0, max: 500, step: 5, value: 220, scale: 'size' },
        { key: 'baseDamage',          label: 'Base damage',      unit: ' dmg', min: 0, max: 1000, step: 5, value: 180 },
        { key: 'damagePerSecond',     label: 'Damage / sec',     unit: ' dmg', min: 0, max: 200, step: 5, value: 35 },
        { key: 'minionDamagePct',     label: 'Minion damage %',  unit: '%', min: 0, max: 100, step: 5, value: 40 },
        { key: 'knockupMinMs',        label: 'Min knock-up',     unit: 'ms', min: 0, max: 3000, step: 25, value: 250 },
        { key: 'knockupMaxMs',        label: 'Max knock-up',     unit: 'ms', min: 0, max: 3000, step: 25, value: 750 },
        { key: 'stunMaxMs',           label: 'Additional stun',  unit: 'ms', min: 0, max: 2000, step: 25, value: 500 },
        { key: 'initialSlowPct',      label: 'Initial slow',     unit: '%', min: 0, max: 100, step: 1, value: 50 },
        { key: 'slowHoldMs',          label: 'Slow hold',        unit: 'ms', min: 0, max: 4000, step: 50, value: 1000 },
        { key: 'speedBoostPct',       label: 'Speed regain %',   unit: '%', min: 0, max: 100, step: 1, value: 25 },
        { key: 'speedBoostDurationMs', label: 'Speed regain time', unit: 'ms', min: 0, max: 5000, step: 25, value: 3000 },
        { key: 'steerSpeedDeg',       label: 'Steer speed',      unit: 'deg/s', min: 0, max: 360, step: 5, value: 150 }
      ]
    },
    slingshot_crash: {
      id: 'slingshot_crash',
      name: 'Slingshot Crash',
      shortName: 'Slingshot',
      description: 'Charge a slingshot leap, then recast to launch within a cone and crash down for area damage and a brief knock-up. Holding longer reaches farther and knocks up longer.',
      fields: [
        { key: 'cooldownMs',         label: 'Cooldown',                unit: 'ms',   min: 0, max: 60000, step: 50,  value: 22000 },
        { key: 'chargeMaxMs',        label: 'Max charge time',         unit: 'ms',   min: 0, max: 6000,  step: 25,  value: 4500 },
        { key: 'minRangePx',         label: 'Min launch range',        unit: 'px',   min: 0, max: 2000,  step: 10,  value: 700 },
        { key: 'maxRangePx',         label: 'Max launch range',        unit: 'px',   min: 0, max: 2400,  step: 10,  value: 1500 },
        { key: 'impactRadius',       label: 'Impact radius',           unit: 'px',   min: 0, max: 800,   step: 5,   value: 265 },
        { key: 'damage',             label: 'Impact damage',           unit: ' dmg', min: 0, max: 2000,  step: 10,  value: 260 },
        { key: 'stunShortMs',        label: 'Knock-up (short charge)', unit: 'ms',   min: 0, max: 3000,  step: 25,  value: 500 },
        { key: 'stunLongMs',         label: 'Knock-up (long charge)',  unit: 'ms',   min: 0, max: 3000,  step: 25,  value: 1000 },
        { key: 'stunThresholdMs',    label: 'Long charge threshold',   unit: 'ms',   min: 0, max: 4000,  step: 25,  value: 1000 },
        { key: 'leapSpeedPxS',       label: 'Leap speed',              unit: 'px/s', min: 0, max: 2400,  step: 10,  value: 1350, scale: 'speed' },
        { key: 'coneHalfAngleDeg',   label: 'Aim cone half-angle',     unit: 'deg',  min: 0, max: 180,   step: 1,   value: 55 },
        { key: 'cooldownRefundPct',  label: 'Cooldown refund on cancel', unit: '%',  min: 0, max: 100,   step: 1,   value: 50 }
      ]
    },
    springquake_stomp: {
      id: 'springquake_stomp',
      name: 'Springquake Stomp',
      shortName: 'Springquake',
      description: 'Bounce four times in place after a quick windup. The first slam knocks enemies back, slows them, and hits for full damage; later bounces deal half damage. You move faster while bouncing but cannot attack or cast other abilities.',
      fields: [
        { key: 'cooldownMs',          label: 'Cooldown',                unit: 'ms',   min: 0, max: 200000, step: 50,  value: 105000 },
        { key: 'castTimeMs',          label: 'Cast time',               unit: 'ms',   min: 0, max: 2000,   step: 25,  value: 300 },
        { key: 'bounceRadiusPx',      label: 'Bounce radius',           unit: 'px',   min: 0, max: 1000,   step: 5,   value: 300, scale: 'size' },
        { key: 'damage',              label: 'First-hit damage',        unit: ' dmg', min: 0, max: 3000,   step: 5,   value: 200 },
        { key: 'subsequentHitPct',    label: 'Damage on repeat hits',   unit: '%',    min: 0, max: 100,    step: 1,   value: 50 },
        { key: 'bounceCount',         label: 'Total bounces',           unit: '',     min: 1, max: 10,     step: 1,   value: 4 },
        { key: 'bounceIntervalMs',    label: 'Bounce interval',         unit: 'ms',   min: 100, max: 4000, step: 50,  value: 1000 },
        { key: 'slowPct',             label: 'Slow on first hit',       unit: '%',    min: 0, max: 100,    step: 1,   value: 20 },
        { key: 'slowDurationMs',      label: 'Slow duration',           unit: 'ms',   min: 0, max: 5000,   step: 25,  value: 1000 },
        { key: 'knockbackDistancePx', label: 'Knockback distance',      unit: 'px',   min: 0, max: 1200,   step: 5,   value: 260, scale: 'size' },
        { key: 'knockupDurationMs',   label: 'Airborne duration',       unit: 'ms',   min: 0, max: 3000,   step: 25,  value: 1000 },
        { key: 'moveSpeedStartPct',   label: 'Move speed start',        unit: '%',    min: 0, max: 200,    step: 1,   value: 20 },
        { key: 'moveSpeedEndPct',     label: 'Move speed peak',         unit: '%',    min: 0, max: 200,    step: 1,   value: 50 }
      ]
    },
    frenetic_volley: {
      id: 'frenetic_volley',
      name: 'Frenzied Volley',
      shortName: 'Volley',
      description: 'Brace for a concentrated flurry that speeds up your shots and lets each hit drain health from foes.',
      fields: [
        { key: 'cooldownMs',    label: 'Cooldown',           unit: 'ms',  min: 0,     max: 200000, step: 50, value: 18000 },
        { key: 'durationMs',    label: 'Duration',           unit: 'ms',  min: 0,     max: 15000,  step: 50, value: 6000 },
        { key: 'attackSpeedPct', label: 'Bonus attack speed', unit: '%',    min: 0,     max: 120,    step: 5,  value: 40 },
        { key: 'arrowCount',    label: 'Arrows per attack',  unit: '',     min: 1,     max: 12,     step: 1,  value: 5 },
        { key: 'arrowDamage',   label: 'Damage per arrow',   unit: ' dmg', min: 0,     max: 400,    step: 1,  value: 18 },
        { key: 'lifeStealPct',  label: 'Life steal',         unit: '%',    min: 0,     max: 100,    step: 1,  value: 8 }
      ]
    },
    piercing_arrow: {
      id: 'piercing_arrow',
      name: 'Piercing Arrow',
      shortName: 'Piercing Arrow',
      description: 'Hold to charge an arrow that gains range and damage, then release to fire a piercing line shot.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs',             label: 'Cooldown',              unit: 'ms',    min: 0,    max: 60000, step: 50,  value: 18000 },
        { key: 'chargeMinMs',            label: 'Min charge time',       unit: 'ms',    min: 0,    max: 4000,  step: 25,  value: 250 },
        { key: 'chargeMaxMs',            label: 'Max charge time',       unit: 'ms',    min: 0,    max: 4000,  step: 25,  value: 2000 },
        { key: 'rangeMinPx',             label: 'Min range',             unit: 'px',    min: 0,    max: 1000,  step: 5,   value: 875 },
        { key: 'rangeMaxPx',             label: 'Max range',             unit: 'px',    min: 0,    max: 1000,  step: 5,   value: 1000 },
        { key: 'damageMin',              label: 'Min damage',            unit: ' dmg',  min: 0,    max: 2000,  step: 5,   value: 70 },
        { key: 'damageMax',              label: 'Max damage',            unit: ' dmg',  min: 0,    max: 2000,  step: 5,   value: 210 },
        { key: 'projectileSpeedPxPerMs', label: 'Projectile speed',      unit: 'px/s',  min: 0,    max: 1000,  step: 1,   value: 900, scale: 'speed' },
        { key: 'widthPx',                label: 'Projectile width',      unit: 'px',    min: 0,    max: 1000,  step: 1,   value: 90 },
        { key: 'movementSlowPct',        label: 'Slow while charging',   unit: '%',     min: 0,    max: 100,   step: 1,   value: 25 },
        { key: 'canCancelCharge',        label: 'Charge can be cancelled',unit: '',      min: 0,    max: 1,     step: 1,   value: 1 }
      ]
    },
    edgeflare_mark: {
      id: 'edgeflare_mark',
      name: 'Edgeflare Mark',
      shortName: 'Edgeflare',
      description: 'Fire a high-speed tracer that tags the first foe hit. Your next strike detonates the mark for bonus damage.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 8000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 2000, step: 5, value: 1200 },
        { key: 'projectileWidthPx', label: 'Width', unit: 'px', min: 0, max: 400, step: 1, value: 160 },
        { key: 'projectileSpeedPxS', label: 'Speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1700, scale: 'speed' },
        { key: 'bonusDamage', label: 'Mark damage', unit: ' dmg', min: 0, max: 800, step: 5, value: 220 },
        { key: 'markDurationMs', label: 'Mark duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 4000 }
      ]
    },
    focused_lockshot: {
      id: 'focused_lockshot',
      name: 'Focused Lockshot',
      shortName: 'Lockshot',
      description: 'Lock onto an enemy champion, channel briefly, then fire a homing round that hunts the first champion it sees.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 200000, step: 50, value: 90000 },
        { key: 'castTimeMs', label: 'Channel', unit: 'ms', min: 0, max: 5000, step: 25, value: 1000 },
        { key: 'projectileRangePx', label: 'Target range', unit: 'px', min: 0, max: 6000, step: 10, value: 3500, scale: 'size' },
        { key: 'projectileSpeedPxS', label: 'Projectile speed', unit: 'px/s', min: 0, max: 6000, step: 10, value: 3200, scale: 'speed' },
        { key: 'projectileWidthPx', label: 'Projectile width', unit: 'px', min: 0, max: 400, step: 5, value: 80 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 2000, step: 5, value: 420 },
        { key: 'cancelCooldownMs', label: 'Cancel cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 5000 }
      ]
    },
    astral_snare: {
      id: 'astral_snare',
      name: 'Astral Snare',
      shortName: 'Snare',
      description: 'Launch a tethered bolt that slows the first enemy and can stun foes it drags behind them.',
      fields: [
        { key: 'cooldownMs',              label: 'Cooldown',               unit: 'ms', min: 0,    max: 30000, step: 50, value: 11000 },
        { key: 'castTimeMs',              label: 'Cast time',              unit: 'ms', min: 0,    max: 2500,  step: 25, value: 250 },
        { key: 'projectile_range_px',     label: 'Initial range',         unit: 'px', min: 0,    max: 2000,  step: 5,  value: 850 },
        { key: 'projectile_speed_px_per_ms', label: 'Bolt speed',           unit: 'px/s', min: 0,    max: 3000,  step: 10, value: 1500, scale: 'speed' },
        { key: 'projectile_width_px',     label: 'Bolt width',            unit: 'px', min: 0,    max: 200,   step: 1,  value: 28 },
        { key: 'afterHitRangePx',         label: 'After-hit range',       unit: 'px', min: 0,    max: 800,   step: 5,  value: 300 },
        { key: 'damage',                  label: 'Damage',                unit: ' dmg', min: 0,    max: 500,   step: 5,  value: 200 },
        { key: 'slowPct',                 label: 'Slow amount',           unit: '%',    min: 0,    max: 100,   step: 1,  value: 60 },
        { key: 'slowDurationMs',          label: 'Slow duration',         unit: 'ms', min: 0,    max: 5000,  step: 25, value: 1400 },
        { key: 'stunDurationMs',          label: 'Stun duration',         unit: 'ms', min: 0,    max: 4000,  step: 25, value: 1400 }
      ]
    },
    plasma_fission: {
      id: 'plasma_fission',
      name: 'Plasma Fission',
      shortName: 'Plasma Fission',
      description: 'Fire a slow that splits into twin bolts on command or when its trigger condition is met.',
      fields: [
        { key: 'cooldownMs',              label: 'Cooldown',                     unit: 'ms',    min: 0,    max: 60000, step: 50,   value: 7000 },
        { key: 'projectile_speed_px_per_ms', label: 'Projectile speed',          unit: 'px/s',  min: 0,    max: 1000,  step: 1,    value: 800, scale: 'speed' },
        { key: 'projectile_width_px',     label: 'Projectile width',              unit: 'px',    min: 0,    max: 1000,  step: 1,    value: 70 },
        { key: 'projectile_range_px',     label: 'Projectile range',              unit: 'px',    min: 0,    max: 1000,  step: 5,    value: 1000 },
        { key: 'split_angle_deg',         label: 'Split angle Â±',                unit: 'Â°',     min: 0,    max: 90,    step: 1,    value: 45 },
        { key: 'split_speed_px_per_ms',   label: 'Split bolt speed',              unit: 'px/s',  min: 0,    max: 1000,  step: 1,    value: 800, scale: 'speed' },
        { key: 'damage_flat',             label: 'Damage',                        unit: ' dmg',  min: 0,    max: 1000,  step: 5,    value: 80 },
        { key: 'slow_percent',            label: 'Slow amount',                   unit: '%',     min: 0,    max: 100,   step: 1,    value: 90 },
        { key: 'slow_duration_ms',        label: 'Slow duration',                 unit: 'ms',    min: 0,    max: 5000,  step: 25,   value: 1500 },
        { key: 'recast_window_ms',        label: 'Recast window',                 unit: 'ms',    min: 0,    max: 5000,  step: 25,   value: 1800 },
        { key: 'split_trigger',           label: 'Split trigger (0=recast,1=collision,2=end)', unit: '', min: 0, max: 2, step: 1, value: 1 }
      ]
    },
    scatter_charge: {
      id: 'scatter_charge',
      name: 'Scatter Charge',
      shortName: 'Scatter',
      description: 'Throw a timed charge that you can recast to detonate, blasting enemies outward and launching yourself if you are in the blast.',
      fields: [
        { key: 'cooldownMs',         label: 'Cooldown',            unit: 'ms',   min: 0, max: 60000, step: 50, value: 16000 },
        { key: 'castTimeMs',         label: 'Cast time',           unit: 'ms',   min: 0, max: 5000,  step: 25, value: 250 },
        { key: 'projectileSpeedPxS', label: 'Throw speed',         unit: 'px/s', min: 0, max: 4000,  step: 10, value: 1750, scale: 'speed' },
        { key: 'maxRangePx',         label: 'Throw range',         unit: 'px',   min: 0, max: 2000,  step: 10, value: 1000 },
        { key: 'chargeLifetimeMs',   label: 'Fuse time',           unit: 'ms',   min: 0, max: 10000, step: 50, value: 4000 },
        { key: 'aoeRadiusPx',        label: 'Blast radius',        unit: 'px',   min: 0, max: 1200,  step: 5,  value: 325 },
        { key: 'damage',             label: 'Blast damage',        unit: ' dmg', min: 0, max: 2000,  step: 5,  value: 150 },
        { key: 'knockbackMaxPx',     label: 'Knockback distance',  unit: 'px',   min: 0, max: 1200,  step: 5,  value: 500 },
        { key: 'selfDashMaxPx',      label: 'Self launch distance',unit: 'px',   min: 0, max: 1600,  step: 5,  value: 825 }
      ]
    },
    culling_barrage: {
      id: 'culling_barrage',
      name: 'Sweeping Barrage',
      shortName: 'Barrage',
      description: 'Hold a channel that unleashes a sweeping stream of first-hit bullets toward your aim.',
      fields: [
        { key: 'cooldownMs',          label: 'Cooldown',              unit: 'ms',   min: 0,    max: 60000, step: 50, value: 22000 },
        { key: 'channelDurationMs',   label: 'Channel duration',      unit: 'ms',   min: 0,    max: 10000, step: 10, value: 3000 },
        { key: 'shotIntervalMs',      label: 'Shot interval',         unit: 'ms',   min: 10,   max: 1000,  step: 5,  value: 80 },
        { key: 'projectileSpeedPxS',  label: 'Projectile speed',      unit: 'px/s', min: 0,    max: 1000,  step: 10, value: 900 },
        { key: 'projectileWidthPx',   label: 'Projectile width',      unit: 'px',   min: 0,    max: 1000,  step: 1,  value: 28 },
        { key: 'projectileRangePx',   label: 'Projectile range',      unit: 'px',   min: 0,    max: 1000,  step: 5,  value: 900 },
        { key: 'damagePerShot',       label: 'Damage per shot',       unit: ' dmg', min: 0,    max: 500,   step: 1,  value: 22 },
        { key: 'turnRateDegPerSec',   label: 'Aim turn rate',         unit: 'deg/s',min: 0,    max: 1440,  step: 10, value: 540 },
        { key: 'aimPreviewRangePx',   label: 'Aim preview length',    unit: 'px',   min: 0,    max: 1000,  step: 5,  value: 900 },
        { key: 'moveSpeedMultPct',    label: 'Move speed %',          unit: '%',    min: 0,    max: 100,   step: 1,  value: 60 },
        { key: 'allowDashDuringCh',   label: 'Allow dash while ch.',  unit: '',     min: 0,    max: 1,     step: 1,  value: 1 },
        { key: 'lockFacing',          label: 'Lock facing',           unit: '',     min: 0,    max: 1,     step: 1,  value: 1 },
        { key: 'projectilesPierce',   label: 'Projectiles pierce',    unit: '',     min: 0,    max: 1,     step: 1,  value: 0 }
      ]
    },
    purging_volley: {
      id: 'purging_volley',
      name: 'Purging Volley',
      shortName: 'Purge',
      description: 'Channel a razor barrage of bolts that fire down your aim line.',
      fields: [
        { key: 'cooldownMs',        label: 'Cooldown',          unit: 'ms',   min: 0,     max: 200000, step: 50, value: 90000 },
        { key: 'channelDurationMs', label: 'Channel duration',  unit: 'ms',   min: 0,     max: 6000,   step: 10, value: 3000 },
        { key: 'shotIntervalMs',    label: 'Shot interval',     unit: 'ms',   min: 10,    max: 1000,   step: 5,  value: 140 },
        { key: 'projectileSpeedPxS',label: 'Bolt speed',        unit: 'px/s', min: 0,     max: 4000,   step: 10, value: 2800, scale: 'speed' },
        { key: 'projectileWidthPx', label: 'Bolt width',        unit: 'px',   min: 0,     max: 200,    step: 1,  value: 32 },
        { key: 'projectileRangePx', label: 'Bolt range',        unit: 'px',   min: 0,     max: 2000,   step: 5,  value: 1200 },
        { key: 'damagePerShot',     label: 'Damage per shot',   unit: ' dmg', min: 0,     max: 500,    step: 5,  value: 48 },
        { key: 'aimPreviewRangePx', label: 'Aim preview',       unit: 'px',   min: 0,     max: 2000,   step: 5,  value: 1200 },
        { key: 'moveSpeedMultPct',  label: 'Move speed %',      unit: '%',    min: 0,     max: 200,    step: 1,  value: 60 },
        { key: 'allowDashDuringCh', label: 'Allow dash while ch.', unit: '',  min: 0,     max: 1,      step: 1,  value: 1 },
        { key: 'lockFacing',        label: 'Lock facing',       unit: '',     min: 0,     max: 1,      step: 1,  value: 1 },
        { key: 'projectilesPierce', label: 'Projectiles pierce', unit: '',    min: 0,     max: 1,      step: 1,  value: 0 }
      ]
    },
    verdict_salvo: {
      id: 'verdict_salvo',
      name: 'Verdict Salvo',
      shortName: 'Salvo',
      description: 'Lock onto a target while loading shots, then recast or auto-fire to unleash the stored volley down the line.',
      fields: [
        { key: 'cooldownMs',          label: 'Cooldown',             unit: 'ms',   min: 0,     max: 120000, step: 50,  value: 70000 },
        { key: 'channelDurationMs',   label: 'Channel duration',     unit: 'ms',   min: 0,     max: 10000,  step: 25,  value: 2500 },
        { key: 'recastDelayMs',       label: 'Recast unlock',        unit: 'ms',   min: 0,     max: 5000,   step: 10,  value: 500 },
        { key: 'maxStoredBullets',    label: 'Max stored shots',     unit: '',     min: 1,     max: 12,     step: 1,   value: 6 },
        { key: 'storeIntervalMs',     label: 'Store interval',       unit: 'ms',   min: 25,    max: 2000,   step: 5,   value: 520 },
        { key: 'fireIntervalMs',      label: 'Fire interval',        unit: 'ms',   min: 25,    max: 1000,   step: 5,   value: 120 },
        { key: 'projectileSpeedPxS',  label: 'Projectile speed',     unit: 'px/s', min: 0,     max: 6000,   step: 10,  value: 3200, scale: 'speed' },
        { key: 'projectileWidthPx',   label: 'Projectile width',     unit: 'px',   min: 0,     max: 400,    step: 1,   value: 120 },
        { key: 'projectileRangePx',   label: 'Projectile range',     unit: 'px',   min: 0,     max: 4000,   step: 5,   value: 2500 },
        { key: 'lockWidthPx',         label: 'Lock-on width',        unit: 'px',   min: 0,     max: 500,    step: 5,   value: 140, scale: 'size' },
        { key: 'damagePerShot',       label: 'Damage per shot',      unit: ' dmg', min: 0,     max: 2000,   step: 5,   value: 60 },
        { key: 'cancelCooldownMs',    label: 'Cooldown on cancel',   unit: 'ms',   min: 0,     max: 60000,  step: 50,  value: 5000 }
      ]
    },
    celestial_crash: {
      id: 'celestial_crash',
      name: 'Celestial Crash',
      shortName: 'Crash',
      description: 'Call down a blazing star that stuns enemies, building stardust to transform the next strike into a shockwave-pushing descent.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs',           label: 'Cooldown',              unit: 'ms',   min: 0,     max: 240000, step: 50,  value: 120000 },
        { key: 'castTimeMs',           label: 'Impact delay',          unit: 'ms',   min: 0,     max: 5000,   step: 25,  value: 1250 },
        { key: 'maxRangePx',           label: 'Target range',          unit: 'px',   min: 0,     max: 5000,   step: 10,  value: 1250, scale: 'size' },
        { key: 'impactRadius',         label: 'Impact radius',         unit: 'px',   min: 0,     max: 1500,   step: 5,   value: 300, scale: 'size' },
        { key: 'damage',               label: 'Impact damage',         unit: ' dmg', min: 0,     max: 2000,   step: 5,   value: 240 },
        { key: 'stunDurationMs',       label: 'Impact stun',           unit: 'ms',   min: 0,     max: 5000,   step: 25,  value: 1000 },
        { key: 'stardustPerHit',       label: 'Stardust per hit',      unit: '',     min: 0,     max: 100,    step: 1,   value: 5 },
        { key: 'stardustThreshold',    label: 'Stardust to empower',   unit: '',     min: 0,     max: 500,    step: 5,   value: 75 },
        { key: 'empoweredCastTimeMs',  label: 'Empowered delay',       unit: 'ms',   min: 0,     max: 5000,   step: 25,  value: 2000 },
        { key: 'empoweredRadius',      label: 'Empowered radius',      unit: 'px',   min: 0,     max: 2000,   step: 5,   value: 360, scale: 'size' },
        { key: 'empoweredDamage',      label: 'Empowered damage',      unit: ' dmg', min: 0,     max: 2500,   step: 5,   value: 300 },
        { key: 'shockRadius',          label: 'Shockwave radius',      unit: 'px',   min: 0,     max: 3500,   step: 5,   value: 900, scale: 'size' },
        { key: 'shockDamage',          label: 'Shockwave damage',      unit: ' dmg', min: 0,     max: 2000,   step: 5,   value: 200 },
        { key: 'shockSlowPct',         label: 'Shockwave slow',        unit: '%',    min: 0,     max: 100,    step: 1,   value: 50 },
        { key: 'shockSlowDurationMs',  label: 'Slow duration',         unit: 'ms',   min: 0,     max: 5000,   step: 25,  value: 1000 },
        { key: 'shockDurationMs',      label: 'Shockwave duration',    unit: 'ms',   min: 0,     max: 10000,  step: 25,  value: 3000 }
      ]
    },
    rite_arcane: {
      id: 'rite_arcane',
      name: 'Rite of the Arcane',
      shortName: 'Rite',
      description: 'Enter Artillery Mode to queue delayed explosions on ground clicks. Ends when charges or time expire.',
      fields: [
        { key: 'cooldownMs',      label: 'Cooldown',            unit: 'ms', min: 0, max: 60000, step: 50, value: 20000 },
        { key: 'modeDurationMs',  label: 'Artillery duration',  unit: 'ms', min: 0, max: 20000, step: 50, value: 8000 },
        { key: 'modeCharges',     label: 'Charges',             unit: '',   min: 0, max: 12,    step: 1,  value: 4 },
        { key: 'explosionDelayMs',label: 'Explosion delay',     unit: 'ms', min: 0, max: 6000,  step: 25, value: 900 },
        { key: 'damage',          label: 'Explosion damage',    unit: ' dmg', min: 0, max: 2000, step: 10, value: 280 },
        { key: 'aoeRadiusPx',     label: 'Explosion radius',    unit: 'px', min: 0, max: 2400, step: 5, value: 220 },
        { key: 'minRangePx',      label: 'Min targeting range', unit: 'px', min: 0, max: 1000, step: 5, value: 420 },
        { key: 'maxRangePx',      label: 'Max targeting range', unit: 'px', min: 0, max: 1000, step: 10, value: 900 },
        { key: 'cancelOnStun',    label: 'Cancelled by stun',   unit: '',   min: 0, max: 1, step: 1, value: 1 },
        { key: 'cancelOnSilence', label: 'Cancelled by silence',unit: '',   min: 0, max: 1, step: 1, value: 0 }
      ]
    },
    shiver_maelstrom: {
      id: 'shiver_maelstrom',
      name: 'Shiver Maelstrom',
      shortName: 'Maelstrom',
      description: 'Drop a growing blizzard at a target point. It expands over time, ticking damage and slowing while active. Recast to collapse it.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs',               label: 'Cooldown',                 unit: 'ms',  min: 0,    max: 60000, step: 50, value: 4000 },
        { key: 'castTimeMs',               label: 'Cast time',                unit: 'ms',  min: 0,    max: 3000,  step: 25, value: 0 },
        { key: 'maxRangePx',               label: 'Cast range',               unit: 'px',  min: 0,    max: 1500,  step: 5,  value: 750, scale: 'size' },
        { key: 'startRadiusPx',            label: 'Start radius',             unit: 'px',  min: 0,    max: 1000,  step: 5,  value: 200, scale: 'size' },
        { key: 'maxRadiusPx',              label: 'Max radius',               unit: 'px',  min: 0,    max: 1400,  step: 5,  value: 400, scale: 'size' },
        { key: 'expandDurationMs',         label: 'Expand time',              unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1500 },
        { key: 'tickDamage',               label: 'Damage per tick',          unit: ' dmg',min: 0,    max: 4000,  step: 5,  value: 40 },
        { key: 'empoweredDamage',          label: 'Damage at max size',       unit: ' dmg',min: 0,    max: 6000,  step: 5,  value: 120 },
        { key: 'tickIntervalMs',           label: 'Tick interval',            unit: 'ms',  min: 50,   max: 2000,  step: 25, value: 500 },
        { key: 'empoweredTickIntervalMs',  label: 'Tick interval at max',     unit: 'ms',  min: 50,   max: 2000,  step: 25, value: 250 },
        { key: 'slowPct',                  label: 'Slow amount',              unit: '%',   min: 0,    max: 100,   step: 1,  value: 25 },
        { key: 'empoweredSlowPct',         label: 'Slow at max',              unit: '%',   min: 0,    max: 100,   step: 1,  value: 50 },
        { key: 'slowDurationMs',           label: 'Slow duration',            unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1000 },
        { key: 'empoweredSlowDurationMs',  label: 'Slow duration at max',     unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1500 },
        { key: 'recastDelayMs',            label: 'Recast unlock',            unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1000 },
        { key: 'tetherRangePx',            label: 'Tether range',             unit: 'px',  min: 0,    max: 2000,  step: 5,  value: 1000, scale: 'size' },
        { key: 'maxDurationMs',            label: 'Storm duration',           unit: 'ms',  min: 0,    max: 60000, step: 50, value: 9000 }
      ]
    },
    hailbound_tempest: {
      id: 'hailbound_tempest',
      name: 'Hailbound Tempest',
      shortName: 'Tempest',
      description: 'Call a growing hailstorm at a target point that shreds and slows foes, then collapse it with a recast for one last burst.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs',               label: 'Cooldown',                 unit: 'ms',  min: 0,    max: 60000, step: 50, value: 12000 },
        { key: 'castTimeMs',               label: 'Cast time',                unit: 'ms',  min: 0,    max: 3000,  step: 25, value: 0 },
        { key: 'maxRangePx',               label: 'Cast range',               unit: 'px',  min: 0,    max: 1500,  step: 5,  value: 750, scale: 'size' },
        { key: 'startRadiusPx',            label: 'Start radius',             unit: 'px',  min: 0,    max: 1000,  step: 5,  value: 200, scale: 'size' },
        { key: 'maxRadiusPx',              label: 'Max radius',               unit: 'px',  min: 0,    max: 1400,  step: 5,  value: 400, scale: 'size' },
        { key: 'expandDurationMs',         label: 'Expand time',              unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1500 },
        { key: 'tickDamage',               label: 'Damage per tick',          unit: ' dmg',min: 0,    max: 4000,  step: 5,  value: 30 },
        { key: 'empoweredDamage',          label: 'Damage at max size',       unit: ' dmg',min: 0,    max: 6000,  step: 5,  value: 90 },
        { key: 'tickIntervalMs',           label: 'Tick interval',            unit: 'ms',  min: 50,   max: 2000,  step: 25, value: 500 },
        { key: 'empoweredTickIntervalMs',  label: 'Tick interval at max',     unit: 'ms',  min: 50,   max: 2000,  step: 25, value: 250 },
        { key: 'slowPct',                  label: 'Slow amount',              unit: '%',   min: 0,    max: 100,   step: 1,  value: 30 },
        { key: 'empoweredSlowPct',         label: 'Slow at max',              unit: '%',   min: 0,    max: 100,   step: 1,  value: 45 },
        { key: 'slowDurationMs',           label: 'Slow duration',            unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1000 },
        { key: 'empoweredSlowDurationMs',  label: 'Slow duration at max',     unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1500 },
        { key: 'recastDelayMs',            label: 'Recast unlock',            unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1000 },
        { key: 'tetherRangePx',            label: 'Tether range',             unit: 'px',  min: 0,    max: 2000,  step: 5,  value: 1000, scale: 'size' },
        { key: 'maxDurationMs',            label: 'Storm duration',           unit: 'ms',  min: 0,    max: 60000, step: 50, value: 8000 }
      ]
    },
    frost_surge: {
      id: 'frost_surge',
      name: 'Frost Surge',
      shortName: 'Surge',
      description: 'Call an expanding blizzard at a target point. It grows, dealing damage and slowing enemies; at full size it strikes faster and harder. Recast to collapse it for a final tick.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs',               label: 'Cooldown',                 unit: 'ms',  min: 0,    max: 60000, step: 50, value: 4000 },
        { key: 'castTimeMs',               label: 'Cast time',                unit: 'ms',  min: 0,    max: 3000,  step: 25, value: 0 },
        { key: 'maxRangePx',               label: 'Cast range',               unit: 'px',  min: 0,    max: 1500,  step: 5,  value: 750, scale: 'size' },
        { key: 'startRadiusPx',            label: 'Start radius',             unit: 'px',  min: 0,    max: 1000,  step: 5,  value: 200, scale: 'size' },
        { key: 'maxRadiusPx',              label: 'Max radius',               unit: 'px',  min: 0,    max: 1400,  step: 5,  value: 400, scale: 'size' },
        { key: 'expandDurationMs',         label: 'Expand time',              unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1500 },
        { key: 'tickDamage',               label: 'Damage per tick',          unit: ' dmg',min: 0,    max: 4000,  step: 5,  value: 30 },
        { key: 'empoweredDamage',          label: 'Damage at max size',       unit: ' dmg',min: 0,    max: 6000,  step: 5,  value: 90 },
        { key: 'tickIntervalMs',           label: 'Tick interval',            unit: 'ms',  min: 50,   max: 2000,  step: 25, value: 500 },
        { key: 'empoweredTickIntervalMs',  label: 'Tick interval at max',     unit: 'ms',  min: 50,   max: 2000,  step: 25, value: 250 },
        { key: 'slowPct',                  label: 'Slow amount',              unit: '%',   min: 0,    max: 100,   step: 1,  value: 30 },
        { key: 'empoweredSlowPct',         label: 'Slow at max',              unit: '%',   min: 0,    max: 100,   step: 1,  value: 45 },
        { key: 'slowDurationMs',           label: 'Slow duration',            unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1000 },
        { key: 'empoweredSlowDurationMs',  label: 'Slow duration at max',     unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1500 },
        { key: 'recastDelayMs',            label: 'Recast unlock',            unit: 'ms',  min: 0,    max: 10000, step: 25, value: 1000 },
        { key: 'tetherRangePx',            label: 'Tether range',             unit: 'px',  min: 0,    max: 2000,  step: 5,  value: 1000, scale: 'size' },
        { key: 'maxDurationMs',            label: 'Storm duration',           unit: 'ms',  min: 0,    max: 60000, step: 50, value: 8000 }
      ]
    },
    mourning_march: {
      id: 'mourning_march',
      name: 'Mourning March',
      shortName: 'March',
      description: 'Call a Maiden and her Mist Walkers to your target point. After a short delay, recast to send them down the nearest lane.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs',      label: 'Cooldown',         unit: 'ms',  min: 0,    max: 300000, step: 50, value: 160000 },
        { key: 'castTimeMs',      label: 'Cast time',        unit: 'ms',  min: 0,    max: 5000,   step: 25, value: 500 },
        { key: 'summonRangePx',   label: 'Summon range',     unit: 'px',  min: 0,    max: 5000,   step: 10, value: 600 },
        { key: 'maidenHp',        label: 'Maiden HP',        unit: ' hp', min: 1,    max: 10000,  step: 10, value: 1400 },
        { key: 'maidenDamage',    label: 'Maiden damage',    unit: ' dmg',min: 0,    max: 1000,   step: 5,  value: 120 },
        { key: 'walkerCount',     label: 'Walker count',     unit: '',    min: 0,    max: 6,      step: 1,  value: 3 },
        { key: 'walkerHp',        label: 'Walker HP',        unit: ' hp', min: 1,    max: 5000,   step: 5,  value: 420 },
        { key: 'walkerDamage',    label: 'Walker damage',    unit: ' dmg',min: 0,    max: 500,    step: 5,  value: 45 },
        { key: 'releaseDelayMs',  label: 'Recast unlock',    unit: 'ms',  min: 0,    max: 60000,  step: 50, value: 10000 },
        { key: 'leashRangePx',    label: 'Escort leash',     unit: 'px',  min: 0,    max: 2000,   step: 5,  value: 320 }
      ]
    },
    skyward_scout: {
      id: 'skyward_scout',
      name: 'Skyward Scout',
      shortName: 'Sky Scout',
      description: 'Send a spirit hawk that reveals the sky for a short time. It grants brief vision along its path and at its landing point.',
      castType: 'quick',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 5000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'maxRangePx', label: 'Range', unit: 'px', min: 0, max: 7000, step: 10, value: 6000, scale: 'size' },
        { key: 'visionRadiusPx', label: 'Vision radius', unit: 'px', min: 0, max: 2000, step: 10, value: 1000, scale: 'size' },
        { key: 'speedPxS', label: 'Flight speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1400, scale: 'speed' },
        { key: 'pulseSpacingPx', label: 'Trail spacing', unit: 'px', min: 20, max: 800, step: 5, value: 100 },
        { key: 'pulseDurationMs', label: 'Trail duration', unit: 'ms', min: 50, max: 2000, step: 25, value: 500 },
        { key: 'destinationDurationMs', label: 'Landing vision', unit: 'ms', min: 1000, max: 20000, step: 100, value: 5000 },
        { key: 'maxCharges', label: 'Max charges', unit: '', min: 1, max: 5, step: 1, value: 2 },
        { key: 'chargeRechargeMs', label: 'Charge recharge', unit: 'ms', min: 1000, max: 120000, step: 1000, value: 90000 }
      ]
    },
    temporal_veil: {
      id: 'temporal_veil',
      name: 'Temporal Veil',
      shortName: 'Veil',
      description: 'Arc a shimmering field that reveals its travel path and locks the landing zone in stasis.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 200000, step: 50, value: 110000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 500 },
        { key: 'maxRangePx', label: 'Range', unit: 'px', min: 0, max: 7000, step: 10, value: 3400, scale: 'size' },
        { key: 'travelSpeedPxS', label: 'Arc speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2200, scale: 'speed' },
        { key: 'aoeRadiusPx', label: 'Impact radius', unit: 'px', min: 0, max: 1200, step: 5, value: 350, scale: 'size' },
        { key: 'stunDurationMs', label: 'Stasis duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 2500 },
        { key: 'revealDurationMs', label: 'Reveal duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 2500 },
        { key: 'trailRadiusPx', label: 'Trail radius', unit: 'px', min: 0, max: 1200, step: 5, value: 180, scale: 'size' },
        { key: 'trailSpacingPx', label: 'Trail spacing', unit: 'px', min: 10, max: 1200, step: 5, value: 200 },
        { key: 'trailDurationMs', label: 'Trail vision duration', unit: 'ms', min: 50, max: 5000, step: 25, value: 1200 }
      ]
    },
    cinderfall_guardian: {
      id: 'cinderfall_guardian',
      name: 'Cinderfall Guardian',
      shortName: 'Cinderfall',
      description: 'Crash a burning guardian at the target point, scorching nearby foes and leaving it under your command. Recast to send the guardian to a new location while it persists.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs',     label: 'Cooldown',          unit: 'ms',  min: 0,    max: 300000, step: 50,   value: 120000 },
        { key: 'castTimeMs',     label: 'Cast time',         unit: 'ms',  min: 0,    max: 2000,   step: 25,   value: 250 },
        { key: 'summonRangePx',  label: 'Summon range',      unit: 'px',  min: 0,    max: 2000,   step: 5,    value: 600 },
        { key: 'impactRadius',   label: 'Ignition radius',   unit: 'px',  min: 0,    max: 800,    step: 5,    value: 280, scale: 'size' },
        { key: 'damage',         label: 'Impact damage',     unit: ' dmg',min: 0,    max: 2000,   step: 5,    value: 320 },
        { key: 'petHp',          label: 'Guardian HP',       unit: ' hp', min: 1,    max: 12000,  step: 10,   value: 2200 },
        { key: 'petDamage',      label: 'Guardian damage',   unit: ' dmg',min: 0,    max: 600,    step: 5,    value: 90 },
        { key: 'petDurationMs',  label: 'Guardian duration', unit: 'ms',  min: 0,    max: 120000, step: 1000, value: 45000 },
        { key: 'petLeashPx',     label: 'Leash radius',      unit: 'px',  min: 0,    max: 1500,   step: 5,    value: 420, scale: 'size' }
      ]
    },
    event_horizon: {
      id: 'event_horizon',
      name: 'Event Horizon',
      shortName: 'Horizon',
      description: 'Summon a void that drags foes inward, slams them with repeated damage, and finishes off weakened enemies in the center.',
      castType: 'quickIndicator',
      fields: [
        { key: 'cooldownMs',          label: 'Cooldown',          unit: 'ms', min: 0,    max: 60000, step: 50,  value: 12000 },
        { key: 'castTimeMs',          label: 'Cast time',         unit: 'ms', min: 0,    max: 2000,  step: 25,  value: 500 },
        { key: 'maxRangePx',          label: 'Cast range',        unit: 'px', min: 0,    max: 2000,  step: 5,   value: 900, scale: 'size' },
        { key: 'durationMs',          label: 'Duration',          unit: 'ms', min: 0,    max: 10000, step: 25,  value: 5000 },
        { key: 'outerRadiusPx',       label: 'Outer radius',      unit: 'px', min: 0,    max: 1200,  step: 5,   value: 280, scale: 'size' },
        { key: 'innerRadiusPx',       label: 'Center radius',     unit: 'px', min: 0,    max: 600,   step: 5,   value: 140, scale: 'size' },
        { key: 'damagePerTick',       label: 'Damage per tick',   unit: ' dmg',min: 0,    max: 1000,  step: 5,   value: 65 },
        { key: 'tickIntervalMs',      label: 'Tick interval',     unit: 'ms', min: 50,   max: 1000,  step: 10,  value: 250 },
        { key: 'pullSpeedPxS',        label: 'Pull speed',        unit: 'px/s',min: 0,   max: 2000,  step: 10,  value: 260, scale: 'speed' },
        { key: 'slowPct',             label: 'Slow amount',       unit: '%', min: 0,    max: 100,   step: 1,   value: 100 },
        { key: 'slowDurationMs',      label: 'Slow duration',     unit: 'ms', min: 0,    max: 5000,  step: 25,  value: 250 },
        { key: 'executeThresholdPct', label: 'Execute threshold', unit: '%', min: 0,    max: 100,   step: 1,   value: 5 }
      ]
    },
    trailblaze: {
      id: 'trailblaze',
      name: 'Trailblaze',
      shortName: 'Trailblaze',
      description: 'Dash toward a point while dropping blazing patches that scorch enemies across your path.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 200000, step: 50, value: 18000 },
        { key: 'dashDistancePx', label: 'Dash range', unit: 'px', min: 0, max: 1200, step: 5, value: 650, scale: 'size' },
        { key: 'dashSpeedPxS', label: 'Dash speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 650, scale: 'speed' },
        { key: 'movementSpeedBonusPct', label: 'Movement speed bonus', unit: '%', min: 0, max: 200, step: 5, value: 100 },
        { key: 'patchRadiusPx', label: 'Patch radius', unit: 'px', min: 0, max: 400, step: 5, value: 200, scale: 'size' },
        { key: 'maxPatches', label: 'Max patches', unit: '', min: 1, max: 5, step: 1, value: 3 },
        { key: 'patchSpacingPx', label: 'Patch spacing', unit: 'px', min: 10, max: 600, step: 5, value: 220 },
        { key: 'patchDurationMs', label: 'Patch duration', unit: 'ms', min: 0, max: 6000, step: 25, value: 2500 },
        { key: 'lingerDurationMs', label: 'Lingering duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 1000 },
        { key: 'tickIntervalMs', label: 'Tick interval', unit: 'ms', min: 50, max: 2000, step: 25, value: 500 },
        { key: 'damagePerTick', label: 'Damage per tick', unit: ' dmg', min: 0, max: 500, step: 5, value: 80 }
      ]
    },
    blade_cyclone: {
      id: 'blade_cyclone',
      name: 'Blade Cyclone',
      shortName: 'Cyclone',
      description: 'Spin a blade in place, clobbering every nearby enemy with twin slashes.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 40000, step: 50, value: 18000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 100 },
        { key: 'durationMs', label: 'Spin duration', unit: 'ms', min: 0, max: 2000, step: 25, value: 750 },
        { key: 'bladeRadiusPx', label: 'Spin radius', unit: 'px', min: 0, max: 600, step: 5, value: 325, scale: 'size' },
        { key: 'damage', label: 'Damage per slash', unit: ' dmg', min: 0, max: 400, step: 5, value: 110 }
      ]
    },
    spiral_ram: {
      id: 'spiral_ram',
      name: 'Spiral Ram',
      shortName: 'Spiral Ram',
      description: 'Curl into a rolling shell, accelerate for several seconds, then slam through enemies to damage, stun, slow, and reveal them.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 40000, step: 50, value: 12000 },
        { key: 'channelDurationMs', label: 'Channel duration', unit: 'ms', min: 0, max: 10000, step: 50, value: 6000 },
        { key: 'manualRecastDelayMs', label: 'Recast delay', unit: 'ms', min: 0, max: 5000, step: 50, value: 1000 },
        { key: 'speedGainPerSecondPct', label: 'Speed gain per second', unit: '%', min: 0, max: 100, step: 1, value: 32 },
        { key: 'maxBonusMoveSpeedPct', label: 'Max bonus speed', unit: '%', min: 0, max: 400, step: 5, value: 180 },
        { key: 'collisionRadiusPx', label: 'Collision radius', unit: 'px', min: 0, max: 200, step: 1, value: 75, scale: 'size' },
        { key: 'impactRadiusPx', label: 'Impact radius', unit: 'px', min: 0, max: 400, step: 5, value: 250, scale: 'size' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 600, step: 5, value: 220 },
        { key: 'knockbackDistancePx', label: 'Knockback distance', unit: 'px', min: 0, max: 400, step: 5, value: 125, scale: 'size' },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 2000, step: 25, value: 400 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 60 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 1000 },
        { key: 'revealRadiusPx', label: 'Reveal radius', unit: 'px', min: 0, max: 400, step: 5, value: 250, scale: 'size' },
        { key: 'revealDurationMs', label: 'Reveal duration', unit: 'ms', min: 0, max: 3000, step: 50, value: 400 }
      ]
    },
    windpiercer_rush: {
      id: 'windpiercer_rush',
      name: 'Windpiercer Rush',
      shortName: 'Rush',
      description: 'Dash through foes with a steel-bound thrust, earning tempest stacks that empower the next cast into a storming explosion.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 40000, step: 50, value: 12000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 150 },
        { key: 'dashDistancePx', label: 'Dash distance', unit: 'px', min: 0, max: 1200, step: 5, value: 700, scale: 'size' },
        { key: 'dashWidthPx', label: 'Trail width', unit: 'px', min: 0, max: 400, step: 5, value: 96 },
        { key: 'damage', label: 'Dash damage', unit: ' dmg', min: 0, max: 600, step: 5, value: 180 },
        { key: 'empowerRadiusPx', label: 'Empower radius', unit: 'px', min: 0, max: 600, step: 5, value: 220, scale: 'size' },
        { key: 'empowerDamage', label: 'Empower damage', unit: ' dmg', min: 0, max: 400, step: 5, value: 130 },
        { key: 'stackDurationMs', label: 'Stack duration', unit: 'ms', min: 0, max: 10000, step: 50, value: 6000 }
      ]
    },
    inferno_barrage: {
      id: 'inferno_barrage',
      name: 'Inferno Barrage',
      shortName: 'Inferno',
      description: 'Channel a bursty hail of shots that hits nearby enemies multiple times.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 18000 },
        { key: 'durationMs', label: 'Channel duration', unit: 'ms', min: 0, max: 5000, step: 25, value: 2277 },
        { key: 'shotIntervalMs', label: 'Shot interval', unit: 'ms', min: 50, max: 1000, step: 10, value: 200 },
        { key: 'effectRadiusPx', label: 'Effect radius', unit: 'px', min: 0, max: 1200, step: 5, value: 600, scale: 'size' },
        { key: 'rangePx', label: 'Target range', unit: 'px', min: 0, max: 1200, step: 5, value: 600, scale: 'size' },
        { key: 'damage', label: 'Damage per shot', unit: ' dmg', min: 0, max: 400, step: 5, value: 25 },
        { key: 'minionDamagePct', label: 'Minion damage %', unit: '%', min: 0, max: 100, step: 5, value: 25 }
      ]
    }
  });

  const abilityIndicatorProfiles = {
    beam: { type: 'line', lengthKey: 'beamLength', widthKey: 'beamWidth', fixedLength: true },
    focused_lockshot: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    grab: { type: 'trapezoid', lengthKey: 'grabRange', startWidthKey: 'grabWidthCenter', endWidthKey: 'grabWidthEdge', fixedLength: true },
    backline_seizure: { type: 'line', lengthKey: 'strikeRangePx', widthKey: 'strikeWidthPx', fixedLength: true },
    wrapdash: { type: 'trapezoid', lengthKey: 'grabRange', startWidthKey: 'grabWidthCenter', endWidthKey: 'grabWidthEdge', fixedLength: true },
    link_lash: { type: 'trapezoid', lengthKey: 'lashRange', startWidthKey: 'lashWidthStart', endWidthKey: 'lashWidthEnd', fixedLength: true },
    laserCone: {
      type: 'cone',
      lengthKey: 'laserDistance',
      widthKey: 'laserWidth',
      projectileWidthKey: 'laserProjectileWidth',
      countKey: 'laserCount',
      fixedLength: true
    },
    duskwave_infernum: {
      type: 'cone',
      lengthKey: 'coneRangePx',
      widthKey: 'coneWidthPx',
      fixedLength: true
    },
    gravity_surge: {
      type: 'line',
      lengthKey: 'projectileRangePx',
      widthKey: 'projectileWidthPx',
      fixedLength: true
    },
    sirens_kiss: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    shiver_spike: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    kunai_fanburst: {
      type: 'cone',
      lengthKey: 'laserDistance',
      widthKey: 'laserWidth',
      projectileWidthKey: 'laserProjectileWidth',
      countKey: 'laserCount',
      fixedLength: true
    },
    shiver_maelstrom: { type: 'aoe', radiusKey: 'maxRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    slam: { type: 'slam', impactRadiusKey: 'impactRadius', fissureLengthKey: 'fissureLength', fissureWidthKey: 'fissureWidth', fixedLength: true },
    blade_cyclone: { type: 'aoe', radiusKey: 'bladeRadiusPx', distanceKey: 'bladeRadiusPx', showRangeRing: true },
    plasma_fission: {
      type: 'line',
      lengthKey: 'projectile_range_px',
      widthKey: 'projectile_width_px',
      splitAngleKey: 'split_angle_deg'
    },
    shatterburst_orb: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    rebound_orb: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    piercing_arrow: { type: 'chargeLine', minLengthKey: 'rangeMinPx', maxLengthKey: 'rangeMaxPx', widthKey: 'widthPx', chargeSpell: true },
    charging_gale: { type: 'chargeLine', minLengthKey: 'minRangePx', maxLengthKey: 'maxRangePx', widthKey: 'widthPx', chargeSpell: true },
    avalanche_roll: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    slingshot_crash: { type: 'blink', rangeKey: 'maxRangePx', aoeRadiusKey: 'impactRadius' },
    bone_skewer: { type: 'chargeLine', minLengthKey: 'rangeMinPx', maxLengthKey: 'rangeMaxPx', widthKey: 'widthEndPx', chargeSpell: true },
    blinkingBolt: { type: 'blink', rangeKey: 'blinkDistance', aoeRadiusKey: 'blinkDistance' },
    flipblade_pursuit: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    cyclone_axes: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    boltburst_rush: { type: 'blink', rangeKey: 'dashDistancePx', aoeRadiusKey: 'boltSeekRadiusPx' },
    windpiercer_rush: { type: 'blink', rangeKey: 'dashDistancePx', aoeRadiusKey: 'empowerRadiusPx' },
    riptide_snapback: { type: 'blink', rangeKey: 'dashDistancePx', aoeRadiusKey: 'impactRadiusPx' },
    chrono_loop: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    skull_rush: { type: 'blink', rangeKey: 'dashDistancePx', aoeRadiusKey: 'impactRadius' },
    skyhook_strafe: { type: 'line', lengthKey: 'hookRangePx', widthKey: 'hookWidthPx', fixedLength: true },
    twinstrike_pursuit: { type: 'blink', rangeKey: 'firstDashRangePx', aoeRadiusKey: 'dashWidthPx' },
    ricochet_lob: { type: 'aoe', radiusKey: 'explosionRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    dirge_bloom: { type: 'aoe', radiusKey: 'aoeRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    event_horizon: { type: 'aoe', radiusKey: 'outerRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    hailbound_tempest: { type: 'aoe', radiusKey: 'maxRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    frost_surge: { type: 'aoe', radiusKey: 'maxRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    culling_barrage: { type: 'line', lengthKey: 'aimPreviewRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    verdict_salvo: { type: 'line', lengthKey: 'projectileRangePx', widthKey: 'projectileWidthPx', fixedLength: true },
    proximity_traps: {
      type: 'trapPlacement',
      rangeKey: 'maxPlaceRangePx',
      triggerRadiusKey: 'triggerRadiusPx',
      aoeRadiusKey: 'aoeRadiusPx',
      countKey: 'dropCount',
      spacingKey: 'placementSpacingPx',
      minSpacingKey: 'minTrapSpacingPx',
      modeKey: 'placementMode'
    },
    scatter_minefield: {
      type: 'trapPlacement',
      rangeKey: 'maxPlaceRangePx',
      triggerRadiusKey: 'triggerRadiusPx',
      aoeRadiusKey: 'aoeRadiusPx',
      countKey: 'dropCount',
      spacingKey: 'placementSpacingPx',
      minSpacingKey: 'minTrapSpacingPx',
      modeKey: 'placementMode'
    },
    edgewatch_snare: {
      type: 'trapPlacement',
      rangeKey: 'maxPlaceRangePx',
      triggerRadiusKey: 'triggerRadiusPx',
      aoeRadiusKey: 'aoeRadiusPx',
      countKey: 'dropCount',
      spacingKey: 'placementSpacingPx',
      minSpacingKey: 'minTrapSpacingPx',
      modeKey: 'placementMode'
    },
    scatter_charge: { type: 'aoe', radiusKey: 'aoeRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    spectral_stockade: { type: 'aoe', radiusKey: 'wallRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true, innerRadiusKey: 'innerPullRadiusPx' },
    cinderfall_guardian: { type: 'aoe', radiusKey: 'impactRadius', distanceKey: 'summonRangePx', showRangeRing: true },
    glacial_uplift: { type: 'wall', lengthKey: 'wallLengthPx', widthKey: 'wallThicknessPx', distanceKey: 'maxRangePx', showRangeRing: true },
    mourning_march: { type: 'aoe', radiusKey: 'leashRangePx', distanceKey: 'summonRangePx', showRangeRing: true },
    temporal_veil: { type: 'aoe', radiusKey: 'aoeRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    celestial_crash: { type: 'aoe', radiusKey: 'impactRadius', distanceKey: 'maxRangePx', showRangeRing: true },
    inferno_barrage: { type: 'aoe', radiusKey: 'effectRadiusPx', distanceKey: 'rangePx', showRangeRing: true },
    rite_arcane: { type: 'aoe', radiusKey: 'aoeRadiusPx', distanceKey: 'maxRangePx', showRangeRing: true },
    serpents_bloom: { type: 'aoe', radiusKey: 'radiusPx', distanceKey: 'targetRangePx', showRangeRing: true },
    stone_gaze: { type: 'cone', lengthKey: 'targetRangePx', widthKey: 'coneWidthPx', fixedLength: true },
    spiral_gale: { type: 'cone', lengthKey: 'coneRangePx', widthKey: 'coneWidthPx', fixedLength: true },
    phantom_return: { type: 'blink', rangeKey: 'dashDistancePx' }
  };

  const abilitySystem = createAbilitySystem({
    abilityDefinitions,
    abilityTunables,
    SPELL_SCALE_MIN,
    SPELL_SCALE_MAX,
    renderAbilityBar,
    isAbilityRepoOpen,
    updateAbilityRepoSubtitle,
    renderSpellList,
    spellSpeedScaleInput,
    spellSizeScaleInput,
    abilityAllowedCastTypes,
    defaultAbilityCastType,
    normalizeCastType
  });
  const {
    listAbilities,
    getAbilityDefinition,
    abilityField,
    isSpellSpeedField,
    isSpellSizeField,
    abilityFieldValue,
    clampFieldValue,
    abilitySummary,
    clampSpellScale,
    refreshAbilitiesForSpellScaling,
    setSpellSpeedScale,
    setSpellSizeScale,
    normalizeAbilityCastType
  } = abilitySystem;

  const perfState = {
    lastSample: (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now()),
    frameSum: 0,
    frameCount: 0,
    lastFps: 0,
    lastFrameMs: 0,
    updateSum: 0,
    renderSum: 0,
    updateMax: 0,
    renderMax: 0,
    circleSum: 0,
    pathfindCalls: 0,
    pathfindNodes: 0,
    minimapRenders: 0,
    intervalMax: 0,
    lastFrameStart: null,
    lastSpike: null,
    history: []
  };

  const perfCounters = {
    circleChecks: 0,
    pathfindCalls: 0,
    pathfindNodesVisited: 0,
    minimapRenders: 0
  };

  const PATHFIND_BUDGET_PER_FRAME = 3;
  let pathfindBudget = PATHFIND_BUDGET_PER_FRAME;
  let stressNavMode = false;

  function perfNow(){
    return (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  }

  function perfProjectileCount(){
    let total = 0;
    if(Array.isArray(projectiles)) total += projectiles.length;
    if(Array.isArray(piercingArrowProjectiles)) total += piercingArrowProjectiles.length;
    if(Array.isArray(plasmaFissionProjectiles)) total += plasmaFissionProjectiles.length;
    if(Array.isArray(chargingGaleProjectiles)) total += chargingGaleProjectiles.length;
    if(Array.isArray(slingshotCrashLeaps)) total += slingshotCrashLeaps.length;
    if(Array.isArray(cullingBarrageProjectiles)) total += cullingBarrageProjectiles.length;
    if(Array.isArray(laserProjectiles)) total += laserProjectiles.length;
    if(Array.isArray(blinkingBoltProjectiles)) total += blinkingBoltProjectiles.length;
    if(Array.isArray(emberWaltzFlames)) total += emberWaltzFlames.length;
    if(Array.isArray(flipbladeProjectiles)) total += flipbladeProjectiles.length;
    if(Array.isArray(shatterburstOrbProjectiles)) total += shatterburstOrbProjectiles.length;
    if(Array.isArray(reboundOrbProjectiles)) total += reboundOrbProjectiles.length;
    if(Array.isArray(ricochetBombProjectiles)) total += ricochetBombProjectiles.length;
    if(Array.isArray(snapbackEchoes)) total += snapbackEchoes.length;
    if(Array.isArray(chronoLoopGrenades)) total += chronoLoopGrenades.length;
    if(Array.isArray(twinstrikeCasts)) total += twinstrikeCasts.length;
    if(Array.isArray(twinstrikeTrails)) total += twinstrikeTrails.length;
    if(Array.isArray(boltburstRushCasts)) total += boltburstRushCasts.length;
    if(Array.isArray(scatterCharges)) total += scatterCharges.length;
    if(Array.isArray(luminousDartCasts)) total += luminousDartCasts.length;
    if(Array.isArray(sirensKissCasts)) total += sirensKissCasts.length;
    if(Array.isArray(dirgeBloomCasts)) total += dirgeBloomCasts.length;
    if(Array.isArray(shatterburstOrbCasts)) total += shatterburstOrbCasts.length;
    if(Array.isArray(reboundOrbCasts)) total += reboundOrbCasts.length;
    return total;
  }

  function buildPerfLog(){
    const fps = perfState.lastFps ? perfState.lastFps.toFixed(2) : 'n/a';
    const frameMs = perfState.lastFrameMs ? perfState.lastFrameMs.toFixed(2) : 'n/a';
    const updateAvg = perfState.frameCount ? (perfState.updateSum / Math.max(1, perfState.frameCount)).toFixed(2) : (perfState.lastFrameMs ? perfState.lastFrameMs.toFixed(2) : 'n/a');
    const renderAvg = perfState.frameCount ? (perfState.renderSum / Math.max(1, perfState.frameCount)).toFixed(2) : 'n/a';
    const updateMax = perfState.updateMax ? perfState.updateMax.toFixed(2) : 'n/a';
    const renderMax = perfState.renderMax ? perfState.renderMax.toFixed(2) : 'n/a';
    const circleRate = perfState.frameCount ? Math.round(perfState.circleSum / Math.max(1, perfState.frameCount)) : perfCounters.circleChecks;
    const pathfindRate = perfState.frameCount ? Math.round(perfState.pathfindCalls / Math.max(1, perfState.frameCount)) : perfCounters.pathfindCalls;
    const pathfindNodes = perfState.frameCount ? Math.round(perfState.pathfindNodes / Math.max(1, perfState.frameCount)) : perfCounters.pathfindNodesVisited;
    const minimapRate = perfState.frameCount ? Math.round(perfState.minimapRenders / Math.max(1, perfState.frameCount)) : perfCounters.minimapRenders;
    const snapTime = new Date().toISOString();
    const mapSize = `${Math.round(mapState.width)}x${Math.round(mapState.height)}`;
    const cameraSize = `${Math.round(camera.width)}x${Math.round(camera.height)} @${(camera.scale || 1).toFixed(2)}`;
    const projCount = perfProjectileCount();
    const spike = perfState.lastSpike;
    const lines = [
      `MakaGame perf snapshot @ ${snapTime}`,
      `FPS=${fps}`,
      `FrameTimeMs=${frameMs} (update avg ${updateAvg}ms, render avg ${renderAvg}ms, update max ${updateMax}ms, render max ${renderMax}ms)`,
      `Map=${mapSize}`,
      `Camera=${cameraSize}`,
      `Minions=${minions.length || 0}`,
      `Projectiles=${projCount}`,
      `Colliders=${customColliders.length || 0}`,
      `VisionSources=${(customVisionSources && customVisionSources.length) || 0}`,
      `PendingSpawns=${pendingSpawns.length || 0}`,
      `CollisionChecksPerFrame=${circleRate}`,
      `PathfindsPerFrame=${pathfindRate}`,
      `PathfindNodesPerFrame=${pathfindNodes}`,
      `MinimapRendersPerFrame=${minimapRate}`,
      spike ? `LastSpike=frame ${spike.frameMs.toFixed(2)}ms (update ${spike.updateMs.toFixed(2)}ms, render ${spike.renderMs.toFixed(2)}ms, gap ${spike.interval.toFixed(2)}ms, coll ${spike.circleChecks}, path ${spike.pathfindCalls}, nodes ${spike.pathfindNodes}) @ ${spike.timestamp}` : ''
    ];
    return lines.filter(Boolean).join('\\n');
  }

  function updatePerfPanel(){
    if(perfFpsValue){
      perfFpsValue.textContent = perfState.lastFps ? perfState.lastFps.toFixed(1) : '--';
    }
    if(perfFrameValue){
      perfFrameValue.textContent = perfState.lastFrameMs ? `${perfState.lastFrameMs.toFixed(1)} ms` : '-- ms';
    }
    if(perfMinionsValue){
      perfMinionsValue.textContent = String(minions.length || 0);
    }
    if(perfProjectilesValue){
      perfProjectilesValue.textContent = String(perfProjectileCount());
    }
    if(perfCollidersValue){
      perfCollidersValue.textContent = String(customColliders.length || 0);
    }
    if(perfVisionValue){
      perfVisionValue.textContent = String((customVisionSources && customVisionSources.length) || 0);
    }
    // Budgets
    // Tweak these to scale the budget meters; current values expect ~60k nodes/frame to show ~80% load
    const COLL_BUDGET = 2500; // checks per frame budget target
    const PATH_BUDGET = 75000; // nodes per frame budget target
    if(perfCollLoadValue){
      const coll = Math.round(perfState.lastCircleRate || perfCounters.circleChecks || 0);
      const pct = COLL_BUDGET > 0 ? Math.min(1, coll / COLL_BUDGET) : 0;
      perfCollLoadValue.textContent = `${coll} / ${COLL_BUDGET} (${Math.round(pct * 100)}% used)`;
      perfCollLoadValue.style.color = pct < 0.5 ? '#9effa0' : (pct < 0.85 ? '#ffd166' : '#ff7b7b');
    }
    if(perfPathLoadValue){
      const nodes = Math.round(perfState.lastPathNodesRate || perfCounters.pathfindNodesVisited || 0);
      const pct = PATH_BUDGET > 0 ? Math.min(1, nodes / PATH_BUDGET) : 0;
      perfPathLoadValue.textContent = `${nodes} / ${PATH_BUDGET} (${Math.round(pct * 100)}% used)`;
      perfPathLoadValue.style.color = pct < 0.5 ? '#9effa0' : (pct < 0.85 ? '#ffd166' : '#ff7b7b');
    }
    if(perfDensityValue){
      const area = Math.max(1, (mapState.width || 0) * (mapState.height || 0));
      const colliderCount = customColliders.length || 0;
      const density = Math.round(colliderCount / area * 100000 * 100) / 100; // per 100k px^2
      perfDensityValue.textContent = `${density} coll / 100k px^2`;
    }
    if(perfSpikeValue){
      if(perfState.lastSpike){
        const spike = perfState.lastSpike;
        perfSpikeValue.textContent = `${spike.frameMs.toFixed(2)}ms (upd ${spike.updateMs.toFixed(2)} / rnd ${spike.renderMs.toFixed(2)} / gap ${spike.interval.toFixed(2)} / coll ${spike.circleChecks} / path ${spike.pathfindCalls})`;
      } else {
        perfSpikeValue.textContent = '--';
      }
    }
  }

  function recordPerfFrame(frameMs, updateMs, renderMs, frameStartTime){
    const now = perfNow();
    perfCounters.circleChecks = perfCounters.circleChecks || 0;
    perfCounters.pathfindCalls = perfCounters.pathfindCalls || 0;
    perfCounters.pathfindNodesVisited = perfCounters.pathfindNodesVisited || 0;
    perfCounters.minimapRenders = perfCounters.minimapRenders || 0;
    const interval = perfState.lastFrameStart === null ? 0 : Math.max(0, frameStartTime - perfState.lastFrameStart);
    perfState.lastFrameStart = frameStartTime;
    if(interval > perfState.intervalMax){
      perfState.intervalMax = interval;
    }
    const spikeCandidate = {
      frameMs,
      updateMs,
      renderMs,
      interval,
      circleChecks: perfCounters.circleChecks,
      pathfindCalls: perfCounters.pathfindCalls,
      pathfindNodes: perfCounters.pathfindNodesVisited,
      timestamp: new Date().toISOString()
    };
    if(!perfState.lastSpike || spikeCandidate.frameMs > perfState.lastSpike.frameMs || spikeCandidate.interval > perfState.lastSpike.interval){
      perfState.lastSpike = spikeCandidate;
    }
    perfState.frameCount += 1;
    perfState.frameSum += frameMs;
    perfState.updateSum += updateMs;
    perfState.renderSum += renderMs;
    if(updateMs > perfState.updateMax) perfState.updateMax = updateMs;
    if(renderMs > perfState.renderMax) perfState.renderMax = renderMs;
    perfState.circleSum += perfCounters.circleChecks;
    perfState.pathfindCalls += perfCounters.pathfindCalls;
    perfState.pathfindNodes += perfCounters.pathfindNodesVisited;
    perfState.minimapRenders += perfCounters.minimapRenders;
    if(now - perfState.lastSample >= 1000){
      const elapsed = now - perfState.lastSample;
      perfState.lastFps = (perfState.frameCount * 1000) / Math.max(1, elapsed);
      perfState.lastFrameMs = perfState.frameSum / Math.max(1, perfState.frameCount);
      perfState.lastCircleRate = perfState.frameCount ? (perfState.circleSum / Math.max(1, perfState.frameCount)) : perfCounters.circleChecks;
      perfState.lastPathNodesRate = perfState.frameCount ? (perfState.pathfindNodes / Math.max(1, perfState.frameCount)) : perfCounters.pathfindNodesVisited;
      // snapshot history
      const snapshot = buildPerfLog();
      perfState.history.push(snapshot);
      if(perfState.history.length > 30){
        perfState.history.shift();
      }
      perfState.lastSample = now;
      perfState.frameCount = 0;
      perfState.frameSum = 0;
      perfState.updateSum = 0;
      perfState.renderSum = 0;
      perfState.updateMax = 0;
      perfState.renderMax = 0;
      perfState.circleSum = 0;
      perfState.pathfindCalls = 0;
      perfState.pathfindNodes = 0;
      perfState.minimapRenders = 0;
      perfState.intervalMax = 0;
      perfCounters.circleChecks = 0;
      perfCounters.pathfindCalls = 0;
      perfCounters.pathfindNodesVisited = 0;
      perfCounters.minimapRenders = 0;
      updatePerfPanel();
    }
  }

  function defaultAbilityBinding(index){
    const defaults = [
      { code: 'Digit1', key: '1', label: '1' },
      { code: 'Digit2', key: '2', label: '2' },
      { code: 'Digit3', key: '3', label: '3' },
      { code: 'Digit4', key: '4', label: '4' },
      { code: 'Digit5', key: '5', label: '5' },
      { code: 'KeyQ', key: 'q', label: 'Q' },
      { code: 'KeyW', key: 'w', label: 'W' },
      { code: 'KeyE', key: 'e', label: 'E' },
      { code: 'KeyR', key: 'r', label: 'R' },
      { code: 'KeyT', key: 't', label: 'T' },
      { code: 'KeyA', key: 'a', label: 'A' },
      { code: 'KeyS', key: 's', label: 'S' },
      { code: 'KeyD', key: 'd', label: 'D' },
      { code: 'KeyF', key: 'f', label: 'F' },
      { code: 'KeyG', key: 'g', label: 'G' },
      { code: 'KeyZ', key: 'z', label: 'Z' },
      { code: 'KeyX', key: 'x', label: 'X' },
      { code: 'KeyC', key: 'c', label: 'C' },
      { code: 'KeyV', key: 'v', label: 'V' },
      { code: 'KeyB', key: 'b', label: 'B' }
    ];
    if(index < 0 || index >= defaults.length) return null;
    const binding = defaults[index];
    return { code: binding.code, key: binding.key, label: binding.label };
  }
  

  const SPELL_CAST_BINDING_KEYS = {
    normal: 'normalModifier',
    quick: 'quickModifier',
    quickIndicator: 'quickIndicatorModifier'
  };

  function getSpellCastBinding(kind){
    const key = SPELL_CAST_BINDING_KEYS[kind];
    if(!key) return null;
    let binding = spellCastingConfig[key];
    if(!binding || typeof binding !== 'object'){
      binding = { key: '', code: '', label: 'â€”' };
      spellCastingConfig[key] = binding;
    }
    if(typeof binding.label !== 'string'){
      binding.label = formatAbilityKeyLabel(binding.key, binding.code);
    }
    return binding;
  }

  function updateSpellCastBindingDisplay(kind){
    const button = kind === 'normal'
      ? spellCastNormalBindBtn
      : (kind === 'quick'
        ? spellCastQuickBindBtn
        : (kind === 'quickIndicator' ? spellCastIndicatorBindBtn : null));
    if(!button) return;
    if(spellCastingRuntime.captureMode === kind){
      button.textContent = 'Press a key...';
      return;
    }
    const binding = getSpellCastBinding(kind);
    button.textContent = binding && binding.label ? binding.label : 'â€”';
  }

  function refreshSpellCastBindingDisplays(){
    updateSpellCastBindingDisplay('normal');
    updateSpellCastBindingDisplay('quick');
    updateSpellCastBindingDisplay('quickIndicator');
  }

  function normalizeCastType(value){
    const raw = typeof value === 'string' ? value.trim() : '';
    const lower = raw.toLowerCase();
    if(lower === 'normal') return 'normal';
    if(lower === 'quickindicator' || raw === 'quickIndicator') return 'quickIndicator';
    if(lower === 'none') return 'none';
    return 'quick';
  }

  function abilityAllowedCastTypes(ability){
    if(ability && ability.id === 'piercing_arrow'){
      return ['normal', 'quick'];
    }
    return ['none', 'normal', 'quickIndicator', 'quick'];
  }

  function defaultAbilityCastType(ability){
    if(ability && ability.id === 'piercing_arrow'){
      return 'quick';
    }
    return 'none';
  }

  function setDefaultSpellCastType(value, { syncInput = true } = {}){
    const normalized = normalizeCastType(value);
    spellCastingConfig.defaultCastType = normalized;
    if(spellCastDefaultSelect && syncInput){
      spellCastDefaultSelect.value = normalized;
    }
  }

  function setSpellCastModifierBinding(kind, key, code){
    const binding = getSpellCastBinding(kind);
    if(!binding) return;
    binding.key = typeof key === 'string' ? key : '';
    binding.code = typeof code === 'string' ? code : '';
    binding.label = formatAbilityKeyLabel(binding.key, binding.code);
    refreshSpellCastBindingDisplays();
  }

  function toggleSpellCastBindingCapture(kind){
    if(spellCastingRuntime.captureMode === kind){
      spellCastingRuntime.captureMode = null;
      refreshSpellCastBindingDisplays();
      return;
    }
    spellCastingRuntime.captureMode = kind;
    refreshSpellCastBindingDisplays();
    if(kind){
      const bindingName = kind === 'normal'
        ? 'normal cast'
        : (kind === 'quick' ? 'quick cast' : 'quick indicator');
      setHudMessage(`Press a key for the ${bindingName} modifier.`);
    }
  }

  function cancelSpellCastBindingCapture(){
    if(!spellCastingRuntime.captureMode) return false;
    spellCastingRuntime.captureMode = null;
    refreshSpellCastBindingDisplays();
    return true;
  }

  function bindingMatches(binding, ev){
    if(!binding || !ev) return false;
    const code = binding.code;
    if(code && ev.code === code){
      return true;
    }
    const key = binding.key ? binding.key.toLowerCase() : '';
    if(!code && key){
      const eventKey = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
      if(eventKey === key){
        return true;
      }
    }
    return false;
  }

  function activeModifierCastType(){
    const mods = spellCastingRuntime.modifiers;
    if(mods.quickIndicator) return 'quickIndicator';
    if(mods.normal) return 'normal';
    if(mods.quick) return 'quick';
    return null;
  }

  function resolveAbilityCastType(ability){
    const modifier = activeModifierCastType();
    if(modifier) return ability ? normalizeAbilityCastType(ability, modifier) : modifier;
    const override = ability ? normalizeAbilityCastType(ability, ability.castType) : 'none';
    let base = override;
    if(base === 'none'){
      base = normalizeCastType(spellCastingConfig.defaultCastType);
    }
    if(base === 'none'){
      base = 'quick';
    }
    return base;
  }

  function eventMatchesIndicatorTrigger(indicator, ev){
    if(!indicator || !ev) return false;
    if(indicator.triggerCode && ev.code === indicator.triggerCode){
      return true;
    }
    if(!indicator.triggerCode && indicator.triggerKey){
      const key = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
      if(key === indicator.triggerKey){
        return true;
      }
    }
    return false;
  }

  function beginSkillshotIndicator(slotIndex, ability, { mode = 'normal', triggerEvent = null, pendingCast = true } = {}){
    const triggerKey = triggerEvent && typeof triggerEvent.key === 'string'
      ? triggerEvent.key.toLowerCase()
      : '';
    const triggerCode = triggerEvent && typeof triggerEvent.code === 'string'
      ? triggerEvent.code
      : '';
    const indicator = {
      slotIndex,
      abilityId: ability ? ability.id : null,
      mode,
      triggerKey,
      triggerCode,
      pendingCast: pendingCast !== false,
      abilityName: ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Ability'
    };
    spellCastingRuntime.activeIndicator = indicator;
    cancelPlayerAttack(false);
    return indicator;
  }

  function clearSkillshotIndicator(){
    if(spellCastingRuntime.activeIndicator){
      spellCastingRuntime.activeIndicator = null;
    }
  }

  function cancelSkillshotIndicator({ reason = 'cancel' } = {}){
    if(!spellCastingRuntime.activeIndicator) return false;
    const indicator = spellCastingRuntime.activeIndicator;
    spellCastingRuntime.activeIndicator = null;
    if(reason === 'pointerCancel' || reason === 'escape'){
      setHudMessage(`${indicator.abilityName} cancelled.`);
    }
    return true;
  }

  function confirmSkillshotIndicator({ cause = 'key', event = null } = {}){
    const indicator = spellCastingRuntime.activeIndicator;
    if(!indicator) return false;
    if(indicator.mode === 'quickIndicator' && indicator.pendingCast === false){
      clearSkillshotIndicator();
      return false;
    }
    const success = activateAbilitySlot(indicator.slotIndex, { triggerEvent: event, castMode: indicator.mode, indicatorConfirm: cause });
    if(success){
      clearSkillshotIndicator();
      return true;
    }
    return false;
  }

  function skillshotAimPoint(){
    if(abilityRuntime.lastPointerWorld && Number.isFinite(abilityRuntime.lastPointerWorld.x) && Number.isFinite(abilityRuntime.lastPointerWorld.y)){
      return abilityRuntime.lastPointerWorld;
    }
    return beamAimPoint();
  }

  function getSkillshotIndicatorProfile(ability){
    if(!ability) return null;
    return abilityIndicatorProfiles[ability.id] || null;
  }

  function indicatorFieldNumber(ability, key, { min = 0, fallback = 0, raw = false } = {}){
    if(!ability || !key) return fallback;
    const value = abilityFieldValue(ability, key, raw ? { skipScaling: true } : undefined);
    if(!Number.isFinite(Number(value))) return fallback;
    const numeric = Number(value);
    if(min === null || min === undefined) return numeric;
    return Math.max(min, numeric);
  }

  function configuredIndicatorLength(ability, profile){
    if(!ability || !profile) return 0;
    const keys = [profile.lengthKey, profile.maxLengthKey, profile.rangeKey, profile.distanceKey];
    for(const key of keys){
      if(!key) continue;
      const val = indicatorFieldNumber(ability, key, { min: 0, fallback: 0 });
      if(val > 0) return val;
    }
    return 0;
  }

  function drawSkillshotIndicator(){
    const indicator = spellCastingRuntime.activeIndicator;
    if(!indicator) return;
    const ability = getAbilityDefinition(indicator.abilityId);
    if(!ability){
      clearSkillshotIndicator();
      return;
    }
    const profile = getSkillshotIndicatorProfile(ability);
    const origin = getSpellOrigin(player);
    const aim = skillshotAimPoint();
    let dx = aim.x - origin.x;
    let dy = aim.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const stroke = indicator.mode === 'quickIndicator' ? '#9fd1ff' : '#7fe3ff';
    const fill = indicator.mode === 'quickIndicator' ? 'rgba(159, 209, 255, 0.2)' : 'rgba(127, 227, 255, 0.28)';
    const accent = indicator.mode === 'quickIndicator' ? '#b8e0ff' : '#d6f4ff';
    const configuredLength = profile ? configuredIndicatorLength(ability, profile) : 0;
    const configuredRange = profile && profile.rangeKey ? indicatorFieldNumber(ability, profile.rangeKey, { min: 0, fallback: 0 }) : 0;
    const configuredRadius = profile && profile.radiusKey ? indicatorFieldNumber(ability, profile.radiusKey, { min: 0, fallback: 0 }) : 0;
    const wallHalfLength = profile && profile.type === 'wall' && profile.lengthKey
      ? indicatorFieldNumber(ability, profile.lengthKey, { min: 0, fallback: 0 }) * 0.5
      : 0;
    const wallHalfWidth = profile && profile.type === 'wall' && profile.widthKey
      ? indicatorFieldNumber(ability, profile.widthKey, { min: 0, fallback: 0 }) * 0.5
      : 0;
    let maxDistance = distance;
    if(profile && profile.distanceKey){
      const configuredDistance = indicatorFieldNumber(ability, profile.distanceKey, { min: 0, fallback: 0 });
      if(configuredDistance > 0){
        maxDistance = configuredDistance;
      }
    }
    if(configuredRange > 0){
      maxDistance = Math.max(maxDistance, configuredRange);
    }
    let targetDistance = maxDistance > 0 ? Math.min(distance, maxDistance) : distance;
    if(profile && profile.fixedLength && configuredLength > 0){
      targetDistance = configuredLength;
    }
    let targetX = origin.x + dirX * targetDistance;
    let targetY = origin.y + dirY * targetDistance;
    const wallExtent = Math.max(wallHalfLength, Math.hypot(wallHalfLength, wallHalfWidth));
    const boundingRadius = Math.max(targetDistance + wallExtent, maxDistance + wallExtent, configuredLength, configuredRange, configuredRadius, 200);
    if(!circleInCamera(origin.x, origin.y, boundingRadius + 120)){
      return;
    }

    if(profile && profile.type === 'aoe'){
      const radius = indicatorFieldNumber(ability, profile.radiusKey, { min: 0, fallback: 0 });
      const innerRadiusRaw = profile.innerRadiusKey ? indicatorFieldNumber(ability, profile.innerRadiusKey, { min: 0, fallback: 0 }) : 0;
      const innerRadius = innerRadiusRaw > 0 ? Math.min(innerRadiusRaw, radius || innerRadiusRaw) : 0;
      if(profile.showRangeRing && maxDistance > 0){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.setLineDash([14, 8]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = accent;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, maxDistance, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      if(radius > 0){
        ctx.save();
        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 6]);
        ctx.beginPath();
        ctx.arc(targetX, targetY, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(targetX, targetY, radius, 0, Math.PI * 2);
        ctx.fill();
        if(innerRadius > 0){
          ctx.globalAlpha = 0.55;
          ctx.setLineDash([6, 8]);
          ctx.lineWidth = 2;
          ctx.strokeStyle = accent;
          ctx.beginPath();
          ctx.arc(targetX, targetY, innerRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        ctx.restore();
      }
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(targetX, targetY);
      ctx.stroke();
      ctx.restore();
    } else if(profile && profile.type === 'blink'){
      const range = configuredRange > 0 ? configuredRange : configuredLength;
      const aoeRadiusRaw = profile.aoeRadiusKey ? indicatorFieldNumber(ability, profile.aoeRadiusKey, { min: 0, fallback: 0 }) : 0;
      const clampedDistance = range > 0 ? Math.min(distance, range) : targetDistance;
      targetDistance = clampedDistance;
      targetX = origin.x + dirX * targetDistance;
      targetY = origin.y + dirY * targetDistance;
      if(range > 0){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.setLineDash([12, 6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      const aoeRadius = aoeRadiusRaw > 0 ? aoeRadiusRaw : Math.max(28, (player && Number(player.r)) ? player.r * 1.4 : 32);
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.arc(targetX, targetY, aoeRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.8;
      ctx.lineWidth = 2;
      ctx.strokeStyle = stroke;
      ctx.beginPath();
      ctx.arc(targetX, targetY, aoeRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.lineWidth = 2;
      ctx.strokeStyle = stroke;
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(targetX, targetY);
      ctx.stroke();
      ctx.restore();
    } else if(profile && profile.type === 'wall'){
      const length = indicatorFieldNumber(ability, profile.lengthKey, { min: 0, fallback: 0 });
      const width = indicatorFieldNumber(ability, profile.widthKey, { min: 2, fallback: 2 });
      const wallDirX = -dirY;
      const wallDirY = dirX;
      const halfLength = Math.max(0, length) * 0.5;
      const halfWidth = Math.max(2, width) * 0.5;
      if(profile.showRangeRing && maxDistance > 0){
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.setLineDash([12, 6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = accent;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, maxDistance, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      const centerX = targetX;
      const centerY = targetY;
      const ax = wallDirX * halfLength;
      const ay = wallDirY * halfLength;
      const nx = dirX * halfWidth;
      const ny = dirY * halfWidth;
      const corners = [
        { x: centerX - ax - nx, y: centerY - ay - ny },
        { x: centerX + ax - nx, y: centerY + ay - ny },
        { x: centerX + ax + nx, y: centerY + ay + ny },
        { x: centerX - ax + nx, y: centerY - ay + ny }
      ];
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.moveTo(corners[0].x, corners[0].y);
      for(let i = 1; i < corners.length; i++){
        ctx.lineTo(corners[i].x, corners[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 2;
      ctx.strokeStyle = stroke;
      ctx.beginPath();
      ctx.moveTo(corners[0].x, corners[0].y);
      for(let i = 1; i < corners.length; i++){
        ctx.lineTo(corners[i].x, corners[i].y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.lineWidth = 2;
      ctx.strokeStyle = stroke;
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(centerX, centerY);
      ctx.stroke();
      ctx.restore();
    } else if(profile && profile.type === 'trapPlacement'){
      const range = configuredRange > 0 ? configuredRange : 0;
      const pointerDistance = range > 0 ? Math.min(distance, range) : distance;
      targetDistance = pointerDistance;
      targetX = origin.x + dirX * pointerDistance;
      targetY = origin.y + dirY * pointerDistance;
      const count = profile.countKey ? Math.max(0, Math.floor(indicatorFieldNumber(ability, profile.countKey, { min: 0, fallback: 0 }))) : 0;
      const spacing = profile.spacingKey ? indicatorFieldNumber(ability, profile.spacingKey, { min: 0, fallback: 0 }) : 0;
      const minSpacing = profile.minSpacingKey ? indicatorFieldNumber(ability, profile.minSpacingKey, { min: 0, fallback: 0 }) : 0;
      const triggerRadius = profile.triggerRadiusKey ? indicatorFieldNumber(ability, profile.triggerRadiusKey, { min: 0, fallback: 0 }) : 0;
      const aoeRadius = profile.aoeRadiusKey ? indicatorFieldNumber(ability, profile.aoeRadiusKey, { min: 0, fallback: 0 }) : 0;
      const placementMode = profile.modeKey ? indicatorFieldNumber(ability, profile.modeKey, { min: null, fallback: 0, raw: true }) : 0;
      const trapRadius = Math.max(16, triggerRadius * 0.6);
      const placements = count > 0
        ? computeTrapPlacements(origin.x, origin.y, dirX, dirY, pointerDistance, {
            count,
            spacing,
            minSpacing,
            maxRange: range,
            mode: placementMode
          })
        : [];
      const adjustedPlacements = placements.map(p => ({ x: p.x, y: p.y }));
      enforceTrapSpacing(adjustedPlacements, minSpacing, origin.x, origin.y, trapRadius, range);
      const resolvedPlacements = [];
      for(const candidate of adjustedPlacements){
        if(!candidate) continue;
        const resolved = resolveTrapPlacement(origin.x, origin.y, candidate.x, candidate.y, trapRadius, range);
        if(resolved) resolvedPlacements.push(resolved);
      }
      if(range > 0){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.setLineDash([12, 6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      const outerRadius = Math.max(triggerRadius, aoeRadius, trapRadius);
      for(const pos of resolvedPlacements){
        if(!circleInCamera(pos.x, pos.y, outerRadius + 60)) continue;
        ctx.save();
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, trapRadius, 0, Math.PI * 2);
        ctx.fill();
        if(triggerRadius > 0){
          ctx.globalAlpha = 0.75;
          ctx.lineWidth = 2;
          ctx.strokeStyle = stroke;
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, triggerRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
        if(aoeRadius > triggerRadius){
          ctx.globalAlpha = 0.6;
          ctx.setLineDash([8, 6]);
          ctx.strokeStyle = accent;
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, aoeRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }
      ctx.save();
      ctx.globalAlpha = 0.45;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(targetX, targetY);
      ctx.stroke();
      ctx.restore();
    } else {
      let slamImpactRadius = 0;
      ctx.save();
      ctx.translate(origin.x, origin.y);
      const angle = Math.atan2(dirY, dirX);
      ctx.rotate(angle);
      if(profile && profile.type === 'trapezoid'){
        const length = indicatorFieldNumber(ability, profile.lengthKey, { min: 0, fallback: 0 });
        const startWidth = indicatorFieldNumber(ability, profile.startWidthKey, { min: 2, fallback: 2 });
        const endWidth = indicatorFieldNumber(ability, profile.endWidthKey, { min: 2, fallback: startWidth });
        const effectiveLength = length > 0 ? Math.min(length, targetDistance) : targetDistance;
        const halfStart = startWidth / 2;
        const halfEnd = endWidth / 2;
        ctx.beginPath();
        ctx.moveTo(0, -halfStart);
        ctx.lineTo(effectiveLength, -halfEnd);
        ctx.lineTo(effectiveLength, halfEnd);
        ctx.lineTo(0, halfStart);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.stroke();
      } else if(profile && profile.type === 'chargeLine'){
        const minLength = indicatorFieldNumber(ability, profile.minLengthKey, { min: 0, fallback: 0 });
        const maxLength = indicatorFieldNumber(ability, profile.maxLengthKey, { min: minLength, fallback: minLength });
        const width = indicatorFieldNumber(ability, profile.widthKey, { min: 2, fallback: 2 });
        const halfWidth = width / 2;
        const effectiveMax = maxLength > 0 ? maxLength : targetDistance;
        ctx.beginPath();
        ctx.moveTo(0, -halfWidth);
        ctx.lineTo(effectiveMax, -halfWidth);
        ctx.lineTo(effectiveMax, halfWidth);
        ctx.lineTo(0, halfWidth);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.stroke();
        if(minLength > 0){
          const effectiveMin = Math.min(minLength, effectiveMax);
          ctx.setLineDash([8, 6]);
          ctx.strokeStyle = accent;
          ctx.beginPath();
          ctx.moveTo(effectiveMin, -halfWidth);
          ctx.lineTo(effectiveMin, halfWidth);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      } else if(profile && profile.type === 'cone'){
        const length = indicatorFieldNumber(ability, profile.lengthKey, { min: 0, fallback: 0 });
        const width = indicatorFieldNumber(ability, profile.widthKey, { min: 0, fallback: 0 });
        const effectiveLength = length > 0 ? Math.min(length, targetDistance) : targetDistance;
        const halfWidth = width / 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(effectiveLength, -halfWidth);
        ctx.lineTo(effectiveLength, halfWidth);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.stroke();
        const count = profile.countKey ? Math.max(0, Math.floor(indicatorFieldNumber(ability, profile.countKey, { min: 0, fallback: 0 }))) : 0;
        if(count > 0){
          const projectileWidth = profile.projectileWidthKey
            ? indicatorFieldNumber(ability, profile.projectileWidthKey, { min: 1, fallback: 6 })
            : Math.max(4, width / Math.max(1, count));
          const lineWidth = Math.max(2, Math.min(projectileWidth, 48));
          ctx.save();
          ctx.globalAlpha = 0.85;
          ctx.lineCap = 'round';
          ctx.strokeStyle = accent;
          ctx.lineWidth = lineWidth;
          for(let i = 0; i < count; i++){
            const fraction = count > 1 ? (i / (count - 1)) : 0.5;
            const offset = (fraction - 0.5) * width;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(effectiveLength, offset);
            ctx.stroke();
          }
          ctx.restore();
        }
      } else if(profile && profile.type === 'slam'){
        const fissureLength = indicatorFieldNumber(ability, profile.fissureLengthKey, { min: 0, fallback: 0 });
        const fissureWidth = indicatorFieldNumber(ability, profile.fissureWidthKey, { min: 0, fallback: 0 });
        slamImpactRadius = indicatorFieldNumber(ability, profile.impactRadiusKey, { min: 0, fallback: 0 });
        const effectiveLength = fissureLength > 0 ? fissureLength : targetDistance;
        if(fissureWidth > 0 && effectiveLength > 0){
          ctx.beginPath();
          ctx.rect(0, -fissureWidth / 2, effectiveLength, fissureWidth);
          ctx.fillStyle = fill;
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = stroke;
          ctx.stroke();
        }
      } else {
        const width = profile && profile.widthKey ? indicatorFieldNumber(ability, profile.widthKey, { min: 2, fallback: 2 }) : 24;
        const dynamic = !profile || !profile.fixedLength && (!profile.lengthKey || configuredLength <= 0);
        const effectiveLength = dynamic ? targetDistance : Math.min(configuredLength, targetDistance);
        const halfWidth = width / 2;
        ctx.beginPath();
        ctx.moveTo(0, -halfWidth);
        ctx.lineTo(effectiveLength, -halfWidth);
        ctx.lineTo(effectiveLength, halfWidth);
        ctx.lineTo(0, halfWidth);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.stroke();
        if(profile && profile.splitAngleKey){
          const projectileRange = profile.lengthKey ? indicatorFieldNumber(ability, profile.lengthKey, { min: 0, fallback: effectiveLength }) : effectiveLength;
          const aimDistance = distance;
          const splitDistance = projectileRange > 0 ? Math.min(aimDistance, projectileRange) : effectiveLength;
          const remainingRange = projectileRange > 0 ? Math.max(0, projectileRange - splitDistance) : Math.max(0, effectiveLength - splitDistance);
          const projectileWidth = profile.widthKey ? indicatorFieldNumber(ability, profile.widthKey, { min: 1, fallback: 6 }) : width;
          const markerRadius = Math.max(6, Math.min(projectileWidth * 0.75, 28));
          ctx.save();
          ctx.globalAlpha = 0.85;
          ctx.setLineDash([6, 4]);
          ctx.strokeStyle = accent;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(splitDistance, 0, markerRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          if(remainingRange > 0){
            const splitAngleDeg = indicatorFieldNumber(ability, profile.splitAngleKey, { min: 0, fallback: 0 });
            const splitAngle = splitAngleDeg * Math.PI / 180;
            const branchWidth = Math.max(2, Math.min(projectileWidth, 36));
            const drawBranch = (angle)=>{
              const endX = splitDistance + Math.cos(angle) * remainingRange;
              const endY = Math.sin(angle) * remainingRange;
              ctx.beginPath();
              ctx.moveTo(splitDistance, 0);
              ctx.lineTo(endX, endY);
              ctx.stroke();
            };
            ctx.save();
            ctx.globalAlpha = 0.75;
            ctx.lineCap = 'round';
            ctx.strokeStyle = accent;
            ctx.lineWidth = branchWidth;
            if(splitAngle > 0.001){
              drawBranch(splitAngle);
              drawBranch(-splitAngle);
            } else {
              drawBranch(0);
            }
            ctx.restore();
          }
        }
      }
      ctx.restore();
      if(profile && profile.type === 'slam' && slamImpactRadius > 0){
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, slamImpactRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.8;
        ctx.lineWidth = 2;
        ctx.strokeStyle = stroke;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, slamImpactRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.lineWidth = 2;
    ctx.strokeStyle = stroke;
    ctx.beginPath();
    ctx.arc(targetX, targetY, 6, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  function handleSpellCastModifierKeyDown(ev){
    if(ev.repeat) return false;
    let handled = false;
    if(bindingMatches(getSpellCastBinding('normal'), ev)){
      spellCastingRuntime.modifiers.normal = true;
      handled = true;
    }
    if(bindingMatches(getSpellCastBinding('quick'), ev)){
      spellCastingRuntime.modifiers.quick = true;
      handled = true;
    }
    if(bindingMatches(getSpellCastBinding('quickIndicator'), ev)){
      spellCastingRuntime.modifiers.quickIndicator = true;
      handled = true;
    }
    return handled;
  }

  function handleSpellCastModifierKeyUp(ev){
    if(bindingMatches(getSpellCastBinding('normal'), ev)){
      spellCastingRuntime.modifiers.normal = false;
    }
    if(bindingMatches(getSpellCastBinding('quick'), ev)){
      spellCastingRuntime.modifiers.quick = false;
    }
    if(bindingMatches(getSpellCastBinding('quickIndicator'), ev)){
      spellCastingRuntime.modifiers.quickIndicator = false;
    }
  }

  function handleAbilityActivationRequest(slotIndex, triggerEvent){
    const resolution = resolveAbilityCast(slotIndex, {});
    if(!resolution.success){
      if(resolution.message){
        setHudMessage(resolution.message);
      }
      return false;
    }

    const ability = resolution.ability;
    const castMode = resolution.castMode;
    const supportsIndicator = resolution.supportsIndicator;
    const active = spellCastingRuntime.activeIndicator;

    if(resolution.ability && resolution.ability.id === 'rite_arcane'){
      const artilleryMode = activeArcaneRiteModeForCaster(player);
      if(artilleryMode && artilleryMode.abilityId === resolution.ability.id){
        if(triggerEvent && typeof triggerEvent.preventDefault === 'function'){
          triggerEvent.preventDefault();
        }
        const aimPoint = beamAimPoint();
        if(!scheduleArcaneRiteExplosion(artilleryMode, aimPoint.x, aimPoint.y)){
          setHudMessage(`${artilleryMode.abilityName || 'Artillery'} cannot fire right now.`);
        }
        return true;
      }
    }

    if(active){
      if(active.slotIndex === slotIndex && supportsIndicator && (castMode === 'normal' || castMode === 'quickIndicator') && eventMatchesIndicatorTrigger(active, triggerEvent)){
        if(active.mode === 'quickIndicator'){
          active.pendingCast = true;
        }
        confirmSkillshotIndicator({ cause: 'key', event: triggerEvent });
        return true;
      }
      cancelSkillshotIndicator({ reason: 'cancel' });
    }

    if(castMode === 'normal' || castMode === 'quickIndicator'){
      if(!supportsIndicator){
        return activateAbilitySlot(slotIndex, { triggerEvent, castMode: 'quick' });
      }
      const pendingCast = castMode !== 'quickIndicator';
      beginSkillshotIndicator(slotIndex, ability, { mode: castMode, triggerEvent, pendingCast });
      if(castMode === 'quickIndicator'){
        const indicator = spellCastingRuntime.activeIndicator;
        if(indicator){
          indicator.pendingCast = false;
        }
      }
      return true;
    }

    return activateAbilitySlot(slotIndex, { triggerEvent, castMode });
  }
  function ensureAbilityHotkeys(){ abilityHotkeys.length = abilityBarState.count; }
  function ensureAbilitySlotStates(){
    abilitySlotStates.length = abilityBarState.count;
    for(let i=0;i<abilityBarState.count;i++){
      if(!abilitySlotStates[i]) abilitySlotStates[i] = { cooldown: 0 };
    }
  }
  function setAbilityOrientation(value, { syncInput = true } = {}){
    const normalized = value === 'vertical' ? 'vertical' : 'horizontal';
    abilityBarState.orientation = normalized;
    if(abilityOrientationSelect && syncInput){
      abilityOrientationSelect.value = normalized;
    }
    renderAbilityBar();
  }
  function setAbilityHealthPlacementHorizontal(value, { syncInput = true } = {}){
    const normalized = value === 'top' ? 'top' : 'bottom';
    abilityBarState.healthPlacement.horizontal = normalized;
    if(abilityHealthHorizontalSelect && syncInput){
      abilityHealthHorizontalSelect.value = normalized;
    }
    applyAbilityLayout();
  }
  function setAbilityHealthPlacementVertical(value, { syncInput = true } = {}){
    const normalized = value === 'left' ? 'left' : 'right';
    abilityBarState.healthPlacement.vertical = normalized;
    if(abilityHealthVerticalSelect && syncInput){
      abilityHealthVerticalSelect.value = normalized;
    }
    applyAbilityLayout();
  }
  function setAbilityHealthTextPlacementVertical(value, { syncInput = true } = {}){
    const normalized = value === 'top' ? 'top' : 'bottom';
    abilityBarState.healthPlacement.textVertical = normalized;
    if(abilityHealthVerticalTextSelect && syncInput){
      abilityHealthVerticalTextSelect.value = normalized;
    }
    applyAbilityLayout();
  }
  function setAbilityStatsPlacementVertical(value, { syncInput = true } = {}){
    const normalized = value === 'bottom' ? 'bottom' : 'top';
    abilityBarState.statsPlacementVertical = normalized;
    if(abilityStatsVerticalSelect && syncInput){
      abilityStatsVerticalSelect.value = normalized;
    }
    applyAbilityLayout();
  }
  function isHudStatsCollapsed(){
    return hudStatsDock && hudStatsDock.getAttribute('data-collapsed') === 'true';
  }
  function updateHudStatsToggleIcon(collapsed = isHudStatsCollapsed()){
    if(!hudStatsToggleIcon){
      return;
    }
    const orientation = abilityBarState.orientation === 'vertical' ? 'vertical' : 'horizontal';
    if(orientation === 'vertical'){
      hudStatsToggleIcon.textContent = collapsed ? 'â–¼' : 'â–²';
    } else {
      hudStatsToggleIcon.textContent = collapsed ? 'â–¶' : 'â—€';
    }
  }
  function applyAbilityLayout(){
    const orientation = abilityBarState.orientation === 'vertical' ? 'vertical' : 'horizontal';
    const horizontalPlacement = abilityBarState.healthPlacement.horizontal === 'top' ? 'top' : 'bottom';
    const verticalPlacement = abilityBarState.healthPlacement.vertical === 'left' ? 'left' : 'right';
    const statsVerticalPlacement = abilityBarState.statsPlacementVertical === 'bottom' ? 'bottom' : 'top';
    const healthTextVerticalPlacement = abilityBarState.healthPlacement.textVertical === 'top' ? 'top' : 'bottom';
    if(abilityBarEl){
      abilityBarEl.dataset.orientation = orientation;
    }
    if(hudAbilityStackEl){
      hudAbilityStackEl.dataset.orientation = orientation;
      hudAbilityStackEl.dataset.horizontalPlacement = horizontalPlacement;
      hudAbilityStackEl.dataset.verticalPlacement = verticalPlacement;
      if(orientation === 'vertical'){
        hudAbilityStackEl.dataset.healthTextPlacement = healthTextVerticalPlacement;
      } else {
        delete hudAbilityStackEl.dataset.healthTextPlacement;
      }
    }
    if(hudAbilityBarWrapEl){
      hudAbilityBarWrapEl.dataset.orientation = orientation;
    }
    if(hudStatsAbilityGroup){
      hudStatsAbilityGroup.dataset.orientation = orientation;
      hudStatsAbilityGroup.dataset.verticalPlacement = statsVerticalPlacement;
    }
    if(hudStatsDock){
      hudStatsDock.dataset.orientation = orientation;
      hudStatsDock.dataset.verticalPlacement = statsVerticalPlacement;
    }
    if(hudStatsPanel){
      hudStatsPanel.dataset.orientation = orientation;
      hudStatsPanel.dataset.verticalPlacement = statsVerticalPlacement;
    }
    if(hudStatsToggle){
      hudStatsToggle.dataset.orientation = orientation;
      hudStatsToggle.dataset.verticalPlacement = statsVerticalPlacement;
    }
    if(hudAbilityVitalsWrap){
      hudAbilityVitalsWrap.dataset.orientation = orientation;
      hudAbilityVitalsWrap.dataset.horizontalPlacement = horizontalPlacement;
      hudAbilityVitalsWrap.dataset.verticalPlacement = verticalPlacement;
    }
    if(hudVitals){
      hudVitals.dataset.orientation = orientation;
      if(orientation === 'vertical'){
        const scale = Math.max(0, Number(abilityBarState.scale) || 0);
        const slotSize = 48 * scale;
        const gap = 8 * scale;
        const count = Math.max(abilityBarState.count, 1);
        const estimatedHeight = count * slotSize + Math.max(0, count - 1) * gap + 16;
        hudVitals.style.setProperty('--hud-health-vertical-height', `${Math.max(estimatedHeight, 48)}px`);
      } else {
        hudVitals.style.removeProperty('--hud-health-vertical-height');
      }
    }
    if(hudVitalsBar){
      hudVitalsBar.dataset.orientation = orientation;
      if(orientation === 'vertical'){
        hudVitalsBar.dataset.textPlacement = healthTextVerticalPlacement;
      } else {
        delete hudVitalsBar.dataset.textPlacement;
      }
    }
    if(hudHpFill){
      hudHpFill.dataset.orientation = orientation;
    }
    if(hudHpText){
      hudHpText.dataset.orientation = orientation;
      if(orientation === 'vertical'){
        if(hudAbilityStackEl){
          if(hudHpText.parentElement !== hudAbilityStackEl){
            hudAbilityStackEl.insertBefore(hudHpText, hudAbilityStackEl.firstChild || null);
          } else if(hudAbilityStackEl.firstChild !== hudHpText){
            hudAbilityStackEl.insertBefore(hudHpText, hudAbilityStackEl.firstChild);
          }
        }
      } else if(hudHpTextDefaultParent && hudHpText.parentElement !== hudHpTextDefaultParent){
        if(hudHpTextDefaultNextSibling && hudHpTextDefaultNextSibling.parentNode === hudHpTextDefaultParent){
          hudHpTextDefaultParent.insertBefore(hudHpText, hudHpTextDefaultNextSibling);
        } else {
          hudHpTextDefaultParent.appendChild(hudHpText);
        }
      }
    }
    updateHudHealth();
    updateHudStatsToggleIcon();
    scheduleHudFit();
  }
  function getAbilitySlotState(index){
    ensureAbilitySlotStates();
    return abilitySlotStates[index] || null;
  }
  function getAbilityBinding(index){
    ensureAbilityHotkeys();
    return abilityHotkeys[index] || defaultAbilityBinding(index);
  }
  function ensureAbilityAssignments(){
    abilityAssignments.length = abilityBarState.count;
    if(abilityBarState.count <= 0) return;
    const used = new Set();
    for(let i=0;i<abilityBarState.count;i++){
      const id = abilityAssignments[i];
      if(id && abilityDefinitions[id] && !used.has(id)){
        used.add(id);
      } else {
        abilityAssignments[i] = null;
      }
    }
    const pool = Object.keys(abilityDefinitions).filter(id => !used.has(id));
    for(let i=0;i<abilityBarState.count;i++){
      if(abilityAssignments[i]) continue;
      if(pool.length === 0) break;
      const pick = Math.floor(Math.random() * pool.length);
      const [id] = pool.splice(pick, 1);
      abilityAssignments[i] = id;
      used.add(id);
    }
  }
  function isAbilityRepoOpen(){ return !!(abilityRepoEl && abilityRepoEl.classList.contains('open')); }
  function resetAbilityEditor(){
    abilityBarState.editingAbilityId = null;
    if(spellEditorPlaceholder) spellEditorPlaceholder.hidden = false;
    if(spellEditorForm){
      spellEditorForm.innerHTML = '';
      spellEditorForm.hidden = true;
    }
  }
  function highlightActiveAbilitySlot(){
    if(!abilityBarEl) return;
    const slots = abilityBarEl.querySelectorAll('.abilitySlot');
    slots.forEach(slot => {
      const index = Number(slot.dataset.index);
      slot.classList.toggle('selected', Number.isFinite(index) && index === abilityBarState.activeSlotIndex);
    });
  }
  function updateAbilityRepoSubtitle(){
    if(!abilityRepoSubtitle) return;
    if(abilityBarState.activeSlotIndex === null){
      abilityRepoSubtitle.textContent = 'Select a spell to assign.';
      return;
    }
    const slotNumber = abilityBarState.activeSlotIndex + 1;
    const abilityId = abilityAssignments[abilityBarState.activeSlotIndex];
    const ability = abilityId ? getAbilityDefinition(abilityId) : null;
    const binding = getAbilityBinding(abilityBarState.activeSlotIndex);
    const hotkeyLabel = binding ? binding.label : 'â€”';
    const hotkeyText = hotkeyLabel && hotkeyLabel !== 'â€”' ? `Hotkey ${hotkeyLabel}` : 'No hotkey';
    if(ability){
      abilityRepoSubtitle.textContent = `Slot ${slotNumber} (${hotkeyText}) â€” ${ability.name}`;
    } else {
      abilityRepoSubtitle.textContent = `Assign a spell to slot ${slotNumber} (${hotkeyText}).`;
    }
  }
  function renderSpellList(){
    if(!spellListEl) return;
    spellListEl.innerHTML = '';
    if(abilityBarState.activeSlotIndex === null){
      const msg = document.createElement('div');
      msg.className = 'spellEmpty';
      msg.textContent = 'Select an ability slot to view spells.';
      spellListEl.appendChild(msg);
      return;
    }
    const abilities = listAbilities();
    if(!abilities.length){
      const empty = document.createElement('div');
      empty.className = 'spellEmpty';
      empty.textContent = 'No spells available yet.';
      spellListEl.appendChild(empty);
      return;
    }
    const assignedId = abilityAssignments[abilityBarState.activeSlotIndex];
    const equippedSet = new Set(abilityAssignments.filter(Boolean));
    abilities.forEach(ability => {
      const option = document.createElement('button');
      option.type = 'button';
      option.className = 'spellCard';
      option.dataset.abilityId = ability.id;
      option.setAttribute('role', 'option');
      option.setAttribute('tabindex', '0');
      option.setAttribute('aria-selected', ability.id === assignedId ? 'true' : 'false');
      option.title = abilitySummary(ability);
      if(ability.id === assignedId) option.classList.add('selected');
      if(ability.id === abilityBarState.editingAbilityId) option.classList.add('editing');
      if(equippedSet.has(ability.id)) option.classList.add('equipped');
      const name = document.createElement('div');
      name.className = 'spellName';
      name.textContent = ability.name;
      option.appendChild(name);
      const desc = document.createElement('div');
      desc.className = 'spellDesc';
      desc.textContent = ability.description;
      option.appendChild(desc);
      const summary = document.createElement('div');
      summary.className = 'spellSummary';
      summary.textContent = abilitySummary(ability);
      option.appendChild(summary);
      option.addEventListener('click', ()=> selectAbilityForActiveSlot(ability.id));
      option.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); selectAbilityForActiveSlot(ability.id); }
      });
      option.addEventListener('contextmenu', (ev)=>{
        ev.preventDefault();
        showAbilityEditor(ability.id);
      });
      spellListEl.appendChild(option);
    });
  }
  function showAbilityEditor(abilityId){
    const ability = getAbilityDefinition(abilityId);
    if(!ability || !spellEditorForm){
      resetAbilityEditor();
      return;
    }
    abilityBarState.editingAbilityId = abilityId;
    if(spellEditorPlaceholder) spellEditorPlaceholder.hidden = true;
    spellEditorForm.hidden = false;
    spellEditorForm.innerHTML = '';
    const title = document.createElement('div');
    title.className = 'editorTitle';
    title.textContent = `${ability.name} attributes`;
    spellEditorForm.appendChild(title);
    const subtitle = document.createElement('div');
    subtitle.className = 'editorSubtitle';
    subtitle.textContent = ability.description;
    spellEditorForm.appendChild(subtitle);
    const castRow = document.createElement('div');
    castRow.className = 'editorRow';
    const castLabel = document.createElement('label');
    const castSelectId = `spell-${ability.id}-castType`;
    castLabel.setAttribute('for', castSelectId);
    castLabel.textContent = 'Default cast behavior';
    const castSelect = document.createElement('select');
    castSelect.id = castSelectId;
    const castOptions = [
      { value: 'none', label: 'Use player default' },
      { value: 'normal', label: 'Normal cast' },
      { value: 'quickIndicator', label: 'Quick cast with indicator' },
      { value: 'quick', label: 'Quick cast' }
    ];
    const allowedCastTypes = new Set(abilityAllowedCastTypes(ability));
    castSelect.innerHTML = castOptions
      .filter(option => allowedCastTypes.has(option.value))
      .map(option => `<option value="${option.value}">${option.label}</option>`)
      .join('');
    const normalizedAbilityCastType = normalizeAbilityCastType(ability, ability.castType);
    castSelect.value = normalizedAbilityCastType;
    castSelect.addEventListener('change', ()=>{
      ability.castType = normalizeAbilityCastType(ability, castSelect.value);
      castSelect.value = ability.castType;
      if(isAbilityRepoOpen()) renderSpellList();
    });
    castRow.appendChild(castLabel);
    castRow.appendChild(castSelect);
    spellEditorForm.appendChild(castRow);
    ability.fields.forEach(field => {
      const row = document.createElement('div');
      row.className = 'editorRow';
      const label = document.createElement('label');
      const inputId = `spell-${ability.id}-${field.key}`;
      label.setAttribute('for', inputId);
      const labelText = document.createElement('span');
      labelText.textContent = field.label;
      const range = document.createElement('span');
      range.className = 'editorRange';
      range.textContent = `${field.min}â€“${field.max}${field.unit || ''}`;
      label.appendChild(labelText);
      label.appendChild(range);
      const input = document.createElement('input');
      input.type = 'number';
      input.id = inputId;
      input.min = String(field.min);
      input.max = String(field.max);
      if(field.step) input.step = String(field.step);
      input.value = String(field.value);
      input.addEventListener('input', ()=>{
        const clamped = clampFieldValue(field, input.value);
        field.value = clamped;
        input.value = String(clamped);
        renderAbilityBar();
        if(isAbilityRepoOpen()) renderSpellList();
      });
      row.appendChild(label);
      row.appendChild(input);
      spellEditorForm.appendChild(row);
    });
    if(isAbilityRepoOpen()) renderSpellList();
  }
  function assignAbilityToSlot(slotIndex, abilityId, options = {}){
    if(slotIndex < 0 || slotIndex >= abilityBarState.count) return false;
    const { keepRepoOpen = false, setActiveSlot = false } = options;
    if(setActiveSlot){
      abilityBarState.activeSlotIndex = slotIndex;
    }
    for(let i=0;i<Math.min(abilityAssignments.length, abilityBarState.count);i++){
      if(i !== slotIndex && abilityAssignments[i] === abilityId){
        abilityAssignments[i] = null;
      }
    }
    abilityAssignments[slotIndex] = abilityId;
    const state = getAbilitySlotState(slotIndex);
    if(state){ state.cooldown = 0; }
    renderAbilityBar();
    updateAbilityRepoSubtitle();
    refreshAbilityCooldownUI();
    const repoOpen = isAbilityRepoOpen();
    if(repoOpen){
      renderSpellList();
      if(!keepRepoOpen){
        closeAbilityRepository();
      }
    }
    return true;
  }
  function selectAbilityForActiveSlot(abilityId){
    if(abilityBarState.activeSlotIndex === null) return;
    assignAbilityToSlot(abilityBarState.activeSlotIndex, abilityId);
  }
  function cycleAbilityAssignment(){
    const abilities = listAbilities().filter(ability => ability && ability.id);
    if(!abilities.length){
      setHudMessage('No spells available to cycle.');
      return;
    }
    if(abilityBarState.count <= 0){
      setHudMessage('Add an ability slot to cycle spells.');
      return;
    }
    let slotIndex = Number.isFinite(abilityBarState.activeSlotIndex) ? abilityBarState.activeSlotIndex : 0;
    slotIndex = Math.max(0, Math.min(abilityBarState.count - 1, slotIndex));
    const abilityCount = abilities.length;
    let nextIndex = Math.max(0, Math.floor(Number(abilityRuntime.abilityCycleIndex) || 0));
    if(nextIndex >= abilityCount){
      nextIndex = 0;
    }
    const ability = abilities[nextIndex];
    abilityRuntime.abilityCycleIndex = (nextIndex + 1) % abilityCount;
    if(!ability || !ability.id) return;
    assignAbilityToSlot(slotIndex, ability.id, { keepRepoOpen: true, setActiveSlot: true });
    const label = ability.shortName || ability.name;
    setHudMessage(`${label} equipped in slot ${slotIndex + 1}.`);
  }
  function serializeAbilityFields(ability){
    if(!ability || !Array.isArray(ability.fields)) return {};
    const fields = {};
    ability.fields.forEach(field => {
      if(!field || typeof field.key === 'undefined') return;
      const key = String(field.key);
      fields[key] = {
        value: field.value,
        min: field.min,
        max: field.max,
        step: field.step,
        unit: field.unit || ''
      };
      if(field.scale){
        fields[key].scale = field.scale;
      }
    });
    return fields;
  }
  function buildSpellConfigSnapshot(){
    const snapshot = {
      generatedAt: new Date().toISOString(),
      abilityTunables: {
        spellSpeedScale: abilityTunables.spellSpeedScale,
        spellSizeScale: abilityTunables.spellSizeScale
      },
      abilities: {}
    };
    listAbilities().forEach(ability => {
      if(!ability || !ability.id) return;
      snapshot.abilities[ability.id] = {
        id: ability.id,
        name: ability.name,
        shortName: ability.shortName,
        description: ability.description,
        castType: normalizeAbilityCastType(ability, ability.castType),
        fields: serializeAbilityFields(ability)
      };
    });
    return snapshot;
  }
  function formatSpellConfigFilename(){
    const now = new Date();
    const pad = (value)=> String(value).padStart(2, '0');
    const base = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    return `spell-configs-${base}.json`;
  }
  function saveSpellConfigurations(){
    const snapshot = buildSpellConfigSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = formatSpellConfigFilename();
    const parent = document.body || document.documentElement;
    if(parent){
      parent.appendChild(link);
      link.click();
      parent.removeChild(link);
    } else {
      link.click();
    }
    setTimeout(() => URL.revokeObjectURL(url), 0);
  }
  function openAbilityRepository(slotIndex){
    if(slotIndex < 0 || slotIndex >= abilityBarState.count) return;
    abilityBarState.activeSlotIndex = slotIndex;
    resetAbilityEditor();
    if(abilityRepoEl){
      abilityRepoEl.classList.add('open');
      abilityRepoEl.setAttribute('aria-hidden', 'false');
    }
    updateAbilityRepoSubtitle();
    renderSpellList();
    highlightActiveAbilitySlot();
  }
  function closeAbilityRepository(){
    if(abilityRepoEl){
      abilityRepoEl.classList.remove('open');
      abilityRepoEl.setAttribute('aria-hidden', 'true');
    }
    abilityBarState.activeSlotIndex = null;
    resetAbilityEditor();
    updateAbilityRepoSubtitle();
    highlightActiveAbilitySlot();
  }
  function updateAbilityHotkeyHint(){
    /* Ability hotkey tooltip removed */
  }
  function enterAbilityHotkeyMode(){
    if(abilityBarState.count <= 0){
      setHudMessage('No ability slots to map. Increase the ability count first.');
      return;
    }
    abilityBarState.hotkeyMode = true;
    abilityBarState.hotkeyCaptureIndex = null;
    if(isAbilityRepoOpen()) closeAbilityRepository();
    updateAbilityHotkeyHint();
    renderAbilityBar();
    setHudMessage('Hotkey mapping active â€” click a slot, then press a key. Press Esc to exit.');
  }
  function exitAbilityHotkeyMode(){
    if(!abilityBarState.hotkeyMode) return;
    abilityBarState.hotkeyMode = false;
    abilityBarState.hotkeyCaptureIndex = null;
    updateAbilityHotkeyHint();
    renderAbilityBar();
    setHudMessage();
  }
  function startAbilityHotkeyCapture(index){
    if(!abilityBarState.hotkeyMode){
      enterAbilityHotkeyMode();
      if(!abilityBarState.hotkeyMode) return;
    }
    if(index < 0 || index >= abilityBarState.count) return;
    if(abilityBarState.hotkeyCaptureIndex === index){
      stopAbilityHotkeyCapture();
      return;
    }
    abilityBarState.hotkeyCaptureIndex = index;
    updateAbilityHotkeyHint();
    renderAbilityBar();
    setHudMessage(`Press a key to bind slot ${index + 1}. Press Esc to cancel.`);
  }
  function stopAbilityHotkeyCapture(options = {}){
    if(abilityBarState.hotkeyCaptureIndex === null) return;
    abilityBarState.hotkeyCaptureIndex = null;
    updateAbilityHotkeyHint();
    renderAbilityBar();
    if(!options.silent){
      setHudMessage('Hotkey mapping active â€” click a slot, then press a key. Press Esc to exit.');
    }
  }
  function sanitizeAbilityCount(value){
    const next = Number(value);
    if(!Number.isFinite(next)) return clamp(abilityBarState.count, 0, 20);
    return clamp(next, 0, 20);
  }
  function sanitizeAbilityScale(value){
    let next = parseFloat(value);
    if(!Number.isFinite(next)) next = abilityBarState.scale;
    next = Math.max(0, Math.min(4, next));
    return Math.round(next * 100) / 100;
  }
  function abilityKeyLabel(index){
    const binding = getAbilityBinding(index);
    return binding ? binding.label : 'â€”';
  }
  function renderAbilityBar(){
    if(!abilityBarEl) return;
    ensureAbilityAssignments();
    ensureAbilityHotkeys();
    ensureAbilitySlotStates();
    abilityBarEl.innerHTML = '';
    const orientation = abilityBarState.orientation === 'vertical' ? 'vertical' : 'horizontal';
    abilityBarEl.dataset.orientation = orientation;
    const abilityWrap = abilityBarEl.closest('.hudAbilityBarWrap');
    if(abilityWrap){
      abilityWrap.dataset.orientation = orientation;
    }
    const scale = abilityBarState.scale > 0 ? abilityBarState.scale : 1;
    abilityBarEl.style.setProperty('--ability-scale', String(scale));
    abilityBarEl.dataset.hotkeyMode = abilityBarState.hotkeyMode ? 'true' : 'false';
    abilityBarEl.dataset.hotkeyCapturing = abilityBarState.hotkeyCaptureIndex !== null ? 'true' : 'false';
    for(let i=0;i<abilityBarState.count;i++){
      const slot = document.createElement('div');
      slot.className = 'abilitySlot';
      if(abilityBarState.hotkeyMode) slot.classList.add('hotkey-mode');
      if(abilityBarState.hotkeyCaptureIndex === i) slot.classList.add('hotkey-capturing');
      slot.dataset.index = String(i);
      slot.setAttribute('role', 'button');
      slot.setAttribute('tabindex', '0');
      slot.setAttribute('aria-haspopup', 'dialog');
      const abilityId = abilityAssignments[i];
      const ability = abilityId ? getAbilityDefinition(abilityId) : null;
      const binding = getAbilityBinding(i);
      const hotkeyLabel = binding ? binding.label : 'â€”';
      const hotkeyTitle = hotkeyLabel && hotkeyLabel !== 'â€”' ? `Hotkey: ${hotkeyLabel}` : 'No hotkey assigned';
      if(ability){
        slot.dataset.hasAbility = 'true';
        const label = document.createElement('span');
        label.className = 'abilityName';
        label.textContent = ability.shortName || ability.name;
        slot.appendChild(label);
        const abilityDescription = ability.description || abilitySummary(ability) || 'No description available';
        slot.title = `${ability.name} â€” ${abilityDescription} (${hotkeyTitle})`;
        slot.setAttribute('aria-label', `${ability.name}. ${abilityDescription}. ${hotkeyTitle}.`);
      } else {
        slot.dataset.hasAbility = 'false';
        slot.title = `Empty ability slot (${hotkeyTitle})`;
        slot.setAttribute('aria-label', `Empty ability slot ${i+1}. ${hotkeyTitle}.`);
      }
      const key = document.createElement('span');
      key.className = 'abilityKey';
      key.textContent = abilityBarState.hotkeyCaptureIndex === i ? '??' : abilityKeyLabel(i);
      slot.appendChild(key);
      const state = getAbilitySlotState(i);
      slot.dataset.cooldown = state && state.cooldown > 0 ? 'true' : 'false';
      const activateSlot = (ev)=>{
        if(abilityBarState.hotkeyMode){
          ev.preventDefault();
          ev.stopPropagation();
          startAbilityHotkeyCapture(i);
          return;
        }
        openAbilityRepository(i);
      };
      slot.addEventListener('click', activateSlot);
      slot.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); activateSlot(ev); }
      });
      slot.addEventListener('contextmenu', (ev)=>{ ev.preventDefault(); activateSlot(ev); });
      abilityBarEl.appendChild(slot);
    }
    const visible = abilityBarState.count > 0 && abilityBarState.scale > 0;
    abilityBarEl.classList.toggle('visible', visible);
    abilityBarEl.setAttribute('aria-hidden', visible ? 'false' : 'true');
    highlightActiveAbilitySlot();
    refreshAbilityCooldownUI();
    updateAbilityHotkeyHint();
    applyAbilityLayout();
  }
  function setAbilityBar(count = abilityBarState.count, scale = abilityBarState.scale, syncInputs = true){
    abilityBarState.count = sanitizeAbilityCount(count);
    abilityBarState.scale = sanitizeAbilityScale(scale);
    ensureAbilityAssignments();
    ensureAbilityHotkeys();
    ensureAbilitySlotStates();
    if(syncInputs){
      if(abilityCountInput){ abilityCountInput.value = String(abilityBarState.count); }
      if(abilityScaleInput){ abilityScaleInput.value = String(abilityBarState.scale); }
    }
    const repoOpen = isAbilityRepoOpen();
    if(abilityBarState.count === 0){
      abilityBarState.activeSlotIndex = null;
      if(abilityBarState.hotkeyMode) exitAbilityHotkeyMode();
      abilityBarState.hotkeyCaptureIndex = null;
      if(repoOpen) closeAbilityRepository();
    } else if(repoOpen){
      if(abilityBarState.activeSlotIndex === null || abilityBarState.activeSlotIndex >= abilityBarState.count){
        abilityBarState.activeSlotIndex = Math.max(0, Math.min(abilityBarState.count - 1, abilityBarState.activeSlotIndex ?? 0));
      }
      updateAbilityRepoSubtitle();
      renderSpellList();
    }
    if(abilityBarState.hotkeyCaptureIndex !== null && abilityBarState.hotkeyCaptureIndex >= abilityBarState.count){
      abilityBarState.hotkeyCaptureIndex = abilityBarState.count > 0 ? abilityBarState.count - 1 : null;
    }
    renderAbilityBar();
  }

  function refreshAbilityCooldownUI(){
    if(!abilityBarEl) return;
    const slots = abilityBarEl.querySelectorAll('.abilitySlot');
    slots.forEach(slot => {
      const index = Number(slot.dataset.index);
      if(!Number.isFinite(index)) return;
      const state = getAbilitySlotState(index);
      const remaining = state ? Math.max(0, Number(state.cooldown) || 0) : 0;
      let cooldownEl = slot.querySelector('.abilityCooldown');
      if(remaining > 0){
        const text = remaining >= 10 ? String(Math.ceil(remaining)) : remaining.toFixed(1);
        if(!cooldownEl){
          cooldownEl = document.createElement('span');
          cooldownEl.className = 'abilityCooldown';
          slot.appendChild(cooldownEl);
        }
        cooldownEl.textContent = text;
        slot.dataset.cooldown = 'true';
      } else {
        if(cooldownEl) cooldownEl.remove();
        slot.dataset.cooldown = 'false';
      }
    });
  }

  function setAbilitySlotCooldown(slotIndex, seconds){
    const state = getAbilitySlotState(slotIndex);
    if(!state) return;
    state.cooldown = Math.max(0, Number(seconds) || 0);
    refreshAbilityCooldownUI();
  }

  function reduceAllAbilityCooldowns(seconds){
    if(!(seconds > 0)) return;
    ensureAbilitySlotStates();
    let changed = false;
    for(const state of abilitySlotStates){
      if(!state) continue;
      const remaining = Math.max(0, Number(state.cooldown) || 0);
      if(!(remaining > 0)) continue;
      const next = Math.max(0, remaining - seconds);
      if(next !== remaining){
        state.cooldown = next;
        changed = true;
      }
    }
    if(changed){
      refreshAbilityCooldownUI();
    }
  }

  function abilityCooldownSeconds(ability){
    const cooldownMs = abilityFieldValue(ability, 'cooldownMs');
    return Math.max(0, Number(cooldownMs) || 0) / 1000;
  }

  function updateAbilityCooldowns(dt){
    ensureAbilitySlotStates();
    for(const state of abilitySlotStates){
      if(!state) continue;
      if(state.cooldown > 0){
        state.cooldown = Math.max(0, state.cooldown - dt);
      }
    }
    refreshAbilityCooldownUI();
  }

  function beamAimPoint(){
    if(abilityRuntime.lastPointerWorld && Number.isFinite(abilityRuntime.lastPointerWorld.x) && Number.isFinite(abilityRuntime.lastPointerWorld.y)){
      return { x: abilityRuntime.lastPointerWorld.x, y: abilityRuntime.lastPointerWorld.y };
    }
    if(player.selectedTarget){
      return { x: player.selectedTarget.x, y: player.selectedTarget.y };
    }
    if(player.chaseTarget){
      return { x: player.chaseTarget.x, y: player.chaseTarget.y };
    }
    if(player.target && Number.isFinite(player.target.x) && Number.isFinite(player.target.y)){
      return { x: player.target.x, y: player.target.y };
    }
    return { x: player.x + player.r, y: player.y };
  }

  Object.assign(abilityDefinitions, {
    spinning_axe: {
      id: 'spinning_axe',
      name: 'Spinning Axe',
      shortName: 'Spinning',
      description: 'Empower your next basic attack to throw a spinning axe that lands nearby. Catch it to regain the buff.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 30000, step: 50, value: 12000 },
        { key: 'bonusDamage', label: 'Bonus damage', unit: ' dmg', min: 0, max: 400, step: 5, value: 25 },
        { key: 'maxInHand', label: 'Max axes held', unit: '', min: 1, max: 4, step: 1, value: 2 },
        { key: 'flightTimeMs', label: 'Flight time', unit: 'ms', min: 0, max: 5000, step: 25, value: 2000 },
        { key: 'catchWindowMs', label: 'Catch window', unit: 'ms', min: 0, max: 5000, step: 25, value: 1200 },
        { key: 'catchRadiusPx', label: 'Catch radius', unit: 'px', min: 0, max: 400, step: 5, value: 120, scale: 'size' },
        { key: 'moveSpeedThreshold', label: 'Move speed threshold', unit: 'px/s', min: 0, max: 600, step: 5, value: 50, scale: 'speed' },
        { key: 'forwardMinPx', label: 'Forward min distance', unit: 'px', min: 0, max: 500, step: 5, value: 130, scale: 'size' },
        { key: 'forwardMaxPx', label: 'Forward max distance', unit: 'px', min: 0, max: 500, step: 5, value: 170, scale: 'size' },
        { key: 'stillMinPx', label: 'Still min distance', unit: 'px', min: 0, max: 300, step: 5, value: 40, scale: 'size' },
        { key: 'stillMaxPx', label: 'Still max distance', unit: 'px', min: 0, max: 300, step: 5, value: 80, scale: 'size' },
        { key: 'sideJitterMaxPx', label: 'Side jitter max', unit: 'px', min: 0, max: 200, step: 5, value: 20, scale: 'size' },
        { key: 'edgeMarginPx', label: 'Edge margin', unit: 'px', min: 0, max: 400, step: 5, value: 50, scale: 'size' }
      ]
    },
    ember_bolt: {
      id: 'ember_bolt',
      name: 'Ember Bolt',
      shortName: 'Ember',
      description: 'Fire a single blazing orb that stuns the first enemy it touches.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 7500 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 1000, step: 25, value: 250 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 3000, step: 5, value: 1100 },
        { key: 'projectileWidthPx', label: 'Width', unit: 'px', min: 0, max: 200, step: 1, value: 120 },
        { key: 'projectileSpeedPxS', label: 'Speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1600, scale: 'speed' },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 400, step: 5, value: 145 },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 1750 }
      ]
    },
    flame_pillar: {
      id: 'flame_pillar',
      name: 'Flame Pillar',
      shortName: 'Pillar',
      description: 'Erupt a column of fire after a brief delay that scars enemies in the blast.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 25000, step: 50, value: 9000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 1000, step: 25, value: 250 },
        { key: 'targetRangePx', label: 'Target range', unit: 'px', min: 0, max: 2000, step: 5, value: 900 },
        { key: 'aoeRadiusPx', label: 'Impact radius', unit: 'px', min: 0, max: 600, step: 5, value: 260 },
        { key: 'releaseDelayMs', label: 'Delay', unit: 'ms', min: 0, max: 2000, step: 25, value: 627 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 190 }
      ]
    },
    pyroclasm_chain: {
      id: 'pyroclasm_chain',
      name: 'Pyroclasm Chain',
      shortName: 'Pyroclasm',
      description: 'Launch a bouncing fireball that slams foes and slows anyone it grazes.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 200000, step: 50, value: 90000 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 3000, step: 5, value: 750 },
        { key: 'projectileWidthPx', label: 'Width', unit: 'px', min: 0, max: 200, step: 1, value: 120 },
        { key: 'projectileSpeedPxS', label: 'Speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2200, scale: 'speed' },
        { key: 'boltCount', label: 'Bounces', unit: '', min: 1, max: 6, step: 1, value: 4 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 400, step: 5, value: 190 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 45 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 2000, step: 25, value: 250 },
        { key: 'bounceRadiusPx', label: 'Bounce radius', unit: 'px', min: 0, max: 1200, step: 5, value: 600 }
      ]
    },
    frenzied_slash: {
      id: 'frenzied_slash',
      name: 'Frenzied Slash',
      shortName: 'Frenzy',
      description: 'Burst into a frenzy that forces nearby targets to feel your bite while buffing your speed and sustain.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 30000, step: 50, value: 12000 },
        { key: 'durationMs', label: 'Frenzy duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 5000 },
        { key: 'attackSpeedPct', label: 'Attack speed', unit: '%', min: 0, max: 200, step: 5, value: 80 },
        { key: 'bonusMoveSpeed', label: 'Move speed', unit: '%', min: 0, max: 100, step: 1, value: 35 },
        { key: 'healPct', label: 'Heal on hit', unit: '% max', min: 0, max: 50, step: 1, value: 5 }
      ]
    },
    royal_onslaught: {
      id: 'royal_onslaught',
      name: 'Royal Onslaught',
      shortName: 'Onslaught',
      description: 'Surge through three empowered strikes, hitting the main foe and bursting nearby enemies.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 60000, step: 50, value: 15000 },
        { key: 'durationMs', label: 'Empower duration', unit: 'ms', min: 0, max: 6000, step: 25, value: 3000 },
        { key: 'attackSpeedPct', label: 'Attack speed', unit: '%', min: 0, max: 200, step: 5, value: 35 },
        { key: 'bonusDamagePct', label: 'Primary bonus damage', unit: '% AD', min: 0, max: 200, step: 5, value: 40 },
        { key: 'splashDamagePct', label: 'Splash damage', unit: '% AD', min: 0, max: 200, step: 5, value: 25 },
        { key: 'splashRadiusPx', label: 'Splash radius', unit: 'px', min: 0, max: 800, step: 5, value: 325 },
        { key: 'charges', label: 'Empowered attacks', unit: '', min: 1, max: 6, step: 1, value: 3 }
      ]
    },
    sweep_strike: {
      id: 'sweep_strike',
      name: 'Sweep Strike',
      shortName: 'Sweep',
      description: 'Sweep a wide arc that deals bonus damage to enemies on the outer blade and nails them with a hard slow.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 14000 },
        { key: 'projectileRangePx', label: 'Range', unit: 'px', min: 0, max: 2000, step: 5, value: 650 },
        { key: 'widthPx', label: 'Cone width', unit: 'px', min: 0, max: 800, step: 1, value: 380 },
        { key: 'damage', label: 'Base damage', unit: ' dmg', min: 0, max: 400, step: 5, value: 150 },
        { key: 'outerDamagePct', label: 'Outer damage %', unit: '%', min: 0, max: 100, step: 1, value: 8 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 80 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 2000 }
      ]
    },
    terrain_grapple: {
      id: 'terrain_grapple',
      name: 'Terrain Grapple',
      shortName: 'Grapple',
      description: 'Fire a hook toward terrain and slam toward the anchor, opening up farther jumps.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 15000 },
        { key: 'projectileRangePx', label: 'Hook range', unit: 'px', min: 0, max: 4000, step: 5, value: 800 },
      { key: 'projectileSpeedPxS', label: 'Hook speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1400, scale: 'speed' },
      { key: 'dashDistancePx', label: 'Dash distance', unit: 'px', min: 0, max: 2000, step: 5, value: 800 },
      { key: 'dashSpeedPxS', label: 'Dash speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 1800, scale: 'speed' },
      { key: 'projectileWidthPx', label: 'Hook width', unit: 'px', min: 0, max: 200, step: 1, value: 100 }
    ]
  },
    wall_leap: {
      id: 'wall_leap',
      name: 'Wall Leap',
      shortName: 'Leap',
      description: 'Leap off walls toward your foe, slamming them and stunning on arrival while gaining attack speed.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 11000 },
        { key: 'dashDistancePx', label: 'Dash distance', unit: 'px', min: 0, max: 2000, step: 5, value: 800 },
        { key: 'impactRadiusPx', label: 'Impact radius', unit: 'px', min: 0, max: 400, step: 5, value: 130 },
        { key: 'damage', label: 'Impact damage', unit: ' dmg', min: 0, max: 600, step: 5, value: 170 },
        { key: 'stunDurationMs', label: 'Stun duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 750 },
        { key: 'bonusAttackSpeedPct', label: 'Attack speed', unit: '%', min: 0, max: 200, step: 5, value: 50 }
      ]
    },
    hextech_zone: {
      id: 'hextech_zone',
      name: 'Hextech Zone',
      shortName: 'Ultimatum',
      description: 'Leap onto a target and trap them in a hex zone that slows, damages, and fears nearby foes.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 240000, step: 50, value: 115000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 500 },
        { key: 'targetRangePx', label: 'Target range', unit: 'px', min: 0, max: 2000, step: 5, value: 475 },
        { key: 'dashDistancePx', label: 'Leap distance', unit: 'px', min: 0, max: 2000, step: 5, value: 475 },
        { key: 'aoeRadiusPx', label: 'Zone radius', unit: 'px', min: 0, max: 1000, step: 5, value: 425 },
        { key: 'durationMs', label: 'Zone duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 3000 },
        { key: 'damage', label: 'Bonus damage', unit: ' dmg', min: 0, max: 400, step: 5, value: 120 },
        { key: 'slowPct', label: 'Slow', unit: '%', min: 0, max: 100, step: 1, value: 35 },
        { key: 'slowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 4000, step: 25, value: 1500 }
      ]
    },
    piercing_vault: {
      id: 'piercing_vault',
      name: 'Piercing Vault',
      shortName: 'Vault',
      description: 'Launch toward the target direction, finishing with a swift stab that refunds half the cooldown on impact.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 25, value: 13000 },
        { key: 'dashDistancePx', label: 'Vault distance', unit: 'px', min: 0, max: 2000, step: 5, value: 420 },
        { key: 'dashSpeedPxS', label: 'Vault speed', unit: 'px/s', min: 0, max: 4000, step: 10, value: 2800, scale: 'speed' },
        { key: 'damage', label: 'Stab damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 115 },
        { key: 'bonusMoveSpeed', label: 'After-hit move speed', unit: '%', min: 0, max: 100, step: 5, value: 25 },
        { key: 'cooldownReductionPct', label: 'Hit cooldown refund', unit: '%', min: 0, max: 100, step: 5, value: 50 }
      ]
    },
    twin_flourish: {
      id: 'twin_flourish',
      name: 'Twin Flourish',
      shortName: 'Flourish',
      description: 'Empower two sweeping strikes: the opener slows before a follow-up that hits hard and crits.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 25, value: 11000 },
        { key: 'durationMs', label: 'Window duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 4000 },
        { key: 'attackSpeedPct', label: 'Attack speed boost', unit: '%', min: 0, max: 200, step: 5, value: 80 },
        { key: 'firstHitDamage', label: 'First hit damage', unit: ' dmg', min: 0, max: 400, step: 5, value: 70 },
        { key: 'firstHitSlowPct', label: 'First hit slow', unit: '%', min: 0, max: 100, step: 1, value: 30 },
        { key: 'firstHitSlowDurationMs', label: 'Slow duration', unit: 'ms', min: 0, max: 2000, step: 25, value: 1000 },
        { key: 'secondHitDamage', label: 'Second hit damage', unit: ' dmg', min: 0, max: 800, step: 5, value: 130 },
        { key: 'secondHitCritMultiplierPct', label: 'Critical multiplier', unit: '%', min: 100, max: 250, step: 5, value: 180 }
      ]
    },
    spiral_gale: {
      id: 'spiral_gale',
      name: 'Spiral Gale',
      shortName: 'Spiral',
      description: 'Cleave a wide cone of wind, shield yourself, and leave enemies staggered by the spiraling impact.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 20000, step: 50, value: 9000 },
        { key: 'castTimeMs', label: 'Cast time', unit: 'ms', min: 0, max: 2000, step: 25, value: 325 },
        { key: 'coneRangePx', label: 'Cleave range', unit: 'px', min: 0, max: 1600, step: 5, value: 600 },
        { key: 'coneWidthPx', label: 'Cleave width', unit: 'deg', min: 0, max: 180, step: 5, value: 80 },
        { key: 'damage', label: 'Damage', unit: ' dmg', min: 0, max: 500, step: 5, value: 210 },
        { key: 'shieldAmount', label: 'Shield grant', unit: ' hp', min: 0, max: 600, step: 10, value: 120 }
      ]
    },
    phantom_return: {
      id: 'phantom_return',
      name: 'Phantom Return',
      shortName: 'Phantom',
      description: 'Dash into spirit form, storing damage, then snap back through your ghost to reclaim your body with a burst.',
      fields: [
        { key: 'cooldownMs', label: 'Cooldown', unit: 'ms', min: 0, max: 240000, step: 50, value: 21000 },
        { key: 'dashDistancePx', label: 'Spirit dash', unit: 'px', min: 0, max: 2000, step: 5, value: 700 },
        { key: 'durationMs', label: 'Spirit duration', unit: 'ms', min: 0, max: 10000, step: 25, value: 5000 },
        { key: 'ghostDurationMs', label: 'Ghost window', unit: 'ms', min: 0, max: 2000, step: 25, value: 300 },
        { key: 'damage', label: 'Return damage', unit: ' dmg', min: 0, max: 800, step: 5, value: 170 },
        { key: 'recastWindowMs', label: 'Recast window', unit: 'ms', min: 0, max: 10000, step: 25, value: 5000 }
      ]
    },
  });

  const abilityHandlers = {
    spinning_axe: castSpinningAxeAbility,
    beam: castBeamAbility,
    serpents_bloom: castVenomBloomAbility,
    laserCone: castLaserConeAbility,
    blade_cyclone: castBladeCycloneAbility,
    duskwave_infernum: castDuskwaveAbility,
    sirens_kiss: castSirensKissAbility,
    shiver_spike: castShiverSpikeAbility,
    bedrock_burst: castBedrockBurstAbility,
    rage_pulse: castRagePulseAbility,
    kunai_fanburst: castKunaiFanburstAbility,
    slam: castSlamAbility,
    grab: castGrabAbility,
    wrapdash: castWrapdashAbility,
    backline_seizure: castBacklineSeizureAbility,
    link_lash: castLinkLashAbility,
    gravity_surge: castGravitySurgeAbility,
    bone_skewer: castBoneSkewerAbility,
    astral_snare: castAstralSnareAbility,
    blinkingBolt: castBlinkingBoltAbility,
    ember_waltz: castEmberWaltzAbility,
    cascade_barrage: castCascadeBarrageAbility,
    frenzied_surge: castFrenziedSurgeAbility,
    royal_onslaught: castRoyalOnslaughtAbility,
    striding_surge: castStridingSurgeAbility,
    phantom_overdrive: castPhantomOverdriveAbility,
    phantom_barrage: castPhantomBarrageAbility,
    inferno_barrage: castInfernoBarrageAbility,
    flipblade_pursuit: castFlipbladePursuitAbility,
    boltburst_rush: castBoltburstRushAbility,
    spiral_ram: castSpiralRamAbility,
    windpiercer_rush: castWindpiercerRushAbility,
    shatterburst_orb: castShatterburstOrbAbility,
    rebound_orb: castReboundOrbAbility,
    cyclone_axes: castCycloneAxesAbility,
    riptide_snapback: castRiptideSnapbackAbility,
    chrono_loop: castChronoLoopAbility,
    skull_rush: castSkullRushAbility,
    skyhook_strafe: castSkyhookStrafeAbility,
    twinstrike_pursuit: castTwinstrikePursuitAbility,
    ricochet_lob: castRicochetLobAbility,
    dirge_bloom: castDirgeBloomAbility,
    event_horizon: castEventHorizonAbility,
    trailblaze: castTrailblazeAbility,
    hailbound_tempest: castHailboundTempestAbility,
    frost_surge: castHailboundTempestAbility,
    shiver_maelstrom: castHailboundTempestAbility,
    proximity_traps: castProximityTrapAbility,
    edgewatch_snare: castProximityTrapAbility,
    scatter_minefield: castProximityTrapAbility,
    toxic_mine: castProximityTrapAbility,
    scatter_charge: castScatterChargeAbility,
    piercing_arrow: castPiercingArrowAbility,
    edgeflare_mark: castEdgeflareMarkAbility,
    focused_lockshot: castFocusedLockshotAbility,
    plasma_fission: castPlasmaFissionAbility,
    stone_gaze: castStoneGazeAbility,
    charging_gale: castChargingGaleAbility,
    avalanche_roll: castAvalancheRollAbility,
    reveal_shock: castRevealShockAbility,
    slingshot_crash: castSlingshotCrashAbility,
    springquake_stomp: castSpringquakeStompAbility,
    frenetic_volley: castFrenziedVolleyAbility,
    culling_barrage: castCullingBarrageAbility,
    purging_volley: castCullingBarrageAbility,
    verdict_salvo: castVerdictSalvoAbility,
    temporal_veil: castTemporalVeilAbility,
    celestial_crash: castCelestialCrashAbility,
    skyward_scout: castSkywardScoutAbility,
    mourning_march: castMourningMarchAbility,
    cinderfall_guardian: castCinderfallGuardianAbility,
    glacial_uplift: castGlacialUpliftAbility,
    spectral_stockade: castSpectralStockadeAbility,
    rite_arcane: castRiteArcaneAbility
  };

  function clampAbilityPoint(x, y){
    if(!mapState || !Number.isFinite(mapState.width) || !Number.isFinite(mapState.height)){
      return { x, y };
    }
    const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
    return {
      x: clampCoord(x, mapState.width),
      y: clampCoord(y, mapState.height)
    };
  }

  function applyPoisonStatus(target, duration){
    if(!target || !(duration > 0)) return;
    const next = Math.max(0, Number(target.poisonTimer) || 0);
    target.poisonTimer = Math.max(next, duration);
  }

  function minimalAngleDifference(a, b){
    if(!Number.isFinite(a) || !Number.isFinite(b)) return Math.PI;
    let diff = Math.abs(a - b) % (Math.PI * 2);
    if(diff > Math.PI){
      diff = Math.abs(diff - Math.PI * 2);
    }
    return diff;
  }

  function castVenomBloomAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Serpent Bloom';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'radiusPx')) || 0);
    const targetRange = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const totalDamage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const cloudDuration = Math.max(0, Number(abilityFieldValue(ability, 'cloudDurationMs')) || 0) / 1000;
    const tickInterval = Math.max(0.05, Number(abilityFieldValue(ability, 'tickIntervalMs')) || 429) / 1000;
    const poisonDuration = Math.max(0, Number(abilityFieldValue(ability, 'poisonDurationMs')) || 0) / 1000;
    const bonusMoveSpeed = Math.max(0, Number(abilityFieldValue(ability, 'bonusMoveSpeedPct')) || 0);
    const bonusMoveDuration = Math.max(0, Number(abilityFieldValue(ability, 'bonusMoveDurationMs')) || 0) / 1000;
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    if(radius <= 0){
      setHudMessage(`${abilityName} needs a radius configured.`);
      return false;
    }
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - player.x;
    let dy = aimPoint.y - player.y;
    let distance = Math.hypot(dx, dy);
    if(distance < 0.0001){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const clamped = targetRange > 0 ? Math.min(targetRange, distance) : distance;
    let targetX = player.x + dx / distance * clamped;
    let targetY = player.y + dy / distance * clamped;
    ({ x: targetX, y: targetY } = clampAbilityPoint(targetX, targetY));
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      targetX,
      targetY,
      radius,
      damage: totalDamage,
      cloudDuration,
      tickInterval,
      poisonDuration,
      bonusMoveSpeedPct: bonusMoveSpeed,
      bonusMoveDuration,
      cooldownSeconds,
      castDuration: castTime,
      elapsed: 0
    };
    if(castTime > 0){
      venomBloomCasts.push(cast);
      player.casting = cast;
      setHudMessage(`${abilityName} curling...`);
      return true;
    }
    spawnVenomBloomCloud(cast);
    setHudMessage(`${abilityName} erupts!`);
    return true;
  }

  function spawnVenomBloomCloud(cast){
    if(!cast) return;
    const radius = Math.max(0, Number(cast.radius) || 0);
    if(radius <= 0) return;
    const damage = Math.max(0, Number(cast.damage) || 0);
    const interval = Math.max(0.05, Number(cast.tickInterval) || 0.429);
    const duration = Math.max(interval, Number(cast.cloudDuration) || interval);
    const ticks = Math.max(1, Math.round(duration / interval));
    const tickDamage = ticks > 0 ? damage / ticks : 0;
    const centerX = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
    const centerY = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
    const cloud = {
      id: `venom-${abilityRuntime.venomBloomSequence++}`,
      abilityId: cast.abilityId,
      abilityName: cast.abilityName,
      casterRef: cast.casterRef,
      x: centerX,
      y: centerY,
      radius,
      duration,
      elapsed: 0,
      tickInterval: interval,
      tickTimer: interval,
      tickDamage,
      poisonDuration: Math.max(0, Number(cast.poisonDuration) || 0),
      bonusMoveSpeedPct: Math.max(0, Number(cast.bonusMoveSpeedPct) || 0),
      bonusMoveDuration: Math.max(0, Number(cast.bonusMoveDuration) || 0),
      hasGrantedHaste: false
    };
    venomClouds.push(cloud);
    flash(centerX, centerY, { startRadius: Math.max(8, radius * 0.4), endRadius: Math.max(radius + 36, 48), color: '#74ff9d' });
  }

  function updateVenomBloomCasts(dt){
    for(let i = venomBloomCasts.length - 1; i >= 0; i--){
      const cast = venomBloomCasts[i];
      if(!cast){
        venomBloomCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      if(cast.castDuration <= 0 || cast.elapsed >= cast.castDuration){
        spawnVenomBloomCloud(cast);
        venomBloomCasts.splice(i, 1);
        if(player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function applyVenomCloudTick(cloud){
    if(!cloud) return;
    const radius = Math.max(0, Number(cloud.radius) || 0);
    const damage = Math.max(0, Number(cloud.tickDamage) || 0);
    if(!(radius > 0) || !(damage > 0)) return;
    const targets = collectAbilityTargets();
    const allowedRadius = radius;
    for(const target of targets){
      if(!target) continue;
      const targetRadius = target === monsterState ? Math.max(minionRadius, monsterAttackRadius()) : minionRadius;
      const dx = target.x - cloud.x;
      const dy = target.y - cloud.y;
      const distSq = dx * dx + dy * dy;
      const rangeSq = (allowedRadius + targetRadius) * (allowedRadius + targetRadius);
      if(distSq > rangeSq) continue;
      const applied = applyAbilityDamage(target, damage);
      if(applied > 0){
        applyPoisonStatus(target, cloud.poisonDuration);
        if(target === monsterState && !cloud.hasGrantedHaste){
          const boost = Math.max(0, Number(cloud.bonusMoveSpeedPct) || 0);
          const boostDuration = Math.max(0, Number(cloud.bonusMoveDuration) || 0);
          if(boost > 0 && boostDuration > 0){
            player.hastePct = Math.max(player.hastePct || 0, boost);
            player.hasteTimer = Math.max(player.hasteTimer || 0, boostDuration);
            player.hasteDecayRate = boostDuration > 0 ? Math.max(0, player.hastePct) / boostDuration : 0;
            player.hasteMinPct = 0;
          }
          cloud.hasGrantedHaste = true;
        }
      }
    }
  }

  function updateVenomClouds(dt){
    for(let i = venomClouds.length - 1; i >= 0; i--){
      const cloud = venomClouds[i];
      if(!cloud){
        venomClouds.splice(i, 1);
        continue;
      }
      cloud.elapsed = Math.max(0, (Number(cloud.elapsed) || 0) + dt);
      cloud.tickTimer = Math.max(0, (Number(cloud.tickTimer) || 0) - dt);
      if(cloud.tickTimer <= 0){
        applyVenomCloudTick(cloud);
        cloud.tickTimer += Math.max(0.001, Number(cloud.tickInterval) || 0.3);
      }
      if(cloud.elapsed >= Math.max(0, Number(cloud.duration) || 0)){
        venomClouds.splice(i, 1);
      }
    }
  }

  function castMiasmaFieldAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Miasma Field';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const aoeRadius = Math.max(0, Number(abilityFieldValue(ability, 'aoeRadiusPx')) || 0);
    const cloudCount = Math.max(1, Math.floor(Number(abilityFieldValue(ability, 'cloudCount')) || 7));
    const cloudDuration = Math.max(0, Number(abilityFieldValue(ability, 'cloudDurationMs')) || 0) / 1000;
    const tickInterval = Math.max(0.05, Number(abilityFieldValue(ability, 'tickIntervalMs')) || 263) / 1000;
    const damagePerSecond = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const poisonDuration = Math.max(0, Number(abilityFieldValue(ability, 'poisonDurationMs')) || 0) / 1000;
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a cast range.`);
      return false;
    }
    if(!(aoeRadius > 0)){
      setHudMessage(`${abilityName} needs a cloud radius.`);
      return false;
    }
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - player.x;
    let dy = aimPoint.y - player.y;
    let distance = Math.hypot(dx, dy);
    if(distance < 0.0001){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const clamped = Math.min(maxRange, distance);
    let targetX = player.x + dx / distance * clamped;
    let targetY = player.y + dy / distance * clamped;
    ({ x: targetX, y: targetY } = clampAbilityPoint(targetX, targetY));
    const dirLen = Math.max(0.0001, Math.hypot(dx, dy));
    const dirX = dx / dirLen;
    const dirY = dy / dirLen;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      targetX,
      targetY,
      dirX,
      dirY,
      maxRange,
      aoeRadius,
      cloudCount,
      cloudDuration,
      tickInterval,
      damagePerSecond,
      slowPct,
      slowDuration,
      poisonDuration,
      cooldownSeconds,
      castDuration: castTime,
      elapsed: 0
    };
    if(castTime > 0){
      miasmaFieldCasts.push(cast);
      player.casting = cast;
      setHudMessage(`${abilityName} seeding...`);
      return true;
    }
    spawnMiasmaClouds(cast);
    setHudMessage(`${abilityName} blooms!`);
    return true;
  }

  function spawnMiasmaClouds(cast){
    if(!cast) return;
    const radius = Math.max(0, Number(cast.aoeRadius) || 0);
    const duration = Math.max(0, Number(cast.cloudDuration) || 0);
    const tickInterval = Math.max(0.05, Number(cast.tickInterval) || 0.263);
    const dps = Math.max(0, Number(cast.damagePerSecond) || 0);
    const damage = dps > 0 ? (dps / 1000) * tickInterval : 0;
    if(!(radius > 0) || !(duration > 0) || !(damage > 0)) return;
    const centerX = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
    const centerY = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
    const dirLen = Math.hypot(cast.dirX, cast.dirY) || 1;
    const normDirX = cast.dirX / dirLen;
    const normDirY = cast.dirY / dirLen;
    const perpX = -normDirY;
    const perpY = normDirX;
    const spacing = Math.max(0, radius * 1.2);
    for(let i = 0; i < cast.cloudCount; i++){
      const normalized = cast.cloudCount > 1 ? (i / (cast.cloudCount - 1)) - 0.5 : 0;
      const offset = normalized * spacing;
      const forward = Math.abs(normalized) * radius * 0.25;
      const cloudX = centerX + perpX * offset + normDirX * forward;
      const cloudY = centerY + perpY * offset + normDirY * forward;
      const cloud = {
        id: `miasma-${abilityRuntime.miasmaSequence++}-${i}`,
        abilityId: cast.abilityId,
        abilityName: cast.abilityName,
        casterRef: cast.casterRef,
        x: cloudX,
        y: cloudY,
        radius,
        duration,
        elapsed: 0,
        tickInterval,
        tickTimer: tickInterval,
        tickDamage: damage,
        slowPct: Math.max(0, Number(cast.slowPct) || 0),
        slowDuration: Math.max(0, Number(cast.slowDuration) || 0),
        poisonDuration: Math.max(0, Number(cast.poisonDuration) || 0)
      };
      miasmaClouds.push(cloud);
    }
    flash(centerX, centerY, { startRadius: Math.max(10, radius * 0.35), endRadius: Math.max(radius + 48, 60), color: '#8c44ff' });
  }

  function applyMiasmaCloudTick(cloud){
    if(!cloud) return;
    const radius = Math.max(0, Number(cloud.radius) || 0);
    const damage = Math.max(0, Number(cloud.tickDamage) || 0);
    if(!(radius > 0) || !(damage > 0)) return;
    const slowBase = Math.max(0, Number(cloud.slowPct) || 0);
    const slowDuration = Math.max(0, Number(cloud.slowDuration) || 0);
    const targets = collectAbilityTargets();
    const decay = Math.max(0, Math.min(1, 1 - (Math.min(cloud.elapsed, cloud.duration) / Math.max(cloud.duration, 0.0001))));
    const slowValue = slowBase * decay;
    for(const target of targets){
      if(!target) continue;
      const targetRadius = target === monsterState ? Math.max(minionRadius, monsterAttackRadius()) : minionRadius;
      const dx = target.x - cloud.x;
      const dy = target.y - cloud.y;
      const distSq = dx * dx + dy * dy;
      const rangeSq = (radius + targetRadius) * (radius + targetRadius);
      if(distSq > rangeSq) continue;
      const applied = applyAbilityDamage(target, damage);
      if(applied > 0){
        if(slowValue > 0){
          const existingSlow = Math.max(0, Number(target.slowPct) || 0);
          target.slowPct = Math.max(existingSlow, slowValue);
          target.slowTimer = Math.max(target.slowTimer || 0, slowDuration > 0 ? slowDuration : cloud.tickInterval);
        }
        applyPoisonStatus(target, cloud.poisonDuration);
      }
    }
  }

  function updateMiasmaFieldCasts(dt){
    for(let i = miasmaFieldCasts.length - 1; i >= 0; i--){
      const cast = miasmaFieldCasts[i];
      if(!cast){
        miasmaFieldCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      if(cast.castDuration <= 0 || cast.elapsed >= cast.castDuration){
        spawnMiasmaClouds(cast);
        miasmaFieldCasts.splice(i, 1);
        if(player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateMiasmaClouds(dt){
    for(let i = miasmaClouds.length - 1; i >= 0; i--){
      const cloud = miasmaClouds[i];
      if(!cloud){
        miasmaClouds.splice(i, 1);
        continue;
      }
      cloud.elapsed = Math.max(0, (Number(cloud.elapsed) || 0) + dt);
      cloud.tickTimer = Math.max(0, (Number(cloud.tickTimer) || 0) - dt);
      if(cloud.tickTimer <= 0){
        applyMiasmaCloudTick(cloud);
        cloud.tickTimer += Math.max(0.001, Number(cloud.tickInterval) || 0.3);
      }
      if(cloud.elapsed >= Math.max(0, Number(cloud.duration) || 0)){
        miasmaClouds.splice(i, 1);
      }
    }
  }

  function castFangStrikeAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Fanged Strike';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const range = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const baseDamage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const bonusDamage = Math.max(0, Number(abilityFieldValue(ability, 'bonusDamage')) || 0);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const healAmount = Math.max(0, Number(abilityFieldValue(ability, 'healAmount')) || 0);
    const healReduction = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'minionHealReductionPct')) || 0));
    const cooldownSeconds = abilityCooldownSeconds(ability);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a valid range.`);
      return false;
    }
    const target = resolveFocusedLockshotTarget(range);
    if(!target){
      setHudMessage(`${abilityName} found no target.`);
      return false;
    }
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      targetRef: target,
      damage: baseDamage,
      bonusDamage,
      healAmount,
      minionHealReductionPct: healReduction,
      cooldownSeconds,
      castDuration: castTime,
      elapsed: 0
    };
    if(castTime > 0){
      fangStrikeCasts.push(cast);
      player.casting = cast;
      cancelPlayerAttack(false);
      player.chaseTarget = null;
      player.navGoal = null;
      player.nav = null;
      setHudMessage(`${abilityName} readying...`);
      return true;
    }
    return executeFangStrike(cast);
  }

  function executeFangStrike(cast){
    if(!cast || !cast.targetRef){
      return false;
    }
    const target = cast.targetRef;
    const damage = Math.max(0, Number(cast.damage) || 0);
    const bonus = target.poisonTimer > 0 ? Math.max(0, Number(cast.bonusDamage) || 0) : 0;
    const totalDamage = damage + bonus;
    let applied = 0;
    if(totalDamage > 0){
      applied = applyAbilityDamage(target, totalDamage);
    }
    if(applied > 0 && target.poisonTimer > 0){
      let healValue = Math.max(0, Number(cast.healAmount) || 0);
      const reduction = Math.max(0, Math.min(100, Number(cast.minionHealReductionPct) || 0));
      if(target !== monsterState && !target.isPracticeDummy){
        healValue = healValue * (1 - reduction / 100);
      }
      if(healValue > 0){
        const nextHp = Math.min(player.maxHp || 0, (player.hp || 0) + healValue);
        const prevHp = Math.max(0, Number(player.hp) || 0);
        player.hp = Math.max(0, nextHp);
        if(player.hp > prevHp){
          spawnHitSplat(player.x, player.y - Math.max(player.r || 0, 12), Math.round(healValue));
          updateHudHealth();
        }
      }
    }
    if(player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, Math.max(0, Number(cast.cooldownSeconds) || 0));
    }
    setHudMessage(`${cast.abilityName || 'Fanged Strike'} ${applied > 0 ? 'hit!' : 'missed.'}`);
    return applied > 0;
  }

  function updateFangStrikeCasts(dt){
    for(let i = fangStrikeCasts.length - 1; i >= 0; i--){
      const cast = fangStrikeCasts[i];
      if(!cast){
        fangStrikeCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      if(cast.elapsed >= Math.max(0, Number(cast.castDuration) || 0)){
        executeFangStrike(cast);
        fangStrikeCasts.splice(i, 1);
      }
    }
  }

  function castStoneGazeAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Stone Gaze';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const range = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'coneWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const stunDuration = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    if(!(range > 0) || !(width > 0) || !(damage > 0)){
      setHudMessage(`${abilityName} is not configured.`);
      return false;
    }
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - player.x;
    let dy = aimPoint.y - player.y;
    let distance = Math.hypot(dx, dy);
    if(distance < 0.0001){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    player.target.x = player.x;
    player.target.y = player.y;
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      dirX,
      dirY,
      range,
      width,
      damage,
      slowPct,
      slowDuration,
      stunDuration,
      cooldownSeconds,
      castDuration: castTime,
      elapsed: 0
    };
    if(castTime > 0){
      stoneGazeCasts.push(cast);
      player.casting = cast;
      setHudMessage(`${abilityName} staring...`);
      return true;
    }
    releaseStoneGaze(cast);
    return true;
  }

  function releaseStoneGaze(cast){
    if(!cast) return;
    const range = Math.max(0, Number(cast.range) || 0);
    const width = Math.max(0, Number(cast.width) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    if(!(range > 0) || !(width > 0) || !(damage > 0)){
      return;
    }
    const dirLen = Math.hypot(cast.dirX, cast.dirY) || 1;
    const dirX = cast.dirX / dirLen;
    const dirY = cast.dirY / dirLen;
    const halfAngle = Math.atan2(width / 2, range);
    const cosThreshold = Math.cos(halfAngle);
    let hits = 0;
    const targets = collectAbilityTargets();
    for(const target of targets){
      if(!target) continue;
      const targetRadius = target === monsterState ? Math.max(minionRadius, monsterAttackRadius()) : minionRadius;
      const dx = target.x - player.x;
      const dy = target.y - player.y;
      const distSq = dx * dx + dy * dy;
      const allowed = (range + targetRadius) * (range + targetRadius);
      if(distSq > allowed) continue;
      const distance = Math.sqrt(distSq) || 1;
      const dot = (dx * dirX + dy * dirY) / distance;
      if(dot < cosThreshold) continue;
      const applied = applyAbilityDamage(target, damage);
      if(applied > 0){
        hits++;
        const angleToCaster = Math.atan2(player.y - target.y, player.x - target.x);
        const targetFacing = Number.isFinite(target.facing) ? target.facing : angleToCaster;
        const diff = minimalAngleDifference(angleToCaster, targetFacing);
        if(diff <= Math.PI / 2){
          const existing = Math.max(0, Number(target.stunTimer) || 0);
          target.stunTimer = Math.max(existing, cast.stunDuration);
        } else {
          const slowValue = Math.max(0, Number(cast.slowPct) || 0);
          if(slowValue > 0){
            const existingSlow = Math.max(0, Number(target.slowPct) || 0);
            target.slowPct = Math.max(existingSlow, slowValue);
            target.slowTimer = Math.max(target.slowTimer || 0, Math.max(0, Number(cast.slowDuration) || 0));
          }
        }
      }
    }
    stoneGazeEffects.push({
      id: `stone-${abilityRuntime.stoneGazeSequence++}`,
      x: player.x,
      y: player.y,
      dirX,
      dirY,
      range,
      width,
      age: 0,
      duration: 0.4
    });
    if(player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, Math.max(0, Number(cast.cooldownSeconds) || 0));
    }
    if(hits > 0){
      setHudMessage(`${cast.abilityName || 'Stone Gaze'} struck ${hits} target${hits === 1 ? '' : 's'}!`);
    } else {
      setHudMessage(`${cast.abilityName || 'Stone Gaze'} missed.`);
    }
  }

  function updateStoneGazeCasts(dt){
    for(let i = stoneGazeCasts.length - 1; i >= 0; i--){
      const cast = stoneGazeCasts[i];
      if(!cast){
        stoneGazeCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      if(cast.elapsed >= Math.max(0, Number(cast.castDuration) || 0)){
        releaseStoneGaze(cast);
        stoneGazeCasts.splice(i, 1);
      }
    }
  }

  function updateStoneGazeEffects(dt){
    for(let i = stoneGazeEffects.length - 1; i >= 0; i--){
      const effect = stoneGazeEffects[i];
      if(!effect){
        stoneGazeEffects.splice(i, 1);
        continue;
      }
      effect.age = Math.max(0, (Number(effect.age) || 0) + dt);
      if(effect.age >= Math.max(0, Number(effect.duration) || 0)){
        stoneGazeEffects.splice(i, 1);
      }
    }
  }
  function resolveBeamCastGeometry(cast){
    const caster = cast && cast.casterRef;
    const hasStartX = cast && Number.isFinite(cast.startX);
    const hasStartY = cast && Number.isFinite(cast.startY);
    const fallbackOrigin = getSpellOrigin(caster || player);
    let startX = hasStartX ? cast.startX : fallbackOrigin.x;
    let startY = hasStartY ? cast.startY : fallbackOrigin.y;
    if(caster){
      const casterOrigin = getSpellOrigin(caster);
      if(Number.isFinite(casterOrigin.x)) startX = casterOrigin.x;
      if(Number.isFinite(casterOrigin.y)) startY = casterOrigin.y;
    }
    const fallbackDirX = cast && Number.isFinite(cast.dirX) ? cast.dirX : 1;
    const fallbackDirY = cast && Number.isFinite(cast.dirY) ? cast.dirY : 0;
    const lockedDirX = cast && Number.isFinite(cast.lockedDirX) ? cast.lockedDirX : null;
    const lockedDirY = cast && Number.isFinite(cast.lockedDirY) ? cast.lockedDirY : null;
    let dirX = fallbackDirX;
    let dirY = fallbackDirY;
    if(Number.isFinite(lockedDirX) && Number.isFinite(lockedDirY)){
      const lockedLen = Math.hypot(lockedDirX, lockedDirY);
      if(lockedLen >= 0.0001){
        dirX = lockedDirX / lockedLen;
        dirY = lockedDirY / lockedLen;
      }
    }
    const lockedDistance = cast && Number.isFinite(cast.lockedDistance) ? Math.max(0, cast.lockedDistance) : null;
    let distanceToTarget = lockedDistance;
    if(!(distanceToTarget > 0)){
      const rawTargetX = cast && Number.isFinite(cast.targetX) ? cast.targetX : (startX + fallbackDirX);
      const rawTargetY = cast && Number.isFinite(cast.targetY) ? cast.targetY : (startY + fallbackDirY);
      let dx = rawTargetX - startX;
      let dy = rawTargetY - startY;
      distanceToTarget = Math.hypot(dx, dy);
      if(!(distanceToTarget > 0.0001)){
        dx = dirX;
        dy = dirY;
        distanceToTarget = Math.hypot(dx, dy);
      }
      if(!(distanceToTarget > 0.0001)){
        dx = 1;
        dy = 0;
        distanceToTarget = 1;
        dirX = dx;
        dirY = dy;
      }
      if(distanceToTarget > 0){
        dirX = dx / distanceToTarget;
        dirY = dy / distanceToTarget;
      }
    }
    if(!(distanceToTarget > 0)){ distanceToTarget = 1; }
    const targetX = startX + dirX * distanceToTarget;
    const targetY = startY + dirY * distanceToTarget;
    return {
      startX,
      startY,
      dirX,
      dirY,
      distanceToTarget,
      targetX: startX + dirX * distanceToTarget,
      targetY: startY + dirY * distanceToTarget
    };
  }

  function castChargingGaleAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Charging Gale';
    const existing = chargingGaleCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      if(existing.state === 'charging'){
        if(!existing.allowManualRecast){
          setHudMessage(`${abilityName} will release automatically.`);
          return false;
        }
        const released = releaseChargingGale(existing, { manual: true });
        return released ? true : false;
      }
      setHudMessage(`${abilityName} is still preparing.`);
      return false;
    }

    if(player.casting && player.casting !== existing && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const chargeDuration = Math.max(0, Number(abilityFieldValue(ability, 'chargeMaxMs')) || 0) / 1000;
    const allowManualRecast = Number(abilityFieldValue(ability, 'allowManualRecast')) > 0;
    const width = Math.max(0, Number(abilityFieldValue(ability, 'widthPx')) || 0);
    const minRange = Math.max(0, Number(abilityFieldValue(ability, 'minRangePx')) || 0);
    const maxRange = Math.max(minRange, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const minSpeed = Math.max(0, Number(abilityFieldValue(ability, 'minSpeedPxS')) || 0);
    const maxSpeed = Math.max(minSpeed, Number(abilityFieldValue(ability, 'maxSpeedPxS')) || 0);
    const minDamage = Math.max(0, Number(abilityFieldValue(ability, 'minDamage')) || 0);
    const bonusPerSecond = Math.max(0, Number(abilityFieldValue(ability, 'bonusPerSecond')) || 0);
    const knockupMin = Math.max(0, Number(abilityFieldValue(ability, 'knockupMinMs')) || 0) / 1000;
    const knockupMax = Math.max(knockupMin, Number(abilityFieldValue(ability, 'knockupMaxMs')) || 0) / 1000;
    const pierceUnits = Number(abilityFieldValue(ability, 'pierceUnits')) > 0;
    const stopAtTerrain = Number(abilityFieldValue(ability, 'stopAtTerrain')) > 0;

    const { x: originX, y: originY } = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - originX;
    let dy = aimPoint.y - originY;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - originX;
      dy = player.target.y - originY;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      originX,
      originY,
      initialDirX: dirX,
      initialDirY: dirY,
      castTime,
      castElapsed: 0,
      state: castTime > 0 ? 'windup' : 'charging',
      chargeDuration,
      chargeElapsed: 0,
      allowManualRecast,
      width,
      minRange,
      maxRange,
      minSpeed,
      maxSpeed,
      minDamage,
      bonusPerSecond,
      knockupMin,
      knockupMax,
      pierce: pierceUnits,
      stopAtTerrain,
      cooldownSeconds,
      released: false
    };

    chargingGaleCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'windup'){
      setHudMessage(`${abilityName} preparing...`);
      return { success: true, deferCooldown: true };
    }

    if(cast.chargeDuration <= 0){
      const released = releaseChargingGale(cast);
      return released ? true : false;
    }

    setHudMessage(`${abilityName} charging...`);
    return { success: true, deferCooldown: true };
  }

  function releaseChargingGale(cast, { manual = false } = {}){
    if(!cast || cast.released) return false;
    cast.released = true;
    const idx = chargingGaleCasts.indexOf(cast);
    if(idx >= 0){
      chargingGaleCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    const abilityName = cast.abilityName || 'Charging Gale';

    let dirX = cast.initialDirX;
    let dirY = cast.initialDirY;
    if(manual && cast.allowManualRecast){
      const aimPoint = beamAimPoint();
      let recastDx = aimPoint.x - cast.originX;
      let recastDy = aimPoint.y - cast.originY;
      let recastLen = Math.hypot(recastDx, recastDy);
      if(!(recastLen > 0.0001)){
        recastDx = player.target.x - cast.originX;
        recastDy = player.target.y - cast.originY;
        recastLen = Math.hypot(recastDx, recastDy);
      }
      if(recastLen > 0.0001){
        dirX = recastDx / recastLen;
        dirY = recastDy / recastLen;
      }
    }

    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
    } else {
      dirX /= dirLen;
      dirY /= dirLen;
    }

    const chargeElapsed = Math.max(0, Number(cast.chargeElapsed) || 0);
    const maxCharge = Math.max(0, Number(cast.chargeDuration) || 0);
    const chargeSeconds = maxCharge > 0 ? Math.min(chargeElapsed, maxCharge) : chargeElapsed;
    const chargeT = maxCharge > 0 ? clamp01(chargeElapsed / Math.max(maxCharge, 0.0001)) : (chargeSeconds > 0 ? 1 : 0);
    const lerp = (a, b, t) => a + (b - a) * t;
    const range = lerp(cast.minRange, cast.maxRange, chargeT);
    const speed = lerp(cast.minSpeed, cast.maxSpeed, chargeT);
    const damage = Math.max(0, cast.minDamage + cast.bonusPerSecond * chargeSeconds);
    const knockup = lerp(cast.knockupMin, cast.knockupMax, chargeT);

    if(!(range > 0) || !(speed > 0)){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }

    const projectile = spawnChargingGaleProjectile({
      abilityName,
      originX: cast.originX,
      originY: cast.originY,
      dirX,
      dirY,
      range,
      speed,
      width: cast.width,
      damage,
      knockup,
      pierce: cast.pierce,
      stopAtTerrain: cast.stopAtTerrain,
      casterRef: cast.casterRef || null
    });

    if(!projectile){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }

    flash(cast.originX, cast.originY, { startRadius: 16, endRadius: 40, color: '#7fe3ff' });
    setHudMessage(manual ? `${abilityName} released!` : `${abilityName} unleashed!`);
    return true;
  }

  function spawnChargingGaleProjectile(opts){
    if(!opts) return null;
    const range = Math.max(0, Number(opts.range) || 0);
    const speed = Math.max(0, Number(opts.speed) || 0);
    if(!(range > 0) || !(speed > 0)) return null;
    let dirX = Number(opts.dirX) || 0;
    let dirY = Number(opts.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      return null;
    }
    dirX /= dirLen;
    dirY /= dirLen;
    const projectile = {
      abilityName: opts.abilityName || 'Charging Gale',
      startX: Number(opts.originX) || 0,
      startY: Number(opts.originY) || 0,
      currentX: Number(opts.originX) || 0,
      currentY: Number(opts.originY) || 0,
      dirX,
      dirY,
      speed,
      range,
      width: Math.max(0, Number(opts.width) || 0),
      damage: Math.max(0, Number(opts.damage) || 0),
      knockup: Math.max(0, Number(opts.knockup) || 0),
      pierce: !!opts.pierce,
      stopAtTerrain: !!opts.stopAtTerrain,
      traveled: 0,
      casterRef: opts.casterRef || null,
      hitTargets: !!opts.pierce ? new Set() : null,
      announcedHit: false
    };
    chargingGaleProjectiles.push(projectile);
    return projectile;
  }

  function applyChargingGaleHit(projectile, target, hitAlong){
    if(!projectile || !target) return;
    const prevHp = Number(target.hp) || 0;
    if(Number(projectile.damage) > 0){
      target.hp = Math.max(0, prevHp - projectile.damage);
      spawnHitSplat(target.x, target.y - minionRadius, projectile.damage);
    }
    if(Number(projectile.knockup) > 0){
      const existing = typeof target.stunTimer === 'number' ? target.stunTimer : 0;
      target.stunTimer = Math.max(existing, projectile.knockup);
    }
    handlePracticeDummyDamage(target, prevHp);
    flash(target.x, target.y, { startRadius: 12, endRadius: 36, color: '#9ce7ff' });
    if(!projectile.announcedHit){
      if(projectile.damage > 0){
        setHudMessage(`${projectile.abilityName || 'Charging Gale'} hit for ${Math.round(projectile.damage)} damage!`);
      } else {
        setHudMessage(`${projectile.abilityName || 'Charging Gale'} hit!`);
      }
      projectile.announcedHit = true;
    }
    if(!projectile.pierce){
      projectile.traveled = Math.max(0, Number(hitAlong) || 0);
      projectile.currentX = projectile.startX + projectile.dirX * projectile.traveled;
      projectile.currentY = projectile.startY + projectile.dirY * projectile.traveled;
    }
  }

  function normalizeAngleDelta(angle){
    let delta = angle;
    while(delta > Math.PI) delta -= Math.PI * 2;
    while(delta < -Math.PI) delta += Math.PI * 2;
    return delta;
  }

  function castAvalancheRollAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Avalanche Roll';
    const existing = snowballRollCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      if(existing.state === 'charging' && !existing.released){
        const canRelease = existing.manualReleaseDelay <= 0 || (existing.chargeElapsed >= existing.manualReleaseDelay);
        if(existing.allowManualRecast && canRelease){
          const released = releaseAvalancheRoll(existing, { manual: true });
          if(released){
            setAbilitySlotCooldown(existing.slotIndex, existing.cooldownSeconds);
          }
          return released ? true : false;
        }
        setHudMessage(`${abilityName} is still building.`);
        return false;
      }
      setHudMessage(`${abilityName} is still preparing.`);
      return false;
    }

    if(player.casting && player.casting !== existing && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const chargeDuration = Math.max(0, Number(abilityFieldValue(ability, 'chargeDurationMs')) || 0) / 1000;
    const allowManualRecast = Number(abilityFieldValue(ability, 'allowManualRecast')) > 0;
    const manualReleaseDelay = Math.max(0, Number(abilityFieldValue(ability, 'manualReleaseDelayMs')) || 0) / 1000;
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const minRadius = Math.max(0, Number(abilityFieldValue(ability, 'minRadiusPx')) || 0);
    const maxRadius = Math.max(minRadius, Number(abilityFieldValue(ability, 'maxRadiusPx')) || minRadius);
    const explosionRadius = Math.max(0, Number(abilityFieldValue(ability, 'explosionRadiusPx')) || 0);
    const baseDamage = Math.max(0, Number(abilityFieldValue(ability, 'baseDamage')) || 0);
    const damagePerSecond = Math.max(0, Number(abilityFieldValue(ability, 'damagePerSecond')) || 0);
    const minionDamagePct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'minionDamagePct')) || 0));
    const knockupMin = Math.max(0, Number(abilityFieldValue(ability, 'knockupMinMs')) || 0) / 1000;
    const knockupMax = Math.max(0, Number(abilityFieldValue(ability, 'knockupMaxMs')) || 0) / 1000;
    const stunMax = Math.max(0, Number(abilityFieldValue(ability, 'stunMaxMs')) || 0) / 1000;
    const initialSlowPct = Math.max(0, Number(abilityFieldValue(ability, 'initialSlowPct')) || 0);
    const slowHoldSeconds = Math.max(0, Number(abilityFieldValue(ability, 'slowHoldMs')) || 0) / 1000;
    const speedBoostPct = Math.max(0, Number(abilityFieldValue(ability, 'speedBoostPct')) || 0);
    const speedBoostDuration = Math.max(0, Number(abilityFieldValue(ability, 'speedBoostDurationMs')) || 0) / 1000;
    const steerSpeedRad = Math.max(0, Number(abilityFieldValue(ability, 'steerSpeedDeg')) || 0) * (Math.PI / 180);
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dirX = aimPoint.x - origin.x;
    let dirY = aimPoint.y - origin.y;
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = player.target.x - origin.x;
      dirY = player.target.y - origin.y;
      dirLen = Math.hypot(dirX, dirY);
    }
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      originX: origin.x,
      originY: origin.y,
      initialDirX: dirX,
      initialDirY: dirY,
      dirX,
      dirY,
      castTime,
      castElapsed: 0,
      state: castTime > 0 ? 'windup' : 'charging',
      chargeDuration,
      chargeElapsed: 0,
      allowManualRecast,
      manualReleaseDelay,
      projectileRange,
      projectileSpeed,
      minRadius,
      maxRadius,
      explosionRadius,
      baseDamage,
      damagePerSecond,
      minionDamagePct,
      knockupMin,
      knockupMax,
      stunMax,
      initialSlowPct,
      slowHoldSeconds,
      speedBoostPct,
      speedBoostDuration,
      steerSpeedRad,
      cooldownSeconds,
      movementSpeedMultiplier: Math.max(0.05, 1 - initialSlowPct / 100)
    };

    snowballRollCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'windup'){
      setHudMessage(`${abilityName} preparing...`);
      return { success: true, deferCooldown: true };
    }

    if(cast.chargeDuration <= 0){
      const released = releaseAvalancheRoll(cast);
      if(released){
        setAbilitySlotCooldown(cast.slotIndex, cast.cooldownSeconds);
      }
      return released ? true : false;
    }

    setHudMessage(`${abilityName} rolling...`);
    return { success: true, deferCooldown: true };
  }

  function releaseAvalancheRoll(cast, { manual = false } = {}){
    if(!cast || cast.released) return false;
    cast.released = true;
    const idx = snowballRollCasts.indexOf(cast);
    if(idx >= 0){
      snowballRollCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    let dirX = cast.dirX;
    let dirY = cast.dirY;
    if(manual && cast.allowManualRecast){
      const aimPoint = beamAimPoint();
      let dx = aimPoint.x - cast.originX;
      let dy = aimPoint.y - cast.originY;
      let len = Math.hypot(dx, dy);
      if(!(len > 0.0001)){
        dx = player.target.x - cast.originX;
        dy = player.target.y - cast.originY;
        len = Math.hypot(dx, dy);
      }
      if(len > 0.0001){
        dirX = dx / len;
        dirY = dy / len;
      }
    }

    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
    } else {
      dirX /= dirLen;
      dirY /= dirLen;
    }

    const chargeElapsed = Math.max(0, Number(cast.chargeElapsed) || 0);
    const maxCharge = Math.max(0, Number(cast.chargeDuration) || 0);
    const chargeT = maxCharge > 0 ? clamp01(chargeElapsed / Math.max(maxCharge, 0.0001)) : (chargeElapsed > 0 ? 1 : 0);
    const lerp = (a, b, t) => a + (b - a) * t;
    const radius = lerp(cast.minRadius, cast.maxRadius, chargeT);
    const explosionRadius = Math.max(radius, cast.explosionRadius);
    const damage = Math.max(0, cast.baseDamage + cast.damagePerSecond * chargeElapsed);
    const knockup = lerp(cast.knockupMin, cast.knockupMax, chargeT);
    const stun = Math.max(0, cast.stunMax * chargeT);

    const projectile = spawnAvalancheRollProjectile({
      abilityName: cast.abilityName,
      originX: cast.originX,
      originY: cast.originY,
      dirX,
      dirY,
      range: cast.projectileRange,
      speed: cast.projectileSpeed,
      radius,
      explosionRadius,
      damage,
      knockup,
      stun,
      minionDamagePct: cast.minionDamagePct,
      casterRef: cast.casterRef || null
    });

    if(!projectile){
      setHudMessage(`${cast.abilityName || 'Avalanche Roll'} fizzled.`);
      return false;
    }

    flash(cast.originX, cast.originY, { startRadius: Math.max(12, radius * 0.5), endRadius: Math.max(32, radius * 1.5), color: '#b4ecff' });
    setHudMessage(manual ? `${cast.abilityName || 'Avalanche Roll'} released!` : `${cast.abilityName || 'Avalanche Roll'} unleashed!`);
    return true;
  }

  function spawnAvalancheRollProjectile(opts){
    if(!opts) return null;
    const range = Math.max(0, Number(opts.range) || 0);
    const speed = Math.max(0, Number(opts.speed) || 0);
    if(!(range > 0) || !(speed > 0)) return null;
    let dirX = Number(opts.dirX) || 0;
    let dirY = Number(opts.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      return null;
    }
    dirX /= dirLen;
    dirY /= dirLen;
    const projectile = {
      abilityName: opts.abilityName || 'Avalanche Roll',
      startX: Number(opts.originX) || 0,
      startY: Number(opts.originY) || 0,
      currentX: Number(opts.originX) || 0,
      currentY: Number(opts.originY) || 0,
      dirX,
      dirY,
      speed,
      range,
      traveled: 0,
      radius: Math.max(0, Number(opts.radius) || 0),
      explosionRadius: Math.max(0, Number(opts.explosionRadius) || 0),
      damage: Math.max(0, Number(opts.damage) || 0),
      knockup: Math.max(0, Number(opts.knockup) || 0),
      stun: Math.max(0, Number(opts.stun) || 0),
      minionDamagePct: Math.max(0, Math.min(1, (Number(opts.minionDamagePct) || 0) / 100)),
      casterRef: opts.casterRef || null,
      exploded: false
    };
    snowballRollProjectiles.push(projectile);
    return projectile;
  }

  function explodeAvalancheRollProjectile(projectile){
    if(!projectile || projectile.exploded) return;
    projectile.exploded = true;
    const centerX = Math.max(0, Number(projectile.currentX) || 0);
    const centerY = Math.max(0, Number(projectile.currentY) || 0);
    const radius = Math.max(0, Number(projectile.explosionRadius) || Number(projectile.radius) || 0);
    const areaRadius = radius + Math.max(minionRadius, 32);
    const areaSq = areaRadius * areaRadius;
    let hitAny = false;
    let highestDamage = 0;
    const minionScale = (Number(projectile.minionDamagePct) || 0) > 0 ? Number(projectile.minionDamagePct) : 1;

    const applyHit = (target, targetRadius, scale = 1)=>{
      if(!target) return;
      const dx = target.x - centerX;
      const dy = target.y - centerY;
      const distSq = dx * dx + dy * dy;
      const effectiveRadius = radius + targetRadius;
      if(distSq > effectiveRadius * effectiveRadius){
        return;
      }
      const damageBase = projectile.damage * scale;
      const damageAmt = Math.max(0, Math.round(damageBase));
      const prevHp = Number(target.hp) || 0;
      if(damageAmt > 0){
        target.hp = Math.max(0, prevHp - damageAmt);
        spawnHitSplat(target.x, target.y - targetRadius, damageAmt);
      }
      const stunAmount = Math.max(0, Number(projectile.knockup) || 0) + Math.max(0, Number(projectile.stun) || 0);
      if(stunAmount > 0){
        const existing = typeof target.stunTimer === 'number' ? target.stunTimer : 0;
        target.stunTimer = Math.max(existing, stunAmount);
      }
      handlePracticeDummyDamage(target, prevHp);
      hitAny = true;
      highestDamage = Math.max(highestDamage, damageAmt);
    };

    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      applyHit(m, minionRadius, minionScale);
    }

    const dummy = practiceDummy && practiceDummy.active !== false && practiceDummy.hp > 0 ? practiceDummy : null;
    if(dummy){
      const dummyRadius = Math.max(minionRadius, (Number(dummy.size) || 0) * 0.5);
      applyHit(dummy, dummyRadius, 1);
    }

    if(isMonsterAttackable(monsterState) && monsterState.hp > 0){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
      applyHit(monsterState, monsterRadius, 1);
    }

    const flashColor = hitAny ? '#bfeeff' : '#8db2ff';
    flash(centerX, centerY, { startRadius: Math.max(16, radius * 0.4), endRadius: Math.max(radius + 32, 56), color: flashColor });
    if(hitAny && highestDamage > 0){
      setHudMessage(`${projectile.abilityName || 'Avalanche Roll'} exploded for ${Math.round(highestDamage)} damage!`);
    } else if(!hitAny){
      setHudMessage(`${projectile.abilityName || 'Avalanche Roll'} scattered snow.`);
    }
  }

  function updateAvalancheRollCasts(dt){
    for(let i = snowballRollCasts.length - 1; i >= 0; i--){
      const cast = snowballRollCasts[i];
      if(!cast){
        snowballRollCasts.splice(i, 1);
        continue;
      }
      if(cast.state === 'windup'){
        const duration = Math.max(0, Number(cast.castTime) || 0);
        cast.castElapsed = Math.max(0, (Number(cast.castElapsed) || 0) + dt);
        if(duration <= 0 || cast.castElapsed >= duration){
          const overflow = duration > 0 ? Math.max(0, cast.castElapsed - duration) : cast.castElapsed;
          cast.state = 'charging';
          cast.chargeElapsed = overflow;
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Avalanche Roll'} rolling...`);
          }
        } else {
          continue;
        }
      }

      if(cast.state !== 'charging'){
        continue;
      }

      const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
      const prevElapsed = Math.max(0, Number(cast.chargeElapsed) || 0);
      cast.chargeElapsed = Math.max(0, prevElapsed + dt);
      const aimPoint = beamAimPoint();
      let dx = aimPoint.x - cast.originX;
      let dy = aimPoint.y - cast.originY;
      let len = Math.hypot(dx, dy);
      if(len > 0.0001){
        dx /= len;
        dy /= len;
        const currentAngle = Math.atan2(cast.dirY, cast.dirX);
        const targetAngle = Math.atan2(dy, dx);
        let delta = normalizeAngleDelta(targetAngle - currentAngle);
        const maxTurn = Math.max(0, Number(cast.steerSpeedRad) || 0) * dt;
        if(maxTurn > 0){
          delta = Math.max(-maxTurn, Math.min(maxTurn, delta));
        }
        const finalAngle = currentAngle + delta;
        cast.dirX = Math.cos(finalAngle);
        cast.dirY = Math.sin(finalAngle);
      }

      const slowFraction = Math.max(0, Math.min(1, (Number(cast.initialSlowPct) || 0) / 100));
      let movementMult = Math.max(0.05, 1 - slowFraction);
      const boostCap = Math.max(0, Number(cast.speedBoostPct) || 0) / 100;
      const boostDuration = Math.max(0, Number(cast.speedBoostDuration) || 0);
      if(boostCap > 0 && boostDuration > 0 && cast.chargeElapsed >= Math.max(0, Number(cast.slowHoldSeconds) || 0)){
        const gainTime = cast.chargeElapsed - Math.max(0, Number(cast.slowHoldSeconds) || 0);
        const boostT = Math.min(1, gainTime / boostDuration);
        movementMult = Math.min(1 + boostCap, movementMult + boostCap * boostT);
      } else if(boostCap > 0 && cast.chargeElapsed >= Math.max(0, Number(cast.slowHoldSeconds) || 0) && boostDuration <= 0){
        movementMult = Math.min(1 + boostCap, movementMult + boostCap);
      }
      cast.movementSpeedMultiplier = Math.max(0.05, movementMult);

      if(cast.chargeDuration <= 0 || cast.chargeElapsed >= Math.max(0, Number(cast.chargeDuration) || 0)){
        if(releaseAvalancheRoll(cast)){
          setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
        }
        continue;
      }
    }
  }

  function updateAvalancheRollProjectiles(dt){
    for(let i = snowballRollProjectiles.length - 1; i >= 0; i--){
      const proj = snowballRollProjectiles[i];
      if(!proj){
        snowballRollProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(range > 0)){
        snowballRollProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      let nextTraveled = prevTraveled + speed * dt;
      if(speed <= 0){
        nextTraveled = range;
      }
      const clampedNext = Math.min(nextTraveled, range);
      proj.traveled = clampedNext;
      proj.currentX = proj.startX + proj.dirX * clampedNext;
      proj.currentY = proj.startY + proj.dirY * clampedNext;
      const hitRadius = Math.max(0, Number(proj.radius) || 0) + minionRadius;
      const hitRadiusSq = hitRadius * hitRadius;
      let collided = false;
      for(const m of minions){
        if(!isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const dx = m.x - proj.currentX;
        const dy = m.y - proj.currentY;
        if(dx * dx + dy * dy <= hitRadiusSq){
          explodeAvalancheRollProjectile(proj);
          snowballRollProjectiles.splice(i, 1);
          collided = true;
          break;
        }
      }
      if(collided) continue;
      if(practiceDummy && practiceDummy.active !== false && practiceDummy.hp > 0){
        const dummyRadius = Math.max(minionRadius, (Number(practiceDummy.size) || 0) * 0.5);
        const dx = practiceDummy.x - proj.currentX;
        const dy = practiceDummy.y - proj.currentY;
        if(dx * dx + dy * dy <= (Math.max(0, Number(proj.radius) || 0) + dummyRadius) ** 2){
          explodeAvalancheRollProjectile(proj);
          snowballRollProjectiles.splice(i, 1);
          continue;
        }
      }
      if(isMonsterAttackable(monsterState) && monsterState.hp > 0){
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
        const dx = monsterState.x - proj.currentX;
        const dy = monsterState.y - proj.currentY;
        const effective = Math.max(0, Number(proj.radius) || 0) + monsterRadius;
        if(dx * dx + dy * dy <= effective * effective){
          explodeAvalancheRollProjectile(proj);
          snowballRollProjectiles.splice(i, 1);
          continue;
        }
      }
      if(clampedNext >= range - 0.001){
        explodeAvalancheRollProjectile(proj);
        snowballRollProjectiles.splice(i, 1);
        continue;
      }
      if(proj.currentX < -64 || proj.currentY < -64 || proj.currentX > mapState.width + 64 || proj.currentY > mapState.height + 64){
        explodeAvalancheRollProjectile(proj);
        snowballRollProjectiles.splice(i, 1);
        continue;
      }
    }
  }

  function clampDirectionToCone(baseX, baseY, desiredX, desiredY, halfAngle){
    let bx = Number(baseX) || 0;
    let by = Number(baseY) || 0;
    let dx = Number(desiredX) || 0;
    let dy = Number(desiredY) || 0;
    const baseLen = Math.hypot(bx, by);
    if(baseLen > 0.0001){
      bx /= baseLen;
      by /= baseLen;
    } else {
      bx = 1;
      by = 0;
    }
    const desiredLen = Math.hypot(dx, dy);
    if(desiredLen > 0.0001){
      dx /= desiredLen;
      dy /= desiredLen;
    } else {
      dx = bx;
      dy = by;
    }
    const half = Math.max(0, Number(halfAngle) || 0);
    if(!(half > 0)){
      return { x: dx, y: dy };
    }
    const dot = Math.max(-1, Math.min(1, bx * dx + by * dy));
    const angle = Math.acos(dot);
    if(angle <= half){
      return { x: dx, y: dy };
    }
    const sign = (bx * dy - by * dx) >= 0 ? 1 : -1;
    const targetAngle = half * sign;
    const cos = Math.cos(targetAngle);
    const sin = Math.sin(targetAngle);
    return { x: bx * cos - by * sin, y: bx * sin + by * cos };
  }

  function castSlingshotCrashAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Slingshot Crash';
    const existing = slingshotCrashCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      if(existing.state === 'charging'){
        const launched = launchSlingshotCrash(existing, { manual: true });
        return launched ? true : false;
      }
      setHudMessage(`${abilityName} is already mid-air.`);
      return false;
    }

    const activeLeap = slingshotCrashLeaps.find(leap => leap && leap.casterRef === player && leap.abilityId === ability.id);
    if(activeLeap){
      setHudMessage(`${abilityName} is already mid-air.`);
      return false;
    }

    if(player.casting && player.casting !== existing && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const chargeDuration = Math.max(0, Number(abilityFieldValue(ability, 'chargeMaxMs')) || 0) / 1000;
    const minRange = Math.max(0, Number(abilityFieldValue(ability, 'minRangePx')) || 0);
    const maxRange = Math.max(minRange, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const stunShort = Math.max(0, Number(abilityFieldValue(ability, 'stunShortMs')) || 0) / 1000;
    const stunLong = Math.max(stunShort, Number(abilityFieldValue(ability, 'stunLongMs')) || 0) / 1000;
    const stunThreshold = Math.max(0, Number(abilityFieldValue(ability, 'stunThresholdMs')) || 0) / 1000;
    const leapSpeed = Math.max(0, Number(abilityFieldValue(ability, 'leapSpeedPxS')) || 0);
    const coneHalfAngle = Math.max(0, Number(abilityFieldValue(ability, 'coneHalfAngleDeg')) || 0) * Math.PI / 180;
    const refundPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'cooldownRefundPct')) || 0));
    const cooldownRefund = refundPct / 100;

    const { x: originX, y: originY } = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - originX;
    let dy = aimPoint.y - originY;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - originX;
      dy = player.target.y - originY;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      originX,
      originY,
      initialDirX: dirX,
      initialDirY: dirY,
      chargeDuration,
      chargeElapsed: 0,
      minRange,
      maxRange,
      impactRadius,
      damage,
      stunShort,
      stunLong,
      stunThreshold,
      leapSpeed,
      coneHalfAngle,
      cooldownSeconds,
      cooldownRefund,
      state: 'charging',
      launched: false
    };

    slingshotCrashCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.chargeDuration <= 0){
      const launched = launchSlingshotCrash(cast, { auto: true });
      return launched ? true : false;
    }

    setHudMessage(`${abilityName} stretching back...`);
    return { success: true, deferCooldown: true };
  }

  function launchSlingshotCrash(cast, { manual = false, auto = false, timedOut = false } = {}){
    if(!cast || cast.launched) return false;
    cast.launched = true;
    const idx = slingshotCrashCasts.indexOf(cast);
    if(idx >= 0){
      slingshotCrashCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    const abilityName = cast.abilityName || 'Slingshot Crash';

    if(timedOut){
      const baseCooldown = Math.max(0, Number(cast.cooldownSeconds) || 0);
      const refundFraction = Math.max(0, Math.min(1, Number(cast.cooldownRefund) || 0));
      setAbilitySlotCooldown(cast.slotIndex, baseCooldown * (1 - refundFraction));
      setHudMessage(`${abilityName} slipped free without a launch.`);
      return true;
    }

    const originX = Number.isFinite(cast.originX) ? cast.originX : player.x;
    const originY = Number.isFinite(cast.originY) ? cast.originY : player.y;
    const aimPoint = beamAimPoint();
    let aimDx = aimPoint.x - originX;
    let aimDy = aimPoint.y - originY;
    let aimLen = Math.hypot(aimDx, aimDy);
    if(!(aimLen > 0.0001)){
      aimDx = player.target.x - originX;
      aimDy = player.target.y - originY;
      aimLen = Math.hypot(aimDx, aimDy);
    }
    if(!(aimLen > 0.0001)){
      aimDx = cast.initialDirX || 1;
      aimDy = cast.initialDirY || 0;
      aimLen = Math.hypot(aimDx, aimDy) || 1;
    }
    aimDx /= aimLen;
    aimDy /= aimLen;
    const clampedDir = clampDirectionToCone(cast.initialDirX, cast.initialDirY, aimDx, aimDy, cast.coneHalfAngle);
    const dirX = clampedDir.x;
    const dirY = clampedDir.y;

    const pointerDistance = Math.hypot(aimPoint.x - originX, aimPoint.y - originY);
    const chargeElapsed = Math.max(0, Number(cast.chargeElapsed) || 0);
    const maxCharge = Math.max(0, Number(cast.chargeDuration) || 0);
    const chargeT = maxCharge > 0 ? clamp01(chargeElapsed / Math.max(maxCharge, 0.0001)) : (chargeElapsed > 0 ? 1 : 0);
    const minRange = Math.max(0, Number(cast.minRange) || 0);
    const maxRange = Math.max(minRange, Number(cast.maxRange) || 0);
    const desiredRange = minRange + (maxRange - minRange) * chargeT;
    let targetDistance = desiredRange;
    if(pointerDistance > 0){
      targetDistance = Math.min(desiredRange, pointerDistance);
      if(minRange > 0){
        targetDistance = Math.max(minRange, targetDistance);
      }
    }

    const moved = moveCircleWithCollision(originX, originY, dirX * targetDistance, dirY * targetDistance, player.r);
    const destX = moved.x;
    const destY = moved.y;
    const travelDistance = Math.hypot(destX - originX, destY - originY);
    if(!(travelDistance > 1)){
      setHudMessage(`${abilityName} needs a clear path to launch.`);
      return false;
    }

    const effectiveSpeed = Number(cast.leapSpeed) > 0 ? Number(cast.leapSpeed) : 0;
    const travelSpeed = effectiveSpeed > 0 ? effectiveSpeed : Math.max(1, travelDistance / 0.35);
    const duration = Math.max(0.05, travelDistance / travelSpeed);

    const leap = {
      abilityId: cast.abilityId,
      abilityName,
      slotIndex: cast.slotIndex,
      casterRef: cast.casterRef || player,
      startX: originX,
      startY: originY,
      targetX: destX,
      targetY: destY,
      currentX: originX,
      currentY: originY,
      dirX,
      dirY,
      distance: travelDistance,
      speed: travelSpeed,
      duration,
      elapsed: 0,
      traveled: 0,
      landingRadius: Math.max(0, Number(cast.impactRadius) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      stunShort: Math.max(0, Number(cast.stunShort) || 0),
      stunLong: Math.max(0, Number(cast.stunLong) || 0),
      stunThreshold: Math.max(0, Number(cast.stunThreshold) || 0),
      chargeElapsed,
      maxCharge,
      cooldownSeconds: Math.max(0, Number(cast.cooldownSeconds) || 0)
    };

    slingshotCrashLeaps.push(leap);
    if(leap.casterRef === player){
      player.casting = leap;
      cancelPlayerAttack(false);
      player.chaseTarget = null;
      player.target.x = destX;
      player.target.y = destY;
      player.navGoal = null;
      player.nav = null;
    }

    flash(originX, originY, { startRadius: 12, endRadius: 36, color: '#7fe3ff' });
    setHudMessage(manual ? `${abilityName} launched!` : `${abilityName} released!`);
    return true;
  }

  function applySlingshotCrashLanding(leap){
    if(!leap) return;
    const radius = Math.max(0, Number(leap.landingRadius) || 0);
    const damage = Math.max(0, Number(leap.damage) || 0);
    const stunThreshold = Math.max(0, Number(leap.stunThreshold) || 0);
    const longStun = Math.max(0, Number(leap.stunLong) || 0);
    const shortStun = Math.max(0, Number(leap.stunShort) || 0);
    const stunDuration = (Number(leap.chargeElapsed) || 0) >= stunThreshold ? longStun : shortStun;
    const effectiveRadius = radius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - leap.currentX;
      const dy = m.y - leap.currentY;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      if(stunDuration > 0){
        const existing = typeof m.stunTimer === 'number' ? m.stunTimer : 0;
        m.stunTimer = Math.max(existing, stunDuration);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }

    const flashStart = radius > 0 ? Math.max(14, radius * 0.5) : 18;
    const flashEnd = radius > 0 ? Math.max(radius + 32, radius * 1.25) : 48;
    flash(leap.currentX, leap.currentY, { startRadius: flashStart, endRadius: flashEnd, color: '#9ce7ff' });
    if(hits > 0){
      setHudMessage(`${leap.abilityName || 'Slingshot Crash'} slammed ${hits} target${hits === 1 ? '' : 's'}!`);
    } else {
      setHudMessage(`${leap.abilityName || 'Slingshot Crash'} landed.`);
    }
  }

  function castBeamAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(distance < 1){
      const fallback = player.target && Number.isFinite(player.target.x) ? player.target : { x: player.x + player.r, y: player.y };
      dx = fallback.x - startX;
      dy = fallback.y - startY;
      distance = Math.hypot(dx, dy);
      if(distance < 1){
        dx = 1;
        dy = 0;
        distance = 1;
      }
    }
    distance = Math.max(distance, 1);
    const dirX = dx / distance;
    const dirY = dy / distance;
    const rawLength = abilityFieldValue(ability, 'beamLength');
    const configuredLength = Math.max(0, Number(rawLength) || 0);
    const rawWidth = abilityFieldValue(ability, 'beamWidth');
    const beamWidth = Math.max(0, Number(rawWidth) || 0);
    const rawDamage = abilityFieldValue(ability, 'damage');
    const damage = Math.max(0, Number(rawDamage) || 0);
    const rawSlow = abilityFieldValue(ability, 'slowPct');
    const slowFraction = Math.max(0, Math.min(1, (Number(rawSlow) || 0) / 100));
    const rawCast = abilityFieldValue(ability, 'castTimeMs');
    const castSeconds = Math.max(0, Number(rawCast) || 0) / 1000;

    const usesDynamicLength = configuredLength <= 0;
    const fireLength = usesDynamicLength ? distance : configuredLength;
    const previewLength = usesDynamicLength ? distance : fireLength;
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName: ability.shortName || ability.name,
      startX,
      startY,
      dirX,
      dirY,
      targetX: aimPoint.x,
      targetY: aimPoint.y,
      fireLength: Math.max(1, fireLength),
      previewLength: Math.max(1, previewLength),
      width: beamWidth,
      damage,
      slowFraction,
      castDuration: castSeconds,
      elapsed: 0,
      casterRef: player,
      dynamicLength: usesDynamicLength,
      lockedDirX: dirX,
      lockedDirY: dirY,
      lockedDistance: Math.max(1, previewLength)
    };

    if(cast.castDuration <= 0){
      fireBeamCast(cast);
    } else {
      beamCasts.push(cast);
      setHudMessage(`${cast.abilityName} charging...`);
      player.casting = cast;
      cancelPlayerAttack(false);
      player.chaseTarget = null;
      player.target.x = player.x;
      player.target.y = player.y;
      player.navGoal = null;
      player.nav = null;
    }
    return true;
  }

  function spawnBlinkingBoltProjectile(startX, startY, target, damage, abilityName, caster, speedOverride){
    const boltSpeed = Math.max(0, Number(speedOverride) || 720);
    const bolt = {
      x: startX,
      y: startY,
      prevX: startX,
      prevY: startY,
      dirX: 1,
      dirY: 0,
      speed: boltSpeed,
      damage: Math.max(0, Number(damage) || 0),
      abilityName: abilityName || 'Blink Bolt',
      casterRef: caster || null,
      targetRef: target || null,
      age: 0,
      maxLifetime: 2.75
    };
    if(target){
      const dx = target.x - startX;
      const dy = target.y - startY;
      const len = Math.hypot(dx, dy);
      if(len > 0.0001){
        bolt.dirX = dx / len;
        bolt.dirY = dy / len;
      }
    }
    blinkingBoltProjectiles.push(bolt);
    return bolt;
  }

  function castBlinkingBoltAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Blink Bolt';
    const blinkDistanceRaw = abilityFieldValue(ability, 'blinkDistance');
    const blinkDistance = Math.max(0, Number(blinkDistanceRaw) || 0);
    const damageRaw = abilityFieldValue(ability, 'damage');
    const boltDamage = Math.max(0, Number(damageRaw) || 0);

    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    let dirX = 1;
    let dirY = 0;
    const hasAim = distance > 0.0001;
    if(hasAim){
      dirX = dx / distance;
      dirY = dy / distance;
    }
    const desiredDistance = blinkDistance > 0 ? (hasAim ? Math.min(blinkDistance, distance) : 0) : 0;
    const moveX = dirX * desiredDistance;
    const moveY = dirY * desiredDistance;
    const moved = moveCircleWithCollision(startX, startY, moveX, moveY, player.r);
    let destX = moved.x;
    let destY = moved.y;
    destX = Math.max(player.r, Math.min(mapState.width - player.r, destX));
    destY = Math.max(player.r, Math.min(mapState.height - player.r, destY));

    if(destX !== player.x || destY !== player.y){
      flash(startX, startY, { startRadius: 12, endRadius: 44, color: '#7fe3ff' });
    }

    player.x = destX;
    player.y = destY;
    player.target.x = destX;
    player.target.y = destY;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    cancelPlayerAttack(false);

    flash(destX, destY, { startRadius: 12, endRadius: 44, color: '#9ff5ff' });

    const target = findNearestEnemyMinionWithinRange(destX, destY, blinkDistance);
    if(target){
      spawnBlinkingBoltProjectile(destX, destY, target, boltDamage, abilityName, player);
      setHudMessage(`${abilityName} unleashed a bolt!`);
    } else {
      setHudMessage(`${abilityName} repositioned, but found no targets.`);
    }

    return true;
  }

  const EMBER_WALTZ_SPIN_SPEED = (75.92 * Math.PI) / 180;

  function emberWaltzTargetRadius(target){
    if(target && target.isPracticeDummy){
      return Math.max(minionRadius, Number(target.radius) || minionRadius);
    }
    return minionRadius;
  }

  function findEmberWaltzTarget(x, y, range){
    const rangeValue = Math.max(0, Number(range) || 0);
    if(!(rangeValue > 0)) return null;
    const rangeSq = rangeValue * rangeValue;
    let best = null;
    let bestDistSq = Infinity;
    const consider = candidate => {
      if(!candidate) return;
      const isDummy = candidate.isPracticeDummy === true;
      if(isDummy){
        if(candidate.active === false || candidate.hp <= 0 || candidate.respawnTimer > 0) return;
      } else if(!isEnemyMinionForPlayer(candidate)){
        return;
      }
      if(!pointInVision(candidate.x, candidate.y, emberWaltzTargetRadius(candidate))) return;
      if(candidate.portalizing > 0 || candidate.hp <= 0) return;
      const dx = candidate.x - x;
      const dy = candidate.y - y;
      const distSq = dx * dx + dy * dy;
      if(distSq <= rangeSq && distSq < bestDistSq){
        best = candidate;
        bestDistSq = distSq;
      }
    };
    const nearestEnemy = findNearestEnemyMinionWithinRange(x, y, rangeValue);
    if(nearestEnemy){
      best = nearestEnemy;
      const dx = nearestEnemy.x - x;
      const dy = nearestEnemy.y - y;
      bestDistSq = dx * dx + dy * dy;
    }
    if(practiceDummy){
      consider(practiceDummy);
    }
    return best;
  }

  function applyEmberWaltzHit(flame, target){
    if(!target) return;
    const cast = emberWaltzCasts.find(entry => entry && entry.id === flame.castId) || null;
    const hitSet = cast ? (cast.hitTargets || (cast.hitTargets = new Set())) : null;
    const alreadyHit = hitSet ? hitSet.has(target) : false;
    const subsequentPct = Math.max(0, Math.min(100, Number(flame.subsequentPct) || 0));
    let damage = Math.max(0, Number(flame.damage) || 0);
    if(alreadyHit){
      damage = damage * (subsequentPct / 100);
    }
    const execThresholdRaw = Number(flame.executeThresholdPct) || 0;
    const execThreshold = execThresholdRaw > 1 ? execThresholdRaw / 100 : execThresholdRaw;
    const execMult = Math.max(0, Number(flame.executeMultiplier) || 0);
    const maxHp = Number(target.maxHp) || 0;
    if(execMult > 0 && execThreshold > 0 && maxHp > 0){
      const executeHp = maxHp * Math.min(1, Math.max(0, execThreshold));
      if(target.hp <= executeHp){
        damage *= execMult;
      }
    }
    const prevHp = Number(target.hp) || 0;
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      const targetRadius = emberWaltzTargetRadius(target);
      spawnHitSplat(target.x, target.y - targetRadius, damage);
    }
    handlePracticeDummyDamage(target, prevHp);
    if(hitSet){
      hitSet.add(target);
    }
    if(damage > 0){
      setHudMessage(`${flame.abilityName || 'Ember Waltz'} hit for ${Math.round(damage)} damage!`);
    } else {
      setHudMessage(`${flame.abilityName || 'Ember Waltz'} hit!`);
    }
  }

  function spawnEmberWaltzFlame(cast, options = {}){
    const origin = getSpellOrigin(player);
    const angle = Number.isFinite(options.angle) ? options.angle : Math.random() * Math.PI * 2;
    const orbitRadius = Math.max(0, Number(options.orbitRadius) || 0);
    const angularSpeed = Math.max(0, Number(options.angularSpeed) || EMBER_WALTZ_SPIN_SPEED);
    const flame = {
      id: options.id || `ember-${(cast && cast.id) || abilityRuntime.emberWaltzSequence}-${Math.random().toString(16).slice(2, 6)}`,
      castId: cast && cast.id,
      abilityName: cast && cast.abilityName,
      state: 'orbit',
      angle,
      orbitRadius,
      angularSpeed,
      seekDelay: Math.max(0, Number(options.seekDelay) || 0),
      seekRange: Math.max(0, Number(options.seekRange) || 0),
      speed: Math.max(0, Number(options.speed) || 0),
      damage: Math.max(0, Number(options.damage) || 0),
      subsequentPct: Math.max(0, Number(options.subsequentPct) || 0),
      executeThresholdPct: Math.max(0, Number(options.executeThresholdPct) || 0),
      executeMultiplier: Math.max(0, Number(options.executeMultiplier) || 0),
      lifetime: Math.max(0, Number(options.lifetime) || 0),
      age: 0,
      dirX: Math.cos(angle),
      dirY: Math.sin(angle),
      x: origin.x + Math.cos(angle) * orbitRadius,
      y: origin.y + Math.sin(angle) * orbitRadius,
      prevX: origin.x,
      prevY: origin.y,
      targetRef: null
    };
    emberWaltzFlames.push(flame);
    return flame;
  }

  function castEmberWaltzAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Ember Waltz';
    const flameCount = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'flameCount')) || 3));
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const subsequentPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'subsequentHitPct')) || 0));
    const seekRange = Math.max(0, Number(abilityFieldValue(ability, 'seekRangePx')) || 0);
    const orbitRadius = Math.max(0, Number(abilityFieldValue(ability, 'orbitRadiusPx')) || 0);
    const flameSpeed = Math.max(0, Number(abilityFieldValue(ability, 'flameSpeedPxS')) || 0);
    const orbitDuration = Math.max(0, Number(abilityFieldValue(ability, 'orbitDurationMs')) || 0) / 1000 || 2.5;
    const seekDelay = Math.max(0, Number(abilityFieldValue(ability, 'seekDelayMs')) || 0) / 1000;
    const hastePct = Math.max(0, Number(abilityFieldValue(ability, 'hastePercent')) || 0);
    const hasteDuration = Math.max(0, Number(abilityFieldValue(ability, 'hasteDurationMs')) || 0) / 1000;
    const executeThreshold = Math.max(0, Number(abilityFieldValue(ability, 'executeThresholdPct')) || 0);
    const executeMultiplier = Math.max(0, Number(abilityFieldValue(ability, 'executeDamageMultiplier')) || 0);

    const castId = abilityRuntime.emberWaltzSequence++;
    const cast = {
      id: castId,
      abilityId: ability && ability.id ? ability.id : 'ember_waltz',
      abilityName,
      elapsed: 0,
      lifetime: orbitDuration,
      hitTargets: new Set(),
      subsequentPct,
      executeThresholdPct: executeThreshold,
      executeMultiplier,
      hasteDuration,
      hastePercent: hastePct
    };
    emberWaltzCasts.push(cast);

    if(hasteDuration > 0 && hastePct > 0){
      player.hasteMinPct = 0;
      player.hasteTimer = hasteDuration;
      player.hastePct = hastePct;
      player.hasteDecayRate = hasteDuration > 0 ? hastePct / hasteDuration : 0;
    }

    const origin = getSpellOrigin(player);
    const aim = beamAimPoint();
    const baseAngle = Math.atan2(aim.y - origin.y, aim.x - origin.x);
    const spinSpacing = (Math.PI * 2) / flameCount;

    for(let i = 0; i < flameCount; i++){
      const angle = baseAngle + spinSpacing * i;
      spawnEmberWaltzFlame(cast, {
        id: `ember-${castId}-${i+1}`,
        angle,
        orbitRadius,
        angularSpeed: EMBER_WALTZ_SPIN_SPEED,
        seekDelay: seekDelay + i * 0.12,
        seekRange,
        speed: flameSpeed,
        damage,
        subsequentPct,
        executeThresholdPct: executeThreshold,
        executeMultiplier,
        lifetime: orbitDuration
      });
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    setHudMessage(`${abilityName} sends embers swirling!`);
    return true;
  }

  function endSkyfireVolleyCast(cast, { reason = 'complete', applyCooldown = true, silent = false } = {}){
    if(!cast || cast.ended) return;
    cast.ended = true;
    const idx = skyfireVolleyCasts.indexOf(cast);
    if(idx >= 0){
      skyfireVolleyCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(applyCooldown && Number.isFinite(cast.slotIndex)){
      const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    if(cast.casterRef === player && !silent){
      const abilityName = cast.abilityName || 'Removed ability';
      let message;
      if(reason === 'control'){
        message = `${abilityName} interrupted!`;
      } else if(reason === 'dead'){
        message = `${abilityName} interrupted by death.`;
      } else if(reason === 'fizzled'){
        message = `${abilityName} fizzled.`;
      } else {
        message = `${abilityName} ended.`;
      }
      setHudMessage(message);
    }
  }

  function fireSkyfireVolleyRocket(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const abilityName = cast.abilityName || 'Removed ability';
    const speed = Math.max(0, Number(cast.speed) || 0);
    const baseRange = Math.max(0, Number(cast.range) || 0);
    const width = Math.max(0, Number(cast.width) || 0);
    const impactRadius = Math.max(0, Number(cast.impactRadius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    if(!(speed > 0 && baseRange > 0 && damage > 0)){
      return false;
    }
    const bigEvery = Math.max(1, Math.round(Number(cast.bigEvery) || 3));
    const shotNumber = Math.max(0, Number(abilityRuntime.skyfireVolleySequence) || 0) + 1;
    abilityRuntime.skyfireVolleySequence = shotNumber;
    const bigShot = bigEvery > 0 && shotNumber % bigEvery === 0;
    const bigDamagePct = Math.max(0, Number(cast.bigDamagePct) || 0);
    const finalDamage = bigShot ? damage * (1 + bigDamagePct / 100) : damage;
    const rangeBonus = bigShot ? Math.max(0, Number(cast.bigRangeBonus) || 0) : 0;
    const radiusBonus = bigShot ? Math.max(0, Number(cast.bigRadiusBonus) || 0) : 0;
    const effectiveRange = baseRange + rangeBonus;
    const explosionRadius = impactRadius + radiusBonus;
    const origin = getSpellOrigin(caster);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;
    const muzzleOffset = (caster && Number.isFinite(caster.r) ? caster.r : player.r || 12) + 6;
    const startX = origin.x + dirX * muzzleOffset;
    const startY = origin.y + dirY * muzzleOffset;
    const rangeValue = effectiveRange > 0 ? effectiveRange : baseRange;
    if(!(rangeValue > 0)){
      return false;
    }
    const projectile = {
      id: `skyfire-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`,
      abilityId: cast.abilityId,
      abilityName,
      casterRef: caster,
      startX,
      startY,
      dirX,
      dirY,
      speed,
      range: rangeValue,
      traveled: 0,
      width,
      damage: finalDamage,
      explosionRadius,
      bigShot
    };
    skyfireVolleyProjectiles.push(projectile);
    if(Number.isFinite(cast.slotIndex)){
      const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    cancelPlayerAttack(false);
    if(caster === player){
      player.chaseTarget = null;
      player.navGoal = null;
      player.nav = null;
      const message = bigShot ? `${abilityName} (Big One) launched!` : `${abilityName} launched!`;
      setHudMessage(message);
    }
    return true;
  }

  function applySkyfireVolleyExplosion(centerX, centerY, proj){
    if(!proj) return;
    const radius = Math.max(0, Number(proj.explosionRadius) || 0);
    const damage = Math.max(0, Number(proj.damage) || 0);
    if(!(radius > 0) || !(damage > 0)) return;
    const abilityName = proj.abilityName || 'Removed ability';
    let hits = 0;
    const radiusSq = radius * radius;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const effectiveRadius = radius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > effectiveRadius * effectiveRadius) continue;
      const prevHp = Number(m.hp) || 0;
      m.hp = Math.max(0, prevHp - damage);
      if(damage > 0){
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      const dealt = Math.max(0, prevHp - m.hp);
      if(dealt > 0 && !practiceTarget && prevHp > 0 && m.hp <= 0){
        addGold(goldState.perKill);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits += dealt > 0 ? 1 : 0;
    }
    const monster = monsterState;
    if(monster && isMonsterAttackable(monster) && monster.hp > 0 && monster.portalizing <= 0){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      if(dx * dx + dy * dy <= (radius + monsterRadius) * (radius + monsterRadius)){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        monster.hp = Math.max(0, prevHp - damage);
        if(damage > 0){
          spawnHitSplat(monster.x, monster.y - monsterRadius, damage);
          updateMonsterHud();
        }
        if(prevHp > 0 && monster.hp <= 0){
          addGold(goldState.perKill);
        }
        hits += prevHp > 0 ? 1 : 0;
      }
    }
    const flashColor = proj.bigShot ? '#ffe7c0' : '#ffc99a';
    flash(centerX, centerY, { startRadius: Math.max(12, radius * 0.4), endRadius: Math.max(radius + 32, radius * 1.2), color: flashColor });
    if(proj.casterRef === player){
      updatePlayerFacingTowards({ x: centerX, y: centerY });
    }
    return hits;
  }

  function applyDawnfallBarrageExplosion(centerX, centerY, radius, damage, minionFraction, abilityName, caster){
    if(!(radius > 0) || !(damage > 0)){
      return 0;
    }
    const safeFraction = Math.max(0, Math.min(1, Number(minionFraction) || 0));
    let hits = 0;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const buffer = radius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > buffer * buffer) continue;
      const prevHp = Math.max(0, Number(m.hp) || 0);
      const finalDamage = practiceTarget ? damage : damage * safeFraction;
      m.hp = Math.max(0, prevHp - finalDamage);
      if(finalDamage > 0){
        spawnHitSplat(m.x, m.y - targetRadius, finalDamage);
      }
      const dealt = Math.max(0, prevHp - m.hp);
      if(dealt > 0 && !practiceTarget && prevHp > 0 && m.hp <= 0){
        addGold(goldState.perKill);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits += dealt > 0 ? 1 : 0;
    }
    const monster = monsterState;
    if(monster && isMonsterAttackable(monster) && monster.hp > 0 && monster.portalizing <= 0){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      if(dx * dx + dy * dy <= (radius + monsterRadius) * (radius + monsterRadius)){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        monster.hp = Math.max(0, prevHp - damage);
        if(damage > 0){
          spawnHitSplat(monster.x, monster.y - monsterRadius, damage);
          updateMonsterHud();
        }
        if(prevHp > 0 && monster.hp <= 0){
          addGold(goldState.perKill);
        }
        hits += prevHp > 0 ? 1 : 0;
      }
    }
    flash(centerX, centerY, { startRadius: Math.max(12, radius * 0.4), endRadius: Math.max(radius + 32, radius * 1.2), color: '#ffe7c0' });
    if(caster === player){
      updatePlayerFacingTowards({ x: centerX, y: centerY });
    }
    return hits;
  }

  function spawnDawnfallBarrageBolt(cast){
    if(!cast) return false;
    const effectRadius = Math.max(0, Number(cast.effectRadius) || 0);
    const explosionRadius = Math.max(0, Number(cast.explosionRadius) || 0);
    const boltDamage = Math.max(0, Number(cast.boltDamage) || 0);
    if(!(effectRadius > 0 && explosionRadius > 0 && boltDamage > 0)){
      return false;
    }
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.sqrt(Math.random()) * effectRadius;
    const landingX = (Number(cast.targetX) || 0) + Math.cos(angle) * distance;
    const landingY = (Number(cast.targetY) || 0) + Math.sin(angle) * distance;
    applyDawnfallBarrageExplosion(landingX, landingY, explosionRadius, boltDamage, cast.minionDamageFraction, cast.abilityName, cast.casterRef);
    return true;
  }

  function endDawnfallBarrageCast(cast, { reason = 'complete', silent = false } = {}){
    if(!cast || cast.ended) return;
    cast.ended = true;
    const idx = dawnfallBarrageCasts.indexOf(cast);
    if(idx >= 0){
      dawnfallBarrageCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(cast.casterRef === player && !silent){
      const abilityName = cast.abilityName || 'Dawnfall Barrage';
      let message;
      if(reason === 'control'){
        message = `${abilityName} interrupted!`;
      } else if(reason === 'dead'){
        message = `${abilityName} interrupted by death.`;
      } else {
        message = `${abilityName} ended.`;
      }
      setHudMessage(message);
    }
  }

  function updateDawnfallBarrageCasts(dt){
    for(let i = dawnfallBarrageCasts.length - 1; i >= 0; i--){
      const cast = dawnfallBarrageCasts[i];
      if(!cast){
        dawnfallBarrageCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        endDawnfallBarrageCast(cast, { reason: 'dead', silent: true });
        continue;
      }
      const interrupted = caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0 || caster.disarmTimer > 0;
      if(interrupted){
        endDawnfallBarrageCast(cast, { reason: 'control' });
        continue;
      }
      cast.elapsed = Math.max(0, Number(cast.elapsed) || 0) + dt;
      let justReady = false;
      if(!cast.previewComplete && cast.elapsed >= Math.max(0, Number(cast.castDuration) || 0)){
        cast.previewComplete = true;
        cast.launchElapsed = Math.max(0, cast.elapsed - Math.max(0, Number(cast.castDuration) || 0));
        justReady = true;
      }
      if(!cast.previewComplete){
        continue;
      }
      if(!cast.cooldownApplied){
        if(Number.isFinite(cast.slotIndex)){
          setAbilitySlotCooldown(cast.slotIndex, Math.max(0, Number(cast.cooldownSeconds) || 0));
        }
        cast.cooldownApplied = true;
      }
      if(!justReady){
        cast.launchElapsed = Math.max(0, Number(cast.launchElapsed) || 0) + dt;
      }
      const interval = Math.max(0.001, Number(cast.boltInterval) || 0.001);
      while(cast.nextBoltIndex < cast.boltCount && cast.launchElapsed >= interval * cast.nextBoltIndex){
        spawnDawnfallBarrageBolt(cast);
        cast.nextBoltIndex += 1;
      }
      if(cast.nextBoltIndex > 0 && !cast.messageShown && cast.casterRef === player){
        setHudMessage(`${cast.abilityName || 'Dawnfall Barrage'} unleashed!`);
        cast.messageShown = true;
      }
      if(cast.nextBoltIndex >= cast.boltCount && cast.launchElapsed >= Math.max(0, Number(cast.launchDuration) || 0)){
        endDawnfallBarrageCast(cast, { reason: 'complete', silent: true });
      }
    }
  }

  function castDawnfallBarrageAbility(slotIndex, ability){
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Dawnfall Barrage';
    const targetRange = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const effectRadius = Math.max(0, Number(abilityFieldValue(ability, 'effectRadiusPx')) || 0);
    const explosionRadius = Math.max(0, Number(abilityFieldValue(ability, 'explosionRadiusPx')) || 0);
    const boltDamage = Math.max(0, Number(abilityFieldValue(ability, 'boltDamage')) || 0);
    const boltCount = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'boltCount')) || 1));
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const rawLaunchMs = Math.max(0, Number(abilityFieldValue(ability, 'launchDurationMs')) || 0);
    const launchDuration = rawLaunchMs > 0 ? rawLaunchMs / 1000 : 0.7;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const minionPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'minionDamagePct')) || 75));
    const minionFraction = minionPct / 100;
    if(!(targetRange > 0)){
      setHudMessage(`${abilityName} needs a target range configured.`);
      return false;
    }
    if(!(effectRadius > 0)){
      setHudMessage(`${abilityName} needs an effect radius.`);
      return false;
    }
    if(!(explosionRadius > 0)){
      setHudMessage(`${abilityName} needs an explosion radius.`);
      return false;
    }
    if(!(boltDamage > 0)){
      setHudMessage(`${abilityName} needs bolt damage.`);
      return false;
    }
    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const range = Math.min(targetRange, distance);
    const targetX = origin.x + dx / distance * range;
    const targetY = origin.y + dy / distance * range;
    const boltInterval = Math.max(0.01, launchDuration / boltCount);

    const cast = {
      abilityId: ability && ability.id ? ability.id : 'dawnfall_barrage',
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      castDuration,
      elapsed: 0,
      targetX,
      targetY,
      effectRadius,
      explosionRadius,
      boltCount,
      boltDamage,
      minionDamageFraction: minionFraction,
      launchDuration,
      boltInterval,
      nextBoltIndex: 0,
      launchElapsed: 0,
      previewComplete: castDuration <= 0,
      cooldownApplied: false,
      messageShown: false,
      ended: false
    };

    dawnfallBarrageCasts.push(cast);
    cancelPlayerAttack(false);
    player.casting = cast;
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(castDuration > 0){
      setHudMessage(`${abilityName} preparing...`);
    } else {
      setHudMessage(`${abilityName} launching...`);
    }
    return { success: true, deferCooldown: true };
  }

  function castSkyfireVolleyAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Removed ability';
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadiusPx')) || 0);
    if(!(projectileRange > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    if(!(projectileSpeed > 0)){
      setHudMessage(`${abilityName} needs projectile speed configured.`);
      return false;
    }
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }
    const cast = {
      id: `skyfire-${Date.now().toString(16)}`,
      abilityId: ability && ability.id ? ability.id : '',
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      castDuration: castTime,
      elapsed: 0,
      speed: projectileSpeed,
      range: projectileRange,
      width: Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0),
      damage,
      impactRadius,
      bigDamagePct: Math.max(0, Number(abilityFieldValue(ability, 'bigDamagePct')) || 0),
      bigRangeBonus: Math.max(0, Number(abilityFieldValue(ability, 'bigRangeBonusPx')) || 0),
      bigRadiusBonus: Math.max(0, Number(abilityFieldValue(ability, 'bigRadiusBonusPx')) || 0),
      bigEvery: Math.max(1, Math.round(Number(abilityFieldValue(ability, 'bigEvery')) || 3)),
      ended: false,
      allowMovementWhileCasting: true,
      movementSpeedMultiplier: 1
    };
    if(castTime <= 0){
      const fired = fireSkyfireVolleyRocket(cast);
      if(!fired){
        setHudMessage(`${abilityName} fizzled.`);
        return false;
      }
      return { success: true, deferCooldown: true };
    }
    skyfireVolleyCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    setHudMessage(`${abilityName} winding up...`);
    return { success: true, deferCooldown: true };
  }

  function updateSkyfireVolleyCasts(dt){
    for(let i = skyfireVolleyCasts.length - 1; i >= 0; i--){
      const cast = skyfireVolleyCasts[i];
      if(!cast){
        skyfireVolleyCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        endSkyfireVolleyCast(cast, { reason: 'dead', applyCooldown: false, silent: true });
        continue;
      }
      const interrupted = caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0 || caster.disarmTimer > 0;
      if(interrupted){
        endSkyfireVolleyCast(cast, { reason: 'control', applyCooldown: false });
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration > 0 && cast.elapsed >= duration){
        fireSkyfireVolleyRocket(cast);
        endSkyfireVolleyCast(cast, { reason: 'complete', applyCooldown: false, silent: true });
      }
    }
  }

  function updateSkyfireVolleyProjectiles(dt){
    for(let i = skyfireVolleyProjectiles.length - 1; i >= 0; i--){
      const proj = skyfireVolleyProjectiles[i];
      if(!proj){
        skyfireVolleyProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(range > 0) || !(speed > 0)){
        skyfireVolleyProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      const nextTraveled = Math.min(range, prevTraveled + speed * dt);
      let impactAlong = Infinity;
      let impactPoint = null;
      const halfWidth = Math.max(0, (Number(proj.width) || 0) / 2);
      const startX = Number.isFinite(proj.startX) ? proj.startX : 0;
      const startY = Number.isFinite(proj.startY) ? proj.startY : 0;
      for(const m of minions){
        if(!m) continue;
        const practiceTarget = m.isPracticeDummy === true;
        if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
        const buffer = halfWidth + targetRadius;
        const relX = m.x - startX;
        const relY = m.y - startY;
        const along = relX * (proj.dirX || 1) + relY * (proj.dirY || 0);
        if(along < prevTraveled - buffer) continue;
        if(along > nextTraveled + buffer) continue;
        if(along < -targetRadius || along > range + targetRadius) continue;
        const closestX = startX + (proj.dirX || 1) * along;
        const closestY = startY + (proj.dirY || 0) * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        if(offX * offX + offY * offY <= buffer * buffer && along < impactAlong){
          impactAlong = along;
          impactPoint = { x: closestX, y: closestY };
        }
      }
      const monster = monsterState;
      if(monster && isMonsterAttackable(monster) && monster.hp > 0 && monster.portalizing <= 0){
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
        const relX = monster.x - startX;
        const relY = monster.y - startY;
        const along = relX * (proj.dirX || 1) + relY * (proj.dirY || 0);
        const buffer = halfWidth + monsterRadius;
        if(along >= prevTraveled - buffer && along <= nextTraveled + buffer && along >= -monsterRadius && along <= range + monsterRadius){
          const closestX = startX + (proj.dirX || 1) * along;
          const closestY = startY + (proj.dirY || 0) * along;
          const offX = monster.x - closestX;
          const offY = monster.y - closestY;
          if(offX * offX + offY * offY <= buffer * buffer && along < impactAlong){
            impactAlong = along;
            impactPoint = { x: closestX, y: closestY };
          }
        }
      }
      if(impactPoint){
        applySkyfireVolleyExplosion(impactPoint.x, impactPoint.y, proj);
        skyfireVolleyProjectiles.splice(i, 1);
        continue;
      }
      if(nextTraveled >= range - 0.001){
        const impactX = startX + (proj.dirX || 1) * range;
        const impactY = startY + (proj.dirY || 0) * range;
        applySkyfireVolleyExplosion(impactX, impactY, proj);
        skyfireVolleyProjectiles.splice(i, 1);
        continue;
      }
      proj.traveled = nextTraveled;
      proj.currentX = startX + (proj.dirX || 1) * nextTraveled;
      proj.currentY = startY + (proj.dirY || 0) * nextTraveled;
    }
  }

  function castCascadeBarrageAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Cascade Barrage';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a target range configured.`);
      return false;
    }
    const missileCount = Math.max(1, Math.floor(Number(abilityFieldValue(ability, 'missileCount')) || 0));
    const missileDelay = Math.max(0, Number(abilityFieldValue(ability, 'missileDelayMs')) || 0) / 1000;
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs missile damage configured.`);
      return false;
    }
    const minionThreshold = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'minionExecuteThresholdPct')) || 0)) / 100;
    const minionMultiplier = Math.max(1, Number(abilityFieldValue(ability, 'minionExecuteMultiplier')) || 2);
    const nonMinionSubPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'nonMinionSubsequentPct')) || 0)) / 100;
    const caster = player;
    const rangeSq = range * range;
    const candidates = [];
    const monster = monsterState;
    if(isMonsterAttackable(monster)){
      const dx = monster.x - caster.x;
      const dy = monster.y - caster.y;
      if(dx * dx + dy * dy <= rangeSq){
        candidates.push({ target: monster, type: 'monster', practice: false, distSq: dx * dx + dy * dy });
      }
    }
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - caster.x;
      const dy = m.y - caster.y;
      if(dx * dx + dy * dy > rangeSq) continue;
      candidates.push({ target: m, type: 'minion', practice: practiceTarget, distSq: dx * dx + dy * dy });
    }
    if(!candidates.length){
      setHudMessage(`${abilityName} needs nearby enemies.`);
      return false;
    }
    candidates.sort((a, b) => a.distSq - b.distSq);
    const totalMissiles = missileCount;
    const perTarget = Math.floor(totalMissiles / candidates.length);
    let remainder = totalMissiles - perTarget * candidates.length;
    const origin = getSpellOrigin(caster);
    const targetHitCounts = new Map();
    let missilesCreated = 0;
    for(const entry of candidates){
      let assign = perTarget;
      if(remainder > 0){
        assign += 1;
        remainder -= 1;
      }
      if(assign <= 0) continue;
      for(let i = 0; i < assign; i++){
        const priorHits = targetHitCounts.get(entry.target) || 0;
        const hitOrder = priorHits;
        targetHitCounts.set(entry.target, priorHits + 1);
        cascadeBarrageMissiles.push({
          abilityId: ability.id,
          abilityName,
          slotIndex,
          casterRef: caster,
          targetRef: entry.target,
          practiceTarget: entry.practice,
          targetType: entry.type,
          delay: missileDelay,
          elapsed: 0,
          startX: origin.x,
          startY: origin.y,
          targetX: entry.target.x,
          targetY: entry.target.y,
          baseDamage: damage,
          nonMinionHitOrder: hitOrder,
          minionExecuteThreshold: minionThreshold,
          minionExecuteMultiplier: minionMultiplier,
          nonMinionSubsequentPct: nonMinionSubPct
        });
        missilesCreated += 1;
      }
    }
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setHudMessage(`${abilityName} rained down ${missilesCreated} missiles!`);
    return true;
  }

  function handleCascadeBarrageImpact(missile){
    if(!missile) return false;
    const impactX = Number.isFinite(missile.targetX)
      ? missile.targetX
      : Number.isFinite(missile.startX) ? missile.startX : player.x;
    const impactY = Number.isFinite(missile.targetY)
      ? missile.targetY
      : Number.isFinite(missile.startY) ? missile.startY : player.y;
    flash(impactX, impactY, { startRadius: 8, endRadius: 24, color: '#c2f4ff' });
    const target = missile.targetRef;
    if(!target){
      return false;
    }
    const prevHp = Math.max(0, Number(target.hp) || 0);
    if(prevHp <= 0){
      return false;
    }
    const isMonsterHit = target === monsterState && isMonsterAttackable(target);
    const practiceTarget = target.isPracticeDummy === true;
    if(!isMonsterHit && !practiceTarget && !isEnemyMinionForPlayer(target)){
      return false;
    }
    let damage = Math.max(0, Number(missile.baseDamage) || 0);
    if(!isMonsterHit){
      const threshold = Math.max(0, Number(missile.minionExecuteThreshold) || 0);
      if(threshold > 0){
        const maxHp = Math.max(0, Number(target.maxHp) || 0);
        if(maxHp > 0 && prevHp <= maxHp * threshold){
          const multiplier = Math.max(1, Number(missile.minionExecuteMultiplier) || 1);
          damage *= multiplier;
        }
      }
    } else if(Number(missile.nonMinionHitOrder) > 0){
      const fraction = Math.max(0, Number(missile.nonMinionSubsequentPct) || 0);
      damage *= fraction;
    }
    damage = Math.max(0, damage);
    if(!(damage > 0)){
      return false;
    }
    const nextHp = Math.max(0, prevHp - damage);
    target.hp = nextHp;
    const radius = isMonsterHit
      ? Math.max(minionRadius, monsterAttackRadius(target))
      : (practiceTarget ? Math.max(minionRadius, Number(target.radius) || minionRadius) : minionRadius);
    spawnHitSplat(target.x, target.y - radius, damage);
    if(practiceTarget){
      handlePracticeDummyDamage(target, prevHp);
    } else if(!isMonsterHit && prevHp > 0 && nextHp <= 0){
      addGold(goldState.perKill);
    }
    if(isMonsterHit){
      updateMonsterHud();
    }
    return true;
  }

  function updateCascadeBarrageMissiles(dt){
    for(let i = cascadeBarrageMissiles.length - 1; i >= 0; i--){
      const missile = cascadeBarrageMissiles[i];
      if(!missile){
        cascadeBarrageMissiles.splice(i, 1);
        continue;
      }
      const target = missile.targetRef;
      if(target){
        if(Number.isFinite(target.x)) missile.targetX = target.x;
        if(Number.isFinite(target.y)) missile.targetY = target.y;
      }
      missile.elapsed = Math.max(0, Number(missile.elapsed) || 0) + dt;
      const delay = Math.max(0, Number(missile.delay) || 0);
      if(missile.elapsed < delay){
        continue;
      }
      handleCascadeBarrageImpact(missile);
      cascadeBarrageMissiles.splice(i, 1);
    }
  }

  function castFrenziedSurgeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Frenzied Surge';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const attackSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'attackSpeedPct')) || 0);
    const moveSpeedStartPct = Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedStartPct')) || 0);
    const moveSpeedEndPct = Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedEndPct')) || 0);
    const ghostDuration = Math.max(0, Number(abilityFieldValue(ability, 'ghostDurationMs')) || 0) / 1000;

    if(duration <= 0){
      setHudMessage(`${abilityName} needs a duration configured.`);
      return false;
    }
    if(attackSpeedPct <= 0){
      setHudMessage(`${abilityName} needs attack speed configured.`);
      return false;
    }

    for(let i = frenziedSurgeAttackBuffs.length - 1; i >= 0; i--){
      const buff = frenziedSurgeAttackBuffs[i];
      if(buff && buff.casterRef === player){
        frenziedSurgeAttackBuffs.splice(i, 1);
      }
    }
    for(let i = frenziedSurgeMoveBuffs.length - 1; i >= 0; i--){
      const buff = frenziedSurgeMoveBuffs[i];
      if(buff && buff.casterRef === player){
        frenziedSurgeMoveBuffs.splice(i, 1);
      }
    }
    frenziedSurgeMoveMultiplier = 1;

    const attackBuff = {
      abilityId: ability && ability.id ? ability.id : 'frenzied_surge',
      abilityName,
      slotIndex,
      casterRef: player,
      duration,
      remaining: duration,
      attackSpeedPct
    };
    frenziedSurgeAttackBuffs.push(attackBuff);

    const moveStart = 1 + moveSpeedStartPct / 100;
    const moveEnd = 1 + moveSpeedEndPct / 100;
    if(moveStart > 1){
      frenziedSurgeMoveBuffs.push({
        abilityId: ability && ability.id ? ability.id : 'frenzied_surge',
        abilityName,
        slotIndex,
        casterRef: player,
        duration,
        age: 0,
        startMult: moveStart,
        endMult: moveEnd,
        currentMult: moveStart
      });
      frenziedSurgeMoveMultiplier = Math.max(frenziedSurgeMoveMultiplier, moveStart);
    }

    if(ghostDuration > 0){
      player.ghostTimer = Math.max(player.ghostTimer || 0, ghostDuration);
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.attackTarget = null;
    player.attackOverride = null;
    player.attackCooldown = 0;
    player.attackWindup = 0;
    const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
    setPlayerAttackCooldownFromPeriod(attackPeriod);

    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    setHudMessage(`${abilityName} surged!`);
    return true;
  }

  function spinningAxeConfigFromAbility(ability){
    return {
      abilityId: ability && ability.id ? ability.id : 'spinning_axe',
      abilityName: ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Spinning Axe',
      bonusDamage: Math.max(0, Number(abilityFieldValue(ability, 'bonusDamage')) || 0),
      maxInHand: Math.max(1, Math.round(Number(abilityFieldValue(ability, 'maxInHand')) || 2)),
      flightTime: Math.max(0, Number(abilityFieldValue(ability, 'flightTimeMs')) || 0) / 1000,
      catchWindow: Math.max(0, Number(abilityFieldValue(ability, 'catchWindowMs')) || 0) / 1000,
      catchRadius: Math.max(0, Number(abilityFieldValue(ability, 'catchRadiusPx')) || 0),
      moveSpeedThreshold: Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedThreshold')) || 0),
      forwardMin: Math.max(0, Number(abilityFieldValue(ability, 'forwardMinPx')) || 0),
      forwardMax: Math.max(0, Number(abilityFieldValue(ability, 'forwardMaxPx')) || 0),
      stillMin: Math.max(0, Number(abilityFieldValue(ability, 'stillMinPx')) || 0),
      stillMax: Math.max(0, Number(abilityFieldValue(ability, 'stillMaxPx')) || 0),
      sideJitterMax: Math.max(0, Number(abilityFieldValue(ability, 'sideJitterMaxPx')) || 0),
      edgeMargin: Math.max(0, Number(abilityFieldValue(ability, 'edgeMarginPx')) || 0)
    };
  }

  function castSpinningAxeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const cfg = spinningAxeConfigFromAbility(ability);
    const abilityName = cfg.abilityName;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    if(cfg.flightTime <= 0){
      setHudMessage(`${abilityName} needs a flight time.`);
      return false;
    }
    if(cfg.catchWindow <= 0 || cfg.catchRadius <= 0){
      setHudMessage(`${abilityName} needs a catch window and radius.`);
      return false;
    }

    const currentHeld = spinningAxesInHand.length;
    if(currentHeld >= cfg.maxInHand){
      setHudMessage(`${abilityName} is already at cap (${cfg.maxInHand}).`);
      return false;
    }

    const axe = {
      ...cfg,
      state: 'IN_HAND',
      slotIndex: Number.isFinite(slotIndex) ? slotIndex : null
    };
    spinningAxesInHand.push(axe);

    cancelPlayerAttack(false);
    player.attackTarget = null;
    player.attackWindup = 0;
    player.attackCooldown = 0;
    const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
    setPlayerAttackCooldownFromPeriod(attackPeriod);

    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    setHudMessage(`${abilityName} readied (${spinningAxesInHand.length}/${cfg.maxInHand}).`);
    return true;
  }

  function castRoyalOnslaughtAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Royal Onslaught';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const attackSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'attackSpeedPct')) || 0);
    const bonusDamagePct = Math.max(0, Number(abilityFieldValue(ability, 'bonusDamagePct')) || 0);
    const splashDamagePct = Math.max(0, Number(abilityFieldValue(ability, 'splashDamagePct')) || 0);
    const splashRadius = Math.max(0, Number(abilityFieldValue(ability, 'splashRadiusPx')) || 0);
    const charges = Math.max(1, Math.min(6, Number(abilityFieldValue(ability, 'charges')) || 3));

    if(duration <= 0){
      setHudMessage(`${abilityName} needs an empower duration.`);
      return false;
    }
    if(attackSpeedPct <= 0){
      setHudMessage(`${abilityName} needs attack speed configured.`);
      return false;
    }

    for(let i = royalOnslaughtBuffs.length - 1; i >= 0; i--){
      const buff = royalOnslaughtBuffs[i];
      if(buff && buff.casterRef === player){
        royalOnslaughtBuffs.splice(i, 1);
      }
    }

    const attackBuff = {
      abilityId: ability && ability.id ? ability.id : 'royal_onslaught',
      abilityName,
      slotIndex: Number.isFinite(slotIndex) ? slotIndex : null,
      casterRef: player,
      duration,
      remaining: duration,
      attackSpeedPct,
      bonusDamagePct,
      splashDamagePct,
      splashRadius,
      chargesRemaining: charges
    };
    royalOnslaughtBuffs.push(attackBuff);

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.attackTarget = null;
    player.attackOverride = null;
    player.attackCooldown = 0;
    player.attackWindup = 0;
    const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
    setPlayerAttackCooldownFromPeriod(attackPeriod);

    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    setHudMessage(`${abilityName} arms ${charges} empowered strikes.`);
    return true;
  }

  function castStridingSurgeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Striding Surge';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const attackSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'attackSpeedPct')) || 0);
    const moveSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedPct')) || 0);

    if(duration <= 0){
      setHudMessage(`${abilityName} needs a duration configured.`);
      return false;
    }
    if(attackSpeedPct <= 0){
      setHudMessage(`${abilityName} needs attack speed configured.`);
      return false;
    }

    for(let i = strideSurgeAttackBuffs.length - 1; i >= 0; i--){
      const buff = strideSurgeAttackBuffs[i];
      if(buff && buff.casterRef === player){
        strideSurgeAttackBuffs.splice(i, 1);
      }
    }
    for(let i = strideSurgeMoveBuffs.length - 1; i >= 0; i--){
      const buff = strideSurgeMoveBuffs[i];
      if(buff && buff.casterRef === player){
        strideSurgeMoveBuffs.splice(i, 1);
      }
    }
    strideSurgeMoveMultiplier = 1;

    const attackBuff = {
      abilityId: ability && ability.id ? ability.id : 'striding_surge',
      abilityName,
      slotIndex,
      casterRef: player,
      duration,
      remaining: duration,
      attackSpeedPct
    };
    strideSurgeAttackBuffs.push(attackBuff);

    const moveMultiplier = 1 + moveSpeedPct / 100;
    if(moveSpeedPct > 0){
      strideSurgeMoveBuffs.push({
        abilityId: ability && ability.id ? ability.id : 'striding_surge',
        abilityName,
        slotIndex,
        casterRef: player,
        duration,
        remaining: duration,
        multiplier: moveMultiplier
      });
      strideSurgeMoveMultiplier = Math.max(strideSurgeMoveMultiplier, moveMultiplier);
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.attackTarget = null;
    player.attackOverride = null;
    player.attackCooldown = 0;
    player.attackWindup = 0;
    const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
    setPlayerAttackCooldownFromPeriod(attackPeriod);

    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    setHudMessage(`${abilityName} surged!`);
    return true;
  }

  function castPhantomOverdriveAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Phantom Overdrive';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'attackDurationMs')) || 0) / 1000;
    if(duration <= 0){
      setHudMessage(`${abilityName} needs a duration configured.`);
      return false;
    }
    const bonusCap = Math.max(0, Number(abilityFieldValue(ability, 'bonusAttackSpeedCapPct')) || 100);
    const currentBonus = Math.max(0, bestActiveAttackSpeedBonusForCaster(player));
    const ratio = bonusCap > 0 ? Math.min(1, currentBonus / bonusCap) : 0;
    const minCastTime = Math.max(0, Number(abilityFieldValue(ability, 'minCastTimeMs')) || 0);
    const maxCastTime = Math.max(minCastTime, Number(abilityFieldValue(ability, 'castTimeMs')) || 1200);
    const castRange = Math.max(0, maxCastTime - minCastTime);
    const castTime = Math.max(0, (maxCastTime - castRange * ratio) / 1000);
    const moveMinPct = Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedMinPct')) || 55);
    const moveMaxPct = Math.max(moveMinPct, Number(abilityFieldValue(ability, 'moveSpeedMaxPct')) || 75);
    const moveRange = Math.max(0, moveMaxPct - moveMinPct);
    const movementPct = moveMinPct + moveRange * ratio;
    const movementMultiplier = 1 + movementPct / 100;
    const attackSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'attackSpeedPct')) || 60);
    const windupReductionPct = Math.max(0, Number(abilityFieldValue(ability, 'windupReductionPct')) || 6.44);
    const missileSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'missileSpeedPct')) || 0);
    const cooldownReductionSeconds = Math.max(0, Number(abilityFieldValue(ability, 'cooldownReductionMsOnAttack')) || 500) / 1000;
    const ghostDuration = Math.max(0, Number(abilityFieldValue(ability, 'ghostDurationMs')) || 500) / 1000;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      castTime,
      castElapsed: 0,
      state: castTime > 0 ? 'windup' : 'complete',
      allowMovementWhileCasting: true,
      movementSpeedMultiplier: movementMultiplier,
      durationSeconds: duration,
      attackSpeedPct,
      windupReductionPct,
      missileSpeedPct,
      cooldownReductionSeconds,
      movementMultiplier,
      cooldownSeconds
    };

    if(ghostDuration > 0){
      player.ghostTimer = Math.max(player.ghostTimer || 0, ghostDuration);
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.attackTarget = null;
    player.attackOverride = null;

    if(cast.state === 'windup' && cast.castTime > 0){
      phantomOverdriveCasts.push(cast);
      player.casting = cast;
      setHudMessage(`${abilityName} charging...`);
      return { success: true, deferCooldown: true };
    }
    return completePhantomOverdriveCast(cast);
  }

  function completePhantomOverdriveCast(cast){
    if(!cast){
      return false;
    }
    const idx = phantomOverdriveCasts.indexOf(cast);
    if(idx >= 0){
      phantomOverdriveCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const abilityName = cast.abilityName || 'Phantom Overdrive';
    const duration = Math.max(0, Number(cast.durationSeconds) || 0);
    if(duration > 0){
      phantomOverdriveAttackBuffs.push({
        abilityId: cast.abilityId,
        abilityName,
        slotIndex: Number.isFinite(cast.slotIndex) ? cast.slotIndex : null,
        casterRef: player,
        duration,
        remaining: duration,
        attackSpeedPct: cast.attackSpeedPct,
        windupReductionPct: cast.windupReductionPct,
        missileSpeedPct: cast.missileSpeedPct,
        cooldownReductionSeconds: cast.cooldownReductionSeconds
      });
      phantomOverdriveMoveBuffs.push({
        abilityId: cast.abilityId,
        abilityName,
        slotIndex: Number.isFinite(cast.slotIndex) ? cast.slotIndex : null,
        casterRef: player,
        duration,
        age: 0,
        startMult: cast.movementMultiplier,
        endMult: cast.movementMultiplier,
        currentMult: cast.movementMultiplier
      });
    }
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cast.cooldownSeconds);
    }
    setHudMessage(`${abilityName} overdriven!`);
    return true;
  }

  function spawnBulletTimeWave(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    if(!caster) return false;
    const origin = getSpellOrigin(caster);
    const count = Math.max(1, Math.round(Number(cast.projectilesPerWave) || 0));
    if(count <= 0) return false;
    const spread = Math.max(0, Number(cast.spreadRad) || 0);
    const halfSpread = spread * 0.5;
    const gap = count > 1 ? spread / (count - 1) : 0;
    const baseAngle = Math.atan2(cast.dirY || 0, cast.dirX || 1);
    for(let i = 0; i < count; i++){
      const angle = baseAngle - halfSpread + gap * i;
      const dirX = Math.cos(angle);
      const dirY = Math.sin(angle);
      const projectile = {
        abilityId: cast.abilityId,
        abilityName: cast.abilityName || 'Phantom Barrage',
        casterRef: caster,
        startX: origin.x,
        startY: origin.y,
        dirX,
        dirY,
        speed: Math.max(0, Number(cast.projectileSpeed) || 0),
        maxDistance: Math.max(0, Number(cast.projectileRange) || 0),
        traveled: 0,
        width: Math.max(0, Number(cast.projectileWidth) || 0),
        damage: Math.max(0, Number(cast.damage) || 0),
        hitMonsters: true,
        currentX: origin.x,
        currentY: origin.y,
        shadowColor: '#ffcfc6',
        outerColor: '#ffd0b6',
        innerColor: '#fff1e6',
        tipColor: '#fff5ed',
        hitStatusText: ' (barrage)'
      };
      laserProjectiles.push(projectile);
    }
    flash(origin.x, origin.y, { startRadius: 12, endRadius: 34, color: '#ffcf9a' });
    return true;
  }

  function endBulletTimeCast(cast, { reason = 'complete', applyCooldown = true } = {}){
    if(!cast){
      return false;
    }
    const idx = phantomBarrageCasts.indexOf(cast);
    if(idx >= 0){
      phantomBarrageCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(applyCooldown && !cast.cooldownApplied && Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, Math.max(0, Number(cast.cooldownSeconds) || 0));
      cast.cooldownApplied = true;
    }
    if(cast.casterRef === player){
      if(reason === 'control'){
        setHudMessage(`${cast.abilityName || 'Phantom Barrage'} interrupted.`);
      } else {
        setHudMessage(`${cast.abilityName || 'Phantom Barrage'} ended.`);
      }
    }
    return true;
  }

  function castPhantomBarrageAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Phantom Barrage';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const channelDuration = Math.max(0, Number(abilityFieldValue(ability, 'channelDurationMs')) || 0) / 1000;
    const waveInterval = Math.max(0, Number(abilityFieldValue(ability, 'waveIntervalMs')) || 0) / 1000;
    const waveCount = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'waveCount')) || 0));
    const projectilesPerWave = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'projectilesPerWave')) || 0));
    const spreadRad = Math.max(0, Number(abilityFieldValue(ability, 'spreadDeg')) || 0) * Math.PI / 180;
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);

    if(channelDuration <= 0){
      setHudMessage(`${abilityName} needs a channel duration.`);
      return false;
    }
    if(waveInterval <= 0){
      setHudMessage(`${abilityName} needs a wave interval.`);
      return false;
    }
    if(waveCount <= 0){
      setHudMessage(`${abilityName} needs a wave count.`);
      return false;
    }
    if(projectileRange <= 0 || projectileSpeed <= 0 || damage <= 0){
      setHudMessage(`${abilityName} needs projectile tuning.`);
      return false;
    }

    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - player.x;
    let dy = aimPoint.y - player.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - player.x;
      dy = player.target.y - player.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      channelDuration,
      elapsed: 0,
      waveInterval,
      waveTimer: 0,
      waveCount,
      wavesFired: 0,
      projectilesPerWave,
      spreadRad,
      projectileRange,
      projectileSpeed,
      projectileWidth,
      damage,
      dirX,
      dirY,
      cooldownApplied: false,
      allowMovementWhileCasting: false
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    phantomBarrageCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} unleashing waves!`);
    return { success: true, deferCooldown: true };
  }

  function updateBulletTimeCasts(dt){
    for(let i = phantomBarrageCasts.length - 1; i >= 0; i--){
      const cast = phantomBarrageCasts[i];
      if(!cast){
        phantomBarrageCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        phantomBarrageCasts.splice(i, 1);
        continue;
      }
      const interrupted = caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0;
      if(interrupted){
        endBulletTimeCast(cast, { reason: 'control', applyCooldown: false });
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      cast.waveTimer = Math.max(0, (Number(cast.waveTimer) || 0) - dt);
      while(cast.waveTimer <= 0 && cast.wavesFired < cast.waveCount){
        spawnBulletTimeWave(cast);
        cast.wavesFired += 1;
        cast.waveTimer += cast.waveInterval;
      }
      if(cast.wavesFired >= cast.waveCount || cast.elapsed >= cast.channelDuration){
        endBulletTimeCast(cast, { reason: 'complete', applyCooldown: true });
      }
    }
  }

  function isVeilHuntNearCover(caster, range){
    if(!caster) return false;
    const margin = Math.max(0, Number(range) || 0);
    const radius = Math.max(0, Number(caster.r) || 0);
    const nearTerrain = circleCollides(caster.x, caster.y, radius + margin);
    const nearEdge = margin > 0 && (
      caster.x - radius <= margin ||
      caster.y - radius <= margin ||
      (mapState.width - caster.x - radius) <= margin ||
      (mapState.height - caster.y - radius) <= margin
    );
    return nearTerrain || nearEdge;
  }

  function findVeilHuntTarget(caster, maxRange){
    if(!caster) return null;
    const range = Math.max(0, Number(maxRange) || 0);
    if(!(range > 0)) return null;
    const rangeSq = range * range;
    let best = null;
    let bestDistSq = Infinity;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const dx = m.x - caster.x;
      const dy = m.y - caster.y;
      const distSq = dx * dx + dy * dy;
      if(range > 0 && distSq > rangeSq) continue;
      if(distSq < bestDistSq){
        best = m;
        bestDistSq = distSq;
      }
    }
    if(isMonsterAttackable(monsterState)){
      const dx = monsterState.x - caster.x;
      const dy = monsterState.y - caster.y;
      const distSq = dx * dx + dy * dy;
      if((range <= 0 || distSq <= rangeSq) && distSq < bestDistSq){
        best = monsterState;
        bestDistSq = distSq;
      }
    }
    return best;
  }

  function beginVeilHuntActive(cast){
    if(!cast || cast.ended) return;
    cast.state = 'active';
    cast.elapsed = cast.castDuration || 0;
    cast.activeElapsed = 0;
    cast.awayTimer = 0;
    cast.recastReady = cast.recastDelay <= 0;
    cast.trackedTarget = null;
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(cast.casterRef === player){
      flash(player.x, player.y, { startRadius: Math.max(14, player.r + 6), endRadius: Math.max(48, player.r + 28), color: '#7fe3ff' });
      setHudMessage(`${cast.abilityName || 'Removed ability'} active - hug terrain to stay hidden.`);
    }
  }

  function endVeilHuntCast(cast, { reason = 'end', silent = false } = {}){
    if(!cast || cast.ended) return;
    cast.ended = true;
    cast.state = 'ended';
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(cast.casterRef === player){
      playerRuntime.shadowPursuitMoveMult = 1;
      playerRuntime.shadowPursuitActive = false;
      if(!silent){
        const abilityName = cast.abilityName || 'Removed ability';
        if(reason === 'outOfCover'){
          setHudMessage(`${abilityName} broke - you left cover too long.`);
        } else if(reason === 'recast'){
          setHudMessage(`${abilityName} ended.`);
        }
      }
    }
  }

  function cancelShadowPursuitForCaster(caster, reason = 'cancel'){
    let cancelled = false;
    for(let i = shadowPursuitCasts.length - 1; i >= 0; i--){
      const cast = shadowPursuitCasts[i];
      if(!cast || cast.ended) continue;
      if(cast.casterRef && cast.casterRef !== caster) continue;
      endVeilHuntCast(cast, { reason, silent: reason === 'cancel' });
      shadowPursuitCasts.splice(i, 1);
      cancelled = true;
    }
    return cancelled;
  }

  function castVeilHuntAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Removed ability';
    const existing = shadowPursuitCasts.find(cast => cast && cast.casterRef === player && !cast.ended);
    if(existing){
      if(existing.state === 'windup'){
        setHudMessage(`${abilityName} is already priming.`);
        return false;
      }
      if(existing.recastReady){
        endVeilHuntCast(existing, { reason: 'recast' });
        const idx = shadowPursuitCasts.indexOf(existing);
        if(idx >= 0) shadowPursuitCasts.splice(idx, 1);
        return { success: true, deferCooldown: true };
      }
      const remaining = Math.max(0, (Number(existing.recastDelay) || 0) - (Number(existing.activeElapsed) || 0));
      if(remaining > 0){
        const text = remaining >= 1 ? remaining.toFixed(1) : remaining.toFixed(2);
        setHudMessage(`${abilityName} recast unlocks in ${text}s.`);
      } else {
        setHudMessage(`${abilityName} is already active.`);
      }
      return false;
    }
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const nearCoverRange = Math.max(0, Number(abilityFieldValue(ability, 'nearTerrainRangePx')) || 0);
    const lingerDuration = Math.max(0, Number(abilityFieldValue(ability, 'lingerDurationMs')) || 0) / 1000;
    const detectionRadius = Math.max(0, Number(abilityFieldValue(ability, 'detectionRadiusPx')) || 0);
    const trailRange = Math.max(0, Number(abilityFieldValue(ability, 'trailRangePx')) || 0);
    const speedBonus = Math.max(0, Number(abilityFieldValue(ability, 'bonusMoveSpeed')) || 0);
    const recastDelay = Math.max(0, Number(abilityFieldValue(ability, 'recastDelayMs')) || 0) / 1000;
    const cast = {
      id: `veil-${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 6)}`,
      abilityId: ability && ability.id ? ability.id : '',
      abilityName,
      slotIndex,
      casterRef: player,
      state: castTime > 0 ? 'windup' : 'active',
      castDuration: castTime,
      elapsed: 0,
      activeElapsed: 0,
      awayTimer: 0,
      nearCoverRange,
      lingerDuration,
      detectionRadius,
      trailRange: trailRange || detectionRadius,
      speedBonus,
      recastDelay,
      recastReady: castTime <= 0 ? recastDelay <= 0 : false,
      ended: false,
      allowMovementWhileCasting: true,
      cooldownSeconds,
      trackedTarget: null,
      moveMult: 1
    };

    shadowPursuitCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'active'){
      beginVeilHuntActive(cast);
    } else {
      setHudMessage(`${abilityName} priming...`);
    }
    return true;
  }

  function findExistingFlipbladeMark(caster, abilityId){
    if(!caster || !abilityId) return null;
    return flipbladeMarks.find(mark => mark && mark.casterRef === caster && mark.abilityId === abilityId) || null;
  }

  function removeFlipbladeMark(mark){
    const idx = flipbladeMarks.indexOf(mark);
    if(idx >= 0){
      flipbladeMarks.splice(idx, 1);
    }
  }

  function applyFlipbladeCooldown(slotIndex, cooldownSeconds){
    if(!Number.isFinite(slotIndex)) return;
    setAbilitySlotCooldown(slotIndex, Math.max(0, Number(cooldownSeconds) || 0));
  }

  function spawnFlipbladeProjectile(opts){
    const range = Math.max(0, Number(opts && opts.range) || 0);
    const speed = Math.max(0, Number(opts && opts.speed) || 0);
    if(!(range > 0) || !(speed > 0)) return null;
    let dirX = Number(opts && opts.dirX) || 0;
    let dirY = Number(opts && opts.dirY) || 0;
    const len = Math.hypot(dirX, dirY);
    if(len > 0.0001){
      dirX /= len;
      dirY /= len;
    } else {
      dirX = 1;
      dirY = 0;
    }
    const proj = {
      abilityId: opts.abilityId,
      abilityName: opts.abilityName || 'Flipblade Pursuit',
      slotIndex: opts.slotIndex,
      casterRef: opts.casterRef || player,
      startX: Number(opts.startX) || 0,
      startY: Number(opts.startY) || 0,
      currentX: Number(opts.startX) || 0,
      currentY: Number(opts.startY) || 0,
      dirX,
      dirY,
      speed,
      range,
      width: Math.max(0, Number(opts.width) || 0),
      damage: Math.max(0, Number(opts.damage) || 0),
      markDamage: Math.max(0, Number(opts.markDamage) || 0),
      markDuration: Math.max(0, Number(opts.markDuration) || 0),
      recastSpeed: Math.max(0, Number(opts.recastSpeed) || 0),
      cooldownSeconds: Math.max(0, Number(opts.cooldownSeconds) || 0),
      traveled: 0
    };
    flipbladeProjectiles.push(proj);
    return proj;
  }

  function launchFlipbladeCast(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const abilityName = cast.abilityName || 'Flipblade Pursuit';
    let dirX = Number(cast.dirX) || 0;
    let dirY = Number(cast.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(dirLen > 0.0001){
      dirX /= dirLen;
      dirY /= dirLen;
    } else {
      dirX = 1;
      dirY = 0;
    }

    const startX = caster.x;
    const startY = caster.y;
    const backstepDistance = Math.max(0, Number(cast.backstepDistance) || 0);
    const backstepSpeed = Math.max(0, Number(cast.backstepSpeed) || 0);
    if(backstepDistance > 0){
      const moveX = -dirX * backstepDistance;
      const moveY = -dirY * backstepDistance;
      const moved = moveCircleWithCollision(startX, startY, moveX, moveY, caster.r || minionRadius);
      caster.x = Math.max(caster.r, Math.min(mapState.width - caster.r, moved.x));
      caster.y = Math.max(caster.r, Math.min(mapState.height - caster.r, moved.y));
      caster.target.x = caster.x;
      caster.target.y = caster.y;
      caster.navGoal = null;
      caster.nav = null;
      caster.chaseTarget = null;
      cancelPlayerAttack(false);
      const flashScale = backstepSpeed > 0 ? Math.min(1.5, backstepSpeed / 1400) : 1;
      flash(startX, startY, { startRadius: 10, endRadius: 32 * flashScale, color: '#7fe3ff' });
      flash(caster.x, caster.y, { startRadius: 10, endRadius: 32 * flashScale, color: '#9ff5ff' });
    }

    const origin = getSpellOrigin(caster);
    const projectile = spawnFlipbladeProjectile({
      abilityId: cast.abilityId,
      abilityName,
      slotIndex: cast.slotIndex,
      casterRef: caster,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      speed: cast.projectileSpeed,
      range: cast.projectileRange,
      width: cast.projectileWidth,
      damage: cast.damage,
      markDamage: cast.recastDamage,
      markDuration: cast.markDuration,
      recastSpeed: cast.recastSpeed,
      cooldownSeconds: cast.cooldownSeconds
    });

    if(projectile){
      if(caster === player){
        setHudMessage(`${abilityName} flipped a blade!`);
      }
      return true;
    }

    applyFlipbladeCooldown(cast.slotIndex, cast.cooldownSeconds);
    if(caster === player){
      setHudMessage(`${abilityName} fizzled.`);
    }
    return false;
  }

  function startFlipbladeRecast(mark, ability, slotIndex, abilityName){
    if(!mark) return false;
    const caster = mark.casterRef || player;
    const targetAlive = mark.targetRef && mark.targetRef.hp > 0 && mark.targetRef.portalizing <= 0;
    const destX = targetAlive ? mark.targetRef.x : mark.lastKnownX;
    const destY = targetAlive ? mark.targetRef.y : mark.lastKnownY;
    const dashSpeed = Math.max(0, Number(abilityFieldValue(ability, 'recastDashSpeedPxS')) || Number(mark.recastSpeed) || 0);
    if(!(dashSpeed > 0)){
      if(caster === player){
        setHudMessage(`${abilityName} needs a recast dash speed.`);
      }
      return false;
    }

    const dash = {
      abilityId: mark.abilityId,
      abilityName: abilityName || mark.abilityName || 'Flipblade Pursuit',
      slotIndex: Number.isFinite(mark.slotIndex) ? mark.slotIndex : slotIndex,
      casterRef: caster,
      targetRef: targetAlive ? mark.targetRef : null,
      targetX: destX,
      targetY: destY,
      speed: dashSpeed,
      damage: Math.max(0, Number(mark.recastDamage) || 0)
    };

    flipbladeDashes.push(dash);
    removeFlipbladeMark(mark);
    applyFlipbladeCooldown(dash.slotIndex, Number.isFinite(mark.cooldownSeconds) ? mark.cooldownSeconds : abilityCooldownSeconds(ability));
    if(caster === player){
      cancelPlayerAttack(false);
      caster.chaseTarget = null;
      caster.navGoal = null;
      caster.nav = null;
      player.casting = dash;
      setHudMessage(`${dash.abilityName} recast!`);
    }
    return true;
  }

  function castFlipbladePursuitAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Flipblade';
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const existingMark = findExistingFlipbladeMark(player, ability.id);
    if(existingMark){
      return startFlipbladeRecast(existingMark, ability, slotIndex, abilityName) ? { success: true, deferCooldown: true } : false;
    }
    const hasActiveCast = flipbladeCasts.some(c => c && c.casterRef === player && c.abilityId === ability.id);
    const hasActiveProjectile = flipbladeProjectiles.some(p => p && p.casterRef === player && p.abilityId === ability.id);
    const hasActiveDash = flipbladeDashes.some(d => d && d.casterRef === player && d.abilityId === ability.id);
    if(hasActiveCast || hasActiveProjectile || hasActiveDash){
      setHudMessage(`${abilityName} is already in motion.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const backstepDistance = Math.max(0, Number(abilityFieldValue(ability, 'backstepDistancePx')) || 0);
    const backstepSpeed = Math.max(0, Number(abilityFieldValue(ability, 'backstepSpeedPxS')) || 0);
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const recastDamage = Math.max(0, Number(abilityFieldValue(ability, 'impactDamage')) || 0);
    const markDuration = Math.max(0, Number(abilityFieldValue(ability, 'markDurationMs')) || 0) / 1000;
    const recastSpeed = Math.max(0, Number(abilityFieldValue(ability, 'recastDashSpeedPxS')) || 0);

    if(!(projectileRange > 0)){
      setHudMessage(`${abilityName} needs a blade range configured.`);
      return false;
    }
    if(!(projectileSpeed > 0)){
      setHudMessage(`${abilityName} needs a blade speed configured.`);
      return false;
    }
    if(!(projectileWidth > 0)){
      setHudMessage(`${abilityName} needs a blade width configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      castDuration: castTime,
      elapsed: 0,
      dirX,
      dirY,
      backstepDistance,
      backstepSpeed,
      projectileRange,
      projectileSpeed,
      projectileWidth,
      damage,
      recastDamage,
      markDuration,
      recastSpeed
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      const launched = launchFlipbladeCast(cast);
      return launched ? { success: true, deferCooldown: true } : false;
    }

    flipbladeCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} preparing...`);
    return { success: true, deferCooldown: true };
  }

  function findBoltburstTargets(x, y, maxTargets, maxRange){
    const desiredCount = Math.max(1, Math.round(Number(maxTargets) || 0));
    const maxRangeValue = Math.max(0, Number(maxRange) || 0);
    const maxRangeSq = maxRangeValue > 0 ? maxRangeValue * maxRangeValue : Infinity;
    const candidates = [];
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      const distSq = dx * dx + dy * dy;
      if(distSq > maxRangeSq) continue;
      candidates.push({ target: m, distSq });
    }
    candidates.sort((a, b) => a.distSq - b.distSq);
    const picks = [];
    for(const entry of candidates){
      if(picks.length >= desiredCount) break;
      const t = entry.target;
      if(!t) continue;
      if(!pointInVision(t.x, t.y, minionRadius)) continue;
      picks.push(t);
    }
    return picks;
  }

  function completeBoltburstRush(state, reason){
    if(!state || state.completed) return;
    state.completed = true;
    if(Number.isFinite(state.slotIndex)){
      const cd = Math.max(0, Number(state.cooldownSeconds) || 0);
      setAbilitySlotCooldown(state.slotIndex, cd);
    }
    if(state.casterRef === player){
      const reasonText = reason === 'expired' ? 'recast window ended' : 'all charges spent';
      setHudMessage(`${state.abilityName || 'Boltburst'} ${reasonText}.`);
    }
    const idx = boltburstRushCasts.indexOf(state);
    if(idx !== -1){
      boltburstRushCasts.splice(idx, 1);
    }
  }

  function castBoltburstRushAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Boltburst';
    let state = boltburstRushCasts.find(cast => cast && !cast.completed && cast.casterRef === player && cast.abilityId === ability.id);

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const dashDistanceRaw = abilityFieldValue(ability, 'dashDistancePx');
    const dashDistance = Math.max(0, Number(dashDistanceRaw) || 0);
    const boltRangeRaw = abilityFieldValue(ability, 'boltSeekRadiusPx');
    const boltSeekRadius = Math.max(0, Number(boltRangeRaw) || 0);
    const boltSpeedRaw = abilityFieldValue(ability, 'boltSpeedPxS');
    const boltSpeed = Math.max(0, Number(boltSpeedRaw) || 0);
    const boltDamageRaw = abilityFieldValue(ability, 'damage');
    const boltDamage = Math.max(0, Number(boltDamageRaw) || 0);
    const boltCountRaw = abilityFieldValue(ability, 'boltCount');
    const boltCount = Math.max(1, Math.round(Number.isFinite(boltCountRaw) ? boltCountRaw : 3));
    const recastWindowMs = abilityFieldValue(ability, 'recastWindowMs');
    const recastWindow = Math.max(0, Number(recastWindowMs) || 0) / 1000;
    const lockoutMs = abilityFieldValue(ability, 'recastLockoutMs');
    const recastLockout = Math.max(0, Number(lockoutMs) || 0) / 1000;
    const maxDashesRaw = abilityFieldValue(ability, 'maxDashes');
    const configuredDashes = Math.max(1, Math.round(Number.isFinite(maxDashesRaw) ? maxDashesRaw : 3));
    const allowRecasts = recastWindow > 0 && configuredDashes > 1;
    const totalDashes = allowRecasts ? configuredDashes : 1;

    if(!state){
      if(!(dashDistance > 0)){
        setHudMessage(`${abilityName} needs a dash distance.`);
        return false;
      }
      state = {
        abilityId: ability.id,
        abilityName,
        slotIndex,
        casterRef: player,
        cooldownSeconds,
        dashDistance,
        boltSeekRadius,
        boltSpeed,
        boltDamage,
        boltCount,
        totalDashes,
        remainingDashes: totalDashes,
        recastWindow: allowRecasts ? recastWindow : 0,
        recastRemaining: allowRecasts ? recastWindow : 0,
        recastLockout,
        lockoutRemaining: 0,
        completed: false
      };
      boltburstRushCasts.push(state);
    }

    if(state.completed){
      return false;
    }
    if(state.recastWindow > 0 && state.recastRemaining <= 0){
      completeBoltburstRush(state, 'expired');
      return false;
    }
    if(Number.isFinite(state.lockoutRemaining) && state.lockoutRemaining > 0){
      const timeText = state.lockoutRemaining >= 1 ? state.lockoutRemaining.toFixed(1) : state.lockoutRemaining.toFixed(2);
      setHudMessage(`${abilityName} is recharging (${timeText}s).`);
      return false;
    }
    if(!(Number(state.remainingDashes) > 0)){
      completeBoltburstRush(state, 'complete');
      return false;
    }

    const dashRange = Math.max(0, Number(state.dashDistance) || dashDistance);
    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    let dirX = 1;
    let dirY = 0;
    const hasAim = distance > 0.0001;
    if(hasAim){
      dirX = dx / distance;
      dirY = dy / distance;
    }
    const desiredDistance = dashRange > 0 ? (hasAim ? Math.min(dashRange, distance) : dashRange) : 0;
    const moveX = dirX * desiredDistance;
    const moveY = dirY * desiredDistance;
    const moved = moveCircleWithCollision(startX, startY, moveX, moveY, player.r);
    let destX = moved.x;
    let destY = moved.y;
    destX = Math.max(player.r, Math.min(mapState.width - player.r, destX));
    destY = Math.max(player.r, Math.min(mapState.height - player.r, destY));

    if(destX !== player.x || destY !== player.y){
      flash(startX, startY, { startRadius: 12, endRadius: 40, color: '#9be0ff' });
    }

    player.x = destX;
    player.y = destY;
    player.target.x = destX;
    player.target.y = destY;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    cancelPlayerAttack(false);

    flash(destX, destY, { startRadius: 12, endRadius: 44, color: '#c4f0ff' });

    const targets = findBoltburstTargets(destX, destY, state.boltCount, state.boltSeekRadius);
    if(targets.length){
      for(const target of targets){
        spawnBlinkingBoltProjectile(destX, destY, target, state.boltDamage, abilityName, player, state.boltSpeed);
      }
      setHudMessage(`${abilityName} fired ${targets.length} bolt${targets.length === 1 ? '' : 's'}.`);
    } else {
      setHudMessage(`${abilityName} dashed but found no targets.`);
    }

    state.remainingDashes = Math.max(0, (Number(state.remainingDashes) || 0) - 1);
    state.lockoutRemaining = Math.max(0, state.recastLockout || 0);
    if(state.remainingDashes <= 0 || state.recastWindow <= 0){
      completeBoltburstRush(state, 'complete');
    } else {
      const timeText = state.recastRemaining >= 10 ? Math.round(state.recastRemaining) : state.recastRemaining.toFixed(1);
      const chargeText = `${state.remainingDashes} dash${state.remainingDashes === 1 ? '' : 'es'} left`;
      setHudMessage(`${abilityName} ready: ${chargeText} (${timeText}s window).`);
    }

    return { success: true, deferCooldown: true };
  }

  function isValidSkullRushTarget(target){
    if(!target) return false;
    const practiceTarget = target.isPracticeDummy === true;
    if(!practiceTarget && !isEnemyMinionForPlayer(target)) return false;
    if(target.hp <= 0 || target.portalizing > 0) return false;
    return true;
  }

  function pickSkullRushTarget(originX, originY, aimPoint, maxRange){
    const maxRangeValue = Math.max(0, Number(maxRange) || 0);
    if(!(maxRangeValue > 0)) return null;
    const aimX = aimPoint && Number.isFinite(aimPoint.x) ? aimPoint.x : originX;
    const aimY = aimPoint && Number.isFinite(aimPoint.y) ? aimPoint.y : originY;
    let best = null;
    let bestScore = Infinity;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const reach = maxRangeValue + targetRadius;
      const dx = m.x - originX;
      const dy = m.y - originY;
      const distSq = dx * dx + dy * dy;
      if(distSq > reach * reach) continue;
      const aimDx = m.x - aimX;
      const aimDy = m.y - aimY;
      const aimDistSq = aimDx * aimDx + aimDy * aimDy;
      const score = aimDistSq + distSq * 0.15;
      if(score < bestScore){
        bestScore = score;
        best = { target: m, targetRadius, distToPlayer: Math.sqrt(distSq) };
      }
    }
    return best;
  }

  function executeSkullRush(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    if(!caster) return false;
    const abilityName = cast.abilityName || 'Skull Rush';
    const dashRange = Math.max(0, Number(cast.dashRange) || 0);
    const impactRadius = Math.max(0, Number(cast.impactRadius) || 0);
    const knockback = Math.max(0, Number(cast.knockbackDistance) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const stunDuration = Math.max(0, Number(cast.stunDuration) || 0);

    let targetInfo = null;
    const aimPoint = {
      x: Number.isFinite(cast.aimX) ? cast.aimX : (caster.target && Number.isFinite(caster.target.x) ? caster.target.x : caster.x + (cast.dirX || 1)),
      y: Number.isFinite(cast.aimY) ? cast.aimY : (caster.target && Number.isFinite(caster.target.y) ? caster.target.y : caster.y + (cast.dirY || 0))
    };

    if(isValidSkullRushTarget(cast.targetRef)){
      const targetRadius = cast.targetRadius || (cast.targetRef.isPracticeDummy === true ? Math.max(minionRadius, Number(cast.targetRef.radius) || minionRadius) : minionRadius);
      const reach = dashRange + targetRadius;
      const dx = cast.targetRef.x - caster.x;
      const dy = cast.targetRef.y - caster.y;
      const distSq = dx * dx + dy * dy;
      if(reach <= 0 || distSq <= reach * reach){
        targetInfo = { target: cast.targetRef, targetRadius };
      }
    }
    if(!targetInfo){
      targetInfo = pickSkullRushTarget(caster.x, caster.y, aimPoint, dashRange);
    }
    if(!targetInfo || !targetInfo.target){
      if(caster === player && player.casting === cast){
        player.casting = null;
      }
      if(caster === player){
        setHudMessage(`${abilityName} needs an enemy within range.`);
      }
      return false;
    }

    const target = targetInfo.target;
    const targetRadius = targetInfo.targetRadius || minionRadius;
    const startX = caster.x;
    const startY = caster.y;
    const dxToTarget = target.x - startX;
    const dyToTarget = target.y - startY;
    const distanceToTarget = Math.hypot(dxToTarget, dyToTarget);
    const dirX = distanceToTarget > 0.0001 ? dxToTarget / distanceToTarget : (Number.isFinite(cast.dirX) ? cast.dirX : 1);
    const dirY = distanceToTarget > 0.0001 ? dyToTarget / distanceToTarget : (Number.isFinite(cast.dirY) ? cast.dirY : 0);
    const desiredDistance = dashRange > 0 ? Math.min(dashRange, distanceToTarget || dashRange) : distanceToTarget;
    const casterRadius = caster.r || player.r;
    const moved = moveCircleWithCollision(startX, startY, dirX * desiredDistance, dirY * desiredDistance, casterRadius);
    let destX = moved.x;
    let destY = moved.y;
    destX = Math.max(casterRadius, Math.min(mapState.width - casterRadius, destX));
    destY = Math.max(casterRadius, Math.min(mapState.height - casterRadius, destY));

    if(caster === player){
      player.x = destX;
      player.y = destY;
      player.target.x = destX;
      player.target.y = destY;
      player.navGoal = null;
      player.nav = null;
      player.chaseTarget = null;
    } else {
      caster.x = destX;
      caster.y = destY;
      caster.target = { x: destX, y: destY };
    }
    cancelPlayerAttack(false);

    flash(startX, startY, { startRadius: 12, endRadius: 34, color: '#f6c172' });
    flash(destX, destY, { startRadius: 14, endRadius: Math.max(impactRadius, 48), color: '#ffd799' });

    const hitDx = target.x - destX;
    const hitDy = target.y - destY;
    const distanceAfter = Math.hypot(hitDx, hitDy);
    const effectiveImpact = impactRadius > 0 ? impactRadius : (casterRadius + targetRadius);
    const withinImpact = distanceAfter <= effectiveImpact + targetRadius * 0.25;
    let hit = false;
    if(withinImpact){
      const prevHp = Number(target.hp) || 0;
      if(damage > 0){
        target.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(target.x, target.y - targetRadius, damage);
      }
      const pushDirX = distanceAfter > 0.0001 ? hitDx / distanceAfter : dirX;
      const pushDirY = distanceAfter > 0.0001 ? hitDy / distanceAfter : dirY;
      if(knockback > 0){
        const pushed = moveCircleWithCollision(target.x, target.y, pushDirX * knockback, pushDirY * knockback, targetRadius);
        target.x = Math.max(targetRadius, Math.min(mapState.width - targetRadius, pushed.x));
        target.y = Math.max(targetRadius, Math.min(mapState.height - targetRadius, pushed.y));
      }
      if(stunDuration > 0){
        const existingStun = typeof target.stunTimer === 'number' ? target.stunTimer : 0;
        target.stunTimer = Math.max(existingStun, stunDuration);
      }
      handlePracticeDummyDamage(target, prevHp);
      if(prevHp > 0 && target.hp <= 0){
        flash(target.x, target.y, { color: '#ff9c9c' });
      }
      hit = true;
    }

    if(caster === player && player.casting === cast){
      player.casting = null;
    }
    if(caster === player){
      if(hit){
        const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
        setHudMessage(`${abilityName} connected${dmgText}.`);
        player.selectedTarget = target;
      } else {
        setHudMessage(`${abilityName} dashed but missed.`);
      }
    }
    return true;
  }

  function executeRiptideLunge(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    if(!caster) return false;
    const abilityName = cast.abilityName || 'Riptide Lunge';
    const dashRange = Math.max(0, Number(cast.dashRange) || 0);
    const impactRadius = Math.max(0, Number(cast.impactRadius) || 0);
    const splashRadius = Math.max(0, Number(cast.splashRadius) || impactRadius);
    const baseDamage = Math.max(0, Number(cast.baseDamage) || 0);
    const adPercent = Math.max(0, Number(cast.adPercent) || 0);
    const onHitDamage = Math.max(0, Number(cast.onHitDamage) || 0);
    const target = cast.targetRef;
    const targetRadius = Math.max(minionRadius, Number(cast.targetRadius) || minionRadius);
    const dirX = Number(cast.dirX) || 1;
    const dirY = Number(cast.dirY) || 0;
    const startX = Number.isFinite(cast.startX) ? cast.startX : caster.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : caster.y;
    const distanceToTarget = target && Number.isFinite(target.x) && Number.isFinite(target.y)
      ? Math.hypot(target.x - startX, target.y - startY)
      : dashRange || 0;
    const desiredDistance = dashRange > 0
      ? Math.min(dashRange, distanceToTarget > 0 ? distanceToTarget : dashRange)
      : distanceToTarget;
    const casterRadius = caster.r || player.r;
    const moved = moveCircleWithCollision(startX, startY, dirX * desiredDistance, dirY * desiredDistance, casterRadius);
    let destX = moved.x;
    let destY = moved.y;
    destX = Math.max(casterRadius, Math.min(mapState.width - casterRadius, destX));
    destY = Math.max(casterRadius, Math.min(mapState.height - casterRadius, destY));

    if(caster === player){
      player.x = destX;
      player.y = destY;
      player.target.x = destX;
      player.target.y = destY;
      player.navGoal = null;
      player.nav = null;
      player.chaseTarget = null;
      cancelPlayerAttack(false);
    } else {
      caster.x = destX;
      caster.y = destY;
      caster.target = { x: destX, y: destY };
    }

    flash(startX, startY, { startRadius: 14, endRadius: 36, color: '#6de0ff' });
    flash(destX, destY, { startRadius: 18, endRadius: Math.max(impactRadius, 48), color: '#8bf3ff' });

    let hit = false;
    let hitDamage = 0;
    if(target && target.hp > 0){
      const hitDx = target.x - destX;
      const hitDy = target.y - destY;
      const distanceAfter = Math.hypot(hitDx, hitDy);
      const effectiveImpact = impactRadius > 0 ? impactRadius : (casterRadius + targetRadius);
      const withinImpact = distanceAfter <= effectiveImpact + targetRadius * 0.25;
      if(withinImpact){
        const totalAttackDamage = Math.max(0, Number(caster.attackDamage) || 0);
        const damageFromAd = totalAttackDamage * (adPercent / 100);
        const totalDamage = baseDamage + damageFromAd;
        const prevHp = Math.max(0, Number(target.hp) || 0);
        if(totalDamage > 0){
          hitDamage = applyAbilityDamage(target, totalDamage);
        }
        if(onHitDamage > 0 && splashRadius > 0){
          damageEnemiesInRadius(target.x, target.y, splashRadius, onHitDamage);
        }
        handlePracticeDummyDamage(target, prevHp);
        if(prevHp > 0 && target.hp <= 0){
          flash(target.x, target.y, { color: '#9cffff' });
        }
        hit = true;
      }
    }

    if(caster === player && player.casting === cast){
      player.casting = null;
    }
    if(caster === player){
      if(hit){
        const dmgText = hitDamage > 0 ? ` for ${Math.round(hitDamage)} damage` : '';
        setHudMessage(`${abilityName} connected${dmgText}.`);
        player.selectedTarget = target;
      } else {
        setHudMessage(`${abilityName} dashed but missed.`);
      }
    }
    return true;
  }

  function castSkullRushAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Skull Rush';
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const dashRange = Math.max(0, Number(abilityFieldValue(ability, 'dashDistancePx')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const knockback = Math.max(0, Number(abilityFieldValue(ability, 'knockbackDistancePx')) || 0);
    const stunDuration = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;

    if(!(dashRange > 0)){
      setHudMessage(`${abilityName} needs a dash range.`);
      return false;
    }
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    const pick = pickSkullRushTarget(origin.x, origin.y, aimPoint, dashRange);
    if(!pick){
      setHudMessage(`${abilityName} needs an enemy within range.`);
      return false;
    }

    const dirX = pick.distToPlayer > 0.0001 ? (pick.target.x - origin.x) / pick.distToPlayer : 1;
    const dirY = pick.distToPlayer > 0.0001 ? (pick.target.y - origin.y) / pick.distToPlayer : 0;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      dashRange,
      impactRadius,
      damage,
      knockbackDistance: knockback,
      stunDuration,
      castDuration: castTime,
      elapsed: 0,
      targetRef: pick.target,
      targetRadius: pick.targetRadius,
      aimX: aimPoint.x,
      aimY: aimPoint.y,
      dirX,
      dirY,
      startX: origin.x,
      startY: origin.y,
      allowMovementWhileCasting: true
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      return executeSkullRush(cast);
    }

    skullRushCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} bracing...`);
    return true;
  }

  function castRiptideLungeAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Riptide Lunge';
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const dashRange = Math.max(0, Number(abilityFieldValue(ability, 'dashDistancePx')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const splashRadius = Math.max(0, Number(abilityFieldValue(ability, 'splashRadius')) || 0);
    const baseDamage = Math.max(0, Number(abilityFieldValue(ability, 'baseDamage')) || 0);
    const onHitDamage = Math.max(0, Number(abilityFieldValue(ability, 'onHitDamage')) || 0);
    const adPercent = Math.max(0, Number(abilityFieldValue(ability, 'adPercent')) || 0);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;

    if(!(dashRange > 0)){
      setHudMessage(`${abilityName} needs a dash range.`);
      return false;
    }
    if(!(baseDamage > 0 || adPercent > 0 || onHitDamage > 0)){
      setHudMessage(`${abilityName} needs some damage configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    const pick = pickSkullRushTarget(origin.x, origin.y, aimPoint, dashRange);
    if(!pick){
      setHudMessage(`${abilityName} needs an enemy within range.`);
      return false;
    }

    const dirX = pick.distToPlayer > 0.0001 ? (pick.target.x - origin.x) / pick.distToPlayer : 1;
    const dirY = pick.distToPlayer > 0.0001 ? (pick.target.y - origin.y) / pick.distToPlayer : 0;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      dashRange,
      impactRadius,
      splashRadius,
      baseDamage,
      onHitDamage,
      adPercent,
      castDuration: castTime,
      elapsed: 0,
      targetRef: pick.target,
      targetRadius: pick.targetRadius,
      dirX,
      dirY,
      startX: origin.x,
      startY: origin.y,
      allowMovementWhileCasting: true
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      return executeRiptideLunge(cast);
    }

    riptideLungeCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} charging...`);
    return true;
  }

  function applyShatterburstImpact(centerX, centerY, radius, damage, slowFraction, slowDuration, stunDuration){
    const safeRadius = Math.max(0, Number(radius) || 0);
    const safeDamage = Math.max(0, Number(damage) || 0);
    const slowFrac = Math.max(0, Math.min(1, Number(slowFraction) || 0));
    const slowSeconds = Math.max(0, Number(slowDuration) || 0);
    const stunSeconds = Math.max(0, Number(stunDuration) || 0);
    if(!(safeRadius > 0)) return 0;

    let hits = 0;

    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      const effective = safeRadius + targetRadius;
      if(dx * dx + dy * dy > effective * effective) continue;
      const prevHp = Number(m.hp) || 0;
      if(safeDamage > 0){
        m.hp = Math.max(0, prevHp - safeDamage);
        spawnHitSplat(m.x, m.y - targetRadius, safeDamage);
      }
      if(slowFrac > 0 && slowSeconds > 0){
        const existingSlow = Number(m.slowPct) || 0;
        m.slowPct = Math.max(existingSlow, slowFrac);
        m.slowTimer = Math.max(Number(m.slowTimer) || 0, slowSeconds);
      }
      if(stunSeconds > 0){
        m.stunTimer = Math.max(Number(m.stunTimer) || 0, stunSeconds);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }

    const monster = monsterState;
    if(monster && isMonsterAttackable(monster)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      const effective = safeRadius + monsterRadius;
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      if(dx * dx + dy * dy <= effective * effective){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        if(safeDamage > 0){
          monster.hp = Math.max(0, prevHp - safeDamage);
          spawnHitSplat(monster.x, monster.y - monsterRadius, safeDamage);
          updateMonsterHud();
        }
        hits += 1;
      }
    }

    return hits;
  }

  function castShatterburstOrbAbility(slotIndex, ability){
    const existing = shatterburstOrbProjectiles.find(p => p && p.casterRef === player && p.abilityId === ability.id);
    if(existing){
      const detonated = detonateShatterburstOrb(existing, { cause: 'recast', announce: true });
      return detonated ? { success: true, deferCooldown: true } : false;
    }

    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Shatterburst';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const impactDamage = Math.max(0, Number(abilityFieldValue(ability, 'impactDamage')) || 0);
    const slowFraction = Math.max(0, Math.min(1, (Number(abilityFieldValue(ability, 'slowPct')) || 0) / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const stunDuration = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);

    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a travel range configured.`);
      return false;
    }
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs an orb width configured.`);
      return false;
    }
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a travel speed configured.`);
      return false;
    }
    if(!(impactRadius > 0)){
      setHudMessage(`${abilityName} needs a shatter radius configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aim = typeof skillshotAimPoint === 'function' ? skillshotAimPoint() : beamAimPoint();
    let dx = aim.x - origin.x;
    let dy = aim.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(distance > range){
      const scale = range > 0 ? range / distance : 1;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const padding = impactRadius + minionRadius;
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      targetX = Math.max(padding, Math.min(mapState.width - padding, targetX));
      targetY = Math.max(padding, Math.min(mapState.height - padding, targetY));
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      range,
      width,
      speed,
      damage,
      impactRadius,
      impactDamage,
      slowFraction,
      slowDuration,
      stunDuration,
      castDuration: castTime,
      cooldownSeconds,
      elapsed: 0,
      originX: origin.x,
      originY: origin.y,
      targetX,
      targetY,
      lockedDirX: dx / distance,
      lockedDirY: dy / distance
    };

    if(cast.castDuration <= 0){
      return launchShatterburstOrb(cast, ability);
    }

    shatterburstOrbCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} gathering frost...`);
    return true;
  }

  function launchShatterburstOrb(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const abilityName = cast.abilityName || 'Shatterburst';
    let dirX = Number(cast.lockedDirX) || 0;
    let dirY = Number(cast.lockedDirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
    } else {
      dirX /= dirLen;
      dirY /= dirLen;
    }
    const range = Math.max(0, Number(cast.range) || 0);
    const width = Math.max(0, Number(cast.width) || 0);
    const speed = Math.max(0, Number(cast.speed) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(cast.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(cast.slowDuration) || 0);
    const impactRadius = Math.max(0, Number(cast.impactRadius) || 0);
    const impactDamage = Math.max(0, Number(cast.impactDamage) || 0);
    const stunDuration = Math.max(0, Number(cast.stunDuration) || 0);
    if(!(range > 0) || !(width > 0) || !(speed > 0)){
      if(caster === player && player.casting === cast){
        player.casting = null;
      }
      if(caster === player){
        setHudMessage(`${abilityName} fizzled.`);
      }
      return false;
    }

    const origin = getSpellOrigin(caster);
    const projectile = {
      abilityId: cast.abilityId,
      abilityName,
      casterRef: caster,
      startX: origin.x,
      startY: origin.y,
      currentX: origin.x,
      currentY: origin.y,
      dirX,
      dirY,
      range,
      width,
      speed,
      damage,
      slowFraction,
      slowDuration,
      impactRadius,
      impactDamage,
      stunDuration,
      traveled: 0,
      slotIndex: cast.slotIndex,
      cooldownSeconds: cast.cooldownSeconds,
      hitPass: new Set()
    };

    shatterburstOrbProjectiles.push(projectile);
    flash(origin.x, origin.y, { startRadius: 10, endRadius: 30, color: '#c6e8ff' });
    if(caster === player && player.casting === cast){
      player.casting = null;
    }
    if(caster === player){
      setHudMessage(`${abilityName} launched - recast to shatter!`);
    }
    return { success: true, deferCooldown: true };
  }

  function applyShatterburstPassHit(proj, hit){
    if(!proj || !hit || !hit.target) return false;
    const target = hit.target;
    const targetRadius = Math.max(minionRadius, Number(hit.targetRadius) || minionRadius);
    const prevHp = Number(target.hp) || 0;
    if(proj.damage > 0){
      target.hp = Math.max(0, prevHp - proj.damage);
      spawnHitSplat(target.x, target.y - targetRadius, proj.damage);
    }
    if(proj.slowFraction > 0 && proj.slowDuration > 0){
      const existing = Number(target.slowPct) || 0;
      target.slowPct = Math.max(existing, proj.slowFraction);
      target.slowTimer = Math.max(Number(target.slowTimer) || 0, proj.slowDuration);
    }
    handlePracticeDummyDamage(target, prevHp);
    const owner = proj.casterRef || (proj.castRef ? proj.castRef.casterRef : null);
    if(owner === player && prevHp > 0 && target.hp <= 0){
      flash(target.x, target.y, { startRadius: 8, endRadius: 18, color: '#dff3ff' });
    }
    return true;
  }

  function detonateShatterburstOrb(proj, { cause = 'recast', announce = false } = {}){
    if(!proj || proj.removed) return false;
    proj.removed = true;
    const x = Number.isFinite(proj.currentX) ? proj.currentX : proj.startX;
    const y = Number.isFinite(proj.currentY) ? proj.currentY : proj.startY;
    const hits = applyShatterburstImpact(x, y, proj.impactRadius, proj.impactDamage, proj.slowFraction, proj.slowDuration, proj.stunDuration);
    const startRadius = Math.max(12, (Number(proj.impactRadius) || 0) * 0.5);
    const endRadius = Math.max(Number(proj.impactRadius) || 0, startRadius + 24);
    flash(x, y, { startRadius, endRadius, color: '#b6e3ff' });
    const idx = shatterburstOrbProjectiles.indexOf(proj);
    if(idx >= 0){
      shatterburstOrbProjectiles.splice(idx, 1);
    }
    if(proj.casterRef === player && announce){
      const hitText = hits > 0 ? `${hits} target${hits === 1 ? '' : 's'}` : 'nothing';
      const causeText = cause === 'maxRange' ? ' at max range' : '';
      setHudMessage(`${proj.abilityName || 'Shatterburst'} shattered${causeText} hitting ${hitText}.`);
    }
    if(Number.isFinite(proj.slotIndex) && Number.isFinite(proj.cooldownSeconds)){
      setAbilitySlotCooldown(proj.slotIndex, Math.max(0, Number(proj.cooldownSeconds) || 0));
    }
    return true;
  }

  function castReboundOrbAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Rebound Orb';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const speedOut = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const speedReturnRaw = abilityFieldValue(ability, 'returnSpeedPxS');
    const speedReturn = Math.max(0, Number.isFinite(speedReturnRaw) ? speedReturnRaw : speedOut);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;

    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a travel range.`);
      return false;
    }
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width configured.`);
      return false;
    }
    if(!(speedOut > 0)){
      setHudMessage(`${abilityName} needs an outbound speed.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      range,
      width,
      speedOut,
      speedReturn: speedReturn > 0 ? speedReturn : speedOut,
      damage,
      castDuration: castTime,
      elapsed: 0,
      originX: origin.x,
      originY: origin.y,
      targetX: aimPoint.x,
      targetY: aimPoint.y,
      lockedDirX: dirX,
      lockedDirY: dirY
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      return launchReboundOrb(cast);
    }

    reboundOrbCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} winding up...`);
    return true;
  }

  function launchReboundOrb(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    let dirX = Number(cast.lockedDirX);
    let dirY = Number(cast.lockedDirY);
    const len = Math.hypot(dirX, dirY);
    if(len > 0.0001){
      dirX /= len;
      dirY /= len;
    } else {
      dirX = 1;
      dirY = 0;
    }
    const range = Math.max(0, Number(cast.range) || 0);
    const width = Math.max(0, Number(cast.width) || 0);
    const speedOut = Math.max(0, Number(cast.speedOut) || 0);
    const speedReturn = Math.max(0, Number(cast.speedReturn) || 0) || speedOut;
    const damage = Math.max(0, Number(cast.damage) || 0);
    if(!(range > 0) || !(speedOut > 0)){
      if(caster === player && player.casting === cast){
        player.casting = null;
      }
      setHudMessage(`${cast.abilityName || 'Rebound Orb'} fizzled.`);
      return false;
    }

    const orb = {
      abilityId: cast.abilityId,
      abilityName: cast.abilityName || 'Rebound Orb',
      casterRef: caster,
      state: 'outbound',
      startX: origin.x,
      startY: origin.y,
      currentX: origin.x,
      currentY: origin.y,
      dirX,
      dirY,
      range,
      width,
      speedOut,
      speedReturn,
      damage,
      traveled: 0,
      hitOutbound: new Set(),
      hitReturn: new Set()
    };

    reboundOrbProjectiles.push(orb);
    flash(origin.x, origin.y, { startRadius: 10, endRadius: 32, color: '#a8e4ff' });
    if(caster === player && player.casting === cast){
      player.casting = null;
    }
    setHudMessage(`${orb.abilityName} launched!`);
    return true;
  }

  function castCycloneAxesAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Cyclone Axes';
    const active = cycloneCasts.find(cast => cast && cast.casterRef === player && !cast.completed);
    if(active){
      if(!active.launched){
        setHudMessage(`${abilityName} is still winding up.`);
        return false;
      }
      if(active.state !== 'returning' && active.recastAvailable){
        beginCycloneAxesReturn(active, { reason: 'manual', announce: true });
        return { success: true, deferCooldown: true };
      }
      setHudMessage(`${abilityName} axes are already returning.`);
      return false;
    }
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const recastDelay = Math.max(0, Number(abilityFieldValue(ability, 'recastDelayMs')) || 0) / 1000;
    const cast = {
      id: `cyclone-${abilityRuntime.cycloneAxesSequence++}`,
      abilityId: ability && ability.id ? ability.id : 'cyclone_axes',
      abilityRef: ability,
      abilityName,
      slotIndex,
      casterRef: player,
      castDuration: castTime,
      elapsed: 0,
      cooldownSeconds,
      recastDelay,
      recastTimer: 0,
      recastAvailable: recastDelay <= 0,
      launched: false,
      completed: false,
      state: 'windup',
      returning: false
    };
    cycloneCasts.push(cast);
    if(castTime <= 0){
      const launched = launchCycloneAxes(cast);
      if(!launched){
        finishCycloneAxesCast(cast, { reason: 'fizzled' });
        return false;
      }
      return { success: true, deferCooldown: true };
    }
    player.casting = cast;
    setHudMessage(`${abilityName} winding up...`);
    return { success: true, deferCooldown: true };
  }

  function launchCycloneAxes(cast){
    if(!cast) return false;
    const ability = cast.abilityRef;
    if(!ability) return false;
    const abilityName = cast.abilityName || 'Cyclone Axes';
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const speedOut = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const returnSpeed = Math.max(0, Number(abilityFieldValue(ability, 'returnSpeedPxS')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const returnDamagePct = Math.max(0, Math.min(200, Number(abilityFieldValue(ability, 'returnDamagePct')) || 100)) / 100;
    if(!(width > 0) || !(speedOut > 0)){
      if(cast.casterRef === player){
        setHudMessage(`${abilityName} needs speed and width configured.`);
      }
      return false;
    }
    const recastDelay = Math.max(0, Number(abilityFieldValue(ability, 'recastDelayMs')) || 0) / 1000;
    const rawRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const mapMax = Math.max(Number(mapState.width) || 0, Number(mapState.height) || 0);
    const fallbackRange = Math.max(1200, mapMax > 0 ? mapMax * 1.35 : 2000);
    const range = rawRange > 0 ? rawRange : fallbackRange;
    const finalReturnSpeed = returnSpeed > 0 ? returnSpeed : Math.max(0, speedOut * 0.75);
    const origin = getSpellOrigin(cast.casterRef || player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const baseAngle = Math.atan2(dy, dx);
    const angleOffset = Math.PI * 0.12;
    const angles = [baseAngle + angleOffset, baseAngle - angleOffset];
    const returnDamage = damage * returnDamagePct;
    const caster = cast.casterRef || player;
    for(let i = 0; i < angles.length; i++){
      const angle = angles[i];
      const dirX = Math.cos(angle);
      const dirY = Math.sin(angle);
      const axis = {
        id: `cyclone-axe-${cast.id}-${i + 1}`,
        castId: cast.id,
        abilityId: cast.abilityId,
        abilityName,
        casterRef: caster,
        state: 'outbound',
        width,
        speedOut,
        speedReturn: finalReturnSpeed,
        damage,
        returnDamage,
        range,
        traveled: 0,
        dirX,
        dirY,
        currentX: origin.x,
        currentY: origin.y,
        prevX: origin.x,
        prevY: origin.y,
        hitOutbound: new Set(),
        hitReturn: new Set()
      };
      cycloneAxes.push(axis);
    }
    cast.state = 'outbound';
    cast.launched = true;
    cast.returning = false;
    cast.recastDelay = recastDelay;
    cast.recastTimer = 0;
    cast.recastAvailable = recastDelay <= 0;
    cast.returnTriggered = false;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = origin.x;
    player.target.y = origin.y;
    player.navGoal = null;
    player.nav = null;
    if(player.casting === cast){
      player.casting = null;
    }
    setHudMessage(`${abilityName} axes launched! Recast to pull them back.`);
    return true;
  }

  function beginCycloneAxesReturn(cast, { reason = 'auto', announce = true } = {}){
    if(!cast || cast.completed) return;
    cast.state = 'returning';
    if(!cast.returning){
      cast.returning = true;
    }
    for(const axis of cycloneAxes){
      if(!axis || axis.castId !== cast.id) continue;
      if(axis.state === 'outbound'){
        axis.state = 'return';
      }
    }
    if(announce && cast.casterRef === player && !cast.returnTriggered){
      cast.returnTriggered = true;
      const suffix = reason === 'manual' ? ' early' : '';
      setHudMessage(`${cast.abilityName || 'Cyclone Axes'} axes returning${suffix}!`);
    }
  }

  function applyCycloneAxisHit(axis, hit, phase){
    if(!axis || !hit || !hit.target) return false;
    const target = hit.target;
    const damageValue = phase === 'return' ? Math.max(0, Number(axis.returnDamage) || 0) : Math.max(0, Number(axis.damage) || 0);
    const prevHp = Number(target.hp) || 0;
    if(damageValue > 0){
      target.hp = Math.max(0, prevHp - damageValue);
      const targetRadius = Number(hit.targetRadius) || minionRadius;
      spawnHitSplat(target.x, target.y - targetRadius, damageValue);
    }
    handlePracticeDummyDamage(target, prevHp);
    const flashColor = phase === 'return' ? '#ffd6b0' : '#bde7ff';
    flash(hit.hitX, hit.hitY, { startRadius: 10, endRadius: 28, color: flashColor });
    return true;
  }

  function finishCycloneAxesCast(cast, { reason = 'returned' } = {}){
    if(!cast || cast.completed) return;
    cast.completed = true;
    for(let i = cycloneAxes.length - 1; i >= 0; i--){
      const axis = cycloneAxes[i];
      if(!axis || axis.castId !== cast.id) continue;
      cycloneAxes.splice(i, 1);
    }
    const idx = cycloneCasts.indexOf(cast);
    if(idx >= 0){
      cycloneCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || abilityCooldownSeconds(cast.abilityRef));
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    if(cast.casterRef === player){
      if(reason === 'fizzled'){
        setHudMessage(`${cast.abilityName || 'Cyclone Axes'} fizzled.`);
      } else {
        setHudMessage(`${cast.abilityName || 'Cyclone Axes'} axes returned.`);
      }
    }
  }

  function applySnapbackHit(echo, target){
    if(!echo || !target) return false;
    if(!echo.hitTargets) echo.hitTargets = new Set();
    if(echo.hitTargets.has(target)) return false;
    const prevHp = Number(target.hp) || 0;
    if(echo.damage > 0){
      target.hp = Math.max(0, prevHp - echo.damage);
      spawnHitSplat(target.x, target.y - minionRadius, echo.damage);
    }
    if(echo.stunDuration > 0){
      const existing = typeof target.stunTimer === 'number' ? target.stunTimer : 0;
      target.stunTimer = Math.max(existing, echo.stunDuration);
    }
    handlePracticeDummyDamage(target, prevHp);
    echo.hitTargets.add(target);
    echo.hitCount = (echo.hitCount || 0) + 1;
    return true;
  }

  function applySnapbackSegmentHits(echo, startX, startY, endX, endY){
    if(!echo) return 0;
    const width = Math.max(0, Number(echo.width) || 0);
    const effectiveRadius = width * 0.5 + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    const segX = endX - startX;
    const segY = endY - startY;
    const segLenSq = segX * segX + segY * segY;
    if(!(segLenSq > 0.0001)) return 0;
    let hits = 0;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      if(echo.hitTargets && echo.hitTargets.has(m)) continue;
      const relX = m.x - startX;
      const relY = m.y - startY;
      const t = (relX * segX + relY * segY) / segLenSq;
      if(t < -0.1 || t > 1.1) continue;
      const clamped = Math.max(0, Math.min(1, t));
      const closestX = startX + segX * clamped;
      const closestY = startY + segY * clamped;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY <= effectiveSq){
        if(applySnapbackHit(echo, m)){
          hits++;
        }
      }
    }
    return hits;
  }

  const STORMWING_IMPACT_OFFSET = 32;
  const STORMWING_STAGE_LABEL = [null, 'first slash', 'second slash', 'final slash'];

  function castStormwingBarrageAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Stormwing Barrage';
    const existing = stormwingSequences.find(seq => seq && seq.casterRef === player && seq.state !== 'complete');
    if(existing){
      if(Number.isFinite(existing.recastRemaining) && existing.recastRemaining <= 0){
        finishStormwingSequence(existing, { message: `${abilityName} stance faded.` });
        return false;
      }
      if(existing.state === 'recast_locked'){
        const lockText = formatSeconds(Math.max(0, Number(existing.recastLockRemaining) || 0) * 1000);
        const readyText = lockText || 'a moment';
        setHudMessage(`${abilityName} ready in ${readyText}.`);
        return { success: true, deferCooldown: true };
      }
      if(existing.state === 'recast_ready'){
        const nextStage = Math.min(3, Math.max(0, Number(existing.currentStage) || 0) + 1);
        if(nextStage <= existing.currentStage){
          return false;
        }
        executeStormwingStage(existing, nextStage);
        return { success: true, deferCooldown: true };
      }
      return false;
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const dashDistance = Math.max(0, Number(abilityFieldValue(ability, 'dashDistancePx')) || 0);
    if(!(dashDistance > 0)){
      setHudMessage(`${abilityName} needs a dash distance configured.`);
      return false;
    }

    const stageData = [
      null,
      {
        damage: Math.max(0, Number(abilityFieldValue(ability, 'firstDamage')) || 0),
        radius: Math.max(0, Number(abilityFieldValue(ability, 'firstRadius')) || 0)
      },
      {
        damage: Math.max(0, Number(abilityFieldValue(ability, 'secondDamage')) || 0),
        radius: Math.max(0, Number(abilityFieldValue(ability, 'secondRadius')) || 0)
      },
      {
        damage: Math.max(0, Number(abilityFieldValue(ability, 'thirdDamage')) || 0),
        radius: Math.max(0, Number(abilityFieldValue(ability, 'thirdRadius')) || 0),
        knockback: Math.max(0, Number(abilityFieldValue(ability, 'thirdKnockbackPx')) || 0)
      }
    ];

    const recastWindow = Math.max(0, Number(abilityFieldValue(ability, 'recastWindowMs')) || 0) / 1000;
    const recastLockout = Math.max(0, Number(abilityFieldValue(ability, 'recastLockoutMs')) || 0) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);

    const sequence = {
      abilityId: ability && ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      dashDistance,
      stageData,
      recastWindow,
      recastLockout,
      cooldownSeconds,
      currentStage: 0,
      state: 'recast_ready',
      recastRemaining: recastWindow,
      recastLockRemaining: 0,
      recastReadyNotified: false,
      cooldownApplied: false
    };

    stormwingSequences.push(sequence);
    executeStormwingStage(sequence, 1);
    return { success: true, deferCooldown: true };
  }

  function executeStormwingStage(sequence, stage){
    if(!sequence) return false;
    const stageData = Array.isArray(sequence.stageData) ? sequence.stageData[stage] : null;
    if(!stageData) return false;
    const caster = sequence.casterRef || player;
    if(!caster) return false;
    const abilityName = sequence.abilityName || 'Stormwing Barrage';
    const dashDistance = Math.max(0, Number(sequence.dashDistance) || 0);
    if(!(dashDistance > 0)){
      finishStormwingSequence(sequence, { message: `${abilityName} cannot move.` });
      return false;
    }

    const startX = caster.x;
    const startY = caster.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const travel = dashDistance > 0 ? dashDistance : distance;
    const moved = moveCircleWithCollision(startX, startY, dirX * travel, dirY * travel, caster.r || player.r);
    let destX = moved.x;
    let destY = moved.y;
    destX = Math.max(player.r, Math.min(mapState.width - player.r, destX));
    destY = Math.max(player.r, Math.min(mapState.height - player.r, destY));

    caster.x = destX;
    caster.y = destY;
    if(caster === player){
      player.target.x = destX;
      player.target.y = destY;
      player.navGoal = null;
      player.nav = null;
      player.chaseTarget = null;
    }

    cancelPlayerAttack(false);

    const radius = Math.max(0, Number(stageData.radius) || 0);
    const impactRadius = Math.max(radius, 16);
    const impactOffset = STORMWING_IMPACT_OFFSET;
    const impactX = destX + dirX * impactOffset;
    const impactY = destY + dirY * impactOffset;
    const clampRadius = Math.max(impactRadius, minionRadius);
    let clampX = impactX;
    let clampY = impactY;
    if(Number.isFinite(mapState.width)){
      clampX = Math.max(clampRadius, Math.min(mapState.width - clampRadius, clampX));
    }
    if(Number.isFinite(mapState.height)){
      clampY = Math.max(clampRadius, Math.min(mapState.height - clampRadius, clampY));
    }

    spawnSlamImpact(clampX, clampY, impactRadius);
    const hits = applyStormwingImpact(caster, clampX, clampY, radius, Math.max(0, Number(stageData.damage) || 0), Math.max(0, Number(stageData.knockback) || 0));

    sequence.currentStage = stage;
    const stageLabel = STORMWING_STAGE_LABEL[stage] || `slash ${stage}`;
    if(caster === player){
      const hitText = hits ? ` Hit ${hits}.` : '';
      setHudMessage(`${abilityName} ${stageLabel} landed.${hitText}`);
    }

    if(stage >= 3){
      const hitMessage = hits
        ? `${abilityName} final slash struck ${hits} target${hits === 1 ? '' : 's'}!`
        : `${abilityName} final slash hit nothing.`;
      finishStormwingSequence(sequence, { message: hitMessage });
      return true;
    }

    if(!(sequence.recastWindow > 0)){
      finishStormwingSequence(sequence, { message: `${abilityName} stance collapsed.` });
      return true;
    }

    sequence.recastRemaining = sequence.recastWindow;
    sequence.recastLockRemaining = Math.max(0, Number(sequence.recastLockout) || 0);
    sequence.state = sequence.recastLockRemaining > 0 ? 'recast_locked' : 'recast_ready';
    sequence.recastReadyNotified = false;
    return true;
  }

  function applyStormwingImpact(caster, centerX, centerY, radius, damage, knockback){
    if(!(radius > 0) && damage <= 0 && knockback <= 0) return 0;
    const effectiveRadius = radius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;

    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      if(knockback > 0){
        const dist = Math.hypot(dx, dy);
        const pushX = dist > 0.0001 ? dx / dist : 0;
        const pushY = dist > 0.0001 ? dy / dist : 0;
        const pushed = moveCircleWithCollision(m.x, m.y, pushX * knockback, pushY * knockback, targetRadius);
        const clampedX = Number.isFinite(mapState.width)
          ? Math.max(targetRadius, Math.min(mapState.width - targetRadius, pushed.x))
          : pushed.x;
        const clampedY = Number.isFinite(mapState.height)
          ? Math.max(targetRadius, Math.min(mapState.height - targetRadius, pushed.y))
          : pushed.y;
        m.x = clampedX;
        m.y = clampedY;
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }

    if(isMonsterAttackable(monsterState)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
      const dx = monsterState.x - centerX;
      const dy = monsterState.y - centerY;
      const reach = radius + monsterRadius;
      if(reach > 0 && dx * dx + dy * dy <= reach * reach){
        const prevHp = Math.max(0, Number(monsterState.hp) || 0);
        if(damage > 0){
          monsterState.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monsterState.x, monsterState.y - monsterRadius, damage);
          updateMonsterHud();
        }
        if(knockback > 0){
          const dist = Math.hypot(dx, dy);
          const pushX = dist > 0.0001 ? dx / dist : 0;
          const pushY = dist > 0.0001 ? dy / dist : 0;
          const pushed = moveCircleWithCollision(monsterState.x, monsterState.y, pushX * knockback, pushY * knockback, monsterRadius);
          const clampedX = Number.isFinite(mapState.width)
            ? Math.max(monsterRadius, Math.min(mapState.width - monsterRadius, pushed.x))
            : pushed.x;
          const clampedY = Number.isFinite(mapState.height)
            ? Math.max(monsterRadius, Math.min(mapState.height - monsterRadius, pushed.y))
            : pushed.y;
          monsterState.x = clampedX;
          monsterState.y = clampedY;
        }
        handlePracticeDummyDamage(monsterState, prevHp);
        hits++;
      }
    }

    return hits;
  }

  function finishStormwingSequence(sequence, { message = null } = {}){
    if(!sequence || sequence.cooldownApplied) return;
    sequence.cooldownApplied = true;
    sequence.state = 'complete';
    if(Number.isFinite(sequence.slotIndex)){
      setAbilitySlotCooldown(sequence.slotIndex, Math.max(0, Number(sequence.cooldownSeconds) || 0));
    }
    if(sequence.casterRef === player && message){
      setHudMessage(message);
    }
  }

  function updateStormwingSequences(dt){
    for(let i = stormwingSequences.length - 1; i >= 0; i--){
      const sequence = stormwingSequences[i];
      if(!sequence){
        stormwingSequences.splice(i, 1);
        continue;
      }
      if(sequence.state === 'complete'){
        stormwingSequences.splice(i, 1);
        continue;
      }
      if(sequence.state === 'recast_locked' || sequence.state === 'recast_ready'){
        sequence.recastRemaining = Math.max(0, (Number(sequence.recastRemaining) || 0) - dt);
        if(sequence.recastRemaining <= 0){
          const name = sequence.abilityName || 'Stormwing Barrage';
          finishStormwingSequence(sequence, { message: sequence.casterRef === player ? `${name} stance faded.` : null });
          stormwingSequences.splice(i, 1);
          continue;
        }
        if(sequence.state === 'recast_locked'){
          sequence.recastLockRemaining = Math.max(0, (Number(sequence.recastLockRemaining) || 0) - dt);
          if(sequence.recastLockRemaining <= 0){
            sequence.state = 'recast_ready';
            sequence.recastReadyNotified = false;
          }
        }
        if(sequence.state === 'recast_ready' && sequence.casterRef === player && !sequence.recastReadyNotified){
          const nextStage = Math.min(3, Math.max(0, Number(sequence.currentStage) || 0) + 1);
          const label = STORMWING_STAGE_LABEL[nextStage] || 'next slash';
          setHudMessage(`${sequence.abilityName || 'Stormwing Barrage'} ready for ${label}.`);
          sequence.recastReadyNotified = true;
        }
      }
    }
  }

  function applySnapbackArrival(echo, targetX, targetY){
    if(!echo) return 0;
    const radius = Math.max(0, Number(echo.impactRadius) || 0);
    const effective = radius + minionRadius;
    const effectiveSq = effective * effective;
    let hits = 0;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      if(echo.hitTargets && echo.hitTargets.has(m)) continue;
      const dx = m.x - targetX;
      const dy = m.y - targetY;
      if(dx * dx + dy * dy <= effectiveSq){
        if(applySnapbackHit(echo, m)){
          hits++;
        }
      }
    }
    flash(targetX, targetY, { startRadius: Math.max(10, radius * 0.5), endRadius: Math.max(radius, radius * 1.4, 30), color: '#9fd1ff' });
    if(echo.casterRef === player){
      const totalHits = echo.hitCount || 0;
      if(totalHits > 0){
        const dmgText = echo.damage > 0 ? ` for ${Math.round(echo.damage)} damage` : '';
        setHudMessage(`${echo.abilityName || 'Snapback'} stunned ${totalHits} target${totalHits === 1 ? '' : 's'}${dmgText}.`);
      } else {
        setHudMessage(`${echo.abilityName || 'Snapback'} returned but hit nothing.`);
      }
    }
    return hits;
  }

  function castRiptideSnapbackAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Snapback';
    const dashRangeRaw = abilityFieldValue(ability, 'dashDistancePx');
    const dashRange = Math.max(0, Number(dashRangeRaw) || 0);
    if(!(dashRange > 0)){
      setHudMessage(`${abilityName} needs a dash distance.`);
      return false;
    }
    const delayRaw = abilityFieldValue(ability, 'returnDelayMs');
    const returnDelay = Math.max(0, Number(delayRaw) || 0) / 1000;
    const speedRaw = abilityFieldValue(ability, 'returnSpeedPxS');
    const returnSpeed = Math.max(0, Number(speedRaw) || 0);
    if(!(returnSpeed > 0)){
      setHudMessage(`${abilityName} needs a return speed.`);
      return false;
    }
    const widthRaw = abilityFieldValue(ability, 'phantomWidthPx');
    const pathWidth = Math.max(0, Number(widthRaw) || 0);
    const impactRaw = abilityFieldValue(ability, 'impactRadiusPx');
    const impactRadius = Math.max(0, Number(impactRaw) || 0);
    const damageRaw = abilityFieldValue(ability, 'damage');
    const damage = Math.max(0, Number(damageRaw) || 0);
    const stunRaw = abilityFieldValue(ability, 'stunDurationMs');
    const stunDuration = Math.max(0, Number(stunRaw) || 0) / 1000;

    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const desiredDistance = dashRange > 0 ? Math.min(dashRange, distance) : 0;
    const moveX = dirX * desiredDistance;
    const moveY = dirY * desiredDistance;
    const moved = moveCircleWithCollision(startX, startY, moveX, moveY, player.r);
    let destX = moved.x;
    let destY = moved.y;
    destX = Math.max(player.r, Math.min(mapState.width - player.r, destX));
    destY = Math.max(player.r, Math.min(mapState.height - player.r, destY));

    if(destX !== player.x || destY !== player.y){
      flash(startX, startY, { startRadius: 12, endRadius: 38, color: '#7fc5ff' });
    }

    player.x = destX;
    player.y = destY;
    player.target.x = destX;
    player.target.y = destY;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    cancelPlayerAttack(false);

    flash(destX, destY, { startRadius: 12, endRadius: 42, color: '#b3e4ff' });

    const echo = {
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      state: 'delay',
      delayRemaining: returnDelay,
      speed: returnSpeed,
      width: pathWidth,
      impactRadius,
      damage,
      stunDuration,
      startX,
      startY,
      x: startX,
      y: startY,
      dashEndX: destX,
      dashEndY: destY,
      hitTargets: new Set(),
      hitCount: 0
    };
    snapbackEchoes.push(echo);

    setHudMessage(`${abilityName} dashed!`);
    return true;
  }

  function applyChronoLoopDamage(loop, target, damage){
    if(!loop || !target) return false;
    const prevHp = Number(target.hp) || 0;
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(target.x, target.y - minionRadius, damage);
    }
    handlePracticeDummyDamage(target, prevHp);
    return true;
  }

  function applyChronoLoopFieldSlow(loop){
    if(!loop) return;
    const slowFraction = Math.max(0, Number(loop.fieldSlowFraction) || 0);
    const slowDuration = Math.max(0, Number(loop.fieldSlowDuration) || 0);
    const radius = Math.max(0, Number(loop.fieldRadius) || 0);
    if(slowFraction <= 0 || slowDuration <= 0 || radius <= 0) return;
    const posX = Number(loop.x) || Number(loop.startX) || 0;
    const posY = Number(loop.y) || Number(loop.startY) || 0;
    const effective = radius + minionRadius;
    const effectiveSq = effective * effective;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - posX;
      const dy = m.y - posY;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const existingSlow = Number(m.slowPct) || 0;
      m.slowPct = Math.max(existingSlow, slowFraction);
      m.slowTimer = Math.max(Number(m.slowTimer) || 0, slowDuration);
    }
  }

  function startChronoLoopField(loop){
    if(!loop) return;
    loop.state = 'field';
    loop.fieldTriggered = true;
    loop.speed = Math.max(0, Number(loop.fieldSpeed) || 0);
    loop.fieldRemaining = Math.max(0, Number(loop.fieldDistance) || 0);
    loop.fieldTimer = Math.max(0, Number(loop.fieldDuration) || 0);
    if(loop.fieldRemaining <= 0 && loop.fieldTimer <= 0){
      startChronoLoopReturn(loop);
    }
  }

  function startChronoLoopReturn(loop){
    if(!loop) return;
    loop.state = 'return';
    loop.speed = Math.max(0, Number(loop.returnSpeed) || 0);
    if(!(loop.speed > 0)){
      loop.speed = Math.max(0.5, Number(loop.fieldSpeed) || 0.5);
    }
  }

  function finishChronoLoop(loop, idx, arrivalX, arrivalY){
    if(Array.isArray(chronoLoopGrenades)){
      if(typeof idx === 'number' && chronoLoopGrenades[idx] === loop){
        chronoLoopGrenades.splice(idx, 1);
      } else {
        const existing = chronoLoopGrenades.indexOf(loop);
        if(existing >= 0){
          chronoLoopGrenades.splice(existing, 1);
        }
      }
    }
    const targetX = Number(arrivalX) || Number(loop.x) || Number(loop.startX) || 0;
    const targetY = Number(arrivalY) || Number(loop.y) || Number(loop.startY) || 0;
    flash(targetX, targetY, { startRadius: 10, endRadius: 42, color: '#8df1ff' });
    if(loop.casterRef === player){
      const outboundHits = loop.outboundHitCount || 0;
      const returnHits = loop.returnHitCount || 0;
      let message = `${loop.abilityName || 'Chrono Loop'} returned`;
      const hitParts = [];
      if(outboundHits > 0){
        hitParts.push(`${outboundHits} outbound hit${outboundHits === 1 ? '' : 's'}`);
      }
      if(returnHits > 0){
        hitParts.push(`${returnHits} returning hit${returnHits === 1 ? '' : 's'}`);
      }
      if(hitParts.length){
        message += ` after ${hitParts.join(' and ')}`;
      }
      setHudMessage(`${message}.`);
    }
  }

  function castChronoLoopAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Chrono Loop';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const returnSpeed = Math.max(0, Number(abilityFieldValue(ability, 'returnSpeedPxS')) || 0);
    const fieldDistance = Math.max(0, Number(abilityFieldValue(ability, 'fieldDistancePx')) || 0);
    const fieldSpeed = Math.max(0, Number(abilityFieldValue(ability, 'fieldSpeedPxS')) || 0);
    const fieldDuration = Math.max(0, Number(abilityFieldValue(ability, 'fieldDurationMs')) || 0) / 1000;
    const fieldRadius = Math.max(0, Number(abilityFieldValue(ability, 'fieldRadiusPx')) || 0);
    const fieldSlowPct = Math.max(0, Number(abilityFieldValue(ability, 'fieldSlowPct')) || 0);
    const fieldSlowDuration = Math.max(0, Number(abilityFieldValue(ability, 'fieldSlowDurationMs')) || 0) / 1000;
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const returnDamage = Math.max(0, Number(abilityFieldValue(ability, 'returnDamage')) || 0);

    if(!(range > 0)){
      setHudMessage(`${abilityName} needs an outbound range.`);
      return false;
    }
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width configured.`);
      return false;
    }
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs an outbound speed.`);
      return false;
    }
    if(!(returnSpeed > 0)){
      setHudMessage(`${abilityName} needs a return speed.`);
      return false;
    }

    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const slowFraction = Math.max(0, Math.min(1, fieldSlowPct / 100));

    const loop = {
      id: `chrono-loop-${abilityRuntime.chronoLoopSequence++}`,
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      startX,
      startY,
      x: startX,
      y: startY,
      dirX,
      dirY,
      width,
      state: 'outbound',
      speed,
      maxDistance: range,
      distanceTraveled: 0,
      outboundDamage: damage,
      returnDamage,
      returnSpeed,
      fieldDistance,
      fieldRemaining: fieldDistance,
      fieldSpeed,
      fieldDuration,
      fieldTimer: fieldDuration,
      fieldRadius,
      fieldSlowFraction: slowFraction,
      fieldSlowDuration,
      hitTargetsOutbound: new Set(),
      hitTargetsReturn: new Set(),
      outboundHitCount: 0,
      returnHitCount: 0
    };

    chronoLoopGrenades.push(loop);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    flash(startX, startY, { startRadius: 12, endRadius: 40, color: '#9fe1ff' });
    setHudMessage(`${abilityName} launched!`);
    return true;
  }

  function collectTwinstrikeSegmentHits(startX, startY, endX, endY, pathWidth){
    const hits = [];
    const segX = endX - startX;
    const segY = endY - startY;
    const segLenSq = segX * segX + segY * segY;
    if(!(segLenSq > 0.0001)){
      return { hits, firstHitDist: null };
    }
    const segLen = Math.sqrt(segLenSq);
    const seen = new Set();
    const width = Math.max(0, Number(pathWidth) || 0);
    let firstHitDist = null;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      if(seen.has(m)) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const effective = width * 0.5 + targetRadius;
      const relX = m.x - startX;
      const relY = m.y - startY;
      const t = (relX * segX + relY * segY) / segLenSq;
      if(t < -0.05 || t > 1.05) continue;
      const clamped = Math.max(0, Math.min(1, t));
      const closestX = startX + segX * clamped;
      const closestY = startY + segY * clamped;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY <= effective * effective){
        const along = clamped * segLen;
        hits.push({ target: m, along, practiceTarget });
        seen.add(m);
        if(firstHitDist === null || along < firstHitDist){
          firstHitDist = along;
        }
      }
    }
    return { hits, firstHitDist };
  }

  function applyTwinstrikeDamage(cast, hitEntries, damage){
    if(!cast || !Array.isArray(hitEntries) || !hitEntries.length) return 0;
    let hits = 0;
    for(const entry of hitEntries){
      const target = entry && entry.target;
      if(!target) continue;
      const practiceTarget = target.isPracticeDummy === true;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(target.radius) || minionRadius) : minionRadius;
      const prevHp = Number(target.hp) || 0;
      if(damage > 0){
        target.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(target.x, target.y - targetRadius, damage);
      }
      handlePracticeDummyDamage(target, prevHp);
      hits++;
    }
    return hits;
  }

  function pushTwinstrikeTrail(startX, startY, endX, endY, width, stage, speed){
    const distance = Math.hypot(endX - startX, endY - startY);
    if(!(distance > 1)) return;
    const duration = Math.max(0.18, Math.min(0.8, (distance / Math.max(80, speed || 1)) * 1.5 + 0.15));
    const trail = {
      startX,
      startY,
      endX,
      endY,
      width: Math.max(6, width * 0.6 + 4),
      age: 0,
      duration,
      stage: stage === 'second' ? 'second' : 'first'
    };
    twinstrikeTrails.push(trail);
  }

  function completeTwinstrikeCast(cast, reason = 'complete', { message = null, applyCooldown = true } = {}){
    if(!cast) return;
    if(applyCooldown && !cast.cooldownApplied && Number.isFinite(cast.slotIndex)){
      const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
      cast.cooldownApplied = true;
    }
    if(cast.casterRef === player && message){
      setHudMessage(message);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    cast.state = 'complete';
    const idx = twinstrikeCasts.indexOf(cast);
    if(idx >= 0){
      twinstrikeCasts.splice(idx, 1);
    }
  }

  function afterTwinstrikeFirstDash(cast, hitCount){
    if(!cast) return;
    const abilityName = cast.abilityName || 'Twinstrike';
    const windowSeconds = Math.max(0, Number(cast.recastWindow) || 0);
    const recastRange = Math.max(0, Number(cast.secondRange) || 0);
    if(!(windowSeconds > 0) || !(recastRange > 0)){
      completeTwinstrikeCast(cast, 'complete', {
        message: cast.casterRef === player
          ? `${abilityName} dashed${hitCount ? ` and hit ${hitCount}` : ''}.`
          : null
      });
      return;
    }
    cast.recastRemaining = windowSeconds;
    cast.recastUnlockRemaining = Math.min(windowSeconds, Math.max(0, Number(cast.recastLockout) || 0));
    cast.state = cast.recastUnlockRemaining > 0 ? 'recast_locked' : 'recast_ready';
    cast.recastReadyNotified = cast.state === 'recast_ready';
    if(cast.casterRef === player){
      const windowText = windowSeconds > 0 ? formatSeconds(windowSeconds * 1000) : null;
      if(cast.state === 'recast_ready'){
        const readyText = windowText ? ` (${windowText} left)` : '';
        const hitText = hitCount ? ` Hit ${hitCount}.` : '';
        setHudMessage(`${abilityName} recast ready${readyText}.${hitText}`);
      } else {
        const lockText = formatSeconds(cast.recastUnlockRemaining * 1000);
        const hitText = hitCount ? ` Hit ${hitCount}.` : '';
        setHudMessage(`${abilityName} dashed. Recast in ${lockText}${windowText ? ` (${windowText} window)` : ''}.${hitText}`);
      }
    }
  }

  function executeTwinstrikeDash(cast, stage){
    if(!cast) return false;
    const abilityName = cast.abilityName || 'Twinstrike';
    const range = stage === 'second'
      ? Math.max(0, Number(cast.secondRange) || 0)
      : Math.max(0, Number(cast.firstRange) || 0);
    if(!(range > 0)){
      if(cast.casterRef === player){
        const which = stage === 'second' ? 'recast' : 'dash';
        setHudMessage(`${abilityName} needs a ${which} range.`);
      }
      return false;
    }
    const damage = stage === 'second'
      ? Math.max(0, Number(cast.secondDamage) || 0)
      : Math.max(0, Number(cast.firstDamage) || 0);
    const dashWidth = Math.max(0, Number(cast.dashWidth) || 0);
    const overshootMin = stage === 'first' ? Math.max(0, Number(cast.overshootMin) || 0) : 0;
    const dashSpeed = stage === 'second'
      ? Math.max(0, Number(cast.secondSpeed) || 0)
      : Math.max(0, Number(cast.firstSpeed) || 0);

    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const desiredDistance = range > 0 ? Math.min(range, distance) : 0;
    let finalDistance = desiredDistance;
    if(range > 0){
      const searchEndX = startX + dirX * range;
      const searchEndY = startY + dirY * range;
      const segmentHits = collectTwinstrikeSegmentHits(startX, startY, searchEndX, searchEndY, dashWidth);
      if(stage === 'first' && Number.isFinite(segmentHits.firstHitDist)){
        finalDistance = Math.max(finalDistance, Math.min(range, segmentHits.firstHitDist + overshootMin));
      }
    }
    finalDistance = Math.max(0, Math.min(range, finalDistance));
    const moved = moveCircleWithCollision(startX, startY, dirX * finalDistance, dirY * finalDistance, player.r);
    let destX = moved.x;
    let destY = moved.y;
    destX = Math.max(player.r, Math.min(mapState.width - player.r, destX));
    destY = Math.max(player.r, Math.min(mapState.height - player.r, destY));
    const travelDistance = Math.hypot(destX - startX, destY - startY);
    if(!(travelDistance > 0.001)){
      if(cast.casterRef === player){
        setHudMessage(`${abilityName} needs a clear path.`);
      }
      return false;
    }

    const hits = collectTwinstrikeSegmentHits(startX, startY, destX, destY, dashWidth);
    const hitCount = applyTwinstrikeDamage(cast, hits.hits, damage);

    if(destX !== player.x || destY !== player.y){
      const startColor = stage === 'second' ? '#ff8bbf' : '#7fc5ff';
      const endColor = stage === 'second' ? '#ffb7d8' : '#b7e7ff';
      flash(startX, startY, { startRadius: 12, endRadius: 38, color: startColor });
      flash(destX, destY, { startRadius: 12, endRadius: 44, color: endColor });
    }

    player.x = destX;
    player.y = destY;
    player.target.x = destX;
    player.target.y = destY;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    cancelPlayerAttack(false);
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    pushTwinstrikeTrail(startX, startY, destX, destY, dashWidth, stage, dashSpeed);
    return hitCount;
  }

  function castTwinstrikePursuitAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Twinstrike';
    const existing = twinstrikeCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id && cast.state !== 'complete');
    if(existing){
      if(existing.state === 'windup'){
        setHudMessage(`${abilityName} is winding up.`);
        return false;
      }
      if(existing.state === 'recast_locked'){
        const lockout = Math.max(0, Number(existing.recastUnlockRemaining) || 0);
        const lockText = lockout > 0 ? formatSeconds(lockout * 1000) : null;
        const windowText = existing.recastRemaining > 0 ? formatSeconds(existing.recastRemaining * 1000) : null;
        setHudMessage(`${abilityName} recast in ${lockText || 'a moment'}${windowText ? ` (${windowText} left)` : ''}.`);
        return { success: true, deferCooldown: true };
      }
      if(existing.state === 'recast_ready'){
        const hitCount = executeTwinstrikeDash(existing, 'second');
        if(hitCount === false){
          completeTwinstrikeCast(existing, 'failed_recast');
          return false;
        }
        const hitText = hitCount ? ` Hit ${hitCount}.` : '';
        completeTwinstrikeCast(existing, 'recast', {
          message: existing.casterRef === player ? `${abilityName} execution dashed.${hitText}` : null
        });
        return { success: true, deferCooldown: true };
      }
      return false;
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const windupSeconds = Math.max(0, Number(abilityFieldValue(ability, 'firstCastTimeMs')) || 0) / 1000;
    const firstRange = Math.max(0, Number(abilityFieldValue(ability, 'firstDashRangePx')) || 0);
    const firstSpeed = Math.max(0, Number(abilityFieldValue(ability, 'firstDashSpeedPxS')) || 0);
    const dashWidth = Math.max(0, Number(abilityFieldValue(ability, 'dashWidthPx')) || 0);
    const overshootMin = Math.max(0, Number(abilityFieldValue(ability, 'minimumOvershootPx')) || 0);
    const firstDamage = Math.max(0, Number(abilityFieldValue(ability, 'firstDamage')) || 0);
    const recastLockout = Math.max(0, Number(abilityFieldValue(ability, 'recastLockoutMs')) || 0) / 1000;
    const recastWindow = Math.max(0, Number(abilityFieldValue(ability, 'recastWindowMs')) || 0) / 1000;
    const secondRange = Math.max(0, Number(abilityFieldValue(ability, 'secondDashRangePx')) || 0);
    const secondSpeed = Math.max(0, Number(abilityFieldValue(ability, 'secondDashSpeedPxS')) || 0);
    const secondDamage = Math.max(0, Number(abilityFieldValue(ability, 'secondDamage')) || 0);

    if(!(firstRange > 0)){
      setHudMessage(`${abilityName} needs a dash range.`);
      return false;
    }
    if(!(secondRange > 0) && recastWindow > 0){
      setHudMessage(`${abilityName} recast range is missing.`);
      return false;
    }

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      firstRange,
      firstSpeed,
      dashWidth,
      overshootMin,
      firstDamage,
      recastLockout,
      recastWindow,
      secondRange,
      secondSpeed,
      secondDamage,
      state: windupSeconds > 0 ? 'windup' : 'primed',
      windupRemaining: windupSeconds,
      recastRemaining: 0,
      recastUnlockRemaining: 0,
      cooldownApplied: false,
      recastReadyNotified: false,
      allowMovementWhileCasting: true
    };
    twinstrikeCasts.push(cast);

    if(windupSeconds > 0){
      player.casting = cast;
      player.chaseTarget = null;
      player.navGoal = null;
      player.nav = null;
      cancelPlayerAttack(false);
      setHudMessage(`${abilityName} focusing...`);
      return { success: true, deferCooldown: true };
    }

    const hitCount = executeTwinstrikeDash(cast, 'first');
    if(hitCount === false){
      completeTwinstrikeCast(cast, 'failed_first', { applyCooldown: false });
      return false;
    }
    afterTwinstrikeFirstDash(cast, hitCount);
    return { success: true, deferCooldown: true };
  }

  function skyhookFacingDir(){
    const facing = Number(GameState.player && GameState.player.facingRadians);
    const rad = Number.isFinite(facing) ? facing : 0;
    return { x: Math.cos(rad), y: Math.sin(rad) };
  }

  function findSkyhookAnchor(startX, startY, dirX, dirY, range, probeRadius){
    const maxRange = Math.max(0, Number(range) || 0);
    if(!(maxRange > 0)) return null;
    const norm = Math.hypot(dirX, dirY);
    const ux = norm > 0.0001 ? dirX / norm : 1;
    const uy = norm > 0.0001 ? dirY / norm : 0;
    const baseStep = navLineStep ? navLineStep() : 12;
    const step = Math.max(6, Math.min(32, (probeRadius || 0) * 0.75 + 6, baseStep * 1.5));
    let lastClear = { x: startX, y: startY, dist: 0 };
    for(let dist = Math.max(probeRadius, step); dist <= maxRange + 0.0001; dist += step){
      const rawX = startX + ux * dist;
      const rawY = startY + uy * dist;
      const clampedX = Math.max(0, Math.min(mapState.width, rawX));
      const clampedY = Math.max(0, Math.min(mapState.height, rawY));
      const outOfBounds = clampedX !== rawX || clampedY !== rawY;
      if(outOfBounds){
        return { x: clampedX, y: clampedY, distance: dist, hitType: 'edge' };
      }
      if(circleCollides(clampedX, clampedY, probeRadius)){
        let lo = lastClear.dist;
        let hi = dist;
        let anchorX = clampedX;
        let anchorY = clampedY;
        for(let i=0;i<5;i++){
          const mid = (lo + hi) / 2;
          const mx = startX + ux * mid;
          const my = startY + uy * mid;
          const mcx = Math.max(0, Math.min(mapState.width, mx));
          const mcy = Math.max(0, Math.min(mapState.height, my));
          if(circleCollides(mcx, mcy, probeRadius)){
            anchorX = mcx;
            anchorY = mcy;
            hi = mid;
          } else {
            lo = mid;
            anchorX = mcx;
            anchorY = mcy;
          }
        }
        return { x: anchorX, y: anchorY, distance: hi, hitType: 'terrain' };
      }
      lastClear = { x: clampedX, y: clampedY, dist };
    }
    if(!hitboxActive()){
      const fallbackX = startX + ux * maxRange;
      const fallbackY = startY + uy * maxRange;
      return {
        x: Math.max(0, Math.min(mapState.width, fallbackX)),
        y: Math.max(0, Math.min(mapState.height, fallbackY)),
        distance: maxRange,
        hitType: 'fallback'
      };
    }
    return null;
  }

  function skyhookTarget(originX, originY, range){
    const maxRange = Math.max(0, Number(range) || 0);
    if(!(maxRange > 0)) return null;
    const rangeSq = maxRange * maxRange;
    let best = null;
    let bestDistSq = rangeSq + 1;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - originX;
      const dy = m.y - originY;
      const distSq = dx * dx + dy * dy;
      if(distSq > rangeSq || distSq >= bestDistSq) continue;
      if(lineOfSight && !lineOfSight(originX, originY, m.x, m.y, minionRadius)){
        continue;
      }
      best = m;
      bestDistSq = distSq;
    }
    return best;
  }

  function applySkyhookShotDamage(cast, target, damage, { finalShot = false } = {}){
    if(!target) return false;
    const prevHp = Number(target.hp) || 0;
    if(prevHp <= 0 || target.portalizing > 0) return false;
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(target.x, target.y - minionRadius, damage);
      if(prevHp > 0 && target.hp <= 0 && !target.isPracticeDummy){
        addGold(goldState.perKill);
      }
    }
    handlePracticeDummyDamage(target, prevHp);
    const color = finalShot ? '#ffd166' : '#9fe3ff';
    flash(target.x, target.y, { startRadius: 6, endRadius: finalShot ? 22 : 14, color });
    return true;
  }

  function fireSkyhookShot(cast, { finalShot = false } = {}){
    if(!cast) return false;
    const originX = Number.isFinite(cast.currentX) ? cast.currentX : player.x;
    const originY = Number.isFinite(cast.currentY) ? cast.currentY : player.y;
    const range = Math.max(0, Number(cast.shotRange) || 0);
    if(!(range > 0)) return false;
    const target = skyhookTarget(originX, originY, range);
    if(!target) return false;
    const damage = Math.max(0, Number(finalShot ? (Number(cast.finalShotDamage) || cast.shotDamage) : cast.shotDamage) || 0);
    const applied = applySkyhookShotDamage(cast, target, damage, { finalShot });
    if(finalShot && applied && cast.casterRef === player){
      const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      setHudMessage(`${cast.abilityName || 'Skyhook'} finished${dmgText}.`);
    }
    return applied;
  }

  function startSkyhookSwing(cast){
    if(!cast || cast.phase !== 'prep') return false;
    cast.phase = 'swing';
    cast.swingElapsed = 0;
    cast.shotTimer = 0;
    cast.allowLanding = false;
    const caster = cast.casterRef || player;
    const facing = skyhookFacingDir();
    const aim = beamAimPoint();
    let cursorDx = aim.x - caster.x;
    let cursorDy = aim.y - caster.y;
    let cursorLen = Math.hypot(cursorDx, cursorDy);
    if(!(cursorLen > 0.0001)){
      cursorDx = facing.x;
      cursorDy = facing.y;
      cursorLen = 1;
    }
    const cross = facing.x * cursorDy - facing.y * cursorDx;
    cast.clockwise = cross < 0;
    cast.angle = Math.atan2(caster.y - cast.anchorY, caster.x - cast.anchorX);
    cast.currentX = caster.x;
    cast.currentY = caster.y;
    if(caster === player){
      setHudMessage(`${cast.abilityName || 'Swing'} engaged!`);
    }
    return true;
  }

  function performSkyhookJump(cast){
    const caster = cast.casterRef || player;
    const jumpRange = Math.max(0, Number(cast.jumpRange) || 0);
    let destX = caster.x;
    let destY = caster.y;
    if(jumpRange > 0){
      const aim = beamAimPoint();
      let dx = aim.x - caster.x;
      let dy = aim.y - caster.y;
      let len = Math.hypot(dx, dy);
      if(!(len > 0.0001)){
        dx = cast.dirX || 1;
        dy = cast.dirY || 0;
        len = Math.hypot(dx, dy);
      }
      if(!(len > 0.0001)){
        dx = 1;
        dy = 0;
        len = 1;
      }
      const clamped = Math.min(jumpRange, len);
      const moveX = dx / len * clamped;
      const moveY = dy / len * clamped;
      const moved = moveCircleWithCollision(caster.x, caster.y, moveX, moveY, caster.r || player.r);
      destX = moved.x;
      destY = moved.y;
    }
    if(caster === player){
      player.x = destX;
      player.y = destY;
      player.target.x = destX;
      player.target.y = destY;
      player.navGoal = null;
      player.nav = null;
      player.chaseTarget = null;
      cancelPlayerAttack(false);
    } else {
      caster.x = destX;
      caster.y = destY;
    }
    cast.currentX = destX;
    cast.currentY = destY;
    flash(destX, destY, { startRadius: 10, endRadius: 30, color: '#9fe3ff' });
  }

  function finishSkyhookSwing(cast, { reason = 'end', withJump = false, skipFinalShot = false } = {}){
    if(!cast || cast.completed) return false;
    cast.completed = true;
    if(withJump){
      performSkyhookJump(cast);
      if(!skipFinalShot){
        fireSkyhookShot(cast, { finalShot: true });
      }
    } else if(cast.phase === 'swing' && !skipFinalShot){
      fireSkyhookShot(cast, { finalShot: true });
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const idx = skyhookSwingCasts.indexOf(cast);
    if(idx >= 0){
      skyhookSwingCasts.splice(idx, 1);
    }
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
    setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    if(cast.casterRef === player && reason === 'expired'){
      setHudMessage(`${cast.abilityName || 'Swing'} cancelled.`);
    }
    return true;
  }

  function castSwiftTransitAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Swift Transit';
    const dashDistance = Math.max(0, Number(abilityFieldValue(ability, 'dashDistancePx')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(!(dashDistance > 0) || !(impactRadius > 0) || !(damage > 0)){
      setHudMessage(`${abilityName} needs dash distance, impact radius, and damage configured.`);
      return false;
    }
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - player.x;
    let dy = aimPoint.y - player.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const moved = moveCircleWithCollision(player.x, player.y, dirX * dashDistance, dirY * dashDistance, player.r);
    player.x = Math.max(player.r, Math.min(mapState.width - player.r, moved.x));
    player.y = Math.max(player.r, Math.min(mapState.height - player.r, moved.y));
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    cancelPlayerAttack(false);
    flash(player.x, player.y, { startRadius: 10, endRadius: Math.max(impactRadius, 32), color: '#ffd47a' });
    const radius = impactRadius + minionRadius;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dxm = m.x - player.x;
      const dym = m.y - player.y;
      const effective = radius + targetRadius;
      if(dxm * dxm + dym * dym > effective * effective){
        continue;
      }
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits.push(m);
    }
    if(isMonsterAttackable(monsterState)){
      const monster = monsterState;
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
      const dxm = monster.x - player.x;
      const dym = monster.y - player.y;
      const effective = radius + monsterRadius;
      if(dxm * dxm + dym * dym <= effective * effective){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        if(damage > 0){
          monster.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monster.x, monster.y - monsterRadius, damage);
        }
        if(prevHp > 0 && monster.hp <= 0){
          updateMonsterHud();
        }
      }
    }
    player.attackCooldown = 0;
    player.attackWindup = 0;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    setHudMessage(`${abilityName} surged!`);
    return true;
  }

  function castSkyforgeCrashAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Sky Crash';
    const targetRange = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const dashDistance = Math.max(0, Number(abilityFieldValue(ability, 'dashDistancePx')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const monsterBonusDamage = Math.max(0, Number(abilityFieldValue(ability, 'monsterBonusDamage')) || 0);
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowFraction = Math.max(0, Math.min(1, slowPct / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const ghostDuration = Math.max(0, Number(abilityFieldValue(ability, 'ghostDurationMs')) || 0) / 1000;
    const moveSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedPct')) || 0);
    if(!(targetRange > 0) || !(dashDistance > 0) || !(impactRadius > 0) || !(damage > 0)){
      setHudMessage(`${abilityName} needs range, dash, radius, and damage values.`);
      return false;
    }
    const aimPoint = beamAimPoint();
    let target = findNearestEnemyMinionWithinRange(aimPoint.x, aimPoint.y, targetRange);
    if(!target && isMonsterAttackable(monsterState)){
      const dx = monsterState.x - aimPoint.x;
      const dy = monsterState.y - aimPoint.y;
      if(dx * dx + dy * dy <= targetRange * targetRange){
        target = monsterState;
      }
    }
    if(!target){
      setHudMessage(`${abilityName} needs a nearby enemy to crash into.`);
      return false;
    }
    const dx = target.x - player.x;
    const dy = target.y - player.y;
    const distance = Math.hypot(dx, dy);
    if(distance > dashDistance){
      setHudMessage(`${abilityName} target is too far.`);
      return false;
    }
    const moved = moveCircleWithCollision(player.x, player.y, dx, dy, player.r);
    const destX = Math.max(player.r, Math.min(mapState.width - player.r, moved.x));
    const destY = Math.max(player.r, Math.min(mapState.height - player.r, moved.y));
    player.x = destX;
    player.y = destY;
    player.target.x = destX;
    player.target.y = destY;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    cancelPlayerAttack(false);
    flash(destX, destY, { startRadius: 10, endRadius: Math.max(impactRadius, 32), color: '#9be4ff' });

    const areaRadius = impactRadius + minionRadius;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const offsetX = m.x - destX;
      const offsetY = m.y - destY;
      const effective = areaRadius + targetRadius;
      if(offsetX * offsetX + offsetY * offsetY > effective * effective){
        continue;
      }
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      if(slowFraction > 0){
        const existingSlow = typeof m.slowPct === 'number' ? m.slowPct : 0;
        m.slowPct = Math.max(existingSlow, slowFraction);
        if(slowDuration > 0){
          m.slowTimer = Math.max(m.slowTimer || 0, slowDuration);
        }
      }
      handlePracticeDummyDamage(m, prevHp);
    }
    let monsterDamaged = false;
    if(isMonsterAttackable(monsterState)){
      const monster = monsterState;
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
      const offsetX = monster.x - destX;
      const offsetY = monster.y - destY;
      const effective = areaRadius + monsterRadius;
      if(offsetX * offsetX + offsetY * offsetY <= effective * effective){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        const appliedDamage = damage + monsterBonusDamage;
        if(appliedDamage > 0){
          monster.hp = Math.max(0, prevHp - appliedDamage);
          spawnHitSplat(monster.x, monster.y - monsterRadius, appliedDamage);
          monsterDamaged = true;
        }
        if(slowFraction > 0){
          const existingSlow = Number(monster.slowPct) || 0;
          monster.slowPct = Math.max(existingSlow, slowFraction);
          if(slowDuration > 0){
            monster.slowTimer = Math.max(monster.slowTimer || 0, slowDuration);
          }
        }
        if(monsterDamaged){
          updateMonsterHud();
        }
      }
    }
    if(ghostDuration > 0){
      player.ghostTimer = Math.max(player.ghostTimer || 0, ghostDuration);
    }
    if(moveSpeedPct > 0 && ghostDuration > 0){
      player.hasteTimer = Math.max(player.hasteTimer || 0, ghostDuration);
      player.hastePct = Math.max(player.hastePct || 0, moveSpeedPct);
      player.hasteDecayRate = 0;
      player.hasteMinPct = 0;
    }
    player.attackCooldown = 0;
    player.attackWindup = 0;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    setHudMessage(`${abilityName} slammed the ground!`);
    return true;
  }

  function castSkyhookStrafeAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Skyhook';
    const existing = skyhookSwingCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id && !cast.completed);
    if(existing){
      if(existing.phase === 'hook'){
        setHudMessage(`${abilityName} hook is on the way.`);
        return { success: true, deferCooldown: true };
      }
      if(existing.phase === 'prep'){
        const started = startSkyhookSwing(existing);
        return started ? { success: true, deferCooldown: true } : false;
      }
      if(existing.phase === 'swing'){
        if(existing.allowLanding){
          finishSkyhookSwing(existing, { withJump: true });
          return { success: true, deferCooldown: true };
        }
        const remain = Math.max(0, (Number(existing.recastUnlock) || 0) - (Number(existing.swingElapsed) || 0));
        setHudMessage(`${abilityName} leap ready in ${remain > 0 ? remain.toFixed(2) : 'a moment'}s.`);
        return { success: true, deferCooldown: true };
      }
      return false;
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const hookRange = Math.max(0, Number(abilityFieldValue(ability, 'hookRangePx')) || 0);
    const hookSpeed = Math.max(0, Number(abilityFieldValue(ability, 'hookSpeedPxS')) || 0);
    const hookWidth = Math.max(1, Number(abilityFieldValue(ability, 'hookWidthPx')) || 0);
    const prepDuration = Math.max(0, Number(abilityFieldValue(ability, 'prepDurationMs')) || 0) / 1000;
    const swingDuration = Math.max(0, Number(abilityFieldValue(ability, 'swingDurationMs')) || 0) / 1000;
    const swingSpeed = Math.max(0, Number(abilityFieldValue(ability, 'swingSpeedPxS')) || 0);
    const shotInterval = Math.max(0.05, Number(abilityFieldValue(ability, 'shotIntervalMs')) || 0) / 1000;
    const shotDamage = Math.max(0, Number(abilityFieldValue(ability, 'damagePerShot')) || 0);
    const finalDamage = Math.max(0, Number(abilityFieldValue(ability, 'impactDamage')) || 0);
    const shotRange = Math.max(0, Number(abilityFieldValue(ability, 'shotRangePx')) || 0);
    const jumpRange = Math.max(0, Number(abilityFieldValue(ability, 'jumpRangePx')) || 0);
    const recastUnlock = Math.max(0, Number(abilityFieldValue(ability, 'recastUnlockMs')) || 0) / 1000;

    if(!(hookRange > 0)){
      setHudMessage(`${abilityName} needs a hook range configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      const facing = skyhookFacingDir();
      dx = facing.x;
      dy = facing.y;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const probeRadius = Math.max(4, hookWidth / 2);
    const anchor = findSkyhookAnchor(origin.x, origin.y, dirX, dirY, hookRange, probeRadius);
    if(!anchor){
      setHudMessage(`${abilityName} found no terrain to hook.`);
      return false;
    }
    const radius = Math.hypot(anchor.x - origin.x, anchor.y - origin.y);
    if(!(radius > player.r + 6)){
      setHudMessage(`${abilityName} needs more room to swing.`);
      return false;
    }

    const hookDuration = hookSpeed > 0 ? anchor.distance / hookSpeed : 0;
    const swing = {
      id: `skyhook-${Date.now()}`,
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      anchorX: anchor.x,
      anchorY: anchor.y,
      radius,
      dirX,
      dirY,
      hookRange,
      hookWidth,
      hookDuration,
      hookElapsed: 0,
      hookProgress: hookDuration > 0 ? 0 : 1,
      prepRemaining: prepDuration,
      maxPrep: prepDuration,
      swingDuration,
      swingSpeed,
      shotInterval,
      shotDamage,
      finalShotDamage: finalDamage > 0 ? finalDamage : shotDamage,
      shotRange,
      jumpRange,
      recastUnlock,
      swingElapsed: 0,
      allowLanding: false,
      phase: hookDuration > 0 ? 'hook' : 'prep',
      cooldownSeconds,
      currentX: origin.x,
      currentY: origin.y,
      angle: Math.atan2(origin.y - anchor.y, origin.x - anchor.x),
      completed: false
    };

    skyhookSwingCasts.push(swing);
    player.casting = swing;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    const latchNote = anchor.hitType === 'edge' ? ' Latched to map edge.' : (anchor.hitType === 'fallback' ? ' Hook set at range.' : '');
    setHudMessage(`${abilityName} fired a hook.${latchNote}`);
    return { success: true, deferCooldown: true };
  }

  function ricochetBounceScale(bomb, bounceIndex){
    if(!bomb) return 0;
    if(bounceIndex === 0){
      return Math.max(0, Number(bomb.firstBounceScale) || 0);
    }
    if(bounceIndex === 1){
      return Math.max(0, Number(bomb.secondBounceScale) || 0);
    }
    const fallback = Number(bomb.secondBounceScale);
    return Math.max(0, Number.isFinite(fallback) ? fallback : (Number(bomb.firstBounceScale) || 0));
  }

  function detonateRicochetBomb(bomb, x, y, cause = 'final'){
    const radius = Math.max(0, Number(bomb && bomb.explosionRadius) || 0);
    const damage = Math.max(0, Number(bomb && bomb.damage) || 0);
    const effectiveRadius = radius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }
    const startRadius = radius > 0 ? Math.max(10, radius * 0.35) : 14;
    const endRadius = radius > 0 ? Math.max(radius, startRadius + 46) : 60;
    flash(x, y, { startRadius, endRadius, color: '#ffd28a' });
    if(bomb && bomb.casterRef === player){
      let message = `${bomb.abilityName || 'Ricochet'} `;
      if(hits > 0){
        const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
        message += `hit ${hits} target${hits === 1 ? '' : 's'}${dmgText}.`;
      } else {
        message += cause === 'enemy' ? 'popped early but hit nothing.' : 'exploded but hit nothing.';
      }
      setHudMessage(message);
    }
  }

  function launchRicochetBomb(cast){
    if(!cast) return false;
    const abilityName = cast.abilityName || 'Ricochet';
    const speed = Math.max(0, Number(cast.speed) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs travel speed.`);
      if(cast.casterRef === player && player.casting === cast){
        player.casting = null;
      }
      return false;
    }
    const startX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    const dirXRaw = Number(cast.dirX) || 0;
    const dirYRaw = Number(cast.dirY) || 0;
    const dirLen = Math.hypot(dirXRaw, dirYRaw);
    const dirX = dirLen > 0.0001 ? dirXRaw / dirLen : 1;
    const dirY = dirLen > 0.0001 ? dirYRaw / dirLen : 0;
    const baseDistance = Math.max(1, Number(cast.baseDistance) || Math.hypot(cast.targetX - startX, cast.targetY - startY) || 1);
    const targetX = Number.isFinite(cast.targetX) ? cast.targetX : (startX + dirX * baseDistance);
    const targetY = Number.isFinite(cast.targetY) ? cast.targetY : (startY + dirY * baseDistance);
    const segDx = targetX - startX;
    const segDy = targetY - startY;
    const segDistance = Math.max(1, Math.hypot(segDx, segDy) || baseDistance);
    const normX = segDistance > 0.0001 ? segDx / segDistance : dirX;
    const normY = segDistance > 0.0001 ? segDy / segDistance : dirY;

    const bomb = {
      abilityId: cast.abilityId,
      abilityName,
      casterRef: cast.casterRef || player,
      startX,
      startY,
      currentX: startX,
      currentY: startY,
      targetX,
      targetY,
      dirX: normX,
      dirY: normY,
      baseDirX: dirX,
      baseDirY: dirY,
      segmentDistance: segDistance,
      baseDistance,
      traveled: 0,
      speed,
      explosionRadius: Math.max(0, Number(cast.explosionRadius) || 0),
      triggerRadius: Math.max(0, Number(cast.triggerRadius) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      bouncesUsed: 0,
      maxBounces: Math.max(0, Number(cast.maxBounces) || 0),
      firstBounceScale: Math.max(0, Number(cast.firstBounceScale) || 0),
      secondBounceScale: Math.max(0, Number(cast.secondBounceScale) || 0)
    };
    ricochetBombProjectiles.push(bomb);
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    setHudMessage(`${abilityName} tossed!`);
    return true;
  }

  function castRicochetLobAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Ricochet';
    const castTimeMs = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeMs) || 0) / 1000;
    const maxRangeRaw = abilityFieldValue(ability, 'maxRangePx');
    const maxRange = Math.max(0, Number(maxRangeRaw) || 0);
    const speedRaw = abilityFieldValue(ability, 'projectileSpeedPxPerMs');
    const projectileSpeed = Math.max(0, Number(speedRaw) || 0);
    const explosionRadiusRaw = abilityFieldValue(ability, 'explosionRadiusPx');
    const explosionRadius = Math.max(0, Number(explosionRadiusRaw) || 0);
    const triggerRadiusRaw = abilityFieldValue(ability, 'triggerRadiusPx');
    const triggerRadius = Math.max(0, Number(triggerRadiusRaw) || 0);
    const damageRaw = abilityFieldValue(ability, 'damage');
    const damage = Math.max(0, Number(damageRaw) || 0);
    const bounceCountRaw = abilityFieldValue(ability, 'bounceCount');
    const maxBounces = Math.max(0, Math.floor(Number(bounceCountRaw) || 0));
    const firstBounceScaleRaw = abilityFieldValue(ability, 'firstBounceScale');
    const secondBounceScaleRaw = abilityFieldValue(ability, 'secondBounceScale');

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(maxRange > 0 && distance > maxRange){
      const scale = maxRange / distance;
      dx *= scale;
      dy *= scale;
      distance = maxRange;
    }
    const dirLen = Math.hypot(dx, dy) || 1;
    const dirX = dx / dirLen;
    const dirY = dy / dirLen;
    const safeRadius = Math.max(triggerRadius, explosionRadius, minionRadius);
    const targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, origin.x + dirX * distance));
    const targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, origin.y + dirY * distance));
    const correctedDx = targetX - origin.x;
    const correctedDy = targetY - origin.y;
    const correctedDistance = Math.hypot(correctedDx, correctedDy) || 1;
    const correctedDirX = correctedDistance > 0.0001 ? correctedDx / correctedDistance : dirX;
    const correctedDirY = correctedDistance > 0.0001 ? correctedDy / correctedDistance : dirY;

    if(!(projectileSpeed > 0)){
      setHudMessage(`${abilityName} needs travel speed.`);
      return false;
    }

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      startX: origin.x,
      startY: origin.y,
      targetX,
      targetY,
      dirX: correctedDirX,
      dirY: correctedDirY,
      baseDistance: correctedDistance,
      speed: projectileSpeed,
      explosionRadius,
      triggerRadius: Math.max(triggerRadius, explosionRadius * 0.6),
      damage,
      maxBounces,
      firstBounceScale: Math.max(0, Number(firstBounceScaleRaw) || 0),
      secondBounceScale: Math.max(0, Number(secondBounceScaleRaw) || 0)
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    // Keep position fixed; Dirge Bloom should not move the caster.
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      return launchRicochetBomb(cast);
    }

    ricochetBombCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} priming...`);
    return true;
  }

  function castDirgeBloomAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Dirge Bloom';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'aoeRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPctRaw = abilityFieldValue(ability, 'slowPct');
    const slowFraction = Math.max(0, Math.min(1, (Number(slowPctRaw) || 0) / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const curseDuration = Math.max(0, Number(abilityFieldValue(ability, 'curseDurationMs')) || 0) / 1000;
    const curseDps = Math.max(0, Number(abilityFieldValue(ability, 'curseDps')) || 0);

    if(!(projectileSpeed > 0)){
      setHudMessage(`${abilityName} needs travel speed.`);
      return false;
    }
    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a burst radius.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      const fallbackTarget = player.target && Number.isFinite(player.target.x) && Number.isFinite(player.target.y)
        ? player.target
        : null;
      if(fallbackTarget){
        dx = fallbackTarget.x - origin.x;
        dy = fallbackTarget.y - origin.y;
      } else {
        dx = 0;
        dy = 0;
      }
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const maxTravel = maxRange > 0 ? Math.min(distance, maxRange) : distance;
    let targetX = origin.x + (dx / distance) * maxTravel;
    let targetY = origin.y + (dy / distance) * maxTravel;
    const safeRadius = Math.max(radius + minionRadius, 4);
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
      targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
      const adjDx = targetX - origin.x;
      const adjDy = targetY - origin.y;
      const adjDist = Math.hypot(adjDx, adjDy);
      if(adjDist > 0.0001){
        dx = adjDx;
        dy = adjDy;
        distance = adjDist;
      }
    }
    const dirLen = Math.hypot(dx, dy) || 1;
    const dirX = dx / dirLen;
    const dirY = dy / dirLen;
    const travelDistance = distance;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      state: castDuration > 0 ? 'windup' : 'flying',
      castDuration,
      castElapsed: 0,
      allowMovementWhileCasting: true,
      originX: origin.x,
      originY: origin.y,
      targetX,
      targetY,
      dirX,
      dirY,
      travelDistance,
      projectileSpeed,
      radius,
      damage,
      slowFraction,
      slowDuration,
      curseDuration,
      curseDps,
      traveled: 0,
      projectileX: origin.x,
      projectileY: origin.y
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = targetX;
    player.target.y = targetY;
    player.navGoal = null;
    player.nav = null;

    dirgeBloomCasts.push(cast);

    if(cast.state === 'windup'){
      player.casting = cast;
      setHudMessage(`${abilityName} priming...`);
    } else {
      player.casting = null;
      setHudMessage(`${abilityName} lobbed!`);
    }
    return true;
  }

  function detonateDirgeBloom(cast){
    if(!cast) return;
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const centerX = Number.isFinite(cast.projectileX) ? cast.projectileX : (Number.isFinite(cast.targetX) ? cast.targetX : cast.originX);
    const centerY = Number.isFinite(cast.projectileY) ? cast.projectileY : (Number.isFinite(cast.targetY) ? cast.targetY : cast.originY);
    const radius = Math.max(0, Number(cast.radius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(cast.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(cast.slowDuration) || 0);
    const curseDuration = Math.max(0, Number(cast.curseDuration) || 0);
    const curseDps = Math.max(0, Number(cast.curseDps) || 0);
    let hits = 0;
    let cursed = 0;

    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const maxRadius = radius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > maxRadius * maxRadius) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      if(slowFraction > 0 && slowDuration > 0){
        const existingSlow = typeof m.slowPct === 'number' ? m.slowPct : 0;
        m.slowPct = Math.max(existingSlow, slowFraction);
        m.slowTimer = Math.max(m.slowTimer || 0, slowDuration);
      }
      if(curseDuration > 0){
        m.dirgeCurseTimer = Math.max(Number(m.dirgeCurseTimer) || 0, curseDuration);
        m.dirgeCurseMax = Math.max(Number(m.dirgeCurseMax) || 0, curseDuration);
        if(curseDps > 0){
          const existingDps = Number(m.dirgeCurseDps) || 0;
          m.dirgeCurseDps = Math.max(existingDps, curseDps);
        }
        m.dirgeCurseTick = 0;
        cursed++;
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }

    const startRadius = radius > 0 ? Math.max(12, radius * 0.55) : 18;
    const endRadius = radius > 0 ? Math.max(radius + 46, radius * 1.35) : 64;
    flash(centerX, centerY, { startRadius, endRadius, color: '#bba3ff' });
    if(cast.casterRef === player){
      if(hits > 0){
        const curseText = cursed > 0 ? `, cursed ${cursed}` : '';
        const dmgText = damage > 0 ? ` for ${Math.round(damage)} dmg` : '';
        setHudMessage(`${cast.abilityName || 'Dirge Bloom'} burst on ${hits} target${hits === 1 ? '' : 's'}${dmgText}${curseText}.`);
      } else {
        setHudMessage(`${cast.abilityName || 'Dirge Bloom'} burst but hit nothing.`);
      }
    }
  }

  const DIRGE_CURSE_TICK = 0.5;

  function updateDirgeBloomCasts(dt){
    for(let i = dirgeBloomCasts.length - 1; i >= 0; i--){
      const cast = dirgeBloomCasts[i];
      if(!cast){
        dirgeBloomCasts.splice(i, 1);
        continue;
      }
      if(cast.state === 'windup'){
        cast.castElapsed = Math.max(0, (Number(cast.castElapsed) || 0) + dt);
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        if(!(duration > 0) || cast.castElapsed >= duration){
          cast.state = 'flying';
          cast.castElapsed = duration;
          if(cast.casterRef === player && player.casting === cast){
            player.casting = null;
          }
          setHudMessage(`${cast.abilityName || 'Dirge Bloom'} lobbed!`);
        }
        continue;
      }
      const speed = Math.max(0, Number(cast.projectileSpeed) || 0);
      const distance = Math.max(0, Number(cast.travelDistance) || 0);
      if(!(speed > 0) || !(distance > 0)){
        detonateDirgeBloom(cast);
        dirgeBloomCasts.splice(i, 1);
        continue;
      }
      const nextTraveled = Math.min(distance, Math.max(0, Number(cast.traveled) || 0) + speed * dt);
      cast.traveled = nextTraveled;
      const dirX = Number(cast.dirX) || 0;
      const dirY = Number(cast.dirY) || 0;
      cast.projectileX = cast.originX + dirX * nextTraveled;
      cast.projectileY = cast.originY + dirY * nextTraveled;
      if(nextTraveled >= distance - 0.0001){
        detonateDirgeBloom(cast);
        dirgeBloomCasts.splice(i, 1);
      }
    }
  }

  function updateDirgeBloomCurses(dt){
    for(const m of minions){
      if(!m) continue;
      if(m.portalizing > 0 || m.hp <= 0){
        if(m.dirgeCurseTimer){
          m.dirgeCurseTimer = 0;
          m.dirgeCurseTick = 0;
          m.dirgeCurseDps = 0;
          m.dirgeCurseMax = 0;
        }
        continue;
      }
      const timer = Math.max(0, Number(m.dirgeCurseTimer) || 0);
      if(!(timer > 0)){
        continue;
      }
      const nextTimer = Math.max(0, timer - dt);
      m.dirgeCurseTimer = nextTimer;
      if(nextTimer <= 0){
        m.dirgeCurseTick = 0;
        m.dirgeCurseDps = 0;
        m.dirgeCurseMax = 0;
        continue;
      }
      const dps = Math.max(0, Number(m.dirgeCurseDps) || 0);
      if(!(dps > 0)) continue;
      m.dirgeCurseTick = Math.max(0, Number(m.dirgeCurseTick) || 0) + dt;
      while(m.dirgeCurseTick >= DIRGE_CURSE_TICK){
        m.dirgeCurseTick -= DIRGE_CURSE_TICK;
        const damage = dps * DIRGE_CURSE_TICK;
        if(!(damage > 0)) continue;
        const prevHp = Number(m.hp) || 0;
        if(prevHp <= 0) break;
        m.hp = Math.max(0, prevHp - damage);
        const targetRadius = m.isPracticeDummy ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
        spawnHitSplat(m.x, m.y - targetRadius, Math.round(damage));
        handlePracticeDummyDamage(m, prevHp);
        if(m.hp <= 0) break;
      }
    }
  }

  function drawDirgeBloomCasts(){
    if(!dirgeBloomCasts.length) return;
    for(const cast of dirgeBloomCasts){
      if(!cast) continue;
      const burstRadius = Math.max(0, Number(cast.radius) || 0);
      const targetX = Number.isFinite(cast.targetX) ? cast.targetX : cast.originX;
      const targetY = Number.isFinite(cast.targetY) ? cast.targetY : cast.originY;
      const ringRadius = burstRadius;
      if(ringRadius > 0 && circleInCamera(targetX, targetY, ringRadius + 28)){
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#bba3ff33';
        ctx.beginPath();
        ctx.arc(targetX, targetY, ringRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.setLineDash([6, 6]);
        ctx.globalAlpha = 0.55;
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#cfc4ff';
        ctx.beginPath();
        ctx.arc(targetX, targetY, ringRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
      if(cast.state !== 'flying') continue;
      const projX = Number.isFinite(cast.projectileX) ? cast.projectileX : cast.originX;
      const projY = Number.isFinite(cast.projectileY) ? cast.projectileY : cast.originY;
      if(!circleInCamera(projX, projY, 28)) continue;
      const projectileRadius = Math.max(7, Math.min(16, burstRadius * 0.18 + 7));
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = '#bba3ff';
      ctx.beginPath();
      ctx.arc(projX, projY, projectileRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#7c66b3';
      ctx.stroke();
      ctx.restore();
    }
  }

  function castEventHorizonAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Event Horizon';
    const castTimeSeconds = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const durationSeconds = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const outerRadius = Math.max(0, Number(abilityFieldValue(ability, 'outerRadiusPx')) || 0);
    const innerRadius = Math.max(0, Number(abilityFieldValue(ability, 'innerRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damagePerTick')) || 0);
    let tickInterval = Math.max(0, Number(abilityFieldValue(ability, 'tickIntervalMs')) || 0) / 1000;
    tickInterval = tickInterval > 0 ? tickInterval : 0.25;
    const pullSpeed = Math.max(0, Number(abilityFieldValue(ability, 'pullSpeedPxS')) || 0);
    const slowFraction = Math.max(0, Math.min(1, (Number(abilityFieldValue(ability, 'slowPct')) || 0) / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const executeThreshold = Math.max(0, Math.min(1, (Number(abilityFieldValue(ability, 'executeThresholdPct')) || 0) / 100));

    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    if(!(outerRadius > 0)){
      setHudMessage(`${abilityName} needs an area configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = typeof skillshotAimPoint === 'function' ? skillshotAimPoint() : beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const clampRadius = Math.max(outerRadius, innerRadius, minionRadius);
    if(Number.isFinite(mapState.width)){
      targetX = Math.max(clampRadius, Math.min(mapState.width - clampRadius, targetX));
    }
    if(Number.isFinite(mapState.height)){
      targetY = Math.max(clampRadius, Math.min(mapState.height - clampRadius, targetY));
    }

    const cast = {
      slotIndex,
      abilityId: ability && ability.id,
      abilityName,
      casterRef: player,
      targetX,
      targetY,
      castDuration: castTimeSeconds,
      elapsed: 0,
      duration: durationSeconds,
      outerRadius,
      innerRadius,
      damage,
      tickInterval,
      tickTimer: tickInterval,
      pullSpeed,
      slowFraction,
      slowDuration,
      executeThreshold
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(castTimeSeconds <= 0){
      deployEventHorizon(cast);
    } else {
      eventHorizonCasts.push(cast);
      player.casting = cast;
      setHudMessage(`${abilityName} forming...`);
    }

    return true;
  }

  function deployEventHorizon(cast){
    if(!cast) return false;
    const targetX = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
    const targetY = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
    const effect = {
      id: `event-horizon-${abilityRuntime.eventHorizonSequence++}`,
      abilityId: cast.abilityId || 'event_horizon',
      abilityName: cast.abilityName || 'Event Horizon',
      slotIndex: cast.slotIndex,
      casterRef: cast.casterRef,
      x: targetX,
      y: targetY,
      outerRadius: Math.max(0, Number(cast.outerRadius) || 0),
      innerRadius: Math.max(0, Number(cast.innerRadius) || 0),
      duration: Math.max(0, Number(cast.duration) || 0),
      age: 0,
      damage: Math.max(0, Number(cast.damage) || 0),
      tickInterval: Math.max(0.05, Number(cast.tickInterval) || 0.25),
      tickTimer: Math.max(0.05, Number(cast.tickInterval) || 0.25),
      pullSpeed: Math.max(0, Number(cast.pullSpeed) || 0),
      slowFraction: Math.max(0, Math.min(1, Number(cast.slowFraction) || 0)),
      slowDuration: Math.max(0, Number(cast.slowDuration) || 0),
      executeThreshold: Math.max(0, Math.min(1, Number(cast.executeThreshold) || 0))
    };

    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    eventHorizons.push(effect);
    flash(targetX, targetY, { startRadius: Math.max(12, effect.outerRadius * 0.4), endRadius: Math.max(effect.outerRadius, effect.outerRadius * 1.5, 120), color: '#6a44ff' });
    setHudMessage(`${effect.abilityName || 'Event Horizon'} opened.`);
    return true;
  }

  function updateEventHorizonCasts(dt){
    for(let i = eventHorizonCasts.length - 1; i >= 0; i--){
      const cast = eventHorizonCasts[i];
      if(!cast){
        eventHorizonCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(caster && Number(caster.hp) <= 0){
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
        eventHorizonCasts.splice(i, 1);
        continue;
      }
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        eventHorizonCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        eventHorizonCasts.splice(i, 1);
        deployEventHorizon(cast);
      }
    }
  }

  function updateEventHorizons(dt){
    for(let i = eventHorizons.length - 1; i >= 0; i--){
      const effect = eventHorizons[i];
      if(!effect){
        eventHorizons.splice(i, 1);
        continue;
      }
      effect.age = Math.max(0, (Number(effect.age) || 0) + dt);
      const duration = Math.max(0, Number(effect.duration) || 0);
      for(const m of minions){
        if(!m) continue;
        const practiceTarget = m.isPracticeDummy === true;
        if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const radius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
        applyEventHorizonPullAndSlow(effect, m, radius, dt);
      }
      const monster = monsterState;
      if(monster && isMonsterAttackable(monster)){
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
        applyEventHorizonPullAndSlow(effect, monster, monsterRadius, dt);
      }
      const interval = Math.max(0.05, Number(effect.tickInterval) || 0.25);
      effect.tickTimer = Math.max(0, Number(effect.tickTimer) || interval) - dt;
      while(interval > 0 && effect.tickTimer <= 0){
        applyEventHorizonTickDamage(effect);
        effect.tickTimer += interval;
      }
      if(duration > 0 && effect.age >= duration){
        eventHorizons.splice(i, 1);
      }
    }
  }

  function applyEventHorizonPullAndSlow(effect, target, targetRadius, dt){
    if(!effect || !target || !(targetRadius >= 0)) return;
    const centerX = Number(effect.x) || 0;
    const centerY = Number(effect.y) || 0;
    const dx = target.x - centerX;
    const dy = target.y - centerY;
    const distSq = dx * dx + dy * dy;
    const outerLimit = effect.outerRadius + targetRadius;
    if(distSq > outerLimit * outerLimit) return;
    if(effect.slowFraction > 0 && effect.slowDuration > 0){
      const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
      target.slowPct = Math.max(existingSlow, effect.slowFraction);
      target.slowTimer = Math.max(target.slowTimer || 0, effect.slowDuration);
    }
    if(effect.pullSpeed > 0 && distSq > 1e-4 && dt > 0){
      const dist = Math.sqrt(distSq);
      const travel = Math.min(effect.pullSpeed * dt, Math.max(0, dist - 2));
      if(travel > 0){
        const normX = dx / dist;
        const normY = dy / dist;
        target.x -= normX * travel;
        target.y -= normY * travel;
        const clampRadius = Math.max(targetRadius, minionRadius);
        if(Number.isFinite(mapState.width)){
          target.x = Math.max(clampRadius, Math.min(mapState.width - clampRadius, target.x));
        }
        if(Number.isFinite(mapState.height)){
          target.y = Math.max(clampRadius, Math.min(mapState.height - clampRadius, target.y));
        }
      }
    }
  }

  function applyEventHorizonDamage(effect, target, centerX, centerY, targetRadius, isMonster){
    if(!effect || !target || target.hp <= 0) return 0;
    const dx = target.x - centerX;
    const dy = target.y - centerY;
    const distSq = dx * dx + dy * dy;
    const outerLimit = effect.outerRadius + targetRadius;
    if(distSq > outerLimit * outerLimit) return 0;
    const prevHp = Math.max(0, Number(target.hp) || 0);
    if(prevHp <= 0) return 0;
    const innerLimit = effect.innerRadius + targetRadius;
    const insideCenter = innerLimit > 0 && distSq <= innerLimit * innerLimit;
    const maxHp = Number(target.maxHp) || 0;
    const threshold = effect.executeThreshold;
    const offset = isMonster
      ? Math.max(minionRadius, monsterAttackRadius(target))
      : (target.isPracticeDummy ? Math.max(minionRadius, Number(target.radius) || minionRadius) : minionRadius);
    if(insideCenter && threshold > 0 && maxHp > 0 && prevHp <= maxHp * threshold){
      target.hp = 0;
      spawnHitSplat(target.x, target.y - offset, prevHp);
      if(isMonster){
        updateMonsterHud();
      } else {
        handlePracticeDummyDamage(target, prevHp);
      }
      return 1;
    }
    const damage = Math.max(0, Number(effect.damage) || 0);
    if(damage <= 0) return 0;
    const applied = Math.min(prevHp, damage);
    if(applied <= 0) return 0;
    target.hp = Math.max(0, prevHp - applied);
    spawnHitSplat(target.x, target.y - offset, applied);
    if(isMonster){
      updateMonsterHud();
    } else {
      handlePracticeDummyDamage(target, prevHp);
    }
    return 1;
  }

  function applyEventHorizonTickDamage(effect){
    if(!effect) return 0;
    const centerX = Number(effect.x) || 0;
    const centerY = Number(effect.y) || 0;
    let hits = 0;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const radius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      hits += applyEventHorizonDamage(effect, m, centerX, centerY, radius, false);
    }
    const monster = monsterState;
    if(monster && isMonsterAttackable(monster)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      hits += applyEventHorizonDamage(effect, monster, centerX, centerY, monsterRadius, true);
    }
    return hits;
  }

  function castTrailblazeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Trailblaze';
    const dashDistance = Math.max(0, Number(abilityFieldValue(ability, 'dashDistancePx')) || 0);
    const baseSpeed = Math.max(0, Number(abilityFieldValue(ability, 'dashSpeedPxS')) || 0);
    const movementBonus = Math.max(0, Number(abilityFieldValue(ability, 'movementSpeedBonusPct')) || 0) / 100;
    const patchRadius = Math.max(0, Number(abilityFieldValue(ability, 'patchRadiusPx')) || 0);
    const patchSpacing = Math.max(1, Number(abilityFieldValue(ability, 'patchSpacingPx')) || 200);
    const maxPatches = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'maxPatches')) || 3));
    const patchDuration = Math.max(0, Number(abilityFieldValue(ability, 'patchDurationMs')) || 0) / 1000;
    const lingerDuration = Math.max(0, Number(abilityFieldValue(ability, 'lingerDurationMs')) || 0) / 1000;
    let tickInterval = Math.max(0, Number(abilityFieldValue(ability, 'tickIntervalMs')) || 0) / 1000;
    tickInterval = tickInterval > 0 ? tickInterval : 0.5;
    const damagePerTick = Math.max(0, Number(abilityFieldValue(ability, 'damagePerTick')) || 0);
    const cooldownSeconds = abilityCooldownSeconds(ability);

    if(!(dashDistance > 0)){
      setHudMessage(`${abilityName} needs a dash range configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(distance > dashDistance){
      const scale = dashDistance / distance;
      dx *= scale;
      dy *= scale;
      distance = dashDistance;
    }
    let destX = origin.x + dx;
    let destY = origin.y + dy;
    const safeRadius = Math.max(minionRadius, patchRadius, player.r || minionRadius);
    if(Number.isFinite(mapState.width)){
      destX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, destX));
    }
    if(Number.isFinite(mapState.height)){
      destY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, destY));
    }

    const dirX = dx / distance;
    const dirY = dy / distance;
    const dashSpeed = Math.max(0, baseSpeed + ((player.speed || 0) * movementBonus));
    if(!(dashSpeed > 0)){
      setHudMessage(`${abilityName} needs a dash speed configured.`);
      return false;
    }

    const dash = {
      abilityId: ability && ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      startX: origin.x,
      startY: origin.y,
      destX,
      destY,
      dirX,
      dirY,
      dashSpeed,
      traveled: 0,
      patchSpacing,
      maxPatches,
      patchRadius,
      patchDuration,
      patchLinger: lingerDuration,
      tickInterval,
      damagePerTick
    };

    trailblazeDashes.push(dash);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.casting = dash;

    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    setHudMessage(`${abilityName} streaks forward!`);
    return true;
  }

  function castPhalanxSurgeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Phalanx Surge';
    const targetRange = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const dashSpeed = Math.max(0, Number(abilityFieldValue(ability, 'dashSpeedPxS')) || 0);
    const soldierCount = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'soldierCount')) || 3));
    const soldierSpacing = Math.max(0, Number(abilityFieldValue(ability, 'soldierSpacingPx')) || 24);
    const effectRadius = Math.max(0, Number(abilityFieldValue(ability, 'widthPx')) || 80);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 120);
    const slowBase = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'slowPct')) || 25)) / 100;
    const extraSlow = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'extraSlowPerSoldierPct')) || 25)) / 100;
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 1000) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);

    if(!(targetRange > 0)){
      setHudMessage(`${abilityName} needs a target range configured.`);
      return false;
    }
    if(!(dashSpeed > 0)){
      setHudMessage(`${abilityName} needs a dash speed configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(distance > targetRange){
      const scale = targetRange / distance;
      dx *= scale;
      dy *= scale;
      distance = targetRange;
    }
    const dirLen = Math.max(0.0001, distance);
    const dirX = dx / dirLen;
    const dirY = dy / dirLen;
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const safeRadius = Math.max(effectRadius, player.r || 0, 8);
    if(Number.isFinite(mapState.width)){
      targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
    }
    if(Number.isFinite(mapState.height)){
      targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
    }

    const perpX = -dirY;
    const perpY = dirX;
    const centerOffset = (soldierCount - 1) / 2;
    const castId = abilityRuntime.phalanxSurgeSequence++;
    for(let i = 0; i < soldierCount; i++){
      const offset = (i - centerOffset) * soldierSpacing;
      const startX = origin.x + perpX * offset;
      const startY = origin.y + perpY * offset;
      let destX = targetX + perpX * offset;
      let destY = targetY + perpY * offset;
      if(Number.isFinite(mapState.width)){
        destX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, destX));
      }
      if(Number.isFinite(mapState.height)){
        destY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, destY));
      }
      const dash = {
        id: `phalanx-${castId}-${i}-${Math.random().toString(16).slice(2,6)}`,
        abilityId: ability && ability.id,
        abilityName,
        slotIndex,
        casterRef: player,
        cooldownSeconds,
        startX,
        startY,
        currentX: startX,
        currentY: startY,
        destX,
        destY,
        dirX,
        dirY,
        speed: dashSpeed,
        damage,
        radius: effectRadius,
        slowBase,
        extraSlow,
        slowDuration,
        castId,
        hitTargets: new Set()
      };
      sandRushDashes.push(dash);
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    setHudMessage(`${abilityName} charges across the field!`);
    return true;
  }

  function completeTrailblazeDash(dash){
    if(!dash) return;
    const caster = dash.casterRef || player;
    if(caster === player && player.casting === dash){
      player.casting = null;
    }
    const startX = Number.isFinite(dash.startX) ? dash.startX : (caster ? caster.x : player.x);
    const startY = Number.isFinite(dash.startY) ? dash.startY : (caster ? caster.y : player.y);
    const endX = Number.isFinite(caster.x) ? caster.x : startX;
    const endY = Number.isFinite(caster.y) ? caster.y : startY;
    const dx = endX - startX;
    const dy = endY - startY;
    const distance = Math.hypot(dx, dy);
    const patchRadius = Math.max(0, Number(dash.patchRadius) || 0);
    const patchSpacing = Math.max(1, Number(dash.patchSpacing) || 200);
    const maxPatches = Math.max(1, Math.round(Number(dash.maxPatches) || 3));
    const patchCount = Math.min(maxPatches, Math.max(1, Math.floor(distance / patchSpacing) + 1));

    for(let i = 0; i < patchCount; i++){
      const fraction = patchCount > 1 ? (i + 1) / (patchCount + 1) : 0.5;
      const patchX = startX + dx * fraction;
      const patchY = startY + dy * fraction;
      spawnTrailblazePatch({
        abilityId: dash.abilityId,
        abilityName: dash.abilityName,
        casterRef: caster,
        x: patchX,
        y: patchY,
        radius: patchRadius,
        duration: Number(dash.patchDuration) || 0,
        linger: Number(dash.patchLinger) || 0,
        tickInterval: Number(dash.tickInterval) || 0.5,
        damagePerTick: Number(dash.damagePerTick) || 0
      });
    }

    if(caster === player){
      flash(endX, endY, { startRadius: Math.max(12, patchRadius * 0.4), endRadius: Math.max(32, patchRadius + 32), color: '#ffae59' });
      setHudMessage(`${dash.abilityName || 'Trailblaze'} scorched the ground!`);
    }
  }

  function spawnTrailblazePatch(options = {}){
    const x = Number.isFinite(options.x) ? options.x : (options.casterRef ? options.casterRef.x : player.x);
    const y = Number.isFinite(options.y) ? options.y : (options.casterRef ? options.casterRef.y : player.y);
    const radius = Math.max(0, Number(options.radius) || 0);
    const patch = {
      id: options.id || `trailblaze-${abilityRuntime.trailblazeSequence++}-${Math.random().toString(16).slice(2, 6)}`,
      abilityId: options.abilityId,
      abilityName: options.abilityName,
      casterRef: options.casterRef,
      x,
      y,
      radius,
      duration: Math.max(0, Number(options.duration) || 0),
      linger: Math.max(0, Number(options.linger) || 0),
      tickInterval: Math.max(0.05, Number(options.tickInterval) || 0.5),
      tickTimer: 0,
      damagePerTick: Math.max(0, Number(options.damagePerTick) || 0),
      age: 0
    };
    trailblazePatches.push(patch);
    flash(x, y, { startRadius: Math.max(12, radius * 0.4), endRadius: Math.max(28, radius + 28), color: '#ffb347' });
    return patch;
  }

  function updateTrailblazeDashes(dt){
    for(let i = trailblazeDashes.length - 1; i >= 0; i--){
      const dash = trailblazeDashes[i];
      if(!dash){
        trailblazeDashes.splice(i, 1);
        continue;
      }
      const caster = dash.casterRef || player;
      if(!caster){
        trailblazeDashes.splice(i, 1);
        continue;
      }
      if(Number(caster.hp) <= 0){
        completeTrailblazeDash(dash);
        trailblazeDashes.splice(i, 1);
        continue;
      }
      const destX = Number.isFinite(dash.destX) ? dash.destX : caster.x;
      const destY = Number.isFinite(dash.destY) ? dash.destY : caster.y;
      const dx = destX - caster.x;
      const dy = destY - caster.y;
      const distance = Math.hypot(dx, dy);
      const speed = Math.max(0, Number(dash.dashSpeed) || 0);
      if(!(distance > 0.0001) || !(speed > 0)){
        completeTrailblazeDash(dash);
        trailblazeDashes.splice(i, 1);
        continue;
      }
      const travel = Math.min(distance, speed * dt);
      const moveX = dx / distance * travel;
      const moveY = dy / distance * travel;
      const moved = moveCircleWithCollision(caster.x, caster.y, moveX, moveY, caster.r || minionRadius);
      const actualTravel = Math.hypot(moved.x - caster.x, moved.y - caster.y);
      caster.x = Math.max(caster.r, Math.min(mapState.width - caster.r, moved.x));
      caster.y = Math.max(caster.r, Math.min(mapState.height - caster.r, moved.y));
      caster.target.x = caster.x;
      caster.target.y = caster.y;
      caster.navGoal = null;
      caster.nav = null;
      caster.chaseTarget = null;
      dash.traveled = Math.max(0, Number(dash.traveled) || 0) + actualTravel;
      if(travel >= distance - 0.0001 || Math.hypot(destX - caster.x, destY - caster.y) <= Math.max(6, caster.r || minionRadius)){
        completeTrailblazeDash(dash);
        trailblazeDashes.splice(i, 1);
      }
    }
  }

  function updateTrailblazePatches(dt){
    for(let i = trailblazePatches.length - 1; i >= 0; i--){
      const patch = trailblazePatches[i];
      if(!patch){
        trailblazePatches.splice(i, 1);
        continue;
      }
      patch.age = Math.max(0, (Number(patch.age) || 0) + dt);
      const lifetime = Math.max(0, Number(patch.duration) || 0) + Math.max(0, Number(patch.linger) || 0);
      if(lifetime > 0 && patch.age >= lifetime){
        trailblazePatches.splice(i, 1);
        continue;
      }
      const interval = Math.max(0.05, Number(patch.tickInterval) || 0.5);
      patch.tickTimer = Math.max(0, Number(patch.tickTimer) || 0) - dt;
      while(interval > 0 && patch.tickTimer <= 0){
        applyTrailblazePatchDamage(patch);
        patch.tickTimer += interval;
      }
    }
  }

  function updateSandRushDashes(dt){
    for(let i = sandRushDashes.length - 1; i >= 0; i--){
      const dash = sandRushDashes[i];
      if(!dash){
        sandRushDashes.splice(i, 1);
        continue;
      }
      const destX = Number.isFinite(dash.destX) ? dash.destX : (dash.casterRef ? dash.casterRef.x : dash.currentX);
      const destY = Number.isFinite(dash.destY) ? dash.destY : (dash.casterRef ? dash.casterRef.y : dash.currentY);
      const dx = destX - dash.currentX;
      const dy = destY - dash.currentY;
      const distance = Math.hypot(dx, dy);
      const speed = Math.max(0, Number(dash.speed) || 0);
      if(!(distance > 0.0001) || !(speed > 0)){
        sandRushDashes.splice(i, 1);
        continue;
      }
      const travel = Math.min(distance, speed * dt);
      const moveX = dx / distance * travel;
      const moveY = dy / distance * travel;
      dash.currentX += moveX;
      dash.currentY += moveY;
      applySandRushDashHits(dash);
      if(travel >= distance - 0.0001 || Math.hypot(destX - dash.currentX, destY - dash.currentY) <= 1.5){
        sandRushDashes.splice(i, 1);
      }
    }
  }

  function applySandRushDashHits(dash){
    if(!dash) return;
    const radius = Math.max(0, Number(dash.radius) || 0);
    const centerX = Number(dash.currentX) || 0;
    const centerY = Number(dash.currentY) || 0;
    const reachBuffer = radius;
    if(!(reachBuffer >= 0)) return;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      const limit = reachBuffer + targetRadius;
      if(dx * dx + dy * dy > limit * limit){
        continue;
      }
      applySandRushHit(dash, m, targetRadius, false);
    }
    const monster = monsterState;
    if(monster && isMonsterAttackable(monster) && monster.hp > 0){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      const limit = reachBuffer + monsterRadius;
      if(dx * dx + dy * dy <= limit * limit){
        applySandRushHit(dash, monster, monsterRadius, true);
      }
    }
  }

  function applySandRushHit(dash, target, targetRadius, isMonster){
    if(!dash || !target) return;
    if(dash.hitTargets && dash.hitTargets.has(target)) return;
    if(!dash.hitTargets){
      dash.hitTargets = new Set();
    }
    dash.hitTargets.add(target);
    const hitState = resolveSandRushHitState(target, dash.castId);
    const prevHits = hitState ? hitState.hits : 0;
    if(hitState){
      hitState.hits = prevHits + 1;
    }
    const slowTotal = Math.min(1, (Number(dash.slowBase) || 0) + (Number(dash.extraSlow) || 0) * prevHits);
    if(prevHits === 0 && Number(dash.damage) > 0){
      const prevHp = Math.max(0, Number(target.hp) || 0);
      if(prevHp > 0){
        const applied = Math.min(prevHp, Number(dash.damage) || 0);
        target.hp = Math.max(0, prevHp - (Number(dash.damage) || 0));
        spawnHitSplat(target.x, target.y - targetRadius, applied);
        if(isMonster){
          updateMonsterHud();
        } else {
          handlePracticeDummyDamage(target, prevHp);
        }
      }
    }
    if(slowTotal > 0){
      const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
      target.slowPct = Math.max(existingSlow, slowTotal);
      target.slowTimer = Math.max(target.slowTimer || 0, Number(dash.slowDuration) || 0);
    }
  }

  function resolveSandRushHitState(target, castId){
    if(!target) return null;
    const current = target.sandRushPhalanx;
    if(!current || current.castId !== castId){
      const next = { castId, hits: 0 };
      target.sandRushPhalanx = next;
      return next;
    }
    return current;
  }

  function applyTrailblazePatchDamage(patch){
    if(!patch) return 0;
    const damage = Math.max(0, Number(patch.damagePerTick) || 0);
    const radius = Math.max(0, Number(patch.radius) || 0);
    if(!(radius > 0) || !(damage > 0)) return 0;
    const centerX = Number(patch.x) || 0;
    const centerY = Number(patch.y) || 0;
    let hits = 0;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const effective = radius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > effective * effective) continue;
      const prevHp = Number(m.hp) || 0;
      m.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(m.x, m.y - targetRadius, damage);
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }
      const monster = monsterState;
      if(monster && isMonsterAttackable(monster)){
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
        const effective = radius + monsterRadius;
        const dx = monster.x - centerX;
        const dy = monster.y - centerY;
        if(dx * dx + dy * dy <= effective * effective){
          const prevHp = Math.max(0, Number(monster.hp) || 0);
          monster.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monster.x, monster.y - monsterRadius, damage);
          updateMonsterHud();
          markEntityWithPlasma(monster);
          hits += 1;
        }
      }
    return hits;
  }

  function drawEventHorizonTelegraphs(){
    if(!eventHorizonCasts.length) return;
    for(const cast of eventHorizonCasts){
      if(!cast) continue;
      const radius = Math.max(0, Number(cast.outerRadius) || 0);
      const innerRadius = Math.max(0, Number(cast.innerRadius) || 0);
      const x = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
      const y = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
      if(!(radius > 0) || !circleInCamera(x, y, radius + 32)) continue;
      const duration = Math.max(0.0001, Number(cast.castDuration) || 0.0001);
      const progress = Math.max(0, Math.min(1, (Number(cast.elapsed) || 0) / duration));
      ctx.save();
      ctx.globalAlpha = 0.2 + 0.45 * (1 - progress);
      ctx.fillStyle = '#05040e';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.65 * (1 - progress);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#8a6cff';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      if(innerRadius > 0){
        ctx.globalAlpha = 0.4 * (1 - progress);
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.strokeStyle = '#c4b8ff';
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.restore();
    }
  }

  function drawEventHorizons(){
    if(!eventHorizons.length) return;
    for(const effect of eventHorizons){
      if(!effect) continue;
      const radius = Math.max(0, Number(effect.outerRadius) || 0);
      const inner = Math.max(0, Number(effect.innerRadius) || 0);
      const x = Number(effect.x) || 0;
      const y = Number(effect.y) || 0;
      if(!(radius > 0) || !circleInCamera(x, y, radius + 32)) continue;
      const duration = Math.max(0.0001, Number(effect.duration) || 0.0001);
      const progress = duration > 0 ? Math.min(1, (Number(effect.age) || 0) / duration) : 0;
      const fade = 1 - progress;
      ctx.save();
      ctx.globalAlpha = 0.25 + 0.25 * fade;
      ctx.fillStyle = '#05040e';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      if(inner > 0){
        ctx.globalAlpha = 0.6 * fade;
        ctx.fillStyle = '#4d2ff7';
        ctx.beginPath();
        ctx.arc(x, y, inner, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 0.65 * fade;
      ctx.strokeStyle = '#8b6bff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 0.35 * fade;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#c4b8ff';
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.3 + (inner > 0 ? inner * 0.5 : 0), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawTrailblazePatches(){
    if(!trailblazePatches.length) return;
    for(const patch of trailblazePatches){
      if(!patch) continue;
      const x = Number.isFinite(patch.x) ? patch.x : 0;
      const y = Number.isFinite(patch.y) ? patch.y : 0;
      const radius = Math.max(0, Number(patch.radius) || 0);
      if(!(radius > 0) || !circleInCamera(x, y, radius + 32)) continue;
      const total = Math.max(0, Number(patch.duration) || 0) + Math.max(0, Number(patch.linger) || 0);
      const progress = total > 0 ? Math.min(1, (Number(patch.age) || 0) / total) : 0;
      const fade = 1 - progress;
      ctx.save();
      ctx.globalAlpha = 0.2 + 0.28 * fade;
      ctx.fillStyle = '#120600';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.55 * fade;
      ctx.strokeStyle = '#ffb347';
      ctx.lineWidth = Math.max(2, radius * 0.1);
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  function drawSandRushDashes(){
    if(!sandRushDashes.length) return;
    for(const dash of sandRushDashes){
      if(!dash) continue;
      const x = Number(dash.currentX) || 0;
      const y = Number(dash.currentY) || 0;
      const radius = Math.max(0, Number(dash.radius) || 0);
      if(!(radius > 0) || !circleInCamera(x, y, radius + 32)) continue;
      ctx.save();
      ctx.globalAlpha = 0.48;
      ctx.fillStyle = '#f7d2a8';
      ctx.beginPath();
      ctx.arc(x, y, Math.max(6, radius * 0.55), 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#f7b347';
      ctx.lineWidth = 2;
      ctx.beginPath();
      const dirX = Number(dash.dirX) || 0;
      const dirY = Number(dash.dirY) || 0;
      ctx.moveTo(x - dirX * radius * 0.2, y - dirY * radius * 0.2);
      ctx.lineTo(x + dirX * (radius + 6), y + dirY * (radius + 6));
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawHailboundTempests(){
    if(!hailboundTempests.length) return;
    for(const storm of hailboundTempests){
      if(!storm || storm.ended) continue;
      const caster = storm.casterRef || player;
      const x = Number.isFinite(storm.x) ? storm.x : (caster ? caster.x : 0);
      const y = Number.isFinite(storm.y) ? storm.y : (caster ? caster.y : 0);
      const { radius, progress, empowered } = resolveHailboundTempestRadius(storm);
      if(!(radius > 0) || !circleInCamera(x, y, radius + 28)) continue;
      const inner = Math.max(10, radius * 0.45);
      ctx.save();
      ctx.globalAlpha = 0.18 + 0.24 * progress;
      ctx.fillStyle = empowered ? '#7fd1ff33' : '#b6ecff26';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = empowered ? '#7fe3ff' : '#b8e0ff';
      ctx.lineWidth = empowered ? 3.5 : 3;
      ctx.setLineDash(empowered ? [6, 5] : [10, 8]);
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#e0f6ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, inner, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawVenomClouds(){
    if(!venomClouds.length) return;
    for(const cloud of venomClouds){
      if(!cloud) continue;
      const radius = Math.max(0, Number(cloud.radius) || 0);
      if(!(radius > 0)) continue;
      const alpha = cloud.duration > 0 ? Math.max(0, Math.min(1, 1 - (cloud.elapsed || 0) / cloud.duration)) : 1;
      if(!circleInCamera(cloud.x, cloud.y, radius + 12)) continue;
      ctx.save();
      ctx.globalAlpha = 0.18 + 0.22 * alpha;
      ctx.fillStyle = '#0c2f0f';
      ctx.beginPath();
      ctx.arc(cloud.x, cloud.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.4 * alpha;
      ctx.strokeStyle = '#43ffb3';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.arc(cloud.x, cloud.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  function drawMiasmaClouds(){
    if(!miasmaClouds.length) return;
    for(const cloud of miasmaClouds){
      if(!cloud) continue;
      const radius = Math.max(0, Number(cloud.radius) || 0);
      if(!(radius > 0)) continue;
      const alpha = cloud.duration > 0 ? Math.max(0, Math.min(1, 1 - (cloud.elapsed || 0) / cloud.duration)) : 1;
      if(!circleInCamera(cloud.x, cloud.y, radius + 12)) continue;
      ctx.save();
      ctx.globalAlpha = 0.16 + 0.2 * alpha;
      ctx.fillStyle = '#2d1a3a';
      ctx.beginPath();
      ctx.arc(cloud.x, cloud.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.5 * alpha;
      ctx.strokeStyle = '#c498ff';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 8]);
      ctx.beginPath();
      ctx.arc(cloud.x, cloud.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  function drawStoneGazeEffects(){
    if(!stoneGazeEffects.length) return;
    for(const effect of stoneGazeEffects){
      if(!effect) continue;
      const range = Math.max(0, Number(effect.range) || 0);
      const width = Math.max(0, Number(effect.width) || 0);
      if(!(range > 0) || !(width > 0)) continue;
      if(!circleInCamera(effect.x, effect.y, range + 12)) continue;
      const progress = Math.max(0, Math.min(1, (effect.age || 0) / Math.max(0.0001, effect.duration || 0.4)));
      const alpha = 0.4 * (1 - progress);
      const dirAngle = Math.atan2(effect.dirY || 0, effect.dirX || 1);
      const halfAngle = Math.atan2(width / 2, range);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#9fd7ff';
      ctx.strokeStyle = '#9fd7ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(effect.x, effect.y);
      ctx.lineTo(effect.x + Math.cos(dirAngle - halfAngle) * range, effect.y + Math.sin(dirAngle - halfAngle) * range);
      ctx.arc(effect.x, effect.y, range, dirAngle - halfAngle, dirAngle + halfAngle);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = alpha * 0.6;
      ctx.setLineDash([12, 8]);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  function drawDirgeBloomCurses(){
    for(const m of minions){
      if(!m) continue;
      const timer = Math.max(0, Number(m.dirgeCurseTimer) || 0);
      if(!(timer > 0)) continue;
      const baseRadius = m.isPracticeDummy ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const ringRadius = baseRadius + 10;
      if(!circleInCamera(m.x, m.y, ringRadius + 8)) continue;
      const maxTimer = Math.max(timer, Number(m.dirgeCurseMax) || 0);
      const intensity = maxTimer > 0 ? Math.max(0, Math.min(1, timer / maxTimer)) : 0.5;
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.25 * intensity;
      ctx.strokeStyle = '#c3a3ff';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([4, 5]);
      ctx.beginPath();
      ctx.arc(m.x, m.y, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  function clampTrapPosition(originX, originY, x, y, radius, maxRange){
    let targetX = Number.isFinite(x) ? x : originX;
    let targetY = Number.isFinite(y) ? y : originY;
    const dx = targetX - originX;
    const dy = targetY - originY;
    const dist = Math.hypot(dx, dy);
    if(maxRange > 0 && dist > maxRange){
      const scale = maxRange / dist;
      targetX = originX + dx * scale;
      targetY = originY + dy * scale;
    }
    const safeRadius = Math.max(0, radius || 0);
    targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
    targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
    return { x: targetX, y: targetY };
  }

  function resolveTrapPlacement(originX, originY, candidateX, candidateY, radius, maxRange){
    const base = clampTrapPosition(originX, originY, candidateX, candidateY, radius, maxRange);
    if(!circleCollides(base.x, base.y, radius)) return base;
    const angles = [0, Math.PI / 4, -Math.PI / 4, Math.PI / 2, -Math.PI / 2, Math.PI, (3 * Math.PI) / 4, -(3 * Math.PI) / 4];
    const step = Math.max(6, Math.max(radius * 0.5, 6));
    const maxSteps = 10;
    for(let ring = 1; ring <= maxSteps; ring++){
      const dist = step * ring;
      for(const angle of angles){
        const offsetX = Math.cos(angle) * dist;
        const offsetY = Math.sin(angle) * dist;
        const candidate = clampTrapPosition(originX, originY, base.x + offsetX, base.y + offsetY, radius, maxRange);
        if(!circleCollides(candidate.x, candidate.y, radius)) return candidate;
      }
    }
    return circleCollides(base.x, base.y, radius) ? null : base;
  }

  function enforceTrapSpacing(points, minSpacing, originX, originY, radius, maxRange){
    if(!Array.isArray(points) || points.length <= 1) return points;
    const minSpacingValue = Math.max(0, Number(minSpacing) || 0);
    if(!(minSpacingValue > 0)) return points;
    const minSq = minSpacingValue * minSpacingValue;
    const iterations = 6;
    for(let iter = 0; iter < iterations; iter++){
      let adjusted = false;
      for(let i = 0; i < points.length; i++){
        const a = points[i];
        if(!a) continue;
        for(let j = i + 1; j < points.length; j++){
          const b = points[j];
          if(!b) continue;
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const distSq = dx * dx + dy * dy;
          if(distSq >= minSq || distSq <= 1e-6) continue;
          const dist = Math.sqrt(distSq);
          const push = (minSpacingValue - dist) * 0.5;
          if(!(push > 0)) continue;
          const nx = dx / dist;
          const ny = dy / dist;
          a.x -= nx * push;
          a.y -= ny * push;
          b.x += nx * push;
          b.y += ny * push;
          const adjA = clampTrapPosition(originX, originY, a.x, a.y, radius, maxRange);
          a.x = adjA.x;
          a.y = adjA.y;
          const adjB = clampTrapPosition(originX, originY, b.x, b.y, radius, maxRange);
          b.x = adjB.x;
          b.y = adjB.y;
          adjusted = true;
        }
      }
      if(!adjusted) break;
    }
    return points;
  }

  const trapHitMemory = new WeakMap();
  const TRAP_HIT_MEMORY_MIN_MS = 1500;

  function registerTrapHit(target, abilityId, memoryMs){
    if(!target || !abilityId) return { isSubsequent: false, count: 1 };
    const now = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
    let record = trapHitMemory.get(target);
    if(!record){
      record = {};
      trapHitMemory.set(target, record);
    }
    const expiryMs = Math.max(TRAP_HIT_MEMORY_MIN_MS, Number(memoryMs) || 0);
    const existing = record[abilityId];
    if(!existing || !Number.isFinite(existing.lastHit) || now - existing.lastHit > expiryMs){
      record[abilityId] = { lastHit: now, count: 1 };
      return { isSubsequent: false, count: 1 };
    }
    const nextCount = Math.max(1, Math.round(existing.count || 0) + 1);
    record[abilityId] = { lastHit: now, count: nextCount };
    return { isSubsequent: nextCount > 1, count: nextCount };
  }

  function computeTrapPlacements(originX, originY, dirX, dirY, pointerDist, {
    count,
    spacing,
    minSpacing,
    maxRange,
    mode
  }){
    const placements = [];
    const trapCount = Math.max(0, Math.floor(Number(count) || 0));
    if(trapCount <= 0) return placements;
    const effectiveSpacing = Math.max(Number(minSpacing) || 0, Number(spacing) || 0);
    const hasRange = maxRange > 0;
    const fallbackDistance = pointerDist > 0
      ? pointerDist
      : (hasRange ? maxRange * 0.6 : 0);
    const baseDistance = hasRange
      ? Math.min(maxRange, Math.max(32, fallbackDistance))
      : Math.max(0, fallbackDistance);
    const perpendicularX = -dirY;
    const perpendicularY = dirX;
    const modeIndex = Math.max(0, Math.min(2, Math.round(Number(mode) || 0)));
    if(modeIndex === 1){
      const center = baseDistance;
      const mid = (trapCount - 1) / 2;
      for(let i = 0; i < trapCount; i++){
        const lateral = (i - mid) * effectiveSpacing;
        let distance = center;
        if(hasRange) distance = Math.min(distance, maxRange);
        const baseX = originX + dirX * distance;
        const baseY = originY + dirY * distance;
        placements.push({
          x: baseX + perpendicularX * lateral,
          y: baseY + perpendicularY * lateral
        });
      }
    } else if(modeIndex === 2){
      const center = baseDistance;
      const centerPoint = {
        x: originX + dirX * center,
        y: originY + dirY * center
      };
      placements.push({ x: centerPoint.x, y: centerPoint.y });
      if(trapCount > 1){
        const angleStep = (Math.PI * 2) / trapCount;
        let ringRadius = effectiveSpacing;
        const denom = Math.sin(Math.PI / trapCount);
        if(denom > 1e-4){
          ringRadius = Math.max(ringRadius, minSpacing > 0 ? minSpacing / (2 * denom) : ringRadius);
        }
        for(let i = 1; i < trapCount; i++){
          const angle = angleStep * i;
          placements.push({
            x: centerPoint.x + Math.cos(angle) * ringRadius,
            y: centerPoint.y + Math.sin(angle) * ringRadius
          });
        }
      }
    } else {
      const start = baseDistance - effectiveSpacing * (trapCount - 1) * 0.5;
      for(let i = 0; i < trapCount; i++){
        let distance = start + effectiveSpacing * i;
        if(hasRange) distance = Math.min(distance, maxRange);
        distance = Math.max(24, distance);
        placements.push({
          x: originX + dirX * distance,
          y: originY + dirY * distance
        });
      }
    }
    return placements;
  }

  function updateQuiverstormBuffs(dt){
    if(!quiverstormBuffs.length) return;
    for(let i = quiverstormBuffs.length - 1; i >= 0; i--){
      const buff = quiverstormBuffs[i];
      if(!buff){
        quiverstormBuffs.splice(i, 1);
        continue;
      }
      const caster = buff.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        quiverstormBuffs.splice(i, 1);
        continue;
      }
      const duration = Math.max(0, Number(buff.duration) || 0);
      const remaining = Math.max(0, (Number(buff.remaining) || duration) - dt);
      buff.remaining = remaining;
      if(remaining <= 0){
        quiverstormBuffs.splice(i, 1);
        if(caster === player){
          setHudMessage(`${buff.abilityName || 'Volley'} faded.`);
        }
      }
    }
  }

  function updateFrenziedSurgeAttackBuffs(dt){
    if(!frenziedSurgeAttackBuffs.length) return;
    for(let i = frenziedSurgeAttackBuffs.length - 1; i >= 0; i--){
      const buff = frenziedSurgeAttackBuffs[i];
      if(!buff){
        frenziedSurgeAttackBuffs.splice(i, 1);
        continue;
      }
      const caster = buff.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        frenziedSurgeAttackBuffs.splice(i, 1);
        continue;
      }
      const remaining = Math.max(0, (Number(buff.remaining) || 0) - dt);
      buff.remaining = remaining;
      if(remaining <= 0){
        frenziedSurgeAttackBuffs.splice(i, 1);
      }
    }
  }

  function updateFrenziedSurgeMoveBuffs(dt){
    let activeMult = 1;
    for(let i = frenziedSurgeMoveBuffs.length - 1; i >= 0; i--){
      const buff = frenziedSurgeMoveBuffs[i];
      if(!buff){
        frenziedSurgeMoveBuffs.splice(i, 1);
        continue;
      }
      buff.age = Math.max(0, (Number(buff.age) || 0) + dt);
      const duration = Math.max(0, Number(buff.duration) || 0);
      const progress = duration > 0 ? Math.min(1, buff.age / duration) : 1;
      const start = Number.isFinite(buff.startMult) ? Math.max(0, buff.startMult) : 1;
      const end = Number.isFinite(buff.endMult) ? Math.max(0, buff.endMult) : start;
      const current = start + (end - start) * progress;
      buff.currentMult = current;
      activeMult = Math.max(activeMult, current || 1);
      if(duration > 0 && buff.age >= duration){
        frenziedSurgeMoveBuffs.splice(i, 1);
      }
    }
    frenziedSurgeMoveMultiplier = Math.max(1, activeMult);
    return frenziedSurgeMoveMultiplier;
  }

  function updateStrideSurgeAttackBuffs(dt){
    if(!strideSurgeAttackBuffs.length) return;
    for(let i = strideSurgeAttackBuffs.length - 1; i >= 0; i--){
      const buff = strideSurgeAttackBuffs[i];
      if(!buff){
        strideSurgeAttackBuffs.splice(i, 1);
        continue;
      }
      const caster = buff.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        strideSurgeAttackBuffs.splice(i, 1);
        continue;
      }
      const remaining = Math.max(0, (Number(buff.remaining) || 0) - dt);
      buff.remaining = remaining;
      if(remaining <= 0){
        strideSurgeAttackBuffs.splice(i, 1);
      }
    }
  }

  function updateStrideSurgeMoveBuffs(dt){
    let activeMult = 1;
    for(let i = strideSurgeMoveBuffs.length - 1; i >= 0; i--){
      const buff = strideSurgeMoveBuffs[i];
      if(!buff){
        strideSurgeMoveBuffs.splice(i, 1);
        continue;
      }
      const caster = buff.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        strideSurgeMoveBuffs.splice(i, 1);
        continue;
      }
      const remaining = Math.max(0, (Number(buff.remaining) || 0) - dt);
      buff.remaining = remaining;
      if(remaining <= 0){
        strideSurgeMoveBuffs.splice(i, 1);
        continue;
      }
      const multiplier = Math.max(0, Number(buff.multiplier) || 1);
      activeMult = Math.max(activeMult, multiplier);
    }
    strideSurgeMoveMultiplier = Math.max(1, activeMult);
  }

  function updatePhantomOverdriveAttackBuffs(dt){
    if(!phantomOverdriveAttackBuffs.length){
      phantomOverdriveProjectileSpeedMultiplier = 1;
      return;
    }
    let bestMissile = 0;
    for(let i = phantomOverdriveAttackBuffs.length - 1; i >= 0; i--){
      const buff = phantomOverdriveAttackBuffs[i];
      if(!buff){
        phantomOverdriveAttackBuffs.splice(i, 1);
        continue;
      }
      const caster = buff.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        phantomOverdriveAttackBuffs.splice(i, 1);
        continue;
      }
      const remaining = Math.max(0, (Number(buff.remaining) || 0) - dt);
      buff.remaining = remaining;
      if(remaining <= 0){
        phantomOverdriveAttackBuffs.splice(i, 1);
        continue;
      }
      const missilePct = Math.max(0, Number(buff.missileSpeedPct) || 0);
      bestMissile = Math.max(bestMissile, missilePct);
    }
    phantomOverdriveProjectileSpeedMultiplier = 1 + bestMissile / 100;
  }

  function updateRoyalOnslaughtBuffs(dt){
    if(!royalOnslaughtBuffs.length) return;
    for(let i = royalOnslaughtBuffs.length - 1; i >= 0; i--){
      const buff = royalOnslaughtBuffs[i];
      if(!buff){
        royalOnslaughtBuffs.splice(i, 1);
        continue;
      }
      const caster = buff.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        royalOnslaughtBuffs.splice(i, 1);
        continue;
      }
      const remaining = Math.max(0, (Number(buff.remaining) || 0) - dt);
      buff.remaining = remaining;
      if(remaining <= 0 || Number(buff.chargesRemaining) <= 0){
        royalOnslaughtBuffs.splice(i, 1);
      }
    }
  }

  function resolveSpinningAxeLanding(flight){
    const originX = Number.isFinite(flight.originX) ? flight.originX : player.x;
    const originY = Number.isFinite(flight.originY) ? flight.originY : player.y;
    const vx = Number(flight.velocityX) || 0;
    const vy = Number(flight.velocityY) || 0;
    const speed = Math.hypot(vx, vy);
    const moving = speed > Math.max(0, Number(flight.moveSpeedThreshold) || 0);
    const randRange = (min, max) => {
      const lo = Math.min(min, max);
      const hi = Math.max(min, max);
      const span = Math.max(0, hi - lo);
      return lo + Math.random() * (span || 0);
    };
    const clampToBounds = (value, min, max, margin) => {
      const innerMin = min + margin;
      const innerMax = max - margin;
      return Math.max(innerMin, Math.min(innerMax, value));
    };

    let lx = originX;
    let ly = originY;
    if(moving){
      const nx = vx / speed;
      const ny = vy / speed;
      const forwardDist = randRange(flight.forwardMin, flight.forwardMax);
      const perpX = -ny;
      const perpY = nx;
      const sideOffset = randRange(-flight.sideJitterMax, flight.sideJitterMax);
      lx = originX + nx * forwardDist + perpX * sideOffset;
      ly = originY + ny * forwardDist + perpY * sideOffset;
    } else {
      const angle = Math.random() * Math.PI * 2;
      const dist = randRange(flight.stillMin, flight.stillMax);
      lx = originX + Math.cos(angle) * dist;
      ly = originY + Math.sin(angle) * dist;
    }

    const margin = Math.max(0, Number(flight.edgeMargin) || 0);
    const minX = 0;
    const minY = 0;
    const maxX = Math.max(minionRadius * 2, mapState.width);
    const maxY = Math.max(minionRadius * 2, mapState.height);
    lx = clampToBounds(lx, minX, maxX, margin);
    ly = clampToBounds(ly, minY, maxY, margin);
    return { x: lx, y: ly };
  }

  function updateSpinningAxeFlights(dt){
    if(!spinningAxeFlights.length) return;
    for(let i = spinningAxeFlights.length - 1; i >= 0; i--){
      const flight = spinningAxeFlights[i];
      if(!flight){
        spinningAxeFlights.splice(i, 1);
        continue;
      }
      const remaining = Math.max(0, (Number(flight.remaining) || 0) - dt);
      flight.remaining = remaining;
      if(remaining > 0){
        continue;
      }
      const landing = resolveSpinningAxeLanding(flight);
      const marker = {
        ...flight,
        state: 'LANDED',
        x: landing.x,
        y: landing.y,
        remaining: Math.max(0, Number(flight.catchWindow) || 0)
      };
      spinningAxeMarkers.push(marker);
      spinningAxeFlights.splice(i, 1);
    }
  }

  function updateSpinningAxeMarkers(dt){
    if(!spinningAxeMarkers.length) return;
    for(let i = spinningAxeMarkers.length - 1; i >= 0; i--){
      const marker = spinningAxeMarkers[i];
      if(!marker){
        spinningAxeMarkers.splice(i, 1);
        continue;
      }
      const radius = Math.max(0, Number(marker.catchRadius) || 0);
      const dx = player.x - marker.x;
      const dy = player.y - marker.y;
      if(dx * dx + dy * dy <= radius * radius){
        const caught = addSpinningAxeInHand(marker);
        if(!caught && marker.abilityName){
          setHudMessage(`${marker.abilityName} dropped (at max).`);
        }
        spinningAxeMarkers.splice(i, 1);
        continue;
      }
      marker.remaining = Math.max(0, (Number(marker.remaining) || 0) - dt);
      if(marker.remaining <= 0){
        spinningAxeMarkers.splice(i, 1);
      }
    }
  }

  function updatePhantomOverdriveMoveBuffs(dt){
    if(!phantomOverdriveMoveBuffs.length){
      phantomOverdriveMoveMultiplier = 1;
      return;
    }
    let activeMult = 1;
    for(let i = phantomOverdriveMoveBuffs.length - 1; i >= 0; i--){
      const buff = phantomOverdriveMoveBuffs[i];
      if(!buff){
        phantomOverdriveMoveBuffs.splice(i, 1);
        continue;
      }
      const caster = buff.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        phantomOverdriveMoveBuffs.splice(i, 1);
        continue;
      }
      buff.age = Math.max(0, (Number(buff.age) || 0) + dt);
      const duration = Math.max(0, Number(buff.duration) || 0);
      const progress = duration > 0 ? Math.min(1, buff.age / duration) : 1;
      const start = Number.isFinite(buff.startMult) ? Math.max(0, buff.startMult) : 1;
      const end = Number.isFinite(buff.endMult) ? Math.max(0, buff.endMult) : start;
      const current = start + (end - start) * progress;
      buff.currentMult = current;
      activeMult = Math.max(activeMult, current || 1);
      if(duration > 0 && buff.age >= duration){
        phantomOverdriveMoveBuffs.splice(i, 1);
        continue;
      }
    }
    phantomOverdriveMoveMultiplier = Math.max(1, activeMult);
  }

  function updatePhantomOverdriveCasts(dt){
    if(!phantomOverdriveCasts.length) return;
    for(let i = phantomOverdriveCasts.length - 1; i >= 0; i--){
      const cast = phantomOverdriveCasts[i];
      if(!cast){
        phantomOverdriveCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        phantomOverdriveCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
        continue;
      }
      if(cast.state === 'windup'){
        cast.castElapsed = Math.min(cast.castTime, (Number(cast.castElapsed) || 0) + dt);
        if(cast.castElapsed >= cast.castTime){
          completePhantomOverdriveCast(cast);
        }
      } else {
        phantomOverdriveCasts.splice(i, 1);
      }
    }
  }

  function resolveHailboundTempestRadius(storm){
    if(!storm) return { radius: 0, progress: 0, empowered: false };
    const startRadius = Math.max(0, Number(storm.startRadius) || 0);
    const maxRadius = Math.max(startRadius, Number(storm.maxRadius) || 0);
    const expandDuration = Math.max(0, Number(storm.expandDuration) || 0);
    const age = Math.max(0, Number(storm.age) || 0);
    const progress = expandDuration > 0 ? Math.min(1, age / expandDuration) : 1;
    const radius = startRadius + (maxRadius - startRadius) * progress;
    return { radius, progress, empowered: progress >= 1 };
  }

  function findActiveHailboundTempest(caster){
    if(!caster) return null;
    for(const storm of hailboundTempests){
      if(!storm || storm.ended) continue;
      if(storm.casterRef === caster) return storm;
    }
    return null;
  }

  function endHailboundTempest(storm, { reason = 'end', applyCooldown = false, cooldownSeconds = 0, finalTick = false, silent = false } = {}){
    if(!storm || storm.ended) return false;
    storm.ended = true;
    if(finalTick){
      const { empowered } = resolveHailboundTempestRadius(storm);
      applyHailboundTempestTick(storm, { empowered });
    }
    if(applyCooldown && Number.isFinite(storm.slotIndex)){
      const cd = Number.isFinite(cooldownSeconds)
        ? Math.max(0, cooldownSeconds)
        : Math.max(0, Number(storm.cooldownSeconds) || 0);
      setAbilitySlotCooldown(storm.slotIndex, cd);
    }
    const idx = hailboundTempests.indexOf(storm);
    if(idx !== -1){
      hailboundTempests.splice(idx, 1);
    }
    if(!silent && storm.casterRef === player){
      const abilityName = storm.abilityName || 'Hailbound Tempest';
      let message = `${abilityName} ended.`;
      if(reason === 'recast'){
        message = `${abilityName} collapsed.`;
      } else if(reason === 'tether'){
        message = `${abilityName} collapsed out of range.`;
      } else if(reason === 'cc'){
        message = `${abilityName} collapsed while you were disabled.`;
      } else if(reason === 'duration'){
        message = `${abilityName} dissipated.`;
      }
      setHudMessage(message);
    }
    return true;
  }

  function applyHailboundTempestTick(storm, { empowered = false } = {}){
    if(!storm) return 0;
    const caster = storm.casterRef || player;
    const centerX = Number.isFinite(storm.x) ? storm.x : (caster ? caster.x : 0);
    const centerY = Number.isFinite(storm.y) ? storm.y : (caster ? caster.y : 0);
    const { radius } = resolveHailboundTempestRadius(storm);
    const damage = Math.max(0, Number(empowered ? storm.empoweredDamage : storm.tickDamage) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(empowered ? storm.empoweredSlowFraction : storm.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(empowered ? storm.empoweredSlowDuration : storm.slowDuration) || 0);
    if(!(radius > 0) || (damage <= 0 && slowFraction <= 0)) return 0;
    let hits = 0;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const maxRadius = radius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > maxRadius * maxRadius) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
        handlePracticeDummyDamage(m, prevHp);
      }
      if(slowFraction > 0 && slowDuration > 0){
        const existingSlow = typeof m.slowPct === 'number' ? m.slowPct : 0;
        m.slowPct = Math.max(existingSlow, slowFraction);
        m.slowTimer = Math.max(m.slowTimer || 0, slowDuration);
      }
      hits++;
    }
    return hits;
  }

  function deployHailboundTempest(cast){
    if(!cast) return false;
    const centerX = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
    const centerY = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
    const startRadius = Math.max(0, Number(cast.startRadius) || 0);
    const maxRadius = Math.max(startRadius, Number(cast.maxRadius) || 0);
    const expandDuration = Math.max(0, Number(cast.expandDuration) || 0);
    const tickInterval = Math.max(0.05, Number(cast.tickInterval) || 0.5);
    const empoweredTickInterval = Math.max(0.05, Number(cast.empoweredTickInterval) || tickInterval);

    const storm = {
      abilityId: cast.abilityId,
      abilityName: cast.abilityName || 'Hailbound Tempest',
      casterRef: cast.casterRef || player,
      slotIndex: cast.slotIndex,
      x: centerX,
      y: centerY,
      startRadius,
      maxRadius,
      expandDuration,
      tickDamage: Math.max(0, Number(cast.tickDamage) || 0),
      empoweredDamage: Math.max(0, Number(cast.empoweredDamage) || 0),
      tickInterval,
      empoweredTickInterval,
      slowFraction: Math.max(0, Math.min(1, Number(cast.slowFraction) || 0)),
      empoweredSlowFraction: Math.max(0, Math.min(1, Number(cast.empoweredSlowFraction) || 0)),
      slowDuration: Math.max(0, Number(cast.slowDuration) || 0),
      empoweredSlowDuration: Math.max(0, Number(cast.empoweredSlowDuration) || 0),
      recastDelay: Math.max(0, Number(cast.recastDelay) || 0),
      tetherRange: Math.max(0, Number(cast.tetherRange) || 0),
      maxDuration: Math.max(0, Number(cast.maxDuration) || 0),
      cooldownSeconds: Math.max(0, Number(cast.cooldownSeconds) || 0),
      age: 0,
      tickTimer: 0,
      pulseTimer: 0,
      ended: false
    };

    hailboundTempests.push(storm);

    const flashStart = startRadius > 0 ? Math.max(12, startRadius * 0.45) : 14;
    const flashEnd = maxRadius > 0 ? Math.max(maxRadius + 40, flashStart + 42) : 60;
    flash(centerX, centerY, { startRadius: flashStart, endRadius: flashEnd, color: '#7fe3ff' });
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    setHudMessage(`${storm.abilityName || 'Tempest'} raging. Recast to collapse.`);
    return true;
  }

  function castHailboundTempestAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Hailbound Tempest';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const existing = findActiveHailboundTempest(player);
    if(existing){
      const recastDelay = Math.max(0, Number(existing.recastDelay) || 0);
      if(existing.age < recastDelay){
        const remaining = Math.max(0, recastDelay - existing.age);
        setHudMessage(`${abilityName} can be collapsed in ${remaining.toFixed(1)}s.`);
        return false;
      }
      flash(existing.x, existing.y, { startRadius: Math.max(10, (existing.currentRadius || existing.maxRadius || 30) * 0.35), endRadius: Math.max(existing.currentRadius || existing.maxRadius || 60, 60), color: '#7fe3ff' });
      endHailboundTempest(existing, { reason: 'recast', applyCooldown: true, cooldownSeconds, finalTick: true });
      return { success: true, deferCooldown: true };
    }
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const startRadius = Math.max(0, Number(abilityFieldValue(ability, 'startRadiusPx')) || 0);
    const maxRadius = Math.max(startRadius, Number(abilityFieldValue(ability, 'maxRadiusPx')) || 0);
    const expandDuration = Math.max(0, Number(abilityFieldValue(ability, 'expandDurationMs')) || 0) / 1000;
    const tickDamage = Math.max(0, Number(abilityFieldValue(ability, 'tickDamage')) || 0);
    const empoweredDamageRaw = abilityFieldValue(ability, 'empoweredDamage');
    const empoweredDamage = Math.max(tickDamage, Number(empoweredDamageRaw) || tickDamage * 3);
    const tickInterval = Math.max(0.05, Number(abilityFieldValue(ability, 'tickIntervalMs')) || 0) / 1000;
    const empoweredTickInterval = Math.max(0.05, Number(abilityFieldValue(ability, 'empoweredTickIntervalMs')) || 0) / 1000;
    const slowPctRaw = abilityFieldValue(ability, 'slowPct');
    const slowFraction = Math.max(0, Math.min(1, (Number(slowPctRaw) || 0) / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const empoweredSlowPctRaw = abilityFieldValue(ability, 'empoweredSlowPct');
    const empoweredSlowFraction = Math.max(slowFraction, Math.min(1, (Number(empoweredSlowPctRaw) || 0) / 100));
    const empoweredSlowDurationRaw = abilityFieldValue(ability, 'empoweredSlowDurationMs');
    const empoweredSlowDuration = Math.max(slowDuration, Number(empoweredSlowDurationRaw) || 0) / 1000;
    const recastDelay = Math.max(0, Number(abilityFieldValue(ability, 'recastDelayMs')) || 0) / 1000;
    const tetherRange = Math.max(0, Number(abilityFieldValue(ability, 'tetherRangePx')) || 0);
    const maxDuration = Math.max(0, Number(abilityFieldValue(ability, 'maxDurationMs')) || 0) / 1000;

    if(!(maxRadius > 0)){
      setHudMessage(`${abilityName} needs a storm radius configured.`);
      return false;
    }
    if(!(tickDamage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const maxTravel = maxRange > 0 ? Math.min(distance, maxRange) : distance;
    let targetX = origin.x + (dx / distance) * maxTravel;
    let targetY = origin.y + (dy / distance) * maxTravel;
    const safeRadius = Math.max(maxRadius + minionRadius, 6);
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
      targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
    }

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      allowMovementWhileCasting: true,
      targetX,
      targetY,
      startRadius,
      maxRadius,
      expandDuration,
      tickDamage,
      empoweredDamage,
      tickInterval,
      empoweredTickInterval,
      slowFraction,
      empoweredSlowFraction,
      slowDuration,
      empoweredSlowDuration,
      recastDelay,
      tetherRange,
      maxDuration,
      cooldownSeconds
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = targetX;
    player.target.y = targetY;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      const deployed = deployHailboundTempest(cast);
      return deployed ? { success: true, deferCooldown: true } : false;
    }

    hailboundTempestCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} gathering a storm...`);
    return true;
  }

  function updateHailboundTempestCasts(dt){
    for(let i = hailboundTempestCasts.length - 1; i >= 0; i--){
      const cast = hailboundTempestCasts[i];
      if(!cast){
        hailboundTempestCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Tempest'} interrupted.`);
        }
        hailboundTempestCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        deployHailboundTempest(cast);
        hailboundTempestCasts.splice(i, 1);
      }
    }
  }

  function updateHailboundTempests(dt){
    for(let i = hailboundTempests.length - 1; i >= 0; i--){
      const storm = hailboundTempests[i];
      if(!storm){
        hailboundTempests.splice(i, 1);
        continue;
      }
      if(storm.ended){
        hailboundTempests.splice(i, 1);
        continue;
      }
      const caster = storm.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        endHailboundTempest(storm, { reason: 'dead', applyCooldown: false, finalTick: false, silent: caster !== player });
        continue;
      }
      storm.age = Math.max(0, (Number(storm.age) || 0) + dt);
      storm.pulseTimer = Math.max(0, (Number(storm.pulseTimer) || 0) - dt);
      const { empowered } = resolveHailboundTempestRadius(storm);
      storm.empowered = empowered;
      const { radius } = resolveHailboundTempestRadius(storm);
      storm.currentRadius = radius;
      const interval = Math.max(0.05, Number(empowered ? storm.empoweredTickInterval : storm.tickInterval) || 0.5);
      let tickTimer = (Number(storm.tickTimer) || 0) - dt;
      while(tickTimer <= 0){
        applyHailboundTempestTick(storm, { empowered });
        storm.pulseTimer = Math.max(storm.pulseTimer, 0.22);
        tickTimer += interval;
        if(tickTimer <= 0) tickTimer += interval;
      }
      storm.tickTimer = tickTimer;

      const maxDuration = Math.max(0, Number(storm.maxDuration) || 0);
      if(maxDuration > 0 && storm.age >= maxDuration){
        endHailboundTempest(storm, { reason: 'duration', applyCooldown: true, cooldownSeconds: storm.cooldownSeconds, finalTick: true });
        continue;
      }
      const ccLocked = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(ccLocked){
        endHailboundTempest(storm, { reason: 'cc', applyCooldown: true, cooldownSeconds: storm.cooldownSeconds, finalTick: true });
        continue;
      }
      const tetherRange = Math.max(0, Number(storm.tetherRange) || 0);
      if(tetherRange > 0){
        const dx = caster.x - (Number.isFinite(storm.x) ? storm.x : caster.x);
        const dy = caster.y - (Number.isFinite(storm.y) ? storm.y : caster.y);
        const tetherLimit = tetherRange + Math.max(0, caster.r || 0);
        if(dx * dx + dy * dy > tetherLimit * tetherLimit){
          endHailboundTempest(storm, { reason: 'tether', applyCooldown: true, cooldownSeconds: storm.cooldownSeconds, finalTick: true });
          continue;
        }
      }
    }
  }

  function applyBulletStormTickDamage(storm){
    if(!storm){
      return 0;
    }
    const radius = Math.max(0, Number(storm.radius) || 0);
    if(!(radius > 0)){
      return 0;
    }
    const damage = Math.max(0, Number(storm.tickDamage) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(storm.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(storm.slowDuration) || 0);
    const effectiveRadius = radius + minionRadius;
    const radiusSq = effectiveRadius * effectiveRadius;
    let hits = 0;

    for(const m of minions){
      if(!m) continue;
      const practice = m.isPracticeDummy === true;
      if(!practice && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - storm.x;
      const dy = m.y - storm.y;
      if(dx * dx + dy * dy > radiusSq) continue;
      const prevHp = Math.max(0, Number(m.hp) || 0);
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      if(prevHp > 0 && m.hp <= 0 && !practice){
        addGold(goldState.perKill);
      }
      handlePracticeDummyDamage(m, prevHp);
      if(slowFraction > 0){
        const existing = Number(m.slowPct) || 0;
        m.slowPct = Math.max(existing, slowFraction);
        if(slowDuration > 0){
          m.slowTimer = Math.max(m.slowTimer || 0, slowDuration);
        }
      }
      if(damage > 0){
        hits += 1;
      }
    }

    const monster = monsterState;
    if(monster && isMonsterAttackable(monster) && monster.hp > 0 && monster.portalizing <= 0){
      const dx = monster.x - storm.x;
      const dy = monster.y - storm.y;
      if(dx * dx + dy * dy <= radiusSq){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        if(damage > 0){
          monster.hp = Math.max(0, prevHp - damage);
          const offset = Math.max(24, monsterAttackRadius());
          spawnHitSplat(monster.x, monster.y - offset, damage);
          updateMonsterHud();
        }
        if(prevHp > 0 && monster.hp <= 0){
          addGold(goldState.perKill);
        }
        handlePracticeDummyDamage(monster, prevHp);
        if(slowFraction > 0){
          const existing = Number(monster.slowPct) || 0;
          monster.slowPct = Math.max(existing, slowFraction);
          if(slowDuration > 0){
            monster.slowTimer = Math.max(monster.slowTimer || 0, slowDuration);
          }
        }
        if(damage > 0){
          hits += 1;
        }
      }
    }

    return hits;
  }

  function deployBulletStorm(cast){
    if(!cast){
      return false;
    }
    const centerX = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
    const centerY = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
    const radius = Math.max(0, Number(cast.radius) || 0);
    if(!(radius > 0)){
      return false;
    }
    const storm = {
      abilityId: cast.abilityId,
      abilityName: cast.abilityName || 'Bullet Storm',
      casterRef: cast.casterRef || player,
      slotIndex: cast.slotIndex,
      x: centerX,
      y: centerY,
      radius,
      duration: Math.max(0, Number(cast.duration) || 0),
      elapsed: 0,
      tickInterval: Math.max(0.05, Number(cast.tickInterval) || 0.25),
      tickTimer: 0,
      tickDamage: Math.max(0, Number(cast.tickDamage) || 0),
      slowFraction: Math.max(0, Math.min(1, Number(cast.slowFraction) || 0)),
      slowDuration: Math.max(0, Number(cast.slowDuration) || 0)
    };
    bulletStorms.push(storm);
    flash(centerX, centerY, { startRadius: Math.max(12, radius * 0.35), endRadius: Math.max(radius + 32, radius * 1.2), color: '#fdbb59' });
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, Math.max(0, Number(cast.cooldownSeconds) || 0));
    }
    setHudMessage(`${storm.abilityName || 'Bullet Storm'} pounding the earth!`);
    return true;
  }

  function castBulletStormAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Bullet Storm';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'radiusPx')) || 0);
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const tickInterval = Math.max(0, Number(abilityFieldValue(ability, 'tickIntervalMs')) || 0) / 1000;
    const tickDamage = Math.max(0, Number(abilityFieldValue(ability, 'tickDamage')) || 0);
    const slowFraction = Math.max(0, Math.min(1, (Number(abilityFieldValue(ability, 'slowPct')) || 0) / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;

    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a radius configured.`);
      return false;
    }
    if(!(tickDamage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const travel = maxRange > 0 ? Math.min(distance, maxRange) : distance;
    let targetX = origin.x + (dx / distance) * travel;
    let targetY = origin.y + (dy / distance) * travel;
    const safeRadius = Math.max(radius + minionRadius, 6);
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
      targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
    }

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      castDuration,
      elapsed: 0,
      targetX,
      targetY,
      radius,
      duration,
      tickInterval: Math.max(0.05, tickInterval),
      tickDamage,
      slowFraction,
      slowDuration
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = targetX;
    player.target.y = targetY;
    player.navGoal = null;
    player.nav = null;

    if(castDuration <= 0){
      const deployed = deployBulletStorm(cast);
      return deployed ? { success: true, deferCooldown: true } : false;
    }

    bulletStormCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} brewing above the area...`);
    return { success: true, deferCooldown: true };
  }

  function updateBulletStormCasts(dt){
    for(let i = bulletStormCasts.length - 1; i >= 0; i--){
      const cast = bulletStormCasts[i];
      if(!cast){
        bulletStormCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        bulletStormCasts.splice(i, 1);
        continue;
      }
      const interrupted = caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0;
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Bullet Storm'} interrupted.`);
        }
        bulletStormCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        deployBulletStorm(cast);
        bulletStormCasts.splice(i, 1);
      }
    }
  }

  function updateBulletStorms(dt){
    for(let i = bulletStorms.length - 1; i >= 0; i--){
      const storm = bulletStorms[i];
      if(!storm){
        bulletStorms.splice(i, 1);
        continue;
      }
      storm.elapsed = Math.max(0, (Number(storm.elapsed) || 0) + dt);
      storm.tickTimer = Math.max(0, (Number(storm.tickTimer) || 0) + dt);
      const interval = Math.max(0.05, Number(storm.tickInterval) || 0.25);
      while(storm.tickTimer >= interval){
        storm.tickTimer -= interval;
        applyBulletStormTickDamage(storm);
      }
      const duration = Math.max(0, Number(storm.duration) || 0);
      if(duration > 0 && storm.elapsed >= duration){
        bulletStorms.splice(i, 1);
      }
    }
  }

  function drawBulletStorms(){
    if(!bulletStorms.length) return;
    for(const storm of bulletStorms){
      if(!storm) continue;
      const radius = Math.max(0, Number(storm.radius) || 0);
      if(!(radius > 0)) continue;
      const x = Number.isFinite(storm.x) ? storm.x : player.x;
      const y = Number.isFinite(storm.y) ? storm.y : player.y;
      if(!circleInCamera(x, y, radius + 24)) continue;
      const duration = Math.max(0, Number(storm.duration) || 0);
      const progress = duration > 0 ? Math.min(1, storm.elapsed / duration) : 0;
      ctx.save();
      ctx.globalAlpha = 0.18 + 0.22 * (1 - progress);
      ctx.fillStyle = '#fff4e6';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.65 * (1 - progress);
      ctx.strokeStyle = '#ffb347';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  function applySerenityFieldPlayerBuff(field){
    if(!field || !player) return;
    const radius = Math.max(0, Number(field.radius) || 0);
    if(!(radius > 0)) return;
    const centerX = Number.isFinite(field.x) ? field.x : player.x;
    const centerY = Number.isFinite(field.y) ? field.y : player.y;
    const playerRadius = Math.max(0, Number(player.r) || 0);
    const dx = player.x - centerX;
    const dy = player.y - centerY;
    const effectiveRadius = radius + playerRadius;
    if(dx * dx + dy * dy > effectiveRadius * effectiveRadius){
      return;
    }
    const movementSpeedPct = Math.max(0, Number(field.movementSpeedPct) || 0);
    const movementDuration = Math.max(0, Number(field.movementDuration) || 0);
    if(movementSpeedPct > 0 && movementDuration > 0){
      player.hastePct = Math.max(player.hastePct || 0, movementSpeedPct);
      player.hasteTimer = Math.max(player.hasteTimer || 0, movementDuration);
      player.hasteDecayRate = 0;
      player.hasteMinPct = 0;
    }
    const ghostDuration = Math.max(0, Number(field.ghostDuration) || 0);
    if(ghostDuration > 0){
      player.ghostTimer = Math.max(player.ghostTimer || 0, ghostDuration);
    }
  }

  function applySerenityFieldTickDamage(field){
    if(!field){
      return 0;
    }
    const radius = Math.max(0, Number(field.radius) || 0);
    if(!(radius > 0)){
      return 0;
    }
    const damage = Math.max(0, Number(field.tickDamage) || 0);
    const effectiveRadius = radius + minionRadius;
    const radiusSq = effectiveRadius * effectiveRadius;
    let hits = 0;

    for(const m of minions){
      if(!m) continue;
      const practice = m.isPracticeDummy === true;
      if(!practice && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - field.x;
      const dy = m.y - field.y;
      if(dx * dx + dy * dy > radiusSq) continue;
      const prevHp = Math.max(0, Number(m.hp) || 0);
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      if(prevHp > 0 && m.hp <= 0 && !practice){
        addGold(goldState.perKill);
      }
      handlePracticeDummyDamage(m, prevHp);
      if(damage > 0){
        hits += 1;
      }
    }

    const monster = monsterState;
    if(monster && isMonsterAttackable(monster) && monster.hp > 0 && monster.portalizing <= 0){
      const dx = monster.x - field.x;
      const dy = monster.y - field.y;
      if(dx * dx + dy * dy <= radiusSq){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        if(damage > 0){
          monster.hp = Math.max(0, prevHp - damage);
          const offset = Math.max(24, monsterAttackRadius());
          spawnHitSplat(monster.x, monster.y - offset, damage);
          updateMonsterHud();
        }
        if(prevHp > 0 && monster.hp <= 0){
          addGold(goldState.perKill);
        }
        handlePracticeDummyDamage(monster, prevHp);
        if(damage > 0){
          hits += 1;
        }
      }
    }

    return hits;
  }

  function deployTranquilTorrent(cast){
    if(!cast){
      return false;
    }
    const centerX = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
    const centerY = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
    const radius = Math.max(0, Number(cast.radius) || 0);
    if(!(radius > 0)){
      return false;
    }
    const field = {
      abilityId: cast.abilityId,
      abilityName: cast.abilityName || 'Tranquil Torrent',
      casterRef: cast.casterRef || player,
      slotIndex: cast.slotIndex,
      x: centerX,
      y: centerY,
      radius,
      duration: Math.max(0, Number(cast.duration) || 0),
      elapsed: 0,
      tickInterval: Math.max(0.05, Number(cast.tickInterval) || 0.25),
      tickTimer: 0,
      tickDamage: Math.max(0, Number(cast.tickDamage) || 0),
      movementSpeedPct: Math.max(0, Number(cast.movementSpeedPct) || 0),
      movementDuration: Math.max(0, Number(cast.movementDuration) || 0),
      ghostDuration: Math.max(0, Number(cast.ghostDuration) || 0)
    };
    serenityFields.push(field);
    const shieldAmount = Math.max(0, Number(cast.shieldAmount) || 0);
    const shieldDuration = Math.max(0, Number(cast.shieldDuration) || 0);
    if(shieldAmount > 0 && shieldDuration > 0){
      applyPlayerShield(shieldAmount, shieldDuration, { source: field.abilityName, castRef: cast });
    }
    flash(centerX, centerY, { startRadius: Math.max(16, radius * 0.35), endRadius: Math.max(radius + 32, radius * 1.4), color: '#7dd8ff' });
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, Math.max(0, Number(cast.cooldownSeconds) || 0));
    }
    setHudMessage(`${field.abilityName || 'Tranquil Torrent'} settles across the ground.`);
    return true;
  }

  function castTranquilTorrentAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Tranquil Torrent';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'radiusPx')) || 0);
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const tickInterval = Math.max(0, Number(abilityFieldValue(ability, 'tickIntervalMs')) || 0) / 1000;
    const tickDamage = Math.max(0, Number(abilityFieldValue(ability, 'tickDamage')) || 0);
    const movementSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'movementSpeedPct')) || 0);
    const movementDuration = Math.max(0, Number(abilityFieldValue(ability, 'movementDurationMs')) || 0) / 1000;
    const ghostDuration = Math.max(0, Number(abilityFieldValue(ability, 'ghostDurationMs')) || 0) / 1000;
    const shieldAmount = Math.max(0, Number(abilityFieldValue(ability, 'shieldAmount')) || 0);
    const shieldDuration = Math.max(0, Number(abilityFieldValue(ability, 'shieldDurationMs')) || 0) / 1000;

    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a radius configured.`);
      return false;
    }
    if(!(duration > 0)){
      setHudMessage(`${abilityName} needs a duration configured.`);
      return false;
    }
    if(!(tickInterval > 0)){
      setHudMessage(`${abilityName} needs a tick interval configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = typeof skillshotAimPoint === 'function' ? skillshotAimPoint() : beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const travel = maxRange > 0 ? Math.min(distance, maxRange) : distance;
    const targetX = origin.x + (dx / distance) * travel;
    const targetY = origin.y + (dy / distance) * travel;
    const safeRadius = Math.max(radius + minionRadius, 6);
    let clampedX = targetX;
    let clampedY = targetY;
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      clampedX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
      clampedY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
    }

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      castDuration,
      elapsed: 0,
      targetX: clampedX,
      targetY: clampedY,
      radius,
      duration,
      tickInterval: Math.max(0.05, tickInterval),
      tickDamage,
      movementSpeedPct,
      movementDuration,
      ghostDuration,
      shieldAmount,
      shieldDuration
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = clampedX;
    player.target.y = clampedY;
    player.navGoal = null;
    player.nav = null;

    if(castDuration <= 0){
      const deployed = deployTranquilTorrent(cast);
      return deployed ? { success: true, deferCooldown: true } : false;
    }

    tranquilTorrentCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} forms a soothing current...`);
    return { success: true, deferCooldown: true };
  }

  function updateTranquilTorrentCasts(dt){
    for(let i = tranquilTorrentCasts.length - 1; i >= 0; i--){
      const cast = tranquilTorrentCasts[i];
      if(!cast){
        tranquilTorrentCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        tranquilTorrentCasts.splice(i, 1);
        continue;
      }
      const interrupted = caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0;
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Tranquil Torrent'} interrupted.`);
        }
        tranquilTorrentCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        deployTranquilTorrent(cast);
        tranquilTorrentCasts.splice(i, 1);
      }
    }
  }

  function updateSerenityFields(dt){
    for(let i = serenityFields.length - 1; i >= 0; i--){
      const field = serenityFields[i];
      if(!field){
        serenityFields.splice(i, 1);
        continue;
      }
      field.elapsed = Math.max(0, (Number(field.elapsed) || 0) + dt);
      field.tickTimer = Math.max(0, (Number(field.tickTimer) || 0) + dt);
      applySerenityFieldPlayerBuff(field);
      const interval = Math.max(0.05, Number(field.tickInterval) || 0.25);
      while(field.tickTimer >= interval){
        field.tickTimer -= interval;
        applySerenityFieldTickDamage(field);
      }
      const duration = Math.max(0, Number(field.duration) || 0);
      if(duration > 0 && field.elapsed >= duration){
        serenityFields.splice(i, 1);
      }
    }
  }

  function drawSerenityFields(){
    if(!serenityFields.length) return;
    for(const field of serenityFields){
      if(!field) continue;
      const radius = Math.max(0, Number(field.radius) || 0);
      if(!(radius > 0)) continue;
      const x = Number.isFinite(field.x) ? field.x : player.x;
      const y = Number.isFinite(field.y) ? field.y : player.y;
      if(!circleInCamera(x, y, radius + 24)) continue;
      const duration = Math.max(0, Number(field.duration) || 0);
      const progress = duration > 0 ? Math.min(1, field.elapsed / duration) : 0;
      ctx.save();
      ctx.globalAlpha = 0.15 + 0.2 * (1 - progress);
      ctx.fillStyle = '#63d5ff';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#b0f1ff';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  function castProximityTrapAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Flame Chompers';
    const dropCountRaw = abilityFieldValue(ability, 'dropCount');
    const dropCount = Math.max(0, Math.floor(Number(dropCountRaw) || 0));
    if(dropCount <= 0){
      setHudMessage(`${abilityName} has no traps configured.`);
      return false;
    }
    const maxActiveRaw = abilityFieldValue(ability, 'maxActiveTraps');
    const maxActive = Math.max(1, Math.floor(Number(maxActiveRaw) || 0));
    const placementModeRaw = abilityFieldValue(ability, 'placementMode', { skipScaling: true });
    const spacingRaw = abilityFieldValue(ability, 'placementSpacingPx');
    const minSpacingRaw = abilityFieldValue(ability, 'minTrapSpacingPx');
    const maxRangeRaw = abilityFieldValue(ability, 'maxPlaceRangePx');
    const armDelayRaw = abilityFieldValue(ability, 'armDelayMs');
    const lifetimeRaw = abilityFieldValue(ability, 'lifetimeMs');
    const triggerRadiusRaw = abilityFieldValue(ability, 'triggerRadiusPx');
    const aoeRadiusRaw = abilityFieldValue(ability, 'aoeRadiusPx');
    const immobilizeRaw = abilityFieldValue(ability, 'immobilizeMs');
    const damageRaw = abilityFieldValue(ability, 'damage');
    const tickDamageRaw = abilityFieldValue(ability, 'tickDamage');
    const tickIntervalRaw = abilityFieldValue(ability, 'tickIntervalMs');
    const tickCountRaw = abilityFieldValue(ability, 'ticks');
    const slowPctRaw = abilityFieldValue(ability, 'slowPct');
    const slowDurationRaw = abilityFieldValue(ability, 'slowDurationMs');
    const subsequentHitPctRaw = abilityFieldValue(ability, 'subsequentHitPct');
    const rootPrimaryOnly = Number(abilityFieldValue(ability, 'rootPrimaryOnly')) > 0;
    const canTriggerByMinions = Number(abilityFieldValue(ability, 'canTriggerByMinions')) > 0;
    const showArmedRing = Number(abilityFieldValue(ability, 'showArmedRing')) > 0;
    const showTriggerRadius = Number(abilityFieldValue(ability, 'showTriggerRadius')) > 0;

    const spacing = Math.max(0, Number(spacingRaw) || 0);
    const minSpacing = Math.max(0, Number(minSpacingRaw) || 0);
    const maxRange = Math.max(0, Number(maxRangeRaw) || 0);
    const armDelay = Math.max(0, Number(armDelayRaw) || 0) / 1000;
    const lifetime = Math.max(0, Number(lifetimeRaw) || 0) / 1000;
    const triggerRadius = Math.max(0, Number(triggerRadiusRaw) || 0);
    const aoeRadius = Math.max(triggerRadius, Number(aoeRadiusRaw) || 0);
    const immobilizeSeconds = Math.max(0, Number(immobilizeRaw) || 0) / 1000;
    const damage = Math.max(0, Number(damageRaw) || 0);
    const tickDamage = Math.max(0, Number(tickDamageRaw) || 0);
    const tickIntervalSeconds = Math.max(0, Number(tickIntervalRaw) || 0) / 1000;
    const tickCount = Math.max(1, Math.floor(Number(tickCountRaw) || 0) || 1);
    const slowPct = Math.max(0, Number(slowPctRaw) || 0);
    const slowDurationSeconds = Math.max(0, Number(slowDurationRaw) || 0) / 1000;
    const subsequentHitPct = Number.isFinite(Number(subsequentHitPctRaw))
      ? Math.max(0, Math.min(100, Number(subsequentHitPctRaw)))
      : null;
    const subsequentHitMultiplier = subsequentHitPct === null ? 1 : subsequentHitPct / 100;
    const placementRevealRaw = abilityFieldValue(ability, 'placementRevealMs');
    const triggerRevealRaw = abilityFieldValue(ability, 'triggerRevealMs');
    const revealRadiusRaw = abilityFieldValue(ability, 'revealRadiusPx');
    const placementRevealSeconds = Math.max(0, Number(placementRevealRaw) || 0) / 1000;
    const triggerRevealSeconds = Math.max(0, Number(triggerRevealRaw) || 0) / 1000;
    const revealRadius = Math.max(triggerRadius, Number(revealRadiusRaw) || 0);
    const hitMemoryRaw = abilityFieldValue(ability, 'hitMemoryMs');
    const defaultHitMemoryMs = Math.round((armDelay + lifetime) * 1000);
    const hitMemoryMs = Math.max(TRAP_HIT_MEMORY_MIN_MS, Math.round(Number(hitMemoryRaw) || defaultHitMemoryMs));

    const { x: originX, y: originY } = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - originX;
    let dy = aimPoint.y - originY;
    let pointerDist = Math.hypot(dx, dy);
    if(!(pointerDist > 0.0001)){
      dx = player.target.x - originX;
      dy = player.target.y - originY;
      pointerDist = Math.hypot(dx, dy);
    }
    if(!(pointerDist > 0.0001)){
      dx = 1;
      dy = 0;
      pointerDist = 1;
    }
    const dirX = dx / pointerDist;
    const dirY = dy / pointerDist;

    const placements = computeTrapPlacements(originX, originY, dirX, dirY, pointerDist, {
      count: dropCount,
      spacing,
      minSpacing,
      maxRange,
      mode: placementModeRaw
    });

    if(!placements.length){
      setHudMessage(`${abilityName} found no valid placement points.`);
      return false;
    }

    const trapRadius = Math.max(16, triggerRadius * 0.6);
    enforceTrapSpacing(placements, minSpacing, originX, originY, trapRadius, maxRange);

    const resolvedPositions = [];
    for(const candidate of placements){
      if(!candidate) continue;
      const resolved = resolveTrapPlacement(originX, originY, candidate.x, candidate.y, trapRadius, maxRange);
      if(resolved){
        resolvedPositions.push(resolved);
      }
    }

    if(!resolvedPositions.length){
      setHudMessage(`${abilityName} could not be placed on valid terrain.`);
      return false;
    }

    while(flameChomperTraps.length + resolvedPositions.length > maxActive){
      const removed = flameChomperTraps.shift();
      if(removed){
        const removedTrigger = Math.max(0, Number(removed.triggerRadius) || 0);
        const removedRadius = Math.max(0, Number(removed.radius) || 0);
        flash(removed.x, removed.y, { startRadius: Math.max(12, removedTrigger * 0.5), endRadius: Math.max(removedTrigger, removedRadius + 24), color: '#ffbfa1' });
      }
    }

    const nowPlaced = [];
    for(const pos of resolvedPositions){
      const trap = {
        id: abilityRuntime.flameChomperSequence++,
        abilityId: ability.id,
        abilityName,
        x: pos.x,
        y: pos.y,
        radius: trapRadius,
        triggerRadius,
        aoeRadius,
        damage,
        tickDamage,
        tickInterval: tickIntervalSeconds,
        tickCount,
        slowPct,
        slowDuration: slowDurationSeconds,
        rootDuration: immobilizeSeconds,
        rootPrimaryOnly,
        canTriggerByMinions,
        showArmedRing,
        showTriggerRadius,
        placementRevealDuration: placementRevealSeconds,
        triggerRevealDuration: triggerRevealSeconds,
        revealRadius,
        armDelay,
        lifeAfterArm: lifetime,
        maxAge: armDelay + lifetime,
        age: 0,
        armed: armDelay <= 0,
        owner: player,
        spawnOrder: abilityRuntime.flameChomperSequence,
        justPlaced: true,
        destructible: ability.id === 'toxic_mine',
        subsequentHitMultiplier,
        hitMemoryMs
      };
      flameChomperTraps.push(trap);
      nowPlaced.push(trap);
      flash(trap.x, trap.y, { startRadius: Math.max(8, trap.radius * 0.6), endRadius: Math.max(trap.triggerRadius, trap.radius + 28), color: '#ffcc7a' });
      if(trap.placementRevealDuration > 0 && trap.revealRadius > 0){
        spawnTrapVisionSource(trap.x, trap.y, trap.revealRadius, trap.placementRevealDuration);
      }
    }

    cancelPlayerAttack(false);

    const placedCount = nowPlaced.length;
    const plural = placedCount === 1 ? '' : 's';
    setHudMessage(`${abilityName} deployed ${placedCount} trap${plural}.`);
    return true;
  }

  function spawnTemporalVisionSource(x, y, radius, duration){
    if(!(radius > 0) || !(duration > 0)) return null;
    const entry = {
      id: GameState.player.vision.nextId++,
      type: 'circle',
      mode: 1,
      x,
      y,
      radius,
      length: radius * 2,
      angle: 0,
      autoVision: true
    };
    ensureVisionConsistency(entry);
    customVisionSources.push(entry);
    temporalVeilVisionSources.push({ entry, remaining: duration });
    return entry;
  }

  function removeTemporalVisionSource(entry){
    if(!entry) return;
    const idx = customVisionSources.indexOf(entry);
    if(idx >= 0){
      customVisionSources.splice(idx, 1);
    }
    if(GameState.player.vision.selectedId === entry.id){
      GameState.player.vision.selectedId = null;
    }
  }

  function updateTemporalVisionSources(dt){
    if(!temporalVeilVisionSources.length) return;
    for(let i = temporalVeilVisionSources.length - 1; i >= 0; i--){
      const record = temporalVeilVisionSources[i];
      if(!record){
        temporalVeilVisionSources.splice(i, 1);
        continue;
      }
      record.remaining = Math.max(0, (record.remaining || 0) - dt);
      if(record.remaining <= 0){
        removeTemporalVisionSource(record.entry);
        temporalVeilVisionSources.splice(i, 1);
      }
    }
  }

  function detonateTemporalVeil(cast){
    if(!cast){
      return;
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const abilityName = cast.abilityName || 'Temporal Veil';
    const centerX = Number.isFinite(cast.destX) ? cast.destX : cast.originX;
    const centerY = Number.isFinite(cast.destY) ? cast.destY : cast.originY;
    const radius = Math.max(0, Number(cast.radius) || 0);
    const stunDuration = Math.max(0, Number(cast.stunDuration) || 0);
    const revealDuration = Math.max(0, Number(cast.revealDuration) || 0);
    if(radius > 0 && revealDuration > 0){
      spawnTemporalVisionSource(centerX, centerY, radius, revealDuration);
    }
    if(radius > 0){
      flash(centerX, centerY, { startRadius: Math.max(16, radius * 0.35), endRadius: Math.max(radius + 36, 64), color: '#9fe8ff' });
    }
    let hits = 0;
    const minionEffective = radius + minionRadius;
    const minionSq = minionEffective * minionEffective;
    if(stunDuration > 0){
      for(const m of minions){
        if(!m || !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const dx = m.x - centerX;
        const dy = m.y - centerY;
        if(dx * dx + dy * dy <= minionSq){
          const existing = Number(m.stunTimer) || 0;
          m.stunTimer = Math.max(existing, stunDuration);
          hits++;
        }
      }
      const monster = monsterState;
      if(monster && isMonsterAttackable(monster)){
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
        const effective = radius + monsterRadius;
        const distSq = (monster.x - centerX) ** 2 + (monster.y - centerY) ** 2;
        if(distSq <= effective * effective){
          const existing = Number(monster.stunTimer) || 0;
          monster.stunTimer = Math.max(existing, stunDuration);
          hits++;
        }
      }
      const turretList = ensureTurrets();
      const turretEffective = radius + 24;
      const turretSq = turretEffective * turretEffective;
      for(const turret of turretList){
        if(!turret || turret.side === player.team) continue;
        const dx = turret.x - centerX;
        const dy = turret.y - centerY;
        if(dx * dx + dy * dy <= turretSq){
          turret.stunTimer = Math.max(Number(turret.stunTimer) || 0, stunDuration);
          hits++;
        }
      }
    }
    if(cast.casterRef === player){
      if(hits > 0){
        const targetText = hits === 1 ? '1 target' : `${hits} targets`;
        setHudMessage(`${abilityName} locked ${targetText} in stasis.`);
      } else {
        setHudMessage(`${abilityName} landed but hit nothing.`);
      }
    }
  }

  function castTemporalVeilAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Temporal Veil';
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const effectRadius = Math.max(0, Number(abilityFieldValue(ability, 'aoeRadiusPx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'travelSpeedPxS')) || 0);
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const trailRadius = Math.max(0, Number(abilityFieldValue(ability, 'trailRadiusPx')) || 0);
    const trailSpacing = Math.max(1, Number(abilityFieldValue(ability, 'trailSpacingPx')) || 200);
    const trailDuration = Math.max(0, Number(abilityFieldValue(ability, 'trailDurationMs')) || 1200) / 1000;
    const stunDuration = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;
    const revealDuration = Math.max(0, Number(abilityFieldValue(ability, 'revealDurationMs')) || 0) / 1000;
    if(!(effectRadius > 0)){
      setHudMessage(`${abilityName} needs an impact radius configured.`);
      return false;
    }
    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a cast range configured.`);
      return false;
    }
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs an arc speed configured.`);
      return false;
    }
    if(!(stunDuration > 0)){
      setHudMessage(`${abilityName} needs a stasis duration configured.`);
      return false;
    }
    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const clamped = maxRange > 0 ? Math.min(maxRange, distance) : distance;
    let destX = origin.x + dx / distance * clamped;
    let destY = origin.y + dy / distance * clamped;
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
      destX = clampCoord(destX, mapState.width);
      destY = clampCoord(destY, mapState.height);
    }
    const actualDx = destX - origin.x;
    const actualDy = destY - origin.y;
    const actualDistance = Math.hypot(actualDx, actualDy);
    const dirX = actualDistance > 0 ? actualDx / actualDistance : (dx / distance);
    const dirY = actualDistance > 0 ? actualDy / actualDistance : (dy / distance);
    const cast = {
      id: `temporal-${abilityRuntime.temporalVeilSequence++}`,
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      originX: origin.x,
      originY: origin.y,
      destX,
      destY,
      dirX,
      dirY,
      maxDistance: actualDistance,
      speed,
      distanceTraveled: 0,
      currentX: origin.x,
      currentY: origin.y,
      radius: effectRadius,
      stunDuration,
      revealDuration,
      trailRadius,
      trailSpacing,
      trailDuration,
      nextPulseDistance: trailSpacing,
      castDuration: castTime,
      castElapsed: 0,
      state: castTime > 0 ? 'windup' : 'flying'
    };
    spawnTemporalVisionSource(origin.x, origin.y, trailRadius, trailDuration);
    temporalVeilCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    flash(origin.x, origin.y, { startRadius: 8, endRadius: 26, color: '#9fe8ff' });
    if(cast.state === 'windup'){
      setHudMessage(`${abilityName} gathering fate...`);
      return true;
    }
    player.casting = null;
    setHudMessage(`${abilityName} launched!`);
    return true;
  }

  function updateTemporalVeilCasts(dt){
    if(!temporalVeilCasts.length) return;
    for(let i = temporalVeilCasts.length - 1; i >= 0; i--){
      const cast = temporalVeilCasts[i];
      if(!cast){
        temporalVeilCasts.splice(i, 1);
        continue;
      }
      if(cast.state === 'windup'){
        cast.castElapsed = Math.min(cast.castDuration, (cast.castElapsed || 0) + dt);
        if(cast.castElapsed >= cast.castDuration){
          cast.state = 'flying';
          if(cast.casterRef === player && player.casting === cast){
            player.casting = null;
          }
          setHudMessage(`${cast.abilityName || 'Temporal Veil'} launched!`);
        }
        continue;
      }
      const speed = Math.max(0, Number(cast.speed) || 0);
      const distance = Math.max(0, Number(cast.maxDistance) || 0);
      if(!(distance > 0) || !(speed > 0)){
        detonateTemporalVeil(cast);
        temporalVeilCasts.splice(i, 1);
        continue;
      }
      const prevDistance = Math.max(0, Number(cast.distanceTraveled) || 0);
      let nextDistance = Math.min(distance, prevDistance + speed * dt);
      cast.distanceTraveled = nextDistance;
      cast.currentX = cast.originX + cast.dirX * nextDistance;
      cast.currentY = cast.originY + cast.dirY * nextDistance;
      while(cast.trailSpacing > 0 && cast.nextPulseDistance <= nextDistance){
        const pulseX = cast.originX + cast.dirX * cast.nextPulseDistance;
        const pulseY = cast.originY + cast.dirY * cast.nextPulseDistance;
        spawnTemporalVisionSource(pulseX, pulseY, cast.trailRadius, cast.trailDuration);
        cast.nextPulseDistance += cast.trailSpacing;
        if(cast.nextPulseDistance > distance){
          break;
        }
      }
      if(nextDistance >= distance - 0.0001){
        detonateTemporalVeil(cast);
        temporalVeilCasts.splice(i, 1);
      }
    }
  }

  function applyMoonlightReveal(target, radius, duration){
    if(!target || !(duration > 0)) return;
    const revealRadius = Math.max(0, Number(radius) || 0);
    const revealDuration = Math.max(0, Number(duration) || 0);
    if(revealRadius > 0 && revealDuration > 0){
      registerScoutflareChampionReveal(target, revealRadius, revealDuration);
    }
    target.moonlightTimer = Math.max(target.moonlightTimer || 0, revealDuration);
  }

  function setMoonlitArcPosition(cast, traveled){
    if(!cast) return;
    const dirX = Number(cast.dirX) || 1;
    const dirY = Number(cast.dirY) || 0;
    const baseX = Number(cast.originX) || player.x;
    const baseY = Number(cast.originY) || player.y;
    const distance = Math.max(0, Number(cast.travelDistance) || 0);
    const arcRadius = Math.max(0, Number(cast.arcRadius) || 0);
    const progress = distance > 0 ? Math.max(0, Math.min(1, traveled / distance)) : 0;
    const theta = Math.PI * progress;
    const offset = arcRadius * Math.sin(theta);
    const perpX = Number(cast.perpX) || -dirY;
    const perpY = Number(cast.perpY) || dirX;
    cast.currentX = baseX + dirX * traveled + perpX * offset;
    cast.currentY = baseY + dirY * traveled + perpY * offset;
  }

  function applyMoonlitArcCooldown(cast){
    if(!cast || cast.cooldownApplied) return;
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    cast.cooldownApplied = true;
  }

  function applyMoonlitArcImpact(cast){
    if(!cast) return;
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const abilityName = cast.abilityName || 'Moonlit Arc';
    const centerX = Number.isFinite(cast.targetX)
      ? cast.targetX
      : (Number.isFinite(cast.currentX) ? cast.currentX : Number(cast.originX) || player.x);
    const centerY = Number.isFinite(cast.targetY)
      ? cast.targetY
      : (Number.isFinite(cast.currentY) ? cast.currentY : Number(cast.originY) || player.y);
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const revealRadius = Math.max(0, Number(cast.revealRadius) || 0);
    const revealDuration = Math.max(0, Number(cast.revealDuration) || 0);
    const moonlightDuration = Math.max(0, Number(cast.moonlightDuration) || 0);
    const moonlightRadius = Math.max(radius, Math.max(0, Number(cast.moonlightRadius) || 0));

    if(revealRadius > 0 && revealDuration > 0){
      spawnTemporalVisionSource(centerX, centerY, revealRadius, revealDuration);
    }
    flash(centerX, centerY, { startRadius: 12, endRadius: Math.max(radius + 32, 48), color: '#b4d6ff' });
    let hits = 0;
    const minionEffective = radius + minionRadius;
    const minionSq = minionEffective * minionEffective;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > minionSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      applyMoonlightReveal(m, moonlightRadius, moonlightDuration);
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }
    const monster = monsterState;
    if(monster && isMonsterAttackable(monster)){
      const monsterRadiusValue = Math.max(minionRadius, monsterAttackRadius(monster));
      const monsterEffective = radius + monsterRadiusValue;
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      if(dx * dx + dy * dy <= monsterEffective * monsterEffective){
        const prevHp = Number(monster.hp) || 0;
        if(damage > 0){
          monster.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monster.x, monster.y - monsterRadiusValue, damage);
        }
        applyMoonlightReveal(monster, moonlightRadius, moonlightDuration);
        hits += 1;
      }
    }
    if(cast.casterRef === player){
      if(hits > 0){
        const targetText = hits === 1 ? '1 enemy' : `${hits} enemies`;
        setHudMessage(`${abilityName} burst ${targetText}!`);
      } else {
        setHudMessage(`${abilityName} burst but hit nothing.`);
      }
    }
  }

  function castMoonlitArcAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Moonlit Arc';
    const castTimeMs = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0);
    const castDuration = castTimeMs / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const revealRadius = Math.max(0, Number(abilityFieldValue(ability, 'revealRadiusPx')) || 0);
    const revealDuration = Math.max(0, Number(abilityFieldValue(ability, 'revealDurationMs')) || 0) / 1000;
    const moonlightRadius = Math.max(Math.max(0, Number(abilityFieldValue(ability, 'moonlightRevealRadiusPx')) || 0), impactRadius);
    const moonlightDuration = Math.max(0, Number(abilityFieldValue(ability, 'moonlightDurationMs')) || 0) / 1000;
    const arcRadius = Math.max(0, Number(abilityFieldValue(ability, 'arcRadiusPx')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const cooldownSeconds = abilityCooldownSeconds(ability);

    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a target range.`);
      return false;
    }
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a travel speed.`);
      return false;
    }
    if(!(impactRadius > 0)){
      setHudMessage(`${abilityName} needs an impact radius.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const aimDirX = dx / distance;
    const aimDirY = dy / distance;
    let travelDistance = Math.min(range, distance);
    let targetX = origin.x + aimDirX * travelDistance;
    let targetY = origin.y + aimDirY * travelDistance;
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
      targetX = clampCoord(targetX, mapState.width);
      targetY = clampCoord(targetY, mapState.height);
    }
    const finalDx = targetX - origin.x;
    const finalDy = targetY - origin.y;
    const finalDistance = Math.hypot(finalDx, finalDy);
    const dirX = finalDistance > 0 ? finalDx / finalDistance : aimDirX;
    const dirY = finalDistance > 0 ? finalDy / finalDistance : aimDirY;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      originX: origin.x,
      originY: origin.y,
      targetX,
      targetY,
      dirX,
      dirY,
      travelDistance: Math.max(0, finalDistance),
      speed,
      impactRadius,
      damage,
      revealRadius,
      revealDuration,
      moonlightDuration,
      moonlightRadius,
      arcRadius,
      projectileWidth: projectileWidth > 0 ? projectileWidth : 18,
      castDuration,
      castElapsed: 0,
      state: castDuration > 0 ? 'windup' : 'flying',
      traveled: 0,
      currentX: origin.x,
      currentY: origin.y,
      perpX: -dirY,
      perpY: dirX,
      cooldownSeconds,
      cooldownApplied: false
    };

    moonlitArcCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'windup'){
      player.casting = cast;
      setHudMessage(`${abilityName} drawing lunar light...`);
      return true;
    }

    applyMoonlitArcCooldown(cast);
    setHudMessage(`${abilityName} launched!`);
    return true;
  }

  function updateMoonlitArcCasts(dt){
    if(!moonlitArcCasts.length) return;
    for(let i = moonlitArcCasts.length - 1; i >= 0; i--){
      const cast = moonlitArcCasts[i];
      if(!cast){
        moonlitArcCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Moonlit Arc'} interrupted.`);
        }
        moonlitArcCasts.splice(i, 1);
        continue;
      }
      if(cast.state === 'windup'){
        cast.castElapsed = Math.min(cast.castDuration, (cast.castElapsed || 0) + dt);
        if(cast.castElapsed >= cast.castDuration){
          cast.state = 'flying';
          applyMoonlitArcCooldown(cast);
          if(caster === player && player.casting === cast){
            player.casting = null;
            setHudMessage(`${cast.abilityName || 'Moonlit Arc'} launched!`);
          }
        }
        continue;
      }
      applyMoonlitArcCooldown(cast);
      const distance = Math.max(0, Number(cast.travelDistance) || 0);
      const speed = Math.max(0, Number(cast.speed) || 0);
      if(!(distance > 0) || !(speed > 0)){
        setMoonlitArcPosition(cast, distance);
        applyMoonlitArcImpact(cast);
        moonlitArcCasts.splice(i, 1);
        continue;
      }
      const traveled = Math.max(0, Number(cast.traveled) || 0);
      let next = traveled + speed * dt;
      if(next >= distance - 0.0001){
        setMoonlitArcPosition(cast, distance);
        applyMoonlitArcImpact(cast);
        moonlitArcCasts.splice(i, 1);
        continue;
      }
      cast.traveled = next;
      setMoonlitArcPosition(cast, next);
    }
  }

  function castScatterChargeAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Scatter Charge';
    const existing = scatterCharges.find(charge => charge && !charge.detonated && charge.casterRef === player && charge.abilityId === ability.id);
    if(existing){
      if(existing.state === 'flying'){
        if(existing.detonateOnLanding){
          setHudMessage(`${abilityName} already primed to detonate on landing.`);
        } else {
          existing.detonateOnLanding = true;
          setHudMessage(`${abilityName} will detonate on landing.`);
        }
        return { success: true, deferCooldown: true };
      }
      if(existing.state === 'armed'){
        const detonated = detonateScatterCharge(existing, { cause: 'recast' });
        return detonated ? { success: true, deferCooldown: true } : false;
      }
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const fuseSeconds = Math.max(0, Number(abilityFieldValue(ability, 'chargeLifetimeMs')) || 0) / 1000;
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'aoeRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const knockbackMax = Math.max(0, Number(abilityFieldValue(ability, 'knockbackMaxPx')) || 0);
    const selfDashMax = Math.max(0, Number(abilityFieldValue(ability, 'selfDashMaxPx')) || 0);

    if(!(projectileSpeed > 0)){
      setHudMessage(`${abilityName} needs a throw speed configured.`);
      return false;
    }
    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a throw range configured.`);
      return false;
    }
    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a blast radius configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const clampedDistance = Math.min(distance, maxRange);
    const destX = origin.x + dirX * clampedDistance;
    const destY = origin.y + dirY * clampedDistance;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      castDuration: castTime,
      elapsed: 0,
      allowMovementWhileCasting: true,
      originX: origin.x,
      originY: origin.y,
      destX,
      destY,
      dirX,
      dirY,
      maxRange,
      projectileSpeed,
      fuseSeconds,
      radius,
      damage,
      knockbackMax,
      selfDashMax
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    player.target.x = player.x;
    player.target.y = player.y;

    if(cast.castDuration <= 0){
      const launched = launchScatterCharge(cast);
      return launched ? { success: true, deferCooldown: true } : false;
    }

    scatterChargeCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} priming...`);
    return { success: true, deferCooldown: true };
  }

  function launchScatterCharge(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const abilityName = cast.abilityName || 'Scatter Charge';
    const originX = Number.isFinite(cast.originX) ? cast.originX : (caster.x || 0);
    const originY = Number.isFinite(cast.originY) ? cast.originY : (caster.y || 0);
    let dx = (Number.isFinite(cast.destX) ? cast.destX : originX) - originX;
    let dy = (Number.isFinite(cast.destY) ? cast.destY : originY) - originY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = Number.isFinite(cast.dirX) ? cast.dirX : 1;
      dy = Number.isFinite(cast.dirY) ? cast.dirY : 0;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const travelDistance = Math.max(0, Math.min(distance, Number(cast.maxRange) || 0));
    const speed = Math.max(0, Number(cast.projectileSpeed) || 0);
    const charge = {
      id: abilityRuntime.scatterChargeSequence++,
      abilityId: cast.abilityId,
      abilityName,
      slotIndex: cast.slotIndex,
      casterRef: caster,
      startX: originX,
      startY: originY,
      destX: originX + dirX * travelDistance,
      destY: originY + dirY * travelDistance,
      dirX,
      dirY,
      travelDistance,
      speed,
      radius: Math.max(0, Number(cast.radius) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      knockbackMax: Math.max(0, Number(cast.knockbackMax) || 0),
      selfDashMax: Math.max(0, Number(cast.selfDashMax) || 0),
      lifetime: Math.max(0, Number(cast.fuseSeconds) || 0),
      age: 0,
      traveled: 0,
      state: speed > 0 && travelDistance > 0 ? 'flying' : 'armed',
      detonateOnLanding: false,
      cooldownSeconds: cast.cooldownSeconds,
      cooldownApplied: false
    };
    charge.currentX = charge.startX;
    charge.currentY = charge.startY;
    if(charge.state === 'armed'){
      charge.currentX = charge.destX;
      charge.currentY = charge.destY;
    }
    scatterCharges.push(charge);
    if(caster === player && player.casting === cast){
      player.casting = null;
    }
    setHudMessage(`${abilityName} tossed! Recast to detonate early.`);
    flash(charge.startX, charge.startY, { startRadius: 10, endRadius: 28, color: '#ffd27a' });
    if(charge.state === 'armed' && charge.lifetime <= 0){
      detonateScatterCharge(charge, { cause: 'landing' });
    }
    return true;
  }

  function castSkywardScoutAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Skyward Scout';
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const effectRadius = Math.max(0, Number(abilityFieldValue(ability, 'visionRadiusPx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'speedPxS')) || 0);
    const pulseSpacing = Math.max(1, Number(abilityFieldValue(ability, 'pulseSpacingPx')) || 100);
    const pulseDuration = Math.max(0, Number(abilityFieldValue(ability, 'pulseDurationMs')) || 500) / 1000;
    const destinationDuration = Math.max(0, Number(abilityFieldValue(ability, 'destinationDurationMs')) || 5000) / 1000;
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const maxCharges = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'maxCharges')) || 2));
    const rechargeSeconds = Math.max(0, Number(abilityFieldValue(ability, 'chargeRechargeMs')) || 90000) / 1000;
    if(!(effectRadius > 0)){
      setHudMessage(`${abilityName} needs a vision radius configured.`);
      return false;
    }
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a flight speed configured.`);
      return false;
    }
    const state = skyScoutChargeState;
    state.maxCharges = maxCharges;
    state.charges = Math.min(maxCharges, Math.max(0, Number(state.charges) || maxCharges));
    if(!(state.charges > 0)){
      setHudMessage(`${abilityName} has no charges ready.`);
      return false;
    }
    state.charges = Math.max(0, state.charges - 1);
    state.rechargeTimer = rechargeSeconds;
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    let travelDistance = distance;
    if(maxRange > 0){
      travelDistance = Math.min(travelDistance, maxRange);
    }
    const rawDestX = origin.x + dirX * travelDistance;
    const rawDestY = origin.y + dirY * travelDistance;
    const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
    const destX = clampCoord(rawDestX, mapState.width);
    const destY = clampCoord(rawDestY, mapState.height);
    if(!(travelDistance > 0)){
      spawnSkyScoutVisionSource(origin.x, origin.y, effectRadius, destinationDuration);
      flash(origin.x, origin.y, { startRadius: Math.max(8, effectRadius * 0.4), endRadius: Math.max(24, effectRadius), color: '#7fe3ff' });
      setHudMessage(`${abilityName} scouted the nearby sky.`);
      return true;
    }
    const flight = {
      id: `sky-${abilityRuntime.skyScoutSequence++}`,
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      startX: origin.x,
      startY: origin.y,
      destX,
      destY,
      dirX,
      dirY,
      speed,
      maxDistance: travelDistance,
      distanceTraveled: 0,
      currentX: origin.x,
      currentY: origin.y,
      pulseSpacing,
      nextPulseDistance: pulseSpacing,
      effectRadius,
      pulseDuration,
      destinationDuration
    };
    skyScoutFlights.push(flight);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    player.target.x = player.x;
    player.target.y = player.y;
    flash(origin.x, origin.y, { startRadius: 8, endRadius: 24, color: '#7fe3ff' });
    setHudMessage(`${abilityName} launched (${state.charges}/${state.maxCharges} charges).`);
    return true;
  }

  function createTemporaryVisionEntry(x, y, radius){
    if(!(radius > 0)) return null;
    return {
      id: GameState.player.vision.nextId++,
      type: 'circle',
      mode: 1,
      x,
      y,
      radius,
      length: radius * 2,
      angle: 0,
      autoVision: true
    };
  }

  function registerTemporaryVisionSource(entry, duration, tracker){
    if(!entry || !(duration > 0) || !Array.isArray(tracker)) return null;
    ensureVisionConsistency(entry);
    customVisionSources.push(entry);
    tracker.push({ entry, lifetime: duration });
    return entry;
  }

  function removeTemporaryVisionSource(entry){
    if(!entry) return;
    const idx = customVisionSources.indexOf(entry);
    if(idx >= 0){
      customVisionSources.splice(idx, 1);
    }
    if(GameState.player.vision.selectedId === entry.id){
      GameState.player.vision.selectedId = null;
    }
  }

  function spawnSkyScoutVisionSource(x, y, radius, duration){
    if(!(radius > 0) || !(duration > 0)) return null;
    const entry = createTemporaryVisionEntry(x, y, radius);
    return registerTemporaryVisionSource(entry, duration, skyScoutVisionSources);
  }

  function applyPlasmaStacks(target, stacks, duration){
    if(!target || !(stacks > 0)) return 0;
    const stacksToAdd = Math.max(0, Math.floor(Number(stacks) || 0));
    if(stacksToAdd <= 0) return 0;
    const existing = Math.max(0, Number(target.plasmaStacks) || 0);
    target.plasmaStacks = existing + stacksToAdd;
    const timer = Math.max(0, Number(duration) || 0);
    if(timer > 0){
      target.plasmaTimer = Math.max(target.plasmaTimer || 0, timer);
    }
    return stacksToAdd;
  }

  function spawnTrapVisionSource(x, y, radius, duration){
    if(!(radius > 0) || !(duration > 0)) return null;
    const entry = createTemporaryVisionEntry(x, y, radius);
    return registerTemporaryVisionSource(entry, duration, trapVisionSources);
  }

  function removeSkyScoutVisionSource(entry){
    removeTemporaryVisionSource(entry);
  }

  function completeSkyScoutFlight(flight){
    if(!flight) return;
    const radius = Math.max(0, Number(flight.effectRadius) || 0);
    const duration = Math.max(0, Number(flight.destinationDuration) || 0);
    spawnSkyScoutVisionSource(flight.destX, flight.destY, radius, duration);
    flash(flight.destX, flight.destY, { startRadius: Math.max(10, radius * 0.35), endRadius: Math.max(24, radius + 12), color: '#7fe3ff' });
  }

  function updateSkyScoutFlights(dt){
    if(!skyScoutFlights.length) return;
    for(let i = skyScoutFlights.length - 1; i >= 0; i--){
      const flight = skyScoutFlights[i];
      if(!flight){
        skyScoutFlights.splice(i, 1);
        continue;
      }
      const previousDistance = Math.max(0, Number(flight.distanceTraveled) || 0);
      const speed = Math.max(0, Number(flight.speed) || 0);
      let nextDistance = previousDistance + speed * dt;
      const maxDistance = Math.max(0, Number(flight.maxDistance) || 0);
      if(maxDistance > 0){
        nextDistance = Math.min(nextDistance, maxDistance);
      }
      flight.distanceTraveled = nextDistance;
      flight.currentX = flight.startX + flight.dirX * nextDistance;
      flight.currentY = flight.startY + flight.dirY * nextDistance;
      while(flight.pulseSpacing > 0 && flight.nextPulseDistance <= nextDistance){
        const px = flight.startX + flight.dirX * flight.nextPulseDistance;
        const py = flight.startY + flight.dirY * flight.nextPulseDistance;
        spawnSkyScoutVisionSource(px, py, flight.effectRadius, flight.pulseDuration);
        flight.nextPulseDistance += flight.pulseSpacing;
        if(maxDistance > 0 && flight.nextPulseDistance > maxDistance){
          break;
        }
      }
      if(maxDistance > 0 && nextDistance >= maxDistance - 0.0001){
        completeSkyScoutFlight(flight);
        skyScoutFlights.splice(i, 1);
      }
    }
  }

  function updateSkyScoutVisionSources(dt){
    if(!skyScoutVisionSources.length) return;
    for(let i = skyScoutVisionSources.length - 1; i >= 0; i--){
      const record = skyScoutVisionSources[i];
      if(!record || !record.entry){
        skyScoutVisionSources.splice(i, 1);
        continue;
      }
      record.lifetime = Math.max(0, (Number(record.lifetime) || 0) - dt);
      if(record.lifetime <= 0){
        removeSkyScoutVisionSource(record.entry);
        skyScoutVisionSources.splice(i, 1);
      }
    }
  }

  function updateTrapVisionSources(dt){
    if(!trapVisionSources.length) return;
    for(let i = trapVisionSources.length - 1; i >= 0; i--){
      const record = trapVisionSources[i];
      if(!record || !record.entry){
        trapVisionSources.splice(i, 1);
        continue;
      }
      record.lifetime = Math.max(0, (Number(record.lifetime) || 0) - dt);
      if(record.lifetime <= 0){
        removeTemporaryVisionSource(record.entry);
        trapVisionSources.splice(i, 1);
      }
    }
  }

  function spawnScoutflareVisionSource(x, y, radius, duration){
    if(!(radius > 0) || !(duration > 0)) return null;
    const entry = createTemporaryVisionEntry(x, y, radius);
    return registerTemporaryVisionSource(entry, duration, scoutflareVisionSources);
  }

  function updateScoutflareVisionSources(dt){
    if(!scoutflareVisionSources.length) return;
    for(let i = scoutflareVisionSources.length - 1; i >= 0; i--){
      const record = scoutflareVisionSources[i];
      if(!record || !record.entry){
        scoutflareVisionSources.splice(i, 1);
        continue;
      }
      record.lifetime = Math.max(0, (Number(record.lifetime) || 0) - dt);
      if(record.lifetime <= 0){
        removeTemporaryVisionSource(record.entry);
        scoutflareVisionSources.splice(i, 1);
      }
    }
  }

  function registerScoutflareChampionReveal(target, radius, duration){
    if(!target || !(radius > 0) || !(duration > 0)) return null;
    const entry = createTemporaryVisionEntry(Number(target.x) || 0, Number(target.y) || 0, radius);
    if(!entry) return null;
    const existing = scoutflareRevealRecords.find(record => record && record.target === target);
    if(existing){
      existing.remaining = Math.max(Number(existing.remaining) || 0, duration);
      existing.radius = Math.max(Number(existing.radius) || 0, radius);
      if(existing.entry){
        existing.entry.radius = Math.max(Number(existing.entry.radius) || 0, radius);
        if(!customVisionSources.includes(existing.entry)){
          customVisionSources.push(existing.entry);
        }
      }
      return existing;
    }
    ensureVisionConsistency(entry);
    customVisionSources.push(entry);
    const record = { target, entry, radius, remaining: duration };
    scoutflareRevealRecords.push(record);
    return record;
  }

  function updateScoutflareRevealRecords(dt){
    if(!scoutflareRevealRecords.length) return;
    for(let i = scoutflareRevealRecords.length - 1; i >= 0; i--){
      const record = scoutflareRevealRecords[i];
      const target = record && record.target;
      const entry = record && record.entry;
      if(!record || !target || !entry){
        if(entry){
          removeTemporaryVisionSource(entry);
        }
        scoutflareRevealRecords.splice(i, 1);
        continue;
      }
      entry.x = Number.isFinite(target.x) ? target.x : entry.x;
      entry.y = Number.isFinite(target.y) ? target.y : entry.y;
      entry.radius = Math.max(0, Number(record.radius) || 0);
      ensureVisionConsistency(entry);
      record.remaining = Math.max(0, (Number(record.remaining) || 0) - dt);
      if(record.remaining <= 0){
        removeTemporaryVisionSource(entry);
        scoutflareRevealRecords.splice(i, 1);
      }
    }
  }

  function updateSkyScoutCharges(dt){
    const ability = getAbilityDefinition('skyward_scout');
    if(!ability) return;
    const maxCharges = Math.max(1, Math.round(Number(abilityFieldValue(ability, 'maxCharges')) || 2));
    const rechargeSeconds = Math.max(0, Number(abilityFieldValue(ability, 'chargeRechargeMs')) || 90000) / 1000;
    skyScoutChargeState.maxCharges = maxCharges;
    skyScoutChargeState.charges = Math.min(maxCharges, Math.max(0, Number(skyScoutChargeState.charges) || maxCharges));
    if(skyScoutChargeState.charges >= maxCharges){
      skyScoutChargeState.rechargeTimer = 0;
      return;
    }
    if(rechargeSeconds <= 0){
      skyScoutChargeState.charges = maxCharges;
      skyScoutChargeState.rechargeTimer = 0;
      return;
    }
    const previousCharges = Number(skyScoutChargeState.charges) || 0;
    skyScoutChargeState.rechargeTimer = Math.max(0, (Number(skyScoutChargeState.rechargeTimer) || rechargeSeconds) - dt);
    if(skyScoutChargeState.rechargeTimer > 0) return;
    if(previousCharges >= maxCharges) return;
    skyScoutChargeState.charges = Math.min(maxCharges, previousCharges + 1);
    skyScoutChargeState.rechargeTimer = skyScoutChargeState.charges < maxCharges ? rechargeSeconds : 0;
    if(skyScoutChargeState.charges > previousCharges){
      const label = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Skyward Scout';
      const plural = skyScoutChargeState.charges === 1 ? '' : 's';
      setHudMessage(`${label} ready — ${skyScoutChargeState.charges}/${maxCharges} charge${plural}.`);
    }
  }

  function completeScatterCharge(charge, { reason = 'complete', message = null } = {}){
    if(!charge) return;
    if(!charge.cooldownApplied && Number.isFinite(charge.slotIndex)){
      const cooldownSeconds = Math.max(0, Number(charge.cooldownSeconds) || 0);
      setAbilitySlotCooldown(charge.slotIndex, cooldownSeconds);
      charge.cooldownApplied = true;
    }
    const idx = scatterCharges.indexOf(charge);
    if(idx >= 0){
      scatterCharges.splice(idx, 1);
    }
    if(charge.casterRef === player && message){
      setHudMessage(message);
    }
  }

  function detonateScatterCharge(charge, { cause = 'manual' } = {}){
    if(!charge || charge.detonated) return false;
    charge.detonated = true;
    const abilityName = charge.abilityName || 'Scatter Charge';
    const centerX = Number.isFinite(charge.currentX) ? charge.currentX : (Number.isFinite(charge.destX) ? charge.destX : player.x);
    const centerY = Number.isFinite(charge.currentY) ? charge.currentY : (Number.isFinite(charge.destY) ? charge.destY : player.y);
    const radius = Math.max(0, Number(charge.radius) || 0);
    const damage = Math.max(0, Number(charge.damage) || 0);
    const knockbackMax = Math.max(0, Number(charge.knockbackMax) || 0);
    const selfDashMax = Math.max(0, Number(charge.selfDashMax) || 0);
    let hits = 0;

    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const maxRadius = radius + targetRadius;
      if(dx * dx + dy * dy > maxRadius * maxRadius) continue;
      const distance = Math.hypot(dx, dy);
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      if(knockbackMax > 0){
        const push = Math.max(0, knockbackMax - distance);
        if(push > 0){
          const dirX = distance > 0.0001 ? dx / distance : 1;
          const dirY = distance > 0.0001 ? dy / distance : 0;
          const moved = moveCircleWithCollision(m.x, m.y, dirX * push, dirY * push, targetRadius);
          m.x = Math.max(targetRadius, Math.min(mapState.width - targetRadius, moved.x));
          m.y = Math.max(targetRadius, Math.min(mapState.height - targetRadius, moved.y));
        }
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }

    const playerRadius = Math.max(player.r, typeof getPlayerHurtRadius === 'function' ? getPlayerHurtRadius() : player.r);
    const dxPlayer = player.x - centerX;
    const dyPlayer = player.y - centerY;
    const playerDistance = Math.hypot(dxPlayer, dyPlayer);
    if(playerDistance <= radius + playerRadius && selfDashMax > 0){
      if(!(player.stunTimer > 0 || player.knockupTimer > 0 || player.polymorphTimer > 0)){
        const push = Math.max(0, selfDashMax - playerDistance);
        if(push > 0){
          const dirX = playerDistance > 0.0001 ? dxPlayer / playerDistance : 1;
          const dirY = playerDistance > 0.0001 ? dyPlayer / playerDistance : 0;
          const moved = moveCircleWithCollision(player.x, player.y, dirX * push, dirY * push, player.r);
          player.x = Math.max(player.r, Math.min(mapState.width - player.r, moved.x));
          player.y = Math.max(player.r, Math.min(mapState.height - player.r, moved.y));
        }
      }
    }

    flash(centerX, centerY, { startRadius: Math.max(12, radius * 0.6), endRadius: Math.max(radius + 48, knockbackMax * 0.4 + radius), color: '#ffe29f' });
    if(charge.casterRef === player){
      const plural = hits === 1 ? '' : 's';
      const dmgText = hits > 0 && damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      const message = hits > 0
        ? `${abilityName} detonated hitting ${hits} target${plural}${dmgText}.`
        : `${abilityName} detonated.`;
      setHudMessage(message);
    }
    completeScatterCharge(charge, { reason: cause });
    return true;
  }

  function castSpringquakeStompAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Springquake Stomp';
    const existing = springquakeCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id && !cast.ended);
    if(existing){
      setHudMessage(`${abilityName} is already bouncing.`);
      return false;
    }
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'bounceRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const bounceCount = Math.max(1, Math.floor(Number(abilityFieldValue(ability, 'bounceCount')) || 0));
    const bounceInterval = Math.max(0.05, Number(abilityFieldValue(ability, 'bounceIntervalMs')) || 0) / 1000;
    const slowFraction = Math.max(0, Math.min(1, (Number(abilityFieldValue(ability, 'slowPct')) || 0) / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const knockback = Math.max(0, Number(abilityFieldValue(ability, 'knockbackDistancePx')) || 0);
    const knockup = Math.max(0, Number(abilityFieldValue(ability, 'knockupDurationMs')) || 0) / 1000;
    const subsequentPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'subsequentHitPct')) || 0));
    const subsequentMultiplier = subsequentPct / 100;
    const moveSpeedStart = 1 + Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedStartPct')) || 0) / 100;
    const moveSpeedEnd = 1 + Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedEndPct')) || 0) / 100;

    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a bounce radius configured.`);
      return false;
    }
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      state: castTime > 0 ? 'windup' : 'active',
      elapsed: 0,
      castDuration: castTime,
      activeElapsed: 0,
      bounceCount,
      bounceInterval,
      totalDuration: bounceInterval * Math.max(0, bounceCount - 1),
      bounceRadius: radius,
      damage,
      subsequentMultiplier,
      slowFraction,
      slowDuration,
      knockback,
      knockup,
      cooldownSeconds,
      moveSpeedStart,
      moveSpeedEnd,
      movementSpeedMultiplier: castTime > 0 ? 1 : moveSpeedStart,
      allowMovementWhileCasting: true,
      hitCounts: new Map(),
      bouncesFired: 0,
      nextBounceTime: 0,
      totalHits: 0,
      primaryHits: 0,
      ended: false,
      cooldownApplied: false
    };

    springquakeCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'active'){
      beginSpringquakeActive(cast);
    } else {
      setHudMessage(`${abilityName} coiling up...`);
    }
    return { success: true, deferCooldown: true };
  }

  function beginSpringquakeActive(cast){
    if(!cast || cast.ended) return;
    cast.state = 'active';
    cast.elapsed = 0;
    cast.activeElapsed = 0;
    cast.bouncesFired = 0;
    cast.nextBounceTime = 0;
    cast.totalHits = 0;
    cast.primaryHits = 0;
    const interval = Math.max(0, Number(cast.bounceInterval) || 0);
    const remainingBounces = Math.max(0, Math.floor(Number(cast.bounceCount) || 0) - 1);
    cast.totalDuration = interval * remainingBounces;
    if(!cast.hitCounts || typeof cast.hitCounts.get !== 'function'){
      cast.hitCounts = new Map();
    } else {
      cast.hitCounts.clear();
    }
    cast.movementSpeedMultiplier = Number.isFinite(cast.moveSpeedStart) ? Math.max(0, cast.moveSpeedStart) : 1;
    if(cast.casterRef === player){
      player.casting = cast;
    }
    performSpringquakeBounce(cast);
    cast.bouncesFired = 1;
    cast.nextBounceTime = cast.bounceInterval;
    setHudMessage(`${cast.abilityName || 'Springquake'} bouncing!`);
  }

  function performSpringquakeBounce(cast){
    if(!cast || cast.ended) return { hits: 0, primaryHits: 0 };
    if(!cast.hitCounts || typeof cast.hitCounts.get !== 'function'){
      cast.hitCounts = new Map();
    }
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    const centerX = Number.isFinite(origin.x) ? origin.x : (caster && Number.isFinite(caster.x) ? caster.x : player.x);
    const centerY = Number.isFinite(origin.y) ? origin.y : (caster && Number.isFinite(caster.y) ? caster.y : player.y);
    const radius = Math.max(0, Number(cast.bounceRadius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const repeatMult = Math.max(0, Number(cast.subsequentMultiplier) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(cast.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(cast.slowDuration) || 0);
    const knockback = Math.max(0, Number(cast.knockback) || 0);
    const knockup = Math.max(0, Number(cast.knockup) || 0);
    if(!(radius > 0)) return { hits: 0, primaryHits: 0 };

    let hits = 0;
    let primaryHits = 0;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const effectiveRadius = radius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > effectiveRadius * effectiveRadius) continue;
      const prevHits = cast.hitCounts.get(m) || 0;
      const appliedDamage = prevHits === 0 ? damage : damage * repeatMult;
      const prevHp = Number(m.hp) || 0;
      if(appliedDamage > 0){
        m.hp = Math.max(0, prevHp - appliedDamage);
        spawnHitSplat(m.x, m.y - targetRadius, appliedDamage);
      }
      if(prevHits === 0){
        if(knockback > 0){
          const dist = Math.hypot(dx, dy);
          const dirX = dist > 0.0001 ? dx / dist : 1;
          const dirY = dist > 0.0001 ? dy / dist : 0;
          const moved = moveCircleWithCollision(m.x, m.y, dirX * knockback, dirY * knockback, targetRadius);
          m.x = Math.max(targetRadius, Math.min(mapState.width - targetRadius, moved.x));
          m.y = Math.max(targetRadius, Math.min(mapState.height - targetRadius, moved.y));
        }
        if(knockup > 0){
          const existingStun = typeof m.stunTimer === 'number' ? m.stunTimer : 0;
          m.stunTimer = Math.max(existingStun, knockup);
        }
        if(slowFraction > 0){
          const existingSlow = typeof m.slowPct === 'number' ? m.slowPct : 0;
          m.slowPct = Math.max(existingSlow, slowFraction);
          if(slowDuration > 0){
            m.slowTimer = Math.max(m.slowTimer || 0, slowDuration);
          }
        }
        primaryHits += 1;
      }
      handlePracticeDummyDamage(m, prevHp);
      cast.hitCounts.set(m, prevHits + 1);
      hits += 1;
    }
    cast.totalHits = Math.max(0, Number(cast.totalHits) || 0) + hits;
    cast.primaryHits = Math.max(0, Number(cast.primaryHits) || 0) + primaryHits;
    flash(centerX, centerY, { startRadius: Math.max(16, radius * 0.55), endRadius: Math.max(radius + 48, radius * 1.05), color: '#94f0a8' });
    return { hits, primaryHits };
  }

  function endSpringquakeCast(cast, { reason = 'complete' } = {}){
    if(!cast || cast.ended) return;
    cast.ended = true;
    if(!cast.cooldownApplied && Number.isFinite(cast.slotIndex)){
      const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
      cast.cooldownApplied = true;
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(cast.casterRef === player){
      const abilityName = cast.abilityName || 'Springquake';
      if(reason === 'complete'){
        const total = Math.max(0, Math.round(Number(cast.totalHits) || 0));
        const primary = Math.max(0, Math.round(Number(cast.primaryHits) || 0));
        const hitText = total > 0 ? ` hitting ${total} time${total === 1 ? '' : 's'}` : '';
        const primaryText = primary > 0 ? ` (${primary} first-hit knockbacks)` : '';
        setHudMessage(`${abilityName} finished${hitText}${primaryText}.`);
      } else if(reason === 'interrupted'){
        setHudMessage(`${abilityName} interrupted.`);
      }
    }
  }

  function castFrenziedVolleyAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Frenzied Volley';
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const attackSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'attackSpeedPct')) || 0);
    const arrowCount = Math.max(0, Math.floor(Number(abilityFieldValue(ability, 'arrowCount')) || 0));
    const arrowDamage = Math.max(0, Number(abilityFieldValue(ability, 'arrowDamage')) || 0);
    const lifeStealPct = Math.max(0, Number(abilityFieldValue(ability, 'lifeStealPct')) || 0);

    if(duration <= 0){
      setHudMessage(`${abilityName} needs a duration configured.`);
      return false;
    }
    if(arrowCount <= 0 || arrowDamage <= 0){
      setHudMessage(`${abilityName} needs arrow damage configured.`);
      return false;
    }

    for(let i = quiverstormBuffs.length - 1; i >= 0; i--){
      const existing = quiverstormBuffs[i];
      if(existing && existing.casterRef === player){
        quiverstormBuffs.splice(i, 1);
      }
    }

    const buff = {
      abilityId: ability && ability.id ? ability.id : 'frenetic_volley',
      abilityName,
      slotIndex,
      casterRef: player,
      duration,
      remaining: duration,
      attackSpeedPct,
      arrowCount,
      arrowDamage,
      lifeStealPct
    };
    quiverstormBuffs.push(buff);

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.attackCooldown = 0;
    player.attackWindup = 0;
    player.attackTarget = null;
    player.attackOverride = null;

    const cooldownSeconds = abilityCooldownSeconds(ability);
    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    setHudMessage(`${abilityName} unleashed!`);
    return true;
  }

  function beginQuakingStrideActive(cast){
    if(!cast || cast.ended) return;
    cast.state = 'active';
    cast.elapsed = 0;
    cast.activeElapsed = 0;
    cast.tickTimer = Math.max(0.05, Number(cast.tickInterval) || 0.5);
    cast.stacks = Math.max(0, Number(cast.stacks) || 0);
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const hits = applyQuakingStrideTick(cast);
    handleQuakingStrideHits(cast, hits);
    cast.tickTimer = Math.max(0.05, Number(cast.tickInterval) || 0.5);
    if(cast.casterRef === player){
      setHudMessage(`${cast.abilityName || 'Quaking Stride'} rumbling!`);
    }
  }

  function handleQuakingStrideHits(cast, hits){
    if(!cast || cast.ended) return;
    const count = Math.max(0, Math.floor(Number(hits) || 0));
    if(count <= 0) return;
    const maxStacks = Math.max(1, Math.floor(Number(cast.maxStacks) || 5));
    const prevStacks = Math.max(0, Math.floor(Number(cast.stacks) || 0));
    const nextStacks = Math.min(maxStacks, prevStacks + 1);
    cast.stacks = nextStacks;
    if(!cast.empowerReady && nextStacks >= maxStacks){
      cast.empowerReady = true;
      cast.empowerTimer = Math.max(0, Number(cast.empowerWindow) || 0);
      if(cast.empowerTimer <= 0){
        cast.empowerTimer = 6;
      }
      if(cast.casterRef === player){
        setHudMessage(`${cast.abilityName || 'Quaking Stride'} ready! Next attack stuns.`);
      }
    }
  }

  function applyQuakingStrideTick(cast){
    if(!cast || cast.ended) return 0;
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    const centerX = Number.isFinite(origin.x) ? origin.x : (caster && Number.isFinite(caster.x) ? caster.x : player.x);
    const centerY = Number.isFinite(origin.y) ? origin.y : (caster && Number.isFinite(caster.y) ? caster.y : player.y);
    const radius = Math.max(0, Number(cast.pulseRadius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    if(!(radius > 0)) return 0;

    let hits = 0;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const effective = radius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > effective * effective) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }

    const monster = monsterState;
    if(monster && isMonsterAttackable(monster)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      const effective = radius + monsterRadius;
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      if(dx * dx + dy * dy <= effective * effective){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        if(damage > 0){
          monster.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monster.x, monster.y - monsterRadius, damage);
          updateMonsterHud();
        }
        hits += 1;
      }
    }

    flash(centerX, centerY, { startRadius: Math.max(12, radius * 0.35), endRadius: Math.max(radius + 40, radius * 0.85), color: '#ffdcaa' });
    return hits;
  }

  function activeVerdictSalvoCastForCaster(caster){
    if(!caster) return null;
    for(const cast of verdictSalvoCasts){
      if(!cast || cast.ended) continue;
      if(cast.casterRef === caster) return cast;
    }
    return null;
  }

  function isVerdictSalvoTargetAlive(target){
    if(!target) return false;
    if(target === player) return true;
    const hp = Number(target.hp);
    if(!(hp > 0)) return false;
    if(target.active === false) return false;
    if(target.portalizing > 0) return false;
    return true;
  }

  function pickVerdictSalvoTarget(originX, originY, dirX, dirY, range, lockWidth){
    const halfWidth = Math.max(0, (Number(lockWidth) || 0) / 2);
    const effectiveRadius = halfWidth + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let best = null;
    let bestAlong = Math.max(0, Number(range) || 0) + minionRadius;
    for(const m of minions){
      if(!m) continue;
      const isDummy = m.isPracticeDummy === true;
      if(!isEnemyMinionForPlayer(m) && !isDummy) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const relX = m.x - originX;
      const relY = m.y - originY;
      const along = relX * dirX + relY * dirY;
      if(along < -minionRadius) continue;
      if(range > 0 && along > range + minionRadius) continue;
      const closestX = originX + dirX * along;
      const closestY = originY + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY <= effectiveSq && along < bestAlong){
        best = m;
        bestAlong = along;
      }
    }
    return { target: best, along: bestAlong };
  }

  function castVerdictSalvoAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Verdict Salvo';
    const existing = activeVerdictSalvoCastForCaster(player);
    if(existing){
      if(existing.state === 'channel' && existing.elapsed >= existing.recastDelay){
        beginVerdictSalvoVolley(existing, { cause: 'manual' });
        return { success: true, deferCooldown: true };
      }
      if(existing.state === 'channel'){
        setHudMessage(`${abilityName} is still loading shots.`);
        return false;
      }
      setHudMessage(`${abilityName} already firing.`);
      return false;
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const channelDuration = Math.max(0, Number(abilityFieldValue(ability, 'channelDurationMs')) || 0) / 1000;
    const recastDelay = Math.max(0, Number(abilityFieldValue(ability, 'recastDelayMs')) || 0) / 1000;
    const maxStoredBullets = Math.max(1, Number(abilityFieldValue(ability, 'maxStoredBullets')) || 1);
    const storeInterval = Math.max(0.025, (Number(abilityFieldValue(ability, 'storeIntervalMs')) || 0) / 1000);
    const fireInterval = Math.max(0.025, (Number(abilityFieldValue(ability, 'fireIntervalMs')) || 0) / 1000);
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const projectileRangeField = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const lockWidth = Math.max(0, Number(abilityFieldValue(ability, 'lockWidthPx')) || projectileWidth);
    const damagePerShot = Math.max(0, Number(abilityFieldValue(ability, 'damagePerShot')) || 0);
    const cancelCooldownSeconds = Math.max(0, (Number(abilityFieldValue(ability, 'cancelCooldownMs')) || 0) / 1000);
    const cooldownSeconds = abilityCooldownSeconds(ability);

    const { x: originX, y: originY } = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dirX = aimPoint.x - originX;
    let dirY = aimPoint.y - originY;
    let len = Math.hypot(dirX, dirY);
    if(!(len > 0.0001)){
      const fallbackX = player.target && Number.isFinite(player.target.x) ? player.target.x : player.x + (player.r || 12);
      const fallbackY = player.target && Number.isFinite(player.target.y) ? player.target.y : player.y;
      dirX = fallbackX - originX;
      dirY = fallbackY - originY;
      len = Math.hypot(dirX, dirY);
    }
    if(!(len > 0.0001)){
      dirX = 1;
      dirY = 0;
      len = 1;
    }
    dirX /= len;
    dirY /= len;

    const lockRange = projectileRangeField > 0 ? projectileRangeField : Math.max(600, len);
    const lockInfo = pickVerdictSalvoTarget(originX, originY, dirX, dirY, lockRange, lockWidth);
    const lockedTarget = lockInfo.target || null;
    const fallbackDistance = Math.min(lockRange, len);
    const lockedPointX = lockedTarget ? lockedTarget.x : originX + dirX * fallbackDistance;
    const lockedPointY = lockedTarget ? lockedTarget.y : originY + dirY * fallbackDistance;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      state: 'channel',
      elapsed: 0,
      duration: channelDuration,
      recastDelay,
      storedBullets: 1,
      maxStoredBullets,
      storageInterval: storeInterval,
      nextStoreTime: storeInterval,
      fireInterval,
      projectileSpeed,
      projectileWidth,
      projectileRange: lockRange,
      damagePerShot,
      lockDirX: dirX,
      lockDirY: dirY,
      lockWidth,
      lockedTarget,
      lockedPointX,
      lockedPointY,
      cooldownSeconds,
      cancelCooldownSeconds,
      cooldownApplied: false,
      allowMovementWhileCasting: true,
      shotsFired: 0,
      shotsToFire: 0,
      volleyElapsed: 0,
      nextShotTime: 0,
      ended: false
    };

    verdictSalvoCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    setHudMessage(`${abilityName} channeling...`);
    if(channelDuration <= 0){
      beginVerdictSalvoVolley(cast, { cause: 'auto' });
    }
    return { success: true, deferCooldown: true };
  }

  function beginVerdictSalvoVolley(cast, { cause = 'auto' } = {}){
    if(!cast || cast.ended) return false;
    if(cast.state === 'firing') return true;
    const shots = Math.max(1, Math.min(Math.round(Number(cast.storedBullets) || 1), Math.round(Number(cast.maxStoredBullets) || 1)));
    cast.state = 'firing';
    cast.volleyElapsed = 0;
    cast.nextShotTime = 0;
    cast.shotsToFire = shots;
    cast.shotsFired = 0;
    if(isVerdictSalvoTargetAlive(cast.lockedTarget)){
      cast.lockedPointX = cast.lockedTarget.x;
      cast.lockedPointY = cast.lockedTarget.y;
    }
    if(cast.casterRef === player){
      const abilityName = cast.abilityName || 'Verdict Salvo';
      const text = cause === 'manual' ? `${abilityName} firing!` : `${abilityName} firing automatically.`;
      setHudMessage(text);
    }
    return true;
  }

  function endVerdictSalvoCast(cast, options = {}){
    if(!cast || cast.ended) return;
    cast.ended = true;
    const idx = verdictSalvoCasts.indexOf(cast);
    if(idx !== -1){
      verdictSalvoCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(!cast.cooldownApplied && Number.isFinite(cast.slotIndex)){
      const normalCd = Math.max(0, Number(cast.cooldownSeconds) || 0);
      const cancelCd = Math.max(0, Number(cast.cancelCooldownSeconds) || 0);
      const cancelledEarly = options.cancelled === true || (cast.state === 'channel' && cast.shotsFired <= 0 && options.reason !== 'complete');
      const appliedCd = cancelledEarly && cancelCd > 0 ? cancelCd : normalCd;
      setAbilitySlotCooldown(cast.slotIndex, appliedCd);
      cast.cooldownApplied = true;
    }
    if(cast.casterRef === player && !options.silent){
      const abilityName = cast.abilityName || 'Verdict Salvo';
      let message;
      switch(options.reason){
        case 'cancel':
          message = `${abilityName} cancelled.`;
          break;
        case 'control':
          message = `${abilityName} interrupted!`;
          break;
        case 'complete':
          message = `${abilityName} finished firing.`;
          break;
        default:
          message = `${abilityName} ended.`;
          break;
      }
      setHudMessage(message);
    }
  }

  function fireVerdictSalvoShot(cast){
    if(!cast || cast.ended) return;
    const caster = cast.casterRef || player;
    const { x: originX, y: originY } = getSpellOrigin(caster);
    const target = isVerdictSalvoTargetAlive(cast.lockedTarget) ? cast.lockedTarget : null;
    let targetX = target ? target.x : cast.lockedPointX;
    let targetY = target ? target.y : cast.lockedPointY;
    let dirX = targetX - originX;
    let dirY = targetY - originY;
    let distance = Math.hypot(dirX, dirY);
    if(!(distance > 0.0001)){
      dirX = Number(cast.lockDirX) || 1;
      dirY = Number(cast.lockDirY) || 0;
      distance = Math.hypot(dirX, dirY);
    }
    if(!(distance > 0.0001)){
      dirX = 1;
      dirY = 0;
      distance = 1;
    }
    const normX = dirX / distance;
    const normY = dirY / distance;
    cast.lockDirX = normX;
    cast.lockDirY = normY;

    let range = Math.max(0, Number(cast.projectileRange) || 0);
    if(!(range > 0)){
      range = distance;
    } else if(distance > 0){
      range = Math.min(range, distance);
    }
    const speed = Math.max(0, Number(cast.projectileSpeed) || 0);
    if(!(speed > 0)){
      return;
    }
    const muzzleOffset = (caster && Number.isFinite(caster.r) ? caster.r : player.r || 10) + 6;
    const startX = originX + normX * muzzleOffset;
    const startY = originY + normY * muzzleOffset;
    const projectile = {
      castRef: cast,
      abilityName: cast.abilityName,
      casterRef: caster,
      startX,
      startY,
      dirX: normX,
      dirY: normY,
      speed,
      range,
      width: cast.projectileWidth,
      damage: cast.damagePerShot,
      traveled: 0,
      age: 0
    };
    projectile.x = startX;
    projectile.y = startY;
    verdictSalvoProjectiles.push(projectile);
    flash(startX, startY, { startRadius: 5, endRadius: 18, color: '#f7d469' });
  }

  function applyVerdictSalvoHit(projectile, target){
    if(!projectile || !target) return;
    const damage = Math.max(0, Number(projectile.damage) || 0);
    const prevHp = Number(target.hp) || 0;
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(target.x, target.y - minionRadius, damage);
      if(prevHp > 0 && target.hp <= 0 && !target.isPracticeDummy){
        addGold(goldState.perKill);
      }
    }
    handlePracticeDummyDamage(target, prevHp);
    flash(target.x, target.y, { startRadius: 8, endRadius: 28, color: '#f7d469' });
  }

  function activeCullingBarrageChannelForCaster(caster){
    if(!caster) return null;
    for(const channel of cullingBarrageChannels){
      if(!channel || channel.ended) continue;
      if(channel.casterRef === caster) return channel;
    }
    return null;
  }

  function castCullingBarrageAbility(slotIndex, ability){
    const caster = player;
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Sweeping Barrage';
    const existing = activeCullingBarrageChannelForCaster(caster);
    if(existing && existing.abilityId === ability.id){
      endCullingBarrageChannel(existing, { reason: 'manual' });
      return false;
    }

    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const channelDurationMs = Math.max(0, Number(abilityFieldValue(ability, 'channelDurationMs')) || 0);
    const shotIntervalMsRaw = Math.max(0, Number(abilityFieldValue(ability, 'shotIntervalMs')) || 0);
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const damagePerShot = Math.max(0, Number(abilityFieldValue(ability, 'damagePerShot')) || 0);
    const aimPreviewRange = Math.max(0, Number(abilityFieldValue(ability, 'aimPreviewRangePx')) || projectileRange || 0);
    const moveSpeedPct = Math.max(0, Number(abilityFieldValue(ability, 'moveSpeedMultPct')) || 0);
    const allowDash = Number(abilityFieldValue(ability, 'allowDashDuringCh')) > 0;
    const lockFacing = Number(abilityFieldValue(ability, 'lockFacing')) > 0;
    const canPierce = Number(abilityFieldValue(ability, 'projectilesPierce')) > 0;
    const cooldownSeconds = abilityCooldownSeconds(ability);

    const safeIntervalMs = Math.max(1, shotIntervalMsRaw);
    const totalShots = Math.max(1, Math.floor(channelDurationMs / safeIntervalMs) || 0);
    const channelDuration = channelDurationMs / 1000;
    const shotInterval = safeIntervalMs / 1000;
    const { x: originX, y: originY } = getSpellOrigin(caster);
    const aimPoint = beamAimPoint();
    let dirX = aimPoint.x - originX;
    let dirY = aimPoint.y - originY;
    let len = Math.hypot(dirX, dirY);
    if(!(len > 0.0001)){
      dirX = 1;
      dirY = 0;
      len = 1;
    }
    dirX /= len;
    dirY /= len;

    const channel = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: caster,
      duration: channelDuration,
      elapsed: 0,
      shotInterval,
      nextShotTime: 0,
      shotsFired: 0,
      totalShots,
      projectileSpeed,
      projectileWidth,
      projectileRange,
      damagePerShot,
      aimDirX: dirX,
      aimDirY: dirY,
      aimPreviewRange,
      moveSpeedMult: moveSpeedPct / 100,
      allowDash,
      lockFacing,
      canPierce,
      cooldownSeconds,
      cooldownApplied: false,
      ended: false,
      allowMovementWhileCasting: true
    };

    channel.originalSpeed = caster.speed;
    if(channel.moveSpeedMult > 0){
      caster.speed = channel.originalSpeed * channel.moveSpeedMult;
    } else {
      caster.speed = 0;
    }
    updateHudStats();

    cancelPlayerAttack(false);
    caster.chaseTarget = null;
    if(!channel.allowMovementWhileCasting){
      caster.target.x = caster.x;
      caster.target.y = caster.y;
      caster.navGoal = null;
      caster.nav = null;
      clearEntityNav(caster);
    }

    player.casting = channel;
    cullingBarrageChannels.push(channel);
    setHudMessage(`${abilityName} channeling...`);
    return { success: true, deferCooldown: true };
  }

  function endCullingBarrageChannel(channel, options = {}){
    if(!channel || channel.ended) return;
    channel.ended = true;
    const idx = cullingBarrageChannels.indexOf(channel);
    if(idx !== -1){
      cullingBarrageChannels.splice(idx, 1);
    }
    const caster = channel.casterRef;
    if(caster){
      if(Number.isFinite(channel.originalSpeed)){
        caster.speed = channel.originalSpeed;
        updateHudStats();
      }
      if(caster === player && player.casting === channel){
        player.casting = null;
      }
    }
    if(!channel.cooldownApplied && Number.isFinite(channel.slotIndex)){
      setAbilitySlotCooldown(channel.slotIndex, Math.max(0, Number(channel.cooldownSeconds) || 0));
      channel.cooldownApplied = true;
    }
    if(caster === player && !options.silent){
      const abilityName = channel.abilityName || 'Sweeping Barrage';
      let message;
      switch(options.reason){
        case 'manual':
          message = `${abilityName} cancelled.`;
          break;
        case 'control':
          message = `${abilityName} interrupted!`;
          break;
        case 'complete':
          message = `${abilityName} finished firing.`;
          break;
        default:
          message = `${abilityName} ended.`;
          break;
      }
      setHudMessage(message);
    }
  }

  function fireCullingBarrageShot(channel, originX, originY){
    if(!channel || channel.ended) return;
    const caster = channel.casterRef || player;
    const muzzleOffset = (caster && Number.isFinite(caster.r) ? caster.r : player.r || 10) + 6;
    const dirX = Number(channel.aimDirX) || 0;
    const dirY = Number(channel.aimDirY) || 0;
    const muzzleX = originX + dirX * muzzleOffset;
    const muzzleY = originY + dirY * muzzleOffset;
    const projectile = {
      channelRef: channel,
      abilityName: channel.abilityName,
      casterRef: caster,
      startX: muzzleX,
      startY: muzzleY,
      dirX,
      dirY,
      speed: channel.projectileSpeed,
      range: channel.projectileRange,
      width: channel.projectileWidth,
      damage: channel.damagePerShot,
      traveled: 0,
      canPierce: channel.canPierce,
      hitTargets: channel.canPierce ? new Set() : null,
      age: 0
    };
    projectile.x = muzzleX;
    projectile.y = muzzleY;
    cullingBarrageProjectiles.push(projectile);
    flash(muzzleX, muzzleY, { startRadius: 6, endRadius: 18, color: '#9ce7ff' });
  }

  function applyCullingBarrageHit(projectile, target){
    if(!projectile || !target) return;
    const damage = Math.max(0, Number(projectile.damage) || 0);
    const prevHp = Number(target.hp) || 0;
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(target.x, target.y - minionRadius, damage);
      if(prevHp > 0 && target.hp <= 0 && !target.isPracticeDummy){
        addGold(goldState.perKill);
      }
    }
    handlePracticeDummyDamage(target, prevHp);
    const slowFraction = Math.max(0, Number(projectile.slowFraction) || 0);
    const slowDuration = Math.max(0, Number(projectile.slowDuration) || 0);
    if(slowFraction > 0 && slowDuration > 0){
      const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
      target.slowPct = Math.max(existingSlow, slowFraction);
      target.slowTimer = Math.max(target.slowTimer || 0, slowDuration);
    }
    const revealRadius = Math.max(0, Number(projectile.revealRadius) || 0);
    const revealDuration = Math.max(0, Number(projectile.revealDuration) || 0);
    if(revealRadius > 0 && revealDuration > 0){
      spawnTemporalVisionSource(target.x, target.y, revealRadius, revealDuration);
    }
    flash(target.x, target.y, { startRadius: 8, endRadius: 24, color: '#9ce7ff' });
  }

  function castRevealShockAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Revealing Shock';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowFraction = Math.max(0, Math.min(1, slowPct / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const revealRadius = Math.max(0, Number(abilityFieldValue(ability, 'revealRadiusPx')) || 0);
    const revealDuration = Math.max(0, Number(abilityFieldValue(ability, 'revealDurationMs')) || 0) / 1000;

    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a bolt speed configured.`);
      return false;
    }
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a bolt width configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const muzzleOffset = (Number.isFinite(player.r) ? player.r : 10) + 6;
    const startX = origin.x + dirX * muzzleOffset;
    const startY = origin.y + dirY * muzzleOffset;

    const projectile = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      startX,
      startY,
      dirX,
      dirY,
      speed,
      range,
      width,
      damage,
      slowFraction,
      slowDuration,
      revealRadius,
      revealDuration,
      traveled: 0,
      age: 0
    };
    projectile.x = startX;
    projectile.y = startY;
    cullingBarrageProjectiles.push(projectile);

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    if(player.target){
      player.target.x = player.x;
      player.target.y = player.y;
    }
    player.navGoal = null;
    player.nav = null;
    flash(startX, startY, { startRadius: 6, endRadius: 20, color: '#94d9ff' });
    setHudMessage(`${abilityName} launched!`);
    return true;
  }

  function launchVoidTrackShot(cast){
    if(!cast) return false;
    const startX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    let dirX = Number(cast.dirX) || 1;
    let dirY = Number(cast.dirY) || 0;
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;
    const speed = Math.max(0, Number(cast.speed) || 0);
    const range = Math.max(0, Number(cast.range) || 0);
    const width = Math.max(0, Number(cast.width) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const pathVisionSpacing = Math.max(0, Number(cast.pathVisionSpacing) || 0);
    const pathVisionRadius = Math.max(0, Number(cast.pathVisionRadius) || 0);
    const pathVisionDuration = Math.max(0, Number(cast.pathVisionDuration) || 0);
    const plasmaStacks = Math.max(0, Number(cast.plasmaStacks) || 0);
    const plasmaDuration = Math.max(0, Number(cast.plasmaDuration) || 0);
    const revealRadius = Math.max(0, Number(cast.revealRadius) || 0);
    const revealDuration = Math.max(0, Number(cast.revealDuration) || 0);
    const projectile = {
      slotIndex: cast.slotIndex,
      abilityId: cast.abilityId,
      abilityName: cast.abilityName,
      casterRef: cast.casterRef || player,
      startX,
      startY,
      dirX,
      dirY,
      speed,
      maxDistance: range,
      traveled: 0,
      width,
      damage,
      hitMonsters: true,
      pathVisionSpacing,
      pathVisionRadius,
      pathVisionDuration,
      nextVisionDistance: 0,
      plasmaStacks,
      plasmaDuration,
      revealRadius,
      revealDuration,
      shadowColor: '#2b0c3b',
      outerColor: '#5e3f9c',
      innerColor: '#a996ff',
      tipColor: '#f4cfff'
    };
    laserProjectiles.push(projectile);
    flash(startX, startY, { startRadius: 8, endRadius: 28, color: '#8d5fe2' });
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    if(cast.casterRef === player){
      if(player.casting === cast){
        player.casting = null;
      }
      setHudMessage(`${projectile.abilityName || 'Void Track'} fired!`);
    }
    return true;
  }

  function castVoidTrackAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Void Track';
    const castTimeMs = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0);
    const castDuration = castTimeMs / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a bolt speed configured.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width configured.`);
      return false;
    }
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const pathVisionRadius = Math.max(0, Number(abilityFieldValue(ability, 'pathVisionRadiusPx')) || 0);
    const pathVisionDuration = Math.max(0, Number(abilityFieldValue(ability, 'pathVisionDurationMs')) || 0) / 1000;
    const pathVisionSpacing = Math.max(0, Number(abilityFieldValue(ability, 'pathVisionSpacingPx')) || 0);
    const plasmaStacks = Math.max(0, Math.floor(Number(abilityFieldValue(ability, 'plasmaStacks')) || 0));
    const plasmaDuration = Math.max(0, Number(abilityFieldValue(ability, 'plasmaDurationMs')) || 0) / 1000;
    const revealRadius = Math.max(0, Number(abilityFieldValue(ability, 'championRevealRadiusPx')) || 0);
    const revealDuration = Math.max(0, Number(abilityFieldValue(ability, 'championRevealDurationMs')) || 0) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    const dirLen = Math.hypot(dx, dy);
    const dirX = dirLen > 0 ? dx / dirLen : 1;
    const dirY = dirLen > 0 ? dy / dirLen : 0;
    const startX = origin.x + dirX * ((Number.isFinite(player.r) ? player.r : 10) + 6);
    const startY = origin.y + dirY * ((Number.isFinite(player.r) ? player.r : 10) + 6);

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      startX,
      startY,
      dirX,
      dirY,
      range,
      speed,
      width,
      damage,
      pathVisionRadius,
      pathVisionDuration,
      pathVisionSpacing,
      plasmaStacks,
      plasmaDuration,
      revealRadius,
      revealDuration,
      cooldownSeconds
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      launchVoidTrackShot(cast);
      return true;
    }

    voidTrackCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} charging...`);
    return true;
  }

  function updateVoidTrackCasts(dt){
    for(let i = voidTrackCasts.length - 1; i >= 0; i--){
      const cast = voidTrackCasts[i];
      if(!cast){
        voidTrackCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        voidTrackCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchVoidTrackShot(cast);
        voidTrackCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function castBedrockBurstAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Bedrock Burst';
    const castTimeMs = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeMs) || 0) / 1000;
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const stunSeconds = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;

    if(!(radius > 0)){
      setHudMessage(`${abilityName} has no impact radius configured.`);
      return false;
    }

    const cast = {
      slotIndex,
      abilityId: ability && ability.id,
      abilityName,
      casterRef: player,
      startX: player.x,
      startY: player.y,
      impactRadius: radius,
      impactDamage: damage,
      impactKnockup: stunSeconds,
      castDuration,
      elapsed: 0
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      return fireBedrockBurstCast(cast);
    }

    bedrockBurstCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} winding up...`);
    return true;
  }

  function fireBedrockBurstCast(cast){
    if(!cast) return false;
    const origin = resolveCastOrigin(cast);
    const centerX = Number.isFinite(origin.x) ? origin.x : player.x;
    const centerY = Number.isFinite(origin.y) ? origin.y : player.y;
    const radius = Math.max(0, Number(cast.impactRadius) || 0);

    spawnSlamImpact(centerX, centerY, radius);
    const hits = applySlamImpact(cast, centerX, centerY);

    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    const abilityId = cast.abilityId || '';
    const label = cast.abilityName || 'Bedrock Burst';
    if(hits > 0){
      setHudMessage(`${label} launched ${hits} target${hits === 1 ? '' : 's'}!`);
    } else {
      setHudMessage(`${label} fizzled.`);
    }

    return true;
  }

  function castGroundbreakerAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Groundbreaker Rift';
    const castTimeSeconds = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const knockup = Math.max(0, Number(abilityFieldValue(ability, 'knockupDurationMs')) || 0) / 1000;
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowFraction = Math.max(0, Math.min(1, slowPct / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;

    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a target range configured.`);
      return false;
    }
    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a rift radius configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = typeof skillshotAimPoint === 'function' ? skillshotAimPoint() : beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const clampRadius = Math.max(radius, minionRadius);
    if(Number.isFinite(mapState.width)){
      targetX = Math.max(clampRadius, Math.min(mapState.width - clampRadius, targetX));
    }
    if(Number.isFinite(mapState.height)){
      targetY = Math.max(clampRadius, Math.min(mapState.height - clampRadius, targetY));
    }

    const cast = {
      slotIndex,
      abilityId: ability && ability.id,
      abilityName,
      casterRef: player,
      targetX,
      targetY,
      castDuration: castTimeSeconds,
      elapsed: 0,
      impactRadius: radius,
      damage,
      knockup,
      slowFraction,
      slowDuration
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(castTimeSeconds <= 0){
      fireGroundbreakerCast(cast);
    } else {
      groundbreakerCasts.push(cast);
      player.casting = cast;
      setHudMessage(`${abilityName} rumbling...`);
    }
    return true;
  }

  function fireGroundbreakerCast(cast){
    if(!cast) return false;
    const targetX = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
    const targetY = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    spawnSlamImpact(targetX, targetY, radius);
    const hits = applyGroundbreakerImpact(cast, targetX, targetY);
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const label = cast.abilityName || 'Groundbreaker Rift';
    if(hits > 0){
      setHudMessage(`${label} shattered ${hits} target${hits === 1 ? '' : 's'}!`);
    } else {
      setHudMessage(`${label} fizzled.`);
    }
    return true;
  }

  function applyGroundbreakerImpact(cast, x, y){
    if(!cast) return 0;
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const knockup = Math.max(0, Number(cast.knockup) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(cast.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(cast.slowDuration) || 0);
    if(!(radius > 0) && damage <= 0 && knockup <= 0 && slowFraction <= 0){
      return 0;
    }
    const effectiveRadius = radius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;

    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      if(knockup > 0){
        const existingStun = Number(m.stunTimer) || 0;
        m.stunTimer = Math.max(existingStun, knockup);
      }
      if(slowFraction > 0 && slowDuration > 0){
        const existingSlow = typeof m.slowPct === 'number' ? m.slowPct : 0;
        m.slowPct = Math.max(existingSlow, slowFraction);
        m.slowTimer = Math.max(m.slowTimer || 0, slowDuration);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }

    if(isMonsterAttackable(monsterState)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
      const dx = monsterState.x - x;
      const dy = monsterState.y - y;
      const allowed = radius + monsterRadius;
      if(allowed > 0 && dx * dx + dy * dy <= allowed * allowed){
        const prevHp = Math.max(0, Number(monsterState.hp) || 0);
        if(damage > 0){
          monsterState.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monsterState.x, monsterState.y - monsterRadius, damage);
          updateMonsterHud();
        }
        if(knockup > 0){
          const existingStun = Number(monsterState.stunTimer) || 0;
          monsterState.stunTimer = Math.max(existingStun, knockup);
        }
        if(slowFraction > 0 && slowDuration > 0){
          const existingSlow = Number(monsterState.slowPct) || 0;
          monsterState.slowPct = Math.max(existingSlow, slowFraction);
          monsterState.slowTimer = Math.max(monsterState.slowTimer || 0, slowDuration);
        }
        hits++;
      }
    }

    return hits;
  }

  function updateGroundbreakerCasts(dt){
    for(let i = groundbreakerCasts.length - 1; i >= 0; i--){
      const cast = groundbreakerCasts[i];
      if(!cast){
        groundbreakerCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        groundbreakerCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        groundbreakerCasts.splice(i, 1);
        fireGroundbreakerCast(cast);
      }
    }
  }

  function applyPlayerShield(amount, duration, { source = 'ability', castRef = null, onBreak = null, retaliationDamage = 0 } = {}){
    const value = Math.max(0, Number(amount) || 0);
    const seconds = Math.max(0, Number(duration) || 0);
    if(!(value > 0) || !(seconds > 0)){
      return null;
    }
    const shield = {
      source: typeof source === 'string' && source.trim() ? source.trim() : 'ability',
      remaining: value,
      max: value,
      duration: seconds,
      castRef: castRef || null,
      absorbed: false,
      broken: false,
      onBreak: typeof onBreak === 'function' ? onBreak : null
    };
    const retaliation = Math.max(0, Number(retaliationDamage) || 0);
    if(retaliation > 0){
      shield.retaliationDamage = retaliation;
      shield.retaliationHits = [];
    }
    playerShields.push(shield);
    flash(player.x, player.y, { startRadius: Math.max(12, player.r * 1.1), endRadius: Math.max(48, player.r * 2.6), color: '#ffe7a8' });
    return shield;
  }

  function markEntityWithPlasma(target, duration = PLASMA_MARK_DURATION){
    if(!target){
      return;
    }
    const seconds = Math.max(0, Number(duration) || PLASMA_MARK_DURATION);
    if(!(seconds > 0)){
      return;
    }
    target.plasmaTimer = Math.max(seconds, Number(target.plasmaTimer) || 0);
  }

  function refreshPlayerShield(shield, amount, duration){
    if(!shield){
      return null;
    }
    const value = Math.max(0, Number(amount) || Number(shield.max) || 0);
    const seconds = Math.max(0, Number(duration) || Number(shield.duration) || 0);
    if(!(value > 0) || !(seconds > 0)){
      return shield;
    }
    shield.max = value;
    shield.remaining = value;
    shield.duration = seconds;
    shield.absorbed = false;
    shield.broken = false;
    return shield;
  }

  function handlePlayerShieldBreak(shield, info = {}){
    if(!shield || shield.broken){
      return;
    }
    shield.broken = true;
    if(typeof shield.onBreak === 'function'){
      try {
        shield.onBreak(info);
      } catch (err){
        console.error('Shield onBreak failed', err);
      }
    }
  }

  function castBulwarkCrashAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Bulwark Crash';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const braceDuration = Math.max(0, Number(abilityFieldValue(ability, 'braceDurationMs')) || 0) / 1000;
    const lockoutRaw = Math.max(0, Number(abilityFieldValue(ability, 'lockoutDurationMs')) || 0) / 1000;
    const lockoutDuration = braceDuration > 0 ? Math.min(braceDuration, lockoutRaw) : lockoutRaw;
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadiusPx')) || 0);
    const baseDamage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const bonusPct = Math.max(0, Number(abilityFieldValue(ability, 'bonusDamagePct')) || 0);
    const shieldAmount = Math.max(0, Number(abilityFieldValue(ability, 'shieldAmount')) || 0);
    const shieldDuration = Math.max(0, Number(abilityFieldValue(ability, 'shieldDurationMs')) || 0) / 1000;

    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs an impact radius configured.`);
      return false;
    }
    if(!(baseDamage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    const cast = {
      slotIndex,
      abilityId: ability && ability.id,
      abilityName,
      casterRef: player,
      braceDuration,
      lockoutDuration,
      impactRadius: radius,
      damage: baseDamage,
      bonusDamagePct: bonusPct,
      shieldAmount,
      shieldDuration,
      cooldownSeconds,
      state: 'lockout',
      elapsed: 0,
      ended: false,
      shieldAbsorbed: false,
      cooldownApplied: false,
      allowMovementWhileCasting: false
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(shieldAmount > 0 && shieldDuration > 0){
      cast.shieldRef = applyPlayerShield(shieldAmount, shieldDuration, { source: 'removed_ability', castRef: cast });
    }

    if(braceDuration <= 0){
      fireBulwarkCrashCast(cast);
      return { success: true, deferCooldown: true };
    }

    bulwarkCrashCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} bracing...`);
    return { success: true, deferCooldown: true };
  }

  function applyBulwarkCrashImpact({ centerX, centerY, radius, damage } = {}){
    const impactRadius = Math.max(0, Number(radius) || 0);
    const impactDamage = Math.max(0, Number(damage) || 0);
    if(!(impactRadius > 0)) return 0;
    let hits = 0;

    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      const effective = impactRadius + targetRadius;
      if(dx * dx + dy * dy > effective * effective) continue;
      const prevHp = Number(m.hp) || 0;
      if(impactDamage > 0){
        m.hp = Math.max(0, prevHp - impactDamage);
        spawnHitSplat(m.x, m.y - targetRadius, impactDamage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }

    const monster = monsterState;
    if(monster && isMonsterAttackable(monster)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      const effective = impactRadius + monsterRadius;
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      if(dx * dx + dy * dy <= effective * effective){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        if(impactDamage > 0){
          monster.hp = Math.max(0, prevHp - impactDamage);
          spawnHitSplat(monster.x, monster.y - monsterRadius, impactDamage);
          updateMonsterHud();
        }
        hits += 1;
      }
    }

    return hits;
  }

  function fireBulwarkCrashCast(cast){
    if(!cast || cast.ended) return false;
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    const centerX = Number.isFinite(origin.x) ? origin.x : player.x;
    const centerY = Number.isFinite(origin.y) ? origin.y : player.y;
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const baseDamage = Math.max(0, Number(cast.damage) || 0);
    const bonusPct = Math.max(0, Number(cast.bonusDamagePct) || 0);
    const bonusMultiplier = cast.shieldAbsorbed ? 1 + bonusPct / 100 : 1;
    const damage = baseDamage * bonusMultiplier;
    const abilityName = cast.abilityName || 'Bulwark Crash';

    const hits = applyBulwarkCrashImpact({ centerX, centerY, radius, damage });
    const pulseColor = cast.shieldAbsorbed ? '#ffd592' : '#d4f0ff';
    flash(centerX, centerY, { startRadius: Math.max(14, radius * 0.5), endRadius: Math.max(radius + 46, radius * 1.1), color: pulseColor });

    if(cast.shieldRef && cast.shieldRef.castRef === cast){
      cast.shieldRef.castRef = null;
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    endBulwarkCrashCast(cast, { reason: 'complete' });

    if(cast.casterRef === player){
      const empowered = cast.shieldAbsorbed ? ' (empowered)' : '';
      const message = hits > 0
        ? `${abilityName}${empowered} hit ${hits} target${hits === 1 ? '' : 's'}.`
        : `${abilityName}${empowered} slammed the ground.`;
      setHudMessage(message);
    }
    return true;
  }

  function endBulwarkCrashCast(cast, { reason = 'complete' } = {}){
    if(!cast || cast.ended) return;
    cast.ended = true;
    if(!cast.cooldownApplied && Number.isFinite(cast.slotIndex)){
      const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
      cast.cooldownApplied = true;
    }
    if(cast.shieldRef && cast.shieldRef.castRef === cast){
      cast.shieldRef.castRef = null;
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
      if(reason === 'interrupted'){
        setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
      }
    }
  }

  function castRagePulseAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Rage Pulse';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'aoeRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);

    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a radius configured.`);
      return false;
    }
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    const cast = {
      slotIndex,
      abilityId: ability && ability.id,
      abilityName,
      casterRef: player,
      startX: player.x,
      startY: player.y,
      radius,
      damage,
      castDuration,
      elapsed: 0
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      return fireRagePulseCast(cast);
    }

    ragePulseCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} bracing to burst...`);
    return true;
  }

  function fireRagePulseCast(cast){
    if(!cast) return false;
    const origin = resolveCastOrigin(cast);
    const centerX = Number.isFinite(origin.x) ? origin.x : player.x;
    const centerY = Number.isFinite(origin.y) ? origin.y : player.y;
    const radius = Math.max(0, Number(cast.radius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);

    const hits = applyRagePulseDamage(centerX, centerY, radius, damage);
    const startRadius = Math.max(12, radius * 0.55);
    const endRadius = Math.max(radius + 40, startRadius + 24);
    flash(centerX, centerY, { startRadius, endRadius, color: '#ffc89b' });

    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    const abilityName = cast.abilityName || 'Rage Pulse';
    if(hits > 0){
      const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      setHudMessage(`${abilityName} hit ${hits} target${hits === 1 ? '' : 's'}${dmgText}.`);
    } else {
      setHudMessage(`${abilityName} found no targets.`);
    }

    return true;
  }

  function applyRagePulseDamage(centerX, centerY, radius, damage){
    const safeRadius = Math.max(0, Number(radius) || 0);
    const safeDamage = Math.max(0, Number(damage) || 0);
    if(!(safeRadius > 0)) return 0;

    let hits = 0;

    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const effective = safeRadius + targetRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      if(dx * dx + dy * dy > effective * effective) continue;
      const prevHp = Number(m.hp) || 0;
      if(safeDamage > 0){
        m.hp = Math.max(0, prevHp - safeDamage);
        spawnHitSplat(m.x, m.y - targetRadius, safeDamage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }

    const monster = monsterState;
    if(monster && isMonsterAttackable(monster)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      const effective = safeRadius + monsterRadius;
      const dx = monster.x - centerX;
      const dy = monster.y - centerY;
      if(dx * dx + dy * dy <= effective * effective){
        const prevHp = Math.max(0, Number(monster.hp) || 0);
        if(safeDamage > 0){
          monster.hp = Math.max(0, prevHp - safeDamage);
          spawnHitSplat(monster.x, monster.y - monsterRadius, safeDamage);
          updateMonsterHud();
        }
        hits += 1;
      }
    }

    return hits;
  }

  function readCleaveCrushConfig(ability){
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const lockout = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const sweepRange = Math.max(0, Number(abilityFieldValue(ability, 'sweepRangePx')) || 0);
    const sweepWidth = Math.max(0, Number(abilityFieldValue(ability, 'sweepWidthPx')) || 0);
    const sweepDamage = Math.max(0, Number(abilityFieldValue(ability, 'sweepDamage')) || 0);
    const edgeStart = Math.max(0, Number(abilityFieldValue(ability, 'edgeStartPx')) || 0);
    const edgeMultiplier = Math.max(1, Number(abilityFieldValue(ability, 'edgeMultiplier')) || 1);
    const recastWindow = Math.max(0, Number(abilityFieldValue(ability, 'recastWindowMs')) || 0) / 1000;
    const slamRange = Math.max(0, Number(abilityFieldValue(ability, 'slamRangePx')) || 0);
    const slamWidth = Math.max(0, Number(abilityFieldValue(ability, 'slamWidthPx')) || 0);
    const slamDamage = Math.max(0, Number(abilityFieldValue(ability, 'slamDamage')) || 0);
    const slamFirstMultiplier = Math.max(1, Number(abilityFieldValue(ability, 'slamFirstMultiplier')) || 1);
    return {
      cooldownSeconds,
      lockout,
      sweepRange,
      sweepWidth,
      sweepDamage,
      edgeStart,
      edgeMultiplier,
      recastWindow,
      slamRange,
      slamWidth,
      slamDamage,
      slamFirstMultiplier
    };
  }

  function cleaveCrushHalfAngle(range, width){
    const safeRange = Math.max(0.0001, Number(range) || 0.0001);
    const safeWidth = Math.max(0, Number(width) || 0);
    return Math.atan2(safeWidth * 0.5, safeRange);
  }

  function completeCleaveCrush(cast, reason){
    if(!cast || cast.completed) return;
    cast.completed = true;
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(cast.slotIndex)){
      const cooldown = Math.max(0, Number(cast.cooldownSeconds) || 0);
      setAbilitySlotCooldown(cast.slotIndex, cooldown);
    }
    if(cast.casterRef === player && reason === 'expired'){
      setHudMessage(`${cast.abilityName || 'Cleave'} follow-up expired.`);
    }
    const idx = cleaveCrushCasts.indexOf(cast);
    if(idx >= 0){
      cleaveCrushCasts.splice(idx, 1);
    }
  }

  function resolveCleaveCrushSweep(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    let dirX = Number(cast.sweepDirX) || 0;
    let dirY = Number(cast.sweepDirY) || 0;
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;

    const range = Math.max(0, Number(cast.sweepRange) || 0);
    const width = Math.max(0, Number(cast.sweepWidth) || 0);
    const halfAngle = cleaveCrushHalfAngle(range, width);
    const cosHalf = Math.cos(halfAngle);
    const baseDamage = Math.max(0, Number(cast.sweepDamage) || 0);
    const edgeStart = Math.max(0, Math.min(range, Number(cast.edgeStart) || 0));
    const edgeMultiplier = Math.max(1, Number(cast.edgeMultiplier) || 1);
    const effectiveRange = range + minionRadius;
    const effectiveSq = effectiveRange * effectiveRange;
    let hits = 0;

    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - origin.x;
      const dy = m.y - origin.y;
      const distSq = dx * dx + dy * dy;
      if(distSq > effectiveSq) continue;
      const dist = Math.sqrt(distSq);
      const dot = (dx * dirX + dy * dirY) / (dist || 1);
      if(dot < cosHalf) continue;
      let damage = baseDamage;
      const effectiveDist = Math.max(0, dist - minionRadius * 0.5);
      if(effectiveDist >= edgeStart && edgeMultiplier > 1){
        damage *= edgeMultiplier;
      }
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }

    flash(origin.x, origin.y, { startRadius: Math.max(10, Math.min(range * 0.35, 28)), endRadius: Math.max(range * 0.8, 42), color: '#7fe3ff' });

    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    if(hits > 0 && cast.recastWindow > 0 && cast.slamRange > 0){
      cast.state = 'recastReady';
      cast.recastRemaining = cast.recastWindow;
      if(cast.casterRef === player){
        setHudMessage(`${cast.abilityName || 'Cleave'} connected! Recast to crush.`);
      }
      return true;
    }

    if(cast.casterRef === player){
      if(hits > 0){
        setHudMessage(`${cast.abilityName || 'Cleave'} struck ${hits} target${hits === 1 ? '' : 's'}.`);
      } else {
        setHudMessage(`${cast.abilityName || 'Cleave'} missed.`);
      }
    }
    completeCleaveCrush(cast, 'sweep');
    return true;
  }

  function resolveCleaveCrushSlam(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    let dirX = Number(cast.slamDirX);
    let dirY = Number(cast.slamDirY);
    if(!Number.isFinite(dirX) || !Number.isFinite(dirY)){
      dirX = Number(cast.sweepDirX) || 0;
      dirY = Number(cast.sweepDirY) || 0;
    }
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;

    const range = Math.max(0, Number(cast.slamRange) || 0);
    const width = Math.max(0, Number(cast.slamWidth) || 0);
    const baseDamage = Math.max(0, Number(cast.slamDamage) || 0);
    const firstMultiplier = Math.max(1, Number(cast.slamFirstMultiplier) || 1);
    if(!(range > 0)){
      if(cast.casterRef === player){
        setHudMessage(`${cast.abilityName || 'Crush'} needs a slam range.`);
      }
      completeCleaveCrush(cast, 'invalid');
      return false;
    }
    const effectiveHalfWidth = width * 0.5 + minionRadius;
    const effectiveHalfWidthSq = effectiveHalfWidth * effectiveHalfWidth;
    const hits = [];

    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const relX = m.x - origin.x;
      const relY = m.y - origin.y;
      const along = relX * dirX + relY * dirY;
      if(along < -minionRadius) continue;
      if(along > range + minionRadius) continue;
      const closestX = origin.x + dirX * along;
      const closestY = origin.y + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY > effectiveHalfWidthSq) continue;
      hits.push({ target: m, along });
    }

    if(hits.length){
      hits.sort((a, b) => a.along - b.along);
    }

    let hitCount = 0;
    for(const entry of hits){
      const target = entry.target;
      if(!target) continue;
      let damage = baseDamage;
      if(hitCount === 0 && firstMultiplier > 1){
        damage *= firstMultiplier;
      }
      const prevHp = Number(target.hp) || 0;
      if(damage > 0){
        target.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(target.x, target.y - minionRadius, damage);
      }
      handlePracticeDummyDamage(target, prevHp);
      hitCount++;
    }

    const flashOffset = Math.min(range, Math.max(30, width * 0.25 || 0));
    flash(origin.x + dirX * flashOffset, origin.y + dirY * flashOffset, { startRadius: Math.max(12, effectiveHalfWidth * 0.4), endRadius: Math.max(range * 0.5, 42), color: '#7fe3ff' });

    if(cast.casterRef === player){
      if(hitCount > 0){
        setHudMessage(`${cast.abilityName || 'Crush'} smashed ${hitCount} target${hitCount === 1 ? '' : 's'}.`);
      } else {
        setHudMessage(`${cast.abilityName || 'Crush'} hit nothing.`);
      }
    }

    completeCleaveCrush(cast, 'used');
    return true;
  }

  function startCleaveCrushRecast(existing, ability, slotIndex, abilityName){
    if(!existing) return false;
    if(existing.state === 'sweepWindup' || existing.state === 'slamWindup'){
      setHudMessage(`${abilityName} is already casting.`);
      return false;
    }
    if(existing.state !== 'recastReady'){
      setHudMessage(`${abilityName} is already in motion.`);
      return false;
    }
    const remaining = Number.isFinite(existing.recastRemaining) ? existing.recastRemaining : 0;
    if(!(remaining > 0)){
      completeCleaveCrush(existing, 'expired');
      return false;
    }

    const config = readCleaveCrushConfig(ability);
    existing.abilityId = ability.id;
    existing.abilityName = abilityName;
    existing.cooldownSeconds = config.cooldownSeconds;
    existing.lockout = config.lockout;
    existing.sweepRange = config.sweepRange;
    existing.sweepWidth = config.sweepWidth;
    existing.sweepDamage = config.sweepDamage;
    existing.edgeStart = config.edgeStart;
    existing.edgeMultiplier = config.edgeMultiplier;
    existing.recastWindow = config.recastWindow;
    existing.slamRange = config.slamRange;
    existing.slamWidth = config.slamWidth;
    existing.slamDamage = config.slamDamage;
    existing.slamFirstMultiplier = config.slamFirstMultiplier;
    existing.slotIndex = slotIndex;
    if(existing.recastWindow > 0 && remaining > existing.recastWindow){
      existing.recastRemaining = existing.recastWindow;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    existing.slamDirX = dx / len;
    existing.slamDirY = dy / len;
    existing.state = existing.lockout > 0 ? 'slamWindup' : 'slamImpact';
    existing.elapsed = 0;

    cancelPlayerAttack(false);
    player.casting = existing;
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(existing.state === 'slamImpact'){
      const resolved = resolveCleaveCrushSlam(existing);
      return resolved ? { success: true, deferCooldown: true } : false;
    }

    setHudMessage(`${abilityName} lining up the crush...`);
    return { success: true, deferCooldown: true };
  }

  function castCleaveCrushAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Cleave and Crush';
    const existing = cleaveCrushCasts.find(c => c && c.casterRef === player && c.abilityId === ability.id && !c.completed);
    if(existing){
      return startCleaveCrushRecast(existing, ability, slotIndex, abilityName);
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const config = readCleaveCrushConfig(ability);
    if(!(config.sweepRange > 0)){
      setHudMessage(`${abilityName} needs a sweep range.`);
      return false;
    }
    if(!(config.sweepDamage > 0)){
      setHudMessage(`${abilityName} needs sweep damage.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds: config.cooldownSeconds,
      lockout: config.lockout,
      sweepRange: config.sweepRange,
      sweepWidth: config.sweepWidth,
      sweepDamage: config.sweepDamage,
      edgeStart: config.edgeStart,
      edgeMultiplier: config.edgeMultiplier,
      recastWindow: config.recastWindow,
      slamRange: config.slamRange,
      slamWidth: config.slamWidth,
      slamDamage: config.slamDamage,
      slamFirstMultiplier: config.slamFirstMultiplier,
      sweepDirX: dirX,
      sweepDirY: dirY,
      recastRemaining: 0,
      elapsed: 0,
      state: config.lockout > 0 ? 'sweepWindup' : 'sweepImpact'
    };

    cleaveCrushCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.casting = cast;

    if(cast.state === 'sweepImpact'){
      const resolved = resolveCleaveCrushSweep(cast);
      return resolved ? { success: true, deferCooldown: true } : false;
    }

    setHudMessage(`${abilityName} sweeping...`);
    return { success: true, deferCooldown: true };
  }

  function castSlamAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Slam';
    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const castTimeRaw = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeRaw) || 0) / 1000;

    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const impactDamage = Math.max(0, Number(abilityFieldValue(ability, 'impactDamage')) || 0);
    const impactKnockup = Math.max(0, Number(abilityFieldValue(ability, 'impactKnockupMs')) || 0) / 1000;

    const fissureLength = Math.max(0, Number(abilityFieldValue(ability, 'fissureLength')) || 0);
    const fissureWidth = Math.max(0, Number(abilityFieldValue(ability, 'fissureWidth')) || 0);
    const fissureSpeed = Math.max(0, Number(abilityFieldValue(ability, 'fissureSpeed')) || 0);
    const fissureDamage = Math.max(0, Number(abilityFieldValue(ability, 'fissureDamage')) || 0);
    const firstNear = Math.max(0, Number(abilityFieldValue(ability, 'fissureFirstNearMs')) || 0) / 1000;
    const firstFar = Math.max(0, Number(abilityFieldValue(ability, 'fissureFirstFarMs')) || 0) / 1000;
    const otherKnock = Math.max(0, Number(abilityFieldValue(ability, 'fissureOtherKnockupMs')) || 0) / 1000;

    const iceFieldDuration = Math.max(0, Number(abilityFieldValue(ability, 'iceFieldDurationMs')) || 0) / 1000;
    const iceFieldTick = Math.max(0.05, (Number(abilityFieldValue(ability, 'iceFieldTickMs')) || 0) / 1000);
    const iceFieldSlowPct = Math.max(0, Number(abilityFieldValue(ability, 'iceFieldSlowPct')) || 0);
    const iceFieldSlowFraction = Math.max(0, Math.min(1, iceFieldSlowPct / 100));

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      startX,
      startY,
      dirX,
      dirY,
      impactRadius,
      impactDamage,
      impactKnockup,
      fissureLength,
      fissureWidth,
      fissureSpeed,
      fissureDamage,
      firstKnockNear: firstNear,
      firstKnockFar: Math.max(firstNear, firstFar),
      otherKnock,
      iceFieldDuration,
      iceFieldTick,
      iceFieldSlowFraction,
      castDuration,
      elapsed: 0
    };

    if(cast.castDuration <= 0){
      return fireSlamCast(cast);
    }

    slamCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setHudMessage(`${abilityName} preparing to slam...`);
    return true;
  }

  function fireSlamCast(cast){
    if(!cast) return false;
    const caster = cast.casterRef;
    let { x: originX, y: originY } = resolveCastOrigin(cast);
    let dirX = Number(cast.dirX) || 0;
    let dirY = Number(cast.dirY) || 0;
    const len = Math.hypot(dirX, dirY);
    if(len > 0.0001){
      dirX /= len;
      dirY /= len;
    } else {
      dirX = 1;
      dirY = 0;
    }
    const abilityName = cast.abilityName || 'Slam';

    spawnSlamImpact(originX, originY, cast.impactRadius);
    const impactHits = applySlamImpact(cast, originX, originY);

    let fissureSpawned = false;
    const length = Math.max(0, Number(cast.fissureLength) || 0);
    const width = Math.max(0, Number(cast.fissureWidth) || 0);
    const speed = Math.max(0, Number(cast.fissureSpeed) || 0);
    if(length > 0 && width > 0 && speed > 0){
      const iceField = {
        startX: originX,
        startY: originY,
        dirX,
        dirY,
        width,
        maxLength: length,
        length: 0,
        slowFraction: Math.max(0, Math.min(1, Number(cast.iceFieldSlowFraction) || 0)),
        tickInterval: Math.max(0.05, Number(cast.iceFieldTick) || 0),
        duration: Math.max(0, Number(cast.iceFieldDuration) || 0),
        age: 0,
        tickTimer: Math.max(0.05, Number(cast.iceFieldTick) || 0),
        owner: null
      };
      slamIceFields.push(iceField);

      const fissure = {
        startX: originX,
        startY: originY,
        dirX,
        dirY,
        maxLength: length,
        width,
        speed,
        damage: Math.max(0, Number(cast.fissureDamage) || 0),
        firstNear: Math.max(0, Number(cast.firstKnockNear) || 0),
        firstFar: Math.max(0, Number(cast.firstKnockFar) || 0),
        otherKnock: Math.max(0, Number(cast.otherKnock) || 0),
        abilityName,
        casterRef: caster || null,
        distance: 0,
        headX: originX,
        headY: originY,
        state: 'travel',
        fadeDuration: 0.45,
        fadeRemaining: 0.45,
        hitTargets: new Set(),
        firstTargetHit: false,
        iceFieldRef: iceField
      };
      iceField.owner = fissure;
      slamFissures.push(fissure);
      fissureSpawned = true;
    }

    cancelPlayerAttack(false);
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }

    if(impactHits > 0){
      setHudMessage(`${abilityName} crushed ${impactHits} target${impactHits === 1 ? '' : 's'}!`);
    } else if(fissureSpawned){
      setHudMessage(`${abilityName} split the ground!`);
    } else {
      setHudMessage(`${abilityName} slammed the ground.`);
    }

    return true;
  }

  function spawnSlamImpact(x, y, radius){
    const safeRadius = Math.max(0, Number(radius) || 0);
    slamImpacts.push({ x, y, radius: safeRadius, age: 0, lifetime: 0.5 });
    const startRadius = safeRadius > 0 ? Math.max(12, safeRadius * 0.4) : 18;
    const endRadius = safeRadius > 0 ? Math.max(safeRadius, startRadius + 28) : 48;
    flash(x, y, { startRadius, endRadius, color: '#8fe3ff' });
  }

  function applySlamImpact(cast, originX, originY){
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const damage = Math.max(0, Number(cast.impactDamage) || 0);
    const knockup = Math.max(0, Number(cast.impactKnockup) || 0);
    if(!(radius > 0) && damage <= 0 && knockup <= 0) return 0;
    const effectiveRadius = radius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - originX;
      const dy = m.y - originY;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      if(knockup > 0){
        const existing = typeof m.stunTimer === 'number' ? m.stunTimer : 0;
        m.stunTimer = Math.max(existing, knockup);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }
    return hits;
  }

  function slamFissureKnockupForDistance(fissure, along){
    if(!fissure) return 0;
    const near = Math.max(0, Number(fissure.firstNear) || 0);
    const far = Math.max(near, Number(fissure.firstFar) || 0);
    const maxLength = Math.max(1, Number(fissure.maxLength) || 1);
    const t = clamp01(along / maxLength);
    return near + (far - near) * (far - near === 0 ? 0 : t);
  }

  function processSlamFissureSegment(fissure, startDist, endDist){
    if(!fissure) return;
    const actualStart = Math.max(0, Math.min(startDist, endDist));
    const actualEnd = Math.max(actualStart, endDist);
    if(!(actualEnd > actualStart)) return;
    const dirX = Number(fissure.dirX) || 0;
    const dirY = Number(fissure.dirY) || 0;
    const startX = Number(fissure.startX) || 0;
    const startY = Number(fissure.startY) || 0;
    const maxLength = Math.max(0, Number(fissure.maxLength) || 0);
    const effectiveHalfWidth = Math.max(0, Number(fissure.width) || 0) * 0.5;
    const effectiveRadius = effectiveHalfWidth + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    if(!fissure.hitTargets) fissure.hitTargets = new Set();

    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      if(fissure.hitTargets.has(m)) continue;
      const relX = m.x - startX;
      const relY = m.y - startY;
      const along = relX * dirX + relY * dirY;
      if(along < actualStart - minionRadius) continue;
      if(along > actualEnd + minionRadius) continue;
      if(along < -minionRadius || along > maxLength + minionRadius) continue;
      const clamped = Math.max(actualStart, Math.min(actualEnd, along));
      const closestX = startX + dirX * clamped;
      const closestY = startY + dirY * clamped;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(fissure.damage > 0){
        m.hp = Math.max(0, prevHp - fissure.damage);
        spawnHitSplat(m.x, m.y - minionRadius, fissure.damage);
      }
      let knock = fissure.otherKnock || 0;
      if(!fissure.firstTargetHit){
        knock = slamFissureKnockupForDistance(fissure, Math.max(0, Math.min(along, fissure.maxLength)));
        fissure.firstTargetHit = true;
      }
      if(knock > 0){
        const existing = typeof m.stunTimer === 'number' ? m.stunTimer : 0;
        m.stunTimer = Math.max(existing, knock);
      }
      handlePracticeDummyDamage(m, prevHp);
      fissure.hitTargets.add(m);
    }
  }

  function applySlamIceFieldTick(field){
    if(!field) return;
    const length = Math.max(0, Math.min(Number(field.maxLength) || 0, Number(field.length) || 0));
    const width = Math.max(0, Number(field.width) || 0);
    if(!(length > 0) || !(width > 0)) return;
    const dirX = Number(field.dirX) || 0;
    const dirY = Number(field.dirY) || 0;
    const startX = Number(field.startX) || 0;
    const startY = Number(field.startY) || 0;
    const slowFraction = Math.max(0, Math.min(1, Number(field.slowFraction) || 0));
    if(slowFraction <= 0) return;
    const halfWidth = width * 0.5;
    const effectiveRadius = halfWidth + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    const slowDuration = Math.max(0.1, (Number(field.tickInterval) || 0) * 2);

    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const relX = m.x - startX;
      const relY = m.y - startY;
      const along = relX * dirX + relY * dirY;
      if(along < -minionRadius || along > length + minionRadius) continue;
      const clamped = Math.max(0, Math.min(length, along));
      const closestX = startX + dirX * clamped;
      const closestY = startY + dirY * clamped;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY > effectiveSq) continue;
      const existing = typeof m.slowPct === 'number' ? m.slowPct : 0;
      m.slowPct = Math.max(existing, slowFraction);
      m.slowTimer = Math.max(m.slowTimer || 0, slowDuration);
    }
  }

  function castKunaiFanburstAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const rawCount = abilityFieldValue(ability, 'laserCount');
    const count = Math.max(0, Math.floor(Number(rawCount) || 0));
    if(count <= 0){
      setHudMessage('Kunai Fanburst has no kunai configured.');
      return false;
    }
    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const baseDirX = dx / distance;
    const baseDirY = dy / distance;
    const configuredDistanceRaw = abilityFieldValue(ability, 'laserDistance');
    const configuredDistance = Math.max(0, Number(configuredDistanceRaw) || 0);
    const centralDistance = configuredDistance > 0 ? configuredDistance : distance;
    const safeDistance = Math.max(1, centralDistance);
    const widthRaw = abilityFieldValue(ability, 'laserWidth');
    const coneWidth = Math.max(0, Number(widthRaw) || 0);
    const projectileWidthRaw = abilityFieldValue(ability, 'laserProjectileWidth');
    const projectileWidth = Math.max(0, Number(projectileWidthRaw) || 0);
    const speedRaw = abilityFieldValue(ability, 'laserSpeed');
    const speed = Math.max(1, Number(speedRaw) || 0);
    const damageRaw = abilityFieldValue(ability, 'damage');
    const damage = Math.max(0, Number(damageRaw) || 0);
    const slowRaw = abilityFieldValue(ability, 'slowPct');
    const slowFraction = Math.max(0, Math.min(1, (Number(slowRaw) || 0) / 100));
    const slowDurationRaw = abilityFieldValue(ability, 'slowDurationMs');
    const slowDurationSeconds = Math.max(0, Number(slowDurationRaw) || 0) / 1000;
    const slowMinRaw = abilityFieldValue(ability, 'slowMinRangePx');
    const slowMinDistance = Math.max(0, Number(slowMinRaw) || 0);
    const castTimeRaw = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeRaw) || 0) / 1000;
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Kunai Fanburst';
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      count,
      coneWidth,
      distance: safeDistance,
      speed,
      damage,
      slowFraction,
      slowDuration: slowDurationSeconds,
      slowMinDistance,
      projectileWidth,
      castDuration,
      elapsed: 0,
      startX,
      startY,
      targetX: aimPoint.x,
      targetY: aimPoint.y,
      lockedDirX: baseDirX,
      lockedDirY: baseDirY
    };

    if(cast.castDuration <= 0){
      return fireLaserConeCast(cast);
    }

    laserConeCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setHudMessage(`${abilityName} readying...`);
    return true;
  }

  function castLaserConeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const rawCount = abilityFieldValue(ability, 'laserCount');
    const count = Math.max(0, Math.floor(Number(rawCount) || 0));
    if(count <= 0){
      setHudMessage('Laser Cone has no lasers configured.');
      return false;
    }
    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const baseDirX = dx / distance;
    const baseDirY = dy / distance;
    const configuredDistanceRaw = abilityFieldValue(ability, 'laserDistance');
    const configuredDistance = Math.max(0, Number(configuredDistanceRaw) || 0);
    const centralDistance = configuredDistance > 0 ? configuredDistance : distance;
    const safeDistance = Math.max(1, centralDistance);
    const widthRaw = abilityFieldValue(ability, 'laserWidth');
    const coneWidth = Math.max(0, Number(widthRaw) || 0);
    const projectileWidthRaw = abilityFieldValue(ability, 'laserProjectileWidth');
    const projectileWidth = Math.max(0, Number(projectileWidthRaw) || 0);
    const speedRaw = abilityFieldValue(ability, 'laserSpeed');
    const speed = Math.max(1, Number(speedRaw) || 0);
    const baseDamageRaw = abilityFieldValue(ability, 'baseDamage');
    const baseDamage = Math.max(0, Number(baseDamageRaw) || 0);
    const scaleRaw = abilityFieldValue(ability, 'damageScalePct');
    portalState.scalePct = Math.max(0, Number(scaleRaw) || 0);
    const bonusDamage = player.attackDamage * (portalState.scalePct / 100);
    const totalDamage = Math.max(0, baseDamage + bonusDamage);
    const slowRaw = abilityFieldValue(ability, 'slowPct');
    const slowFraction = Math.max(0, Math.min(1, (Number(slowRaw) || 0) / 100));
    const slowDurationRaw = abilityFieldValue(ability, 'slowDurationMs');
    const slowDurationSeconds = Math.max(0, Number(slowDurationRaw) || 0) / 1000;
    const castTimeRaw = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeRaw) || 0) / 1000;
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Laser Cone';
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      count,
      coneWidth,
      distance: safeDistance,
      speed,
      damage: totalDamage,
      slowFraction,
      slowDuration: slowDurationSeconds,
      projectileWidth,
      castDuration,
      elapsed: 0,
      startX,
      startY,
      targetX: aimPoint.x,
      targetY: aimPoint.y,
      lockedDirX: baseDirX,
      lockedDirY: baseDirY
    };

    if(cast.castDuration <= 0){
      return fireLaserConeCast(cast);
    }

    laserConeCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setHudMessage(`${abilityName} charging...`);
    return true;
  }

  function collectAbilityTargets(){
    const targets = [];
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      targets.push(m);
    }
    if(monsterState && isMonsterAttackable(monsterState)){
      targets.push(monsterState);
    }
    if(practiceDummy && practiceDummy.active !== false && Number(practiceDummy.hp) > 0){
      targets.push(practiceDummy);
    }
    return targets;
  }

  function findNearestEnemy(originX, originY, maxRange){
    const maxDist = Math.max(0, Number(maxRange) || 0);
    const maxSq = maxDist > 0 ? maxDist * maxDist : Infinity;
    const startX = Number(originX) || 0;
    const startY = Number(originY) || 0;
    let best = null;
    let bestSq = Infinity;
    const targets = collectAbilityTargets();
    for(const target of targets){
      if(!target) continue;
      const dx = target.x - startX;
      const dy = target.y - startY;
      const distSq = dx * dx + dy * dy;
      if(distSq > maxSq) continue;
      if(distSq < bestSq){
        bestSq = distSq;
        best = target;
      }
    }
    return best;
  }

  function applyAbilityDamage(target, amount){
    if(!target || amount <= 0) return 0;
    const bonus = consumeShadowTalonMarkDamage(target);
    const totalDamage = amount + bonus;
    if(totalDamage <= 0) return 0;
    const prevHp = Math.max(0, Number(target.hp) || 0);
    if(prevHp <= 0) return 0;
    const nextHp = Math.max(0, prevHp - totalDamage);
    const applied = prevHp - nextHp;
    if(applied <= 0) return 0;
    target.hp = nextHp;
    const offset = target === monsterState ? Math.max(24, monsterAttackRadius()) : minionRadius;
    spawnHitSplat(target.x, target.y - offset, applied);
    handlePracticeDummyDamage(target, prevHp);
    if(prevHp > 0 && nextHp <= 0){
      if(target === monsterState){
        updateMonsterHud();
      } else if(!target.isPracticeDummy){
        addGold(goldState.perKill);
      }
    }
    return applied;
  }

  function setShadowTalonMark(target, { duration = 0, stacks = 0, bonusDamage = 0 } = {}){
    if(!target) return null;
    const markDuration = Math.max(0, Number(duration) || 0);
    const hitBonus = Math.max(0, Number(bonusDamage) || 0);
    const hitStacks = Math.max(0, Math.floor(Number(stacks) || 0));
    if(!(markDuration > 0) || !(hitBonus > 0) || !(hitStacks > 0)){
      return null;
    }
    if(target.shadowTalonMark){
      removeShadowTalonMark(target.shadowTalonMark);
    }
    const mark = {
      target,
      remainingHits: hitStacks,
      bonusDamage: hitBonus,
      remainingDuration: markDuration
    };
    target.shadowTalonMark = mark;
    shadowTalonMarks.push(mark);
    return mark;
  }

  function removeShadowTalonMark(mark){
    if(!mark) return;
    const target = mark.target;
    if(target && target.shadowTalonMark === mark){
      target.shadowTalonMark = null;
    }
    const idx = shadowTalonMarks.indexOf(mark);
    if(idx >= 0){
      shadowTalonMarks.splice(idx, 1);
    }
  }

  function consumeShadowTalonMarkDamage(target){
    const mark = target && target.shadowTalonMark;
    if(!mark || !(mark.bonusDamage > 0)){
      return 0;
    }
    if(mark.remainingHits <= 0){
      removeShadowTalonMark(mark);
      return 0;
    }
    mark.remainingHits -= 1;
    const amount = mark.bonusDamage;
    if(mark.remainingHits <= 0){
      removeShadowTalonMark(mark);
    }
    return amount;
  }

  function updateShadowTalonMarks(dt){
    for(let i = shadowTalonMarks.length - 1; i >= 0; i--){
      const mark = shadowTalonMarks[i];
      if(!mark){
        shadowTalonMarks.splice(i, 1);
        continue;
      }
      mark.remainingDuration = Math.max(0, (mark.remainingDuration || 0) - dt);
      if(mark.remainingDuration <= 0){
        removeShadowTalonMark(mark);
      }
    }
  }

  function healPlayerFromLifeSteal(totalDamage, lifeStealPct){
    const pct = Math.max(0, Number(lifeStealPct) || 0);
    if(totalDamage <= 0 || pct <= 0){
      return;
    }
    const healAmount = totalDamage * (pct / 100);
    if(healAmount <= 0){
      return;
    }
    const currentHp = Math.max(0, Number(player.hp) || 0);
    const maxHp = Math.max(1, Number(player.maxHp) || 1);
    player.hp = Math.min(maxHp, currentHp + healAmount);
  }

  function collectTargetsInCone(originX, originY, dirX, dirY, range, angleDeg){
    const results = [];
    if(!(range > 0)){
      return results;
    }
    let halfAngle = (Number(angleDeg) || 0) * (Math.PI / 360);
    if(halfAngle < 0) halfAngle = 0;
    const cosThreshold = Math.cos(halfAngle);
    const targets = collectAbilityTargets();
    for(const target of targets){
      if(!target || !Number.isFinite(target.x) || !Number.isFinite(target.y)) continue;
      const dx = target.x - originX;
      const dy = target.y - originY;
      const dist = Math.hypot(dx, dy);
      if(dist > range + minionRadius) continue;
      const dot = dist > 0.0001 ? (dx * dirX + dy * dirY) / dist : 1;
      if(dot < cosThreshold) continue;
      results.push(target);
    }
    return results;
  }

  function findFirstEnemyAlongRay(originX, originY, dirX, dirY, range, width){
    if(!(range > 0)) return null;
    const safeWidth = Math.max(0, Number(width) || 0) + minionRadius;
    let bestTarget = null;
    let bestAlong = Infinity;
    const targets = collectAbilityTargets();
    for(const target of targets){
      if(!target) continue;
      const dx = target.x - originX;
      const dy = target.y - originY;
      const along = dx * dirX + dy * dirY;
      if(along < -minionRadius) continue;
      if(along > range + minionRadius) continue;
      const perp = Math.abs(dx * dirY - dy * dirX);
      const radiusBuffer = target === monsterState ? Math.max(minionRadius, monsterAttackRadius()) : minionRadius;
      if(perp > safeWidth + radiusBuffer) continue;
      if(along < bestAlong){
        bestAlong = along;
        bestTarget = target;
      }
    }
    return bestTarget;
  }

  function damageEnemiesInRadius(centerX, centerY, radius, damage){
    if(radius <= 0 || damage <= 0) return 0;
    const maxRadius = radius + minionRadius;
    const maxRadiusSq = maxRadius * maxRadius;
    let total = 0;
    const targets = collectAbilityTargets();
    for(const target of targets){
      if(!target) continue;
      const dx = target.x - centerX;
      const dy = target.y - centerY;
      const distSq = dx * dx + dy * dy;
      if(distSq > maxRadiusSq) continue;
      total += applyAbilityDamage(target, damage);
    }
    if(total > 0){
      pulses.push({
        x: centerX,
        y: centerY,
        startRadius: Math.max(12, minionRadius),
        endRadius: Math.max(radius, minionRadius * 2),
        color: '#ff8f68',
        t: 0
      });
    }
    return total;
  }

  function pointSegmentDistanceSq(px, py, x1, y1, x2, y2){
    const dx = x2 - x1;
    const dy = y2 - y1;
    const segLenSq = dx * dx + dy * dy;
    if(segLenSq <= 0.0001){
      const vx = px - x1;
      const vy = py - y1;
      return vx * vx + vy * vy;
    }
    const t = ((px - x1) * dx + (py - y1) * dy) / segLenSq;
    const clamped = Math.max(0, Math.min(1, t));
    const projX = x1 + dx * clamped;
    const projY = y1 + dy * clamped;
    const vx = px - projX;
    const vy = py - projY;
    return vx * vx + vy * vy;
  }

  function damageEnemiesAlongSegment(startX, startY, endX, endY, width, damage){
    if(damage <= 0) return 0;
    const dx = endX - startX;
    const dy = endY - startY;
    const segLen = Math.hypot(dx, dy);
    if(segLen <= 0.0001) return 0;
    const allowable = Math.max(0, Number(width) || 0) + minionRadius;
    const allowableSq = allowable * allowable;
    let total = 0;
    const targets = collectAbilityTargets();
    for(const target of targets){
      if(!target) continue;
      const relX = target.x - startX;
      const relY = target.y - startY;
      const along = (relX * dx + relY * dy) / segLen;
      if(along < -minionRadius || along > segLen + minionRadius) continue;
      const distSq = pointSegmentDistanceSq(target.x, target.y, startX, startY, endX, endY);
      if(distSq > allowableSq) continue;
      total += applyAbilityDamage(target, damage);
    }
    return total;
  }

  function detonateWildRushExplosives(){
    if(!wildRushState || !wildRushState.ready){
      return 0;
    }
    const now = perfNow();
    if(wildRushState.expiresAt > 0 && wildRushState.expiresAt < now){
      wildRushState.ready = false;
      return 0;
    }
    const radius = Math.max(0, Number(wildRushState.burstRadius) || 0);
    const damage = Math.max(0, Number(wildRushState.burstDamage) || 0);
    if(!(radius > 0) || !(damage > 0)){
      wildRushState.ready = false;
      return 0;
    }
    const centerX = Number.isFinite(wildRushState.x) ? wildRushState.x : player.x;
    const centerY = Number.isFinite(wildRushState.y) ? wildRushState.y : player.y;
    wildRushState.ready = false;
    return damageEnemiesInRadius(centerX, centerY, radius, damage);
  }

  function castEdgeBurstAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Edge Burst';
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const bladeRange = Math.max(0, Number(abilityFieldValue(ability, 'bladeRangePx')) || 0);
    const bladeAngle = Math.max(0, Number(abilityFieldValue(ability, 'bladeAngleDeg')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const lifeStealPct = Math.max(0, Number(abilityFieldValue(ability, 'lifeStealPct')) || 0);
    if(damage <= 0){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    let hitCount = 0;
    let totalDamage = 0;
    if(bladeRange > 0){
      const coneTargets = collectTargetsInCone(origin.x, origin.y, dirX, dirY, bladeRange, bladeAngle);
      if(coneTargets.length){
        for(const target of coneTargets){
          const applied = applyAbilityDamage(target, damage);
          if(applied > 0){
            totalDamage += applied;
            hitCount += 1;
          }
        }
        flash(origin.x + dirX * Math.min(bladeRange, 180), origin.y + dirY * Math.min(bladeRange, 180), { startRadius: 16, endRadius: Math.max(bladeRange, 40), color: '#ffc36c' });
      }
    }
    if(hitCount === 0 && projectileRange > 0){
      const target = findFirstEnemyAlongRay(origin.x, origin.y, dirX, dirY, projectileRange, projectileWidth);
      if(target){
        const applied = applyAbilityDamage(target, damage);
        if(applied > 0){
          totalDamage += applied;
          hitCount += 1;
          flash(target.x, target.y, { startRadius: 10, endRadius: 32, color: '#ffe9a0' });
        }
      }
    }
    const explosionDamage = detonateWildRushExplosives();
    const parts = [];
    if(hitCount > 0){
      parts.push(`hit ${hitCount} target${hitCount === 1 ? '' : 's'}`);
    } else {
      parts.push('missed');
    }
    if(explosionDamage > 0){
      parts.push(`detonated trail for ${Math.round(explosionDamage)} damage`);
    }
    setHudMessage(`${abilityName} ${parts.join(' and ')}.`);
    if(totalDamage > 0){
      healPlayerFromLifeSteal(totalDamage, lifeStealPct);
    }
    pulses.push({
      x: origin.x + dirX * Math.min(projectileRange || bladeRange || 120, 180),
      y: origin.y + dirY * Math.min(projectileRange || bladeRange || 120, 180),
      startRadius: 10,
      endRadius: Math.max(projectileRange, bladeRange, 60),
      color: '#f7d271',
      t: 0
    });
    return true;
  }

  function castBladeCycloneAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Blade Cyclone';
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'bladeRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(radius <= 0 || damage <= 0){
      setHudMessage(`${abilityName} needs a radius and damage configured.`);
      return false;
    }
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    const firstDamage = damageEnemiesInRadius(player.x, player.y, radius, damage);
    const secondDamage = damageEnemiesInRadius(player.x, player.y, radius, damage * 0.65);
    const total = firstDamage + secondDamage;
    flash(player.x, player.y, { startRadius: Math.max(12, radius * 0.3), endRadius: Math.max(radius + 40, 80), color: '#f16a8b' });
    if(total > 0){
      setHudMessage(`${abilityName} shredded ${Math.round(total)} damage.`);
    } else {
      setHudMessage(`${abilityName} swung but hit nothing.`);
    }
    return true;
  }

  function castReapingMaelstromAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Reaping Maelstrom';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const outerRadius = Math.max(0, Number(abilityFieldValue(ability, 'outerRadiusPx')) || 0);
    const innerRadiusRaw = Math.max(0, Number(abilityFieldValue(ability, 'innerRadiusPx')) || 0);
    const innerRadius = outerRadius > 0 ? Math.min(innerRadiusRaw, outerRadius) : innerRadiusRaw;
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const innerBonusPct = Math.max(0, Number(abilityFieldValue(ability, 'innerDamagePct')) || 0);
    const ghostDuration = Math.max(0, Number(abilityFieldValue(ability, 'ghostDurationMs')) || 0) / 1000;
    const healPerTargetPct = Math.max(0, Number(abilityFieldValue(ability, 'healPerTargetPct')) || 0);
    const maxHealPct = Math.max(0, Number(abilityFieldValue(ability, 'maxHealPct')) || 0);

    if(!(outerRadius > 0)){
      setHudMessage(`${abilityName} needs an outer radius configured.`);
      return false;
    }
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      outerRadius,
      innerRadius,
      damage,
      innerBonusPct,
      healPerTargetPct,
      maxHealPct
    };

    if(ghostDuration > 0){
      player.ghostTimer = Math.max(player.ghostTimer || 0, ghostDuration);
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.attackTarget = null;
    player.attackOverride = null;

    if(cast.castDuration <= 0){
      resolveReapingMaelstromCast(cast);
      return true;
    }

    reapingMaelstromCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} winding up...`);
    return true;
  }

  function resolveReapingMaelstromCast(cast){
    if(!cast) return null;
    const caster = cast.casterRef || player;
    if(caster === player && player.casting === cast){
      player.casting = null;
    }
    const originX = Number(caster.x) || 0;
    const originY = Number(caster.y) || 0;
    const info = applyReapingMaelstromDamage(cast, originX, originY);
    const displayOuter = Math.max(0, Number(cast.outerRadius) || 0);
    const displayInner = Math.max(0, Number(cast.innerRadius) || 0);
    const startRadius = displayInner > 0 ? Math.max(12, displayInner * 0.5) : 12;
    const endRadius = Math.max(displayOuter + 20, 60);
    flash(originX, originY, { startRadius, endRadius, color: '#d34722' });
    pulses.push({
      x: originX,
      y: originY,
      startRadius,
      endRadius,
      color: '#ff9c65',
      t: 0
    });
    if(cast.casterRef === player){
      const abilityName = cast.abilityName || 'Reaping Maelstrom';
      if(info.hitCount > 0){
        const parts = [`${abilityName} hit ${info.hitCount} target${info.hitCount === 1 ? '' : 's'}`];
        if(info.healed > 0){
          parts.push(`healing for ${Math.round(info.healed)} hp`);
        }
        setHudMessage(`${parts.join(' and ')}.`);
      } else {
        setHudMessage(`${abilityName} spun but clipped nothing.`);
      }
    }
    return info;
  }

  function applyReapingMaelstromDamage(cast, originX, originY){
    const outerRadius = Math.max(0, Number(cast.outerRadius) || 0);
    if(!(outerRadius > 0)){
      return { hitCount: 0, innerHits: 0, totalDamage: 0, healed: 0 };
    }
    const damage = Math.max(0, Number(cast.damage) || 0);
    if(damage <= 0){
      return { hitCount: 0, innerHits: 0, totalDamage: 0, healed: 0 };
    }
    const innerRadius = Math.max(0, Math.min(outerRadius, Number(cast.innerRadius) || 0));
    const innerMultiplier = Math.max(0, Number(cast.innerBonusPct) || 0) / 100 + 1;
    const innerDamage = damage * innerMultiplier;
    const targets = collectAbilityTargets();
    const largeTargets = new Set();
    let hitCount = 0;
    let innerHits = 0;
    let totalDamage = 0;
    for(const target of targets){
      if(!target || !Number.isFinite(target.x) || !Number.isFinite(target.y)) continue;
      const dx = target.x - originX;
      const dy = target.y - originY;
      const distSq = dx * dx + dy * dy;
      const targetRadius = target === monsterState
        ? Math.max(minionRadius, monsterAttackRadius(target))
        : (target && target.isPracticeDummy
            ? Math.max(minionRadius, Number(target.radius) || minionRadius)
            : minionRadius);
      const outerThreshold = outerRadius + targetRadius;
      if(distSq > outerThreshold * outerThreshold) continue;
      const innerThreshold = innerRadius > 0 ? innerRadius + targetRadius : 0;
      const innerHit = innerRadius > 0 && distSq <= innerThreshold * innerThreshold;
      const applied = applyAbilityDamage(target, innerHit ? innerDamage : damage);
      if(applied <= 0) continue;
      hitCount += 1;
      totalDamage += applied;
      if(innerHit){
        innerHits += 1;
      }
      if(target === monsterState || (target && target.isPracticeDummy)){
        largeTargets.add(target);
      }
    }
    let healed = 0;
    if(largeTargets.size > 0){
      const caster = cast.casterRef || player;
      const maxHp = Math.max(1, Number(caster.maxHp) || 1);
      const currentHp = Math.max(0, Number(caster.hp) || 0);
      const missing = Math.max(0, maxHp - currentHp);
      if(missing > 0){
        const perTargetPct = Math.max(0, Number(cast.healPerTargetPct) || 0) / 100;
        const capPct = Math.max(0, Number(cast.maxHealPct) || 0) / 100;
        const healPct = Math.min(capPct, perTargetPct * largeTargets.size);
        if(healPct > 0){
          healed = Math.min(missing, missing * healPct);
          caster.hp = Math.min(maxHp, currentHp + healed);
        }
      }
    }
    return { hitCount, innerHits, totalDamage, healed, largeHits: largeTargets.size };
  }

  function updateReapingMaelstromCasts(dt){
    for(let i = reapingMaelstromCasts.length - 1; i >= 0; i--){
      const cast = reapingMaelstromCasts[i];
      if(!cast){
        reapingMaelstromCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        reapingMaelstromCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        reapingMaelstromCasts.splice(i, 1);
        resolveReapingMaelstromCast(cast);
      }
    }
  }

  // Fallback no-ops for removed/disabled abilities to prevent loop errors
  function updateConvergingGaleCasts(dt){ convergingGaleCasts.length = 0; }
  function updateConvergingGaleBlasts(dt){ convergingGaleBlasts.length = 0; }
  function updateConvergingGaleTornadoes(dt){ convergingGaleTornadoes.length = 0; }
  function updateDriftingVeilCasts(dt){ driftingVeilCasts.length = 0; }
  function updateDriftingVeils(dt){ driftingVeils.length = 0; }
  function updateScarecrowStormCasts(dt){ scarecrowStormCasts.length = 0; }
  function updateScarecrowStormZones(dt){ scarecrowStormZones.length = 0; }
  function drawDriftingVeils(){ /* no-op */ }
  function drawMoonlitArcCasts(){ /* no-op */ }
  function drawQuakingStrideAuras(){ /* no-op */ }
  function drawScarecrowStormZones(){ /* no-op */ }
  function drawTemporalVeilCasts(){ /* no-op */ }
  function drawSlamIceFields(){ /* no-op */ }

  function castPhantomSweepAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Phantom Sweep';
    const outerRadius = Math.max(0, Number(abilityFieldValue(ability, 'outerRadiusPx')) || 0);
    const innerRadiusRaw = Math.max(0, Number(abilityFieldValue(ability, 'innerRadiusPx')) || 0);
    const innerRadius = outerRadius > 0 ? Math.min(innerRadiusRaw, outerRadius) : innerRadiusRaw;
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(outerRadius <= 0 || damage <= 0){
      setHudMessage(`${abilityName} needs radius and damage configured.`);
      return false;
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    player.attackTarget = null;
    player.attackOverride = null;

    const innerDamagePct = Math.max(0, Number(abilityFieldValue(ability, 'innerDamagePct')) || 100) / 100;
    const innerDamage = damage * innerDamagePct;
    const buffer = Math.max(0, minionRadius);
    const innerLimit = innerRadius > 0 ? innerRadius + buffer : 0;
    const outerLimit = outerRadius + buffer;
    const innerLimitSq = innerLimit * innerLimit;
    const outerLimitSq = outerLimit * outerLimit;
    let totalDamage = 0;
    let hitCount = 0;
    const targets = collectAbilityTargets();
    for(const target of targets){
      if(!target || !Number.isFinite(target.x) || !Number.isFinite(target.y)) continue;
      const dx = target.x - player.x;
      const dy = target.y - player.y;
      const distSq = dx * dx + dy * dy;
      if(innerRadius > 0 && distSq <= innerLimitSq){
        const applied = applyAbilityDamage(target, innerDamage);
        if(applied > 0){
          totalDamage += applied;
          hitCount += 1;
        }
        continue;
      }
      if(distSq <= outerLimitSq){
        const applied = applyAbilityDamage(target, damage);
        if(applied > 0){
          totalDamage += applied;
          hitCount += 1;
        }
      }
    }

    const ghostDuration = Math.max(0, Number(abilityFieldValue(ability, 'ghostDurationMs')) || 0) / 1000;
    if(ghostDuration > 0){
      player.ghostTimer = Math.max(player.ghostTimer || 0, ghostDuration);
    }

    pulses.push({
      x: player.x,
      y: player.y,
      startRadius: Math.max(12, (innerRadius || 0) * 0.35),
      endRadius: Math.max(outerRadius + 40, outerRadius * 1.2),
      color: '#ff9c65',
      t: 0
    });

    if(totalDamage > 0){
      setHudMessage(`${abilityName} slammed ${Math.round(totalDamage)} damage across ${hitCount} target${hitCount === 1 ? '' : 's'}.`);
    } else {
      setHudMessage(`${abilityName} spun but clipped nothing.`);
    }
    return true;
  }

  function castSpiralRamAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Spiral Ram';
    let state = GameState.effects.spiralRamRoll;
    if(state && state.completed){
      GameState.effects.spiralRamRoll = null;
      state = null;
    }
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id && (!state || state.abilityId !== ability.id)){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    if(state){
      const delay = Math.max(0, Number(state.recastDelay) || 0);
      if(state.elapsed < delay){
        const remaining = Math.max(0, delay - state.elapsed);
        const timeText = remaining >= 1 ? remaining.toFixed(1) : remaining.toFixed(2);
        setHudMessage(`${abilityName} needs ${timeText}s more to cancel.`);
        return false;
      }
      completeSpiralRamRoll(state, { reason: 'manual' });
      return true;
    }

    const channelDuration = Math.max(0, Number(abilityFieldValue(ability, 'channelDurationMs')) || 0) / 1000;
    const recastDelay = Math.max(0, Number(abilityFieldValue(ability, 'manualRecastDelayMs')) || 0) / 1000;
    const gainPerSecond = Math.max(0, Number(abilityFieldValue(ability, 'speedGainPerSecondPct')) || 0) / 100;
    const maxBonus = Math.max(0, Number(abilityFieldValue(ability, 'maxBonusMoveSpeedPct')) || 0) / 100;
    const collisionRadius = Math.max(0, Number(abilityFieldValue(ability, 'collisionRadiusPx')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const knockbackDistance = Math.max(0, Number(abilityFieldValue(ability, 'knockbackDistancePx')) || 0);
    const stunDuration = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0) / 100;
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const revealRadius = Math.max(0, Number(abilityFieldValue(ability, 'revealRadiusPx')) || 0);
    const revealDuration = Math.max(0, Number(abilityFieldValue(ability, 'revealDurationMs')) || 0) / 1000;
    const aimPoint = beamAimPoint();
    const startX = player.x;
    const startY = player.y;
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const cooldownSeconds = abilityCooldownSeconds(ability);

    state = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      cooldownApplied: false,
      channelDuration,
      elapsed: 0,
      recastDelay,
      speedGainPerSecond: gainPerSecond,
      maxSpeedBonus: maxBonus,
      collisionRadius,
      effectRadius: impactRadius,
      damage,
      knockbackDistance,
      stunDuration,
      slowPct,
      slowDuration,
      revealRadius,
      revealDuration,
      dirX,
      dirY,
      completed: false,
      allowMovementWhileCasting: true
    };
    GameState.effects.spiralRamRoll = state;
    player.casting = state;
    player.target.x = player.x + dirX * 2000;
    player.target.y = player.y + dirY * 2000;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    player.facing = Math.atan2(dirY, dirX);
    cancelPlayerAttack(false);
    setHudMessage(`${abilityName} rolling!`);
    return { success: true, deferCooldown: true };
  }

  function completeSpiralRamRoll(state, { reason = 'complete' } = {}){
    if(!state || state.completed) return;
    state.completed = true;
    if(state.slotIndex !== undefined && state.slotIndex !== null && !state.cooldownApplied){
      setAbilitySlotCooldown(state.slotIndex, Math.max(0, Number(state.cooldownSeconds) || 0));
      state.cooldownApplied = true;
    }
    const caster = state.casterRef || player;
    if(caster === player && player.casting === state){
      player.casting = null;
    }
    const centerX = Number.isFinite(caster && caster.x) ? caster.x : player.x;
    const centerY = Number.isFinite(caster && caster.y) ? caster.y : player.y;
    const radius = Math.max(0, Number(state.effectRadius) || 0);
    const damage = Math.max(0, Number(state.damage) || 0);
    const knockback = Math.max(0, Number(state.knockbackDistance) || 0);
    const stunDuration = Math.max(0, Number(state.stunDuration) || 0);
    const slowPct = Math.max(0, Number(state.slowPct) || 0);
    const slowDuration = Math.max(0, Number(state.slowDuration) || 0);
    const revealRadius = Math.max(0, Number(state.revealRadius) || 0);
    const revealDuration = Math.max(0, Number(state.revealDuration) || 0);
    let hits = 0;
    if(radius > 0){
      const targets = collectAbilityTargets();
      for(const target of targets){
        if(!target) continue;
        const targetRadius = target === monsterState
          ? Math.max(minionRadius, monsterAttackRadius())
          : minionRadius;
        const dx = target.x - centerX;
        const dy = target.y - centerY;
        const limit = radius + targetRadius;
        if(dx * dx + dy * dy > limit * limit) continue;
        if(damage > 0){
          applyAbilityDamage(target, damage);
        }
        if(knockback > 0){
          const dist = Math.hypot(dx, dy);
          let pushX = dx;
          let pushY = dy;
          if(dist <= 0.0001){
            pushX = state.dirX || 1;
            pushY = state.dirY || 0;
          } else {
            pushX = dx / dist;
            pushY = dy / dist;
          }
          const pushed = moveCircleWithCollision(target.x, target.y, pushX * knockback, pushY * knockback, targetRadius);
          target.x = Math.max(targetRadius, Math.min(mapState.width - targetRadius, pushed.x));
          target.y = Math.max(targetRadius, Math.min(mapState.height - targetRadius, pushed.y));
        }
        if(stunDuration > 0){
          target.stunTimer = Math.max(Number(target.stunTimer) || 0, stunDuration);
        }
        if(slowPct > 0){
          const existingSlow = Number(target.slowPct) || 0;
          target.slowPct = Math.max(existingSlow, slowPct);
          if(slowDuration > 0){
            target.slowTimer = Math.max(Number(target.slowTimer) || 0, slowDuration);
          }
        }
        hits += 1;
      }
    }
    if(revealRadius > 0 && revealDuration > 0){
      spawnTemporalVisionSource(centerX, centerY, revealRadius, revealDuration);
    }
    const flashRadius = Math.max(18, radius, Number(state.collisionRadius) || 0);
    flash(centerX, centerY, { startRadius: Math.max(12, flashRadius * 0.4), endRadius: Math.max(radius + 40, flashRadius + 40), color: '#9ef0ff' });
    if(caster === player){
      const hitText = hits > 0 ? `hit ${hits} target${hits === 1 ? '' : 's'}` : 'hit nothing';
      const suffix = reason === 'manual' ? ' (manual stop)' : reason === 'collision' ? '' : '';
      setHudMessage(`${state.abilityName || 'Spiral Ram'} ${hitText}${suffix}.`);
    }
    GameState.effects.spiralRamRoll = null;
    spiralRamMoveMultiplier = 1;
  }

  function updateSpiralRamRoll(dt){
    const state = GameState.effects.spiralRamRoll;
    if(!state || state.completed){
      if(state && state.completed){
        GameState.effects.spiralRamRoll = null;
      }
      spiralRamMoveMultiplier = 1;
      return;
    }
    const caster = state.casterRef || player;
    if(!caster || Number(caster.hp) <= 0){
      completeSpiralRamRoll(state, { reason: 'interrupted' });
      return;
    }
    state.elapsed = Math.max(0, Number(state.elapsed) || 0) + Math.max(0, dt);
    const maxDuration = Math.max(0, Number(state.channelDuration) || 0);
    if(maxDuration > 0 && state.elapsed >= maxDuration){
      completeSpiralRamRoll(state, { reason: 'duration' });
      return;
    }
    const speedBonus = Math.min(Math.max(0, Number(state.maxSpeedBonus) || 0), (state.elapsed * Math.max(0, Number(state.speedGainPerSecond) || 0)));
    spiralRamMoveMultiplier = 1 + speedBonus;
    const dirX = Number(state.dirX) || 1;
    const dirY = Number(state.dirY) || 0;
    if(caster === player){
      player.target.x = player.x + dirX * 2000;
      player.target.y = player.y + dirY * 2000;
      player.navGoal = null;
      player.nav = null;
      player.chaseTarget = null;
      player.facing = Math.atan2(dirY, dirX);
    }
    if(state.collisionRadius > 0){
      const targets = collectAbilityTargets();
      for(const target of targets){
        if(!target) continue;
        const targetRadius = target === monsterState
          ? Math.max(minionRadius, monsterAttackRadius())
          : minionRadius;
        const dx = target.x - player.x;
        const dy = target.y - player.y;
        const limit = state.collisionRadius + targetRadius;
        if(dx * dx + dy * dy <= limit * limit){
          completeSpiralRamRoll(state, { reason: 'collision' });
          break;
        }
      }
    }
  }

  function castWindpiercerRushAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Windpiercer Rush';
    const dashDistance = Math.max(0, Number(abilityFieldValue(ability, 'dashDistancePx')) || 0);
    const trailWidth = Math.max(0, Number(abilityFieldValue(ability, 'dashWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const empowerRadius = Math.max(0, Number(abilityFieldValue(ability, 'empowerRadiusPx')) || 0);
    const empowerDamage = Math.max(0, Number(abilityFieldValue(ability, 'empowerDamage')) || 0);
    const stackDurationMs = Math.max(0, Number(abilityFieldValue(ability, 'stackDurationMs')) || 0);
    if(dashDistance <= 0 || trailWidth <= 0 || damage <= 0){
      setHudMessage(`${abilityName} needs dash distance, width, and damage configured.`);
      return false;
    }

    const now = perfNow();
    let stacks = Math.max(0, Number(abilityRuntime.windpiercerStacks) || 0);
    let expiresAt = Math.max(0, Number(abilityRuntime.windpiercerStackExpires) || 0);
    if(expiresAt > 0 && now >= expiresAt){
      stacks = 0;
      expiresAt = 0;
    }
    const stacksBefore = stacks;
    const empoweredReady = stacksBefore >= 2;
    if(empoweredReady){
      abilityRuntime.windpiercerStacks = 0;
      abilityRuntime.windpiercerStackExpires = 0;
    } else {
      abilityRuntime.windpiercerStacks = stacksBefore;
      abilityRuntime.windpiercerStackExpires = expiresAt;
    }

    const startX = player.x;
    const startY = player.y;
    const maxRange = dashDistance;
    let target = null;
    let closestSq = Number.POSITIVE_INFINITY;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - startX;
      const dy = m.y - startY;
      const distSq = dx * dx + dy * dy;
      if(distSq > maxRange * maxRange) continue;
      if(distSq < closestSq){
        closestSq = distSq;
        target = { x: m.x, y: m.y };
      }
    }
    if(isMonsterAttackable(monsterState)){
      const dx = monsterState.x - startX;
      const dy = monsterState.y - startY;
      const distSq = dx * dx + dy * dy;
      if(distSq <= maxRange * maxRange && distSq < closestSq){
        closestSq = distSq;
        target = { x: monsterState.x, y: monsterState.y };
      }
    }
    if(!target){
      setHudMessage(`${abilityName} needs a target in range.`);
      return false;
    }
    let dx = target.x - startX;
    let dy = target.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    flash(startX, startY, { startRadius: 12, endRadius: 34, color: '#7fe3ff' });
    const move = moveCircleWithCollision(startX, startY, dirX * dashDistance, dirY * dashDistance, player.r);
    player.x = Math.max(player.r, Math.min(mapState.width - player.r, move.x));
    player.y = Math.max(player.r, Math.min(mapState.height - player.r, move.y));
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    player.chaseTarget = null;
    cancelPlayerAttack(false);

    const pathDamage = damageEnemiesAlongSegment(startX, startY, player.x, player.y, Math.max(1, trailWidth), damage);
    let areaDamage = 0;
    if(empoweredReady && pathDamage > 0 && empowerDamage > 0 && empowerRadius > 0){
      areaDamage = damageEnemiesInRadius(player.x, player.y, empowerRadius, empowerDamage);
      flash(player.x, player.y, { startRadius: 16, endRadius: Math.max(empowerRadius, 32), color: '#8cf6ff' });
    }

    if(!empoweredReady && pathDamage > 0){
      const nextStacks = Math.min(2, stacksBefore + 1);
      abilityRuntime.windpiercerStacks = nextStacks;
      abilityRuntime.windpiercerStackExpires = now + stackDurationMs;
    }

    flash(player.x, player.y, { startRadius: 14, endRadius: 42, color: '#4dd2ff' });
    let message = `${abilityName} lunged`;
    if(pathDamage > 0){
      message = `${abilityName} carved ${Math.round(pathDamage)} damage`;
      if(empoweredReady){
        if(areaDamage > 0){
          message += ` and detonated ${Math.round(areaDamage)} storm damage`;
        } else {
          message += ' and consumed the tempest stacks';
        }
      } else {
        const stackCount = abilityRuntime.windpiercerStacks;
        message += ` (${stackCount}/2 stacks)`;
      }
    } else {
      message = empoweredReady
        ? `${abilityName} consumed its stacks but clipped nothing.`
        : `${abilityName} lunged but clipped nothing.`;
    }
    setHudMessage(message);
    return true;
  }

  function castInfernoBarrageAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Inferno Barrage';
    const duration = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const shotInterval = Math.max(0, Number(abilityFieldValue(ability, 'shotIntervalMs')) || 0) / 1000;
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const effectRadius = Math.max(0, Number(abilityFieldValue(ability, 'effectRadiusPx')) || 0);
    const range = Math.max(0, Number(abilityFieldValue(ability, 'rangePx')) || 0);
    const minionPct = Math.max(0, Number(abilityFieldValue(ability, 'minionDamagePct')) || 0);
    if(duration <= 0 || shotInterval <= 0 || damage <= 0){
      setHudMessage(`${abilityName} needs duration, interval, and damage configured.`);
      return false;
    }
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    const maxShots = Math.max(1, Math.round(duration / shotInterval));
    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      duration,
      elapsed: 0,
      shotInterval,
      nextShot: 0,
      maxShots,
      shotsFired: 0,
      damagePerShot: damage,
      effectRadius,
      range,
      minionDamagePct: minionPct
    };
    infernoBarrageCasts.push(cast);
    setHudMessage(`${abilityName} firing!`);
    return true;
  }

  function fireInfernoBarrageShot(cast){
    if(!cast) return 0;
    const damage = Math.max(0, Number(cast.damagePerShot) || 0);
    if(damage <= 0) return 0;
    const range = Math.max(0, Number(cast.range) || 0);
    const radius = Math.max(0, Number(cast.effectRadius) || 0);
    const candidates = [];
    const targets = collectAbilityTargets();
    for(const entry of targets){
      if(!entry) continue;
      const dx = entry.x - player.x;
      const dy = entry.y - player.y;
      const dist = Math.hypot(dx, dy);
      if(range > 0 && dist > range + minionRadius) continue;
      if(radius > 0 && dist > radius + minionRadius) continue;
      candidates.push({ target: entry, dist });
    }
    if(!candidates.length) return 0;
    candidates.sort((a, b) => a.dist - b.dist);
    let total = 0;
    const hits = Math.min(3, candidates.length);
    for(let i = 0; i < hits; i++){
      const target = candidates[i] && candidates[i].target;
      if(!target) continue;
      let shotDamage = damage;
      if(target !== monsterState && !target.isPracticeDummy){
        const pct = Math.max(0, Number(cast.minionDamagePct) || 0) / 100;
        shotDamage = shotDamage * pct;
      }
      if(shotDamage <= 0) continue;
      total += applyAbilityDamage(target, shotDamage);
    }
    if(total > 0){
      pulses.push({
        x: player.x,
        y: player.y,
        startRadius: Math.max(8, Math.min(radius, 40)),
        endRadius: Math.max(radius, 60),
        color: '#ff9e43',
        t: 0
      });
    }
    return total;
  }

  function updateInfernoBarrageCasts(dt){
    for(let i = infernoBarrageCasts.length - 1; i >= 0; i--){
      const cast = infernoBarrageCasts[i];
      if(!cast) continue;
      cast.elapsed = Math.max(0, Number(cast.elapsed) || 0) + dt;
      cast.nextShot = Math.max(0, Number(cast.nextShot) || 0) - dt;
      if(cast.nextShot <= 0 && cast.shotsFired < cast.maxShots){
        fireInfernoBarrageShot(cast);
        cast.shotsFired += 1;
        cast.nextShot += Math.max(0.01, cast.shotInterval || 0.2);
      }
      if(cast.elapsed >= cast.duration || cast.shotsFired >= cast.maxShots){
        infernoBarrageCasts.splice(i, 1);
        if(cast.casterRef === player){
          setHudMessage(`${cast.abilityName || 'Inferno'} concluded.`);
        }
      }
    }
  }

  function castLuminousDartAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Luminous Dart';
    const castTimeMs = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeMs) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs travel speed.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width.`);
      return false;
    }
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      speed,
      width,
      damage,
      cooldownSeconds
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      launchLuminousDart(cast);
      return true;
    }

    luminousDartCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} charging...`);
    return true;
  }

  function castPlunderShotAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Plunder Shot';
    const castTimeMs = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeMs) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs travel speed.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width.`);
      return false;
    }
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const goldOnKill = Math.max(0, Number(abilityFieldValue(ability, 'plunderGold')) || 0);

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      speed,
      width,
      damage,
      cooldownSeconds,
      goldOnKill
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      launchPlunderShot(cast);
      return true;
    }

    plunderShotCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} charging...`);
    return true;
  }

  function launchLuminousDart(cast){
    if(!cast) return false;
    const startX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    let dirX = Number(cast.dirX) || 0;
    let dirY = Number(cast.dirY) || 0;
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;

    const projectile = {
      abilityId: cast.abilityId,
      abilityName: cast.abilityName || 'Luminous Dart',
      startX,
      startY,
      dirX,
      dirY,
      speed: Math.max(0, Number(cast.speed) || 0),
      maxDistance: Math.max(0, Number(cast.range) || 0),
      traveled: 0,
      width: Math.max(0, Number(cast.width) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      cooldownRefundSeconds: 1.5,
      hitMonsters: true,
      casterRef: cast.casterRef || player,
      currentX: startX,
      currentY: startY,
      shadowColor: '#9cf3ff',
      outerColor: '#80eafb',
      innerColor: '#d6f9ff',
      tipColor: '#f7ffff',
      hitStatusText: ' (cooldowns -1.5s)'
    };

    laserProjectiles.push(projectile);
    flash(startX, startY, { startRadius: 10, endRadius: 32, color: '#9df5ff' });
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    if(cast.casterRef === player){
      if(player.casting === cast){
        player.casting = null;
      }
      setHudMessage(`${projectile.abilityName} fired!`);
    }
    return true;
  }

  function launchPlunderShot(cast){
    if(!cast){
      return false;
    }
    const startX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    let dirX = Number(cast.dirX) || 0;
    let dirY = Number(cast.dirY) || 0;
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;

    const abilityName = cast.abilityName || 'Plunder Shot';
    const projectile = {
      abilityId: cast.abilityId,
      abilityName,
      startX,
      startY,
      dirX,
      dirY,
      speed: Math.max(0, Number(cast.speed) || 0),
      maxDistance: Math.max(0, Number(cast.range) || 0),
      traveled: 0,
      width: Math.max(0, Number(cast.width) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      goldOnKill,
      casterRef: cast.casterRef || player,
      shadowColor: '#b38241',
      outerColor: '#ffc87f',
      innerColor: '#ffe4b0',
      tipColor: '#fff4dd',
      hitStatusText: goldOnKill > 0 ? '(plunder)' : ''
    };

    laserProjectiles.push(projectile);
    flash(startX, startY, { startRadius: 12, endRadius: 32, color: '#ffd085' });
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    if(cast.casterRef === player){
      if(player.casting === cast){
        player.casting = null;
      }
      setHudMessage(`${projectile.abilityName} fired!`);
    }
    return true;
  }

  function castShadowTalonAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Shadow Talon';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range constant.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs travel speed.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width.`);
      return false;
    }
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'baseDamage')) || 0);
    const markDuration = Math.max(0, Number(abilityFieldValue(ability, 'markDurationMs')) || 0) / 1000;
    const markDamage = Math.max(0, Number(abilityFieldValue(ability, 'markDamage')) || 0);
    const markStacks = Math.max(1, Math.floor(Number(abilityFieldValue(ability, 'markStacks')) || 3));
    const recastCount = Math.max(0, Math.floor(Number(abilityFieldValue(ability, 'recastCount')) || 0));
    const recastDamage = Math.max(0, Number(abilityFieldValue(ability, 'recastDamage')) || 0);
    const recastRange = Math.max(0, Number(abilityFieldValue(ability, 'recastRangePx')) || 0);
    const recastWidth = Math.max(0, Number(abilityFieldValue(ability, 'recastWidthPx')) || 0);
    const recastInterval = Math.max(0, Number(abilityFieldValue(ability, 'recastIntervalMs')) || 0) / 1000;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      speed,
      width,
      baseDamage: damage,
      markDuration,
      markDamage,
      markStacks,
      recastCount,
      recastDamage,
      recastRange,
      recastWidth,
      recastInterval,
      cooldownSeconds
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      launchShadowTalonBolt(cast);
      return true;
    }

    shadowTalonCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} charging...`);
    return true;
  }

  function launchShadowTalonBolt(cast){
    if(!cast) return false;
    const startX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    let dirX = Number(cast.dirX) || 0;
    let dirY = Number(cast.dirY) || 0;
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;

    const projectile = {
      abilityId: cast.abilityId,
      abilityName: cast.abilityName,
      startX,
      startY,
      dirX,
      dirY,
      speed: Math.max(0, Number(cast.speed) || 0),
      maxDistance: Math.max(0, Number(cast.range) || 0),
      traveled: 0,
      width: Math.max(0, Number(cast.width) || 0),
      damage: Math.max(0, Number(cast.baseDamage) || 0),
      markDuration: Math.max(0, Number(cast.markDuration) || 0),
      markDamage: Math.max(0, Number(cast.markDamage) || 0),
      markStacks: Math.max(0, Math.floor(Number(cast.markStacks) || 0)),
      recastCount: Math.max(0, Math.floor(Number(cast.recastCount) || 0)),
      recastDamage: Math.max(0, Number(cast.recastDamage) || 0),
      recastRange: Math.max(0, Number(cast.recastRange) || 0),
      recastWidth: Math.max(0, Number(cast.recastWidth) || 0),
      recastInterval: Math.max(0, Number(cast.recastInterval) || 0),
      cooldownSeconds: Math.max(0, Number(cast.cooldownSeconds) || 0),
      slotIndex: Number.isFinite(cast.slotIndex) ? cast.slotIndex : null,
      casterRef: cast.casterRef || player,
      hitMonsters: true,
      shadowColor: '#b864ff',
      outerColor: '#9e4ff1',
      innerColor: '#d3a7ff',
      tipColor: '#ffffff',
      hitStatusText: '(marked)'
    };

    laserProjectiles.push(projectile);
    flash(startX, startY, { startRadius: 10, endRadius: 32, color: '#b864ff' });
    const cooldownSeconds = projectile.cooldownSeconds;
    if(projectile.slotIndex !== null){
      setAbilitySlotCooldown(projectile.slotIndex, cooldownSeconds);
    }
    if(cast.casterRef === player){
      if(player.casting === cast){
        player.casting = null;
      }
      setHudMessage(`${projectile.abilityName} fired!`);
    }
    return true;
  }

  function scheduleShadowTalonRecasts(source, caster, target){
    if(!source || !target) return;
    const count = Math.max(0, Math.floor(Number(source.recastCount) || 0));
    const range = Math.max(0, Number(source.recastRange) || 0);
    const damage = Math.max(0, Number(source.recastDamage) || 0);
    const width = Math.max(0, Number(source.recastWidth) || 0);
    const interval = Math.max(0, Number(source.recastInterval) || 0);
    if(!(count > 0 && range > 0 && damage > 0 && width > 0)) return;
    const origin = getSpellOrigin(caster || player);
    const dirX = Number(source.dirX) || 1;
    const dirY = Number(source.dirY) || 0;
    shadowTalonRecasts.push({
      abilityName: source.abilityName,
      slotIndex: Number.isFinite(source.slotIndex) ? source.slotIndex : null,
      casterRef: caster || player,
      originX: origin.x,
      originY: origin.y,
      dirX,
      dirY,
      range,
      width,
      damage,
      interval,
      timer: interval,
      remaining: count
    });
  }

  function launchShadowTalonRecast(recast){
    if(!recast || recast.remaining <= 0) return;
    const originX = Number.isFinite(recast.originX) ? recast.originX : player.x;
    const originY = Number.isFinite(recast.originY) ? recast.originY : player.y;
    let dirX = Number(recast.dirX) || 0;
    let dirY = Number(recast.dirY) || 0;
    const range = Math.max(0, Number(recast.range) || 0);
    if(range <= 0) return;
    const target = findNearestEnemy(originX, originY, range);
    if(target){
      const dx = target.x - originX;
      const dy = target.y - originY;
      const len = Math.hypot(dx, dy);
      if(len > 0.0001){
        dirX = dx / len;
        dirY = dy / len;
      }
    }
    const dirLen = Math.hypot(dirX, dirY);
    if(dirLen <= 0.0001){
      dirX = 1;
      dirY = 0;
    } else {
      dirX /= dirLen;
      dirY /= dirLen;
    }
    const endX = originX + dirX * range;
    const endY = originY + dirY * range;
    const damage = Math.max(0, Number(recast.damage) || 0);
    const width = Math.max(0, Number(recast.width) || 0);
    if(damage <= 0 || width <= 0){
      return;
    }
    const hits = damageEnemiesAlongSegment(originX, originY, endX, endY, width, damage);
    spawnBeamVisual(originX, originY, null, range, width, { dirX, dirY, lifetime: 0.25 });
    if(hits > 0){
      flash(originX, originY, { startRadius: 10, endRadius: 26, color: '#c96bff' });
    }
    recast.dirX = dirX;
    recast.dirY = dirY;
  }

  function applyShadowTalonMark(target, source){
    if(!target || !source) return;
    const duration = Math.max(0, Number(source.markDuration) || 0);
    const bonus = Math.max(0, Number(source.markDamage) || 0);
    const stacks = Math.max(0, Math.floor(Number(source.markStacks) || 0));
    if(!(duration > 0 && bonus > 0 && stacks > 0)) return;
    setShadowTalonMark(target, {
      duration,
      stacks,
      bonusDamage: bonus
    });
  }

  function castPestilentTossAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Pestilent Toss';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width.`);
      return false;
    }
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs damage.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a throw speed.`);
      return false;
    }
    const minDamage = Math.max(0, Number(abilityFieldValue(ability, 'minDamage')) || 0);
    const monsterCap = Math.max(0, Number(abilityFieldValue(ability, 'monsterDamageCap')) || 0);
    const slowFraction = Math.max(0, Math.min(1, (Number(abilityFieldValue(ability, 'slowPct')) || 0) / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const healthCost = Math.max(0, Number(abilityFieldValue(ability, 'healthCost')) || 0);
    if(healthCost > 0 && Number(player.hp) <= healthCost){
      setHudMessage(`Not enough health to cast ${abilityName}.`);
      return false;
    }
    const normalHeal = Math.max(0, Number(abilityFieldValue(ability, 'healPct')) || 0) / 100;
    const largeHeal = Math.max(0, Number(abilityFieldValue(ability, 'healPctLarge')) || 0) / 100;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      castDuration,
      elapsed: 0,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      width,
      speed,
      damage,
      minDamage,
      monsterDamageCap: monsterCap,
      slowFraction,
      slowDuration,
      healthCost,
      healPct: normalHeal,
      healPctLarge: largeHeal,
      cooldownSeconds
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      const launched = executePestilentToss(cast);
      return launched;
    }

    pestilentTossCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} winding up...`);
    return true;
  }

  function executePestilentToss(cast){
    if(!cast) return false;
    const abilityName = cast.abilityName || 'Pestilent Toss';
    const originX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const originY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    let dirX = Number(cast.dirX) || 0;
    let dirY = Number(cast.dirY) || 0;
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    dirX /= dirLen;
    dirY /= dirLen;
    const range = Math.max(0, Number(cast.range) || 0);
    const width = Math.max(0, Number(cast.width) || 0);
    const targetData = findEnemyAlongRay(originX, originY, dirX, dirY, range, width);
    if(!targetData || !targetData.target){
      setHudMessage(`${abilityName} needs a target in range.`);
      return false;
    }
    const target = targetData.target;
    const minDamage = Math.max(0, Number(cast.minDamage) || 0);
    const monsterCap = Math.max(0, Number(cast.monsterDamageCap) || 0);
    let damage = Math.max(minDamage, Math.max(0, Number(cast.damage) || 0));
    if(target === monsterState && monsterCap > 0){
      damage = Math.min(damage, monsterCap);
    }
    const applied = applyAbilityDamage(target, damage);
    const slowFraction = Math.max(0, Math.min(1, Number(cast.slowFraction) || 0));
    if(slowFraction > 0){
      const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
      target.slowPct = Math.max(existingSlow, slowFraction);
      const slowDuration = Math.max(0, Number(cast.slowDuration) || 0);
      if(slowDuration > 0){
        target.slowTimer = Math.max(target.slowTimer || 0, slowDuration);
      }
    }
    const healthCost = Math.max(0, Number(cast.healthCost) || 0);
    const owner = cast.casterRef || player;
    if(healthCost > 0 && owner){
      owner.hp = Math.max(0, (Number(owner.hp) || 0) - healthCost);
    }
    const largeTarget = target === monsterState || target.isPracticeDummy || Boolean(target.isChampion);
    const healFrac = largeTarget ? Number(cast.healPctLarge) || 0 : Number(cast.healPct) || 0;
    let healAmount = 0;
    if(owner && healFrac > 0 && healthCost > 0){
      const prevHp = Math.max(0, Number(owner.hp) || 0);
      const maxHp = Math.max(1, Number(owner.maxHp) || 1);
      healAmount = Math.min(maxHp - prevHp, healthCost * healFrac);
      if(healAmount > 0){
        owner.hp = Math.min(maxHp, prevHp + healAmount);
      }
    }
    flash(target.x, target.y, { startRadius: 10, endRadius: 38, color: '#a1ff9d' });
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    }
    const hitLabel = target === monsterState ? 'the monster' : 'a target';
    const messageParts = [];
    if(applied > 0){
      messageParts.push(`hit ${hitLabel} for ${Math.round(applied)} damage`);
    } else {
      messageParts.push(`hit ${hitLabel}`);
    }
    if(healAmount > 0){
      messageParts.push(`healed for ${Math.round(healAmount)} HP`);
    }
    setHudMessage(`${abilityName} ${messageParts.join(' and ')}.`);
    return true;
  }

  function findEnemyAlongRay(originX, originY, dirX, dirY, maxRange, width, skipTarget){
    if(!Number.isFinite(dirX) || !Number.isFinite(dirY)) return null;
    let dx = Number(dirX);
    let dy = Number(dirY);
    let dirLen = Math.hypot(dx, dy);
    if(!(dirLen > 0.0001)) return null;
    dx /= dirLen;
    dy /= dirLen;
    const startX = Number(originX) || 0;
    const startY = Number(originY) || 0;
    const maxDist = maxRange > 0 ? maxRange : Infinity;
    const halfWidth = Math.max(0, Number(width) || 0) / 2;
    let bestTarget = null;
    let bestAlong = Infinity;

    const consider = (target, radius) => {
      if(!target || target === skipTarget) return;
      const hp = Number(target.hp) || 0;
      if(hp <= 0 || Number(target.portalizing) > 0) return;
      if(target === monsterState){
        if(!isMonsterAttackable(target)) return;
      } else if(!target.isPracticeDummy && !isEnemyMinionForPlayer(target)){
        return;
      }
      const relX = target.x - startX;
      const relY = target.y - startY;
      const along = relX * dx + relY * dy;
      if(along < -radius) return;
      if(maxDist < Infinity && along > maxDist + radius) return;
      const distSq = relX * relX + relY * relY;
      const perpSq = Math.max(0, distSq - along * along);
      const buffer = halfWidth + radius;
      if(perpSq > buffer * buffer) return;
      if(along < bestAlong){
        bestAlong = along;
        bestTarget = target;
      }
    };

    for(const m of minions){
      if(!m) continue;
      const practice = m.isPracticeDummy === true;
      if(!practice && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const radius = practice ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      consider(m, radius);
    }

    if(monsterState && isMonsterAttackable(monsterState) && monsterState.hp > 0 && monsterState.portalizing <= 0){
      const radius = Math.max(minionRadius, monsterAttackRadius());
      consider(monsterState, radius);
    }

    if(!bestTarget){
      return null;
    }
    return { target: bestTarget, along: bestAlong };
  }

  function castVenomProbeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Venom Probe';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    const baseDamage = Math.max(0, Number(abilityFieldValue(ability, 'baseDamage')) || 0);
    if(baseDamage <= 0){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }
    const healthPct = Math.max(0, Number(abilityFieldValue(ability, 'healthPctDamage')) || 0) / 100;
    const monsterCap = Math.max(0, Number(abilityFieldValue(ability, 'monsterDamageCap')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const targetInfo = findEnemyAlongRay(origin.x, origin.y, dirX, dirY, range, width || 40);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.navGoal = null;
    player.nav = null;
    player.target.x = player.x;
    player.target.y = player.y;
    if(!targetInfo){
      const effectDistance = Math.min(range, 140);
      flash(origin.x + dirX * effectDistance, origin.y + dirY * effectDistance, { startRadius: 10, endRadius: 32, color: '#59d9b5' });
      setHudMessage(`${abilityName} slipped through empty air.`);
      return true;
    }
    const target = targetInfo.target;
    const targetHp = Math.max(0, Number(target.hp) || 0);
    const healthDamage = targetHp * healthPct;
    let totalDamage = baseDamage + healthDamage;
    const isMonster = target === monsterState;
    if(isMonster && monsterCap > 0){
      totalDamage = Math.min(totalDamage, monsterCap);
    }
    const applied = applyAbilityDamage(target, totalDamage);
    const color = applied > 0 ? '#69f0c2' : '#3da888';
    flash(target.x, target.y, { startRadius: 12, endRadius: 36, color });
    if(applied > 0){
      const cappedNote = isMonster && monsterCap > 0 && totalDamage >= monsterCap - 0.001 ? ' (capped)' : '';
      setHudMessage(`${abilityName} burrowed for ${Math.round(applied)} damage${cappedNote}.`);
    } else {
      setHudMessage(`${abilityName} fizzled against the target.`);
    }
    return true;
  }

  function applyReboundShotDamage(target, damage){
    if(!target || damage <= 0){
      return false;
    }
    const prevHp = Math.max(0, Number(target.hp) || 0);
    if(prevHp <= 0){
      return false;
    }
    target.hp = Math.max(0, prevHp - damage);
    const targetRadius = target === monsterState ? Math.max(24, monsterAttackRadius()) : minionRadius;
    if(damage > 0){
      spawnHitSplat(target.x, target.y - targetRadius, damage);
    }
    if(target === monsterState){
      updateMonsterHud();
    } else if(prevHp > 0 && target.hp <= 0 && !target.isPracticeDummy){
      addGold(goldState.perKill);
    }
    handlePracticeDummyDamage(target, prevHp);
    return true;
  }

  function castReboundShotAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Rebound Shot';
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const range = Math.max(0, Number(abilityFieldValue(ability, 'rangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range configured.`);
      return false;
    }
    const impactWidth = Math.max(0, Number(abilityFieldValue(ability, 'impactWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(!(damage > 0)){
      setHudMessage(`${abilityName} needs damage configured.`);
      return false;
    }
    const bounceDamage = Math.max(0, Number(abilityFieldValue(ability, 'bounceDamage')) || 0);
    const bounceRange = Math.max(0, Number(abilityFieldValue(ability, 'bounceRangePx')) || 0);
    const bounceWidth = Math.max(0, Number(abilityFieldValue(ability, 'bounceWidthPx')) || 0);
    const cooldownSeconds = abilityCooldownSeconds(ability);

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const primary = findEnemyAlongRay(origin.x, origin.y, dirX, dirY, range, impactWidth);
    if(!primary){
      setHudMessage(`${abilityName} needs a target in range.`);
      return false;
    }

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    updatePlayerFacingTowards(primary.target);
    applyReboundShotDamage(primary.target, damage);
    flash(primary.target.x, primary.target.y, { startRadius: 10, endRadius: 30, color: '#ffd166' });

    const bounceOriginX = primary.target.x + dirX * Math.max(16, impactWidth * 0.5);
    const bounceOriginY = primary.target.y + dirY * Math.max(16, impactWidth * 0.5);
    const bounceTarget = findEnemyAlongRay(bounceOriginX, bounceOriginY, dirX, dirY, bounceRange, bounceWidth, primary.target);
    if(bounceTarget){
      applyReboundShotDamage(bounceTarget.target, bounceDamage);
    }

    if(Number.isFinite(slotIndex)){
      setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    }
    const hits = bounceTarget ? 2 : 1;
    setHudMessage(`${abilityName} struck ${hits} target${hits === 1 ? '' : 's'}.`);
    return true;
  }

  function castRadiantLancerAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Radiant Lancer';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(!(range > 0) || !(speed > 0) || !(width > 0) || !(damage > 0)){
      setHudMessage(`${abilityName} needs range, width, speed, and damage configured.`);
      return false;
    }
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const projectile = {
      abilityId: ability.id,
      abilityName,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      speed,
      maxDistance: range,
      width,
      damage,
      hitMonsters: true,
      casterRef: player,
      currentX: origin.x,
      currentY: origin.y,
      shadowColor: '#ffe1c7',
      outerColor: '#ffc05c',
      innerColor: '#fff0c0',
      tipColor: '#ffffff'
    };
    laserProjectiles.push(projectile);
    flash(origin.x, origin.y, { startRadius: Math.max(12, width * 0.5), endRadius: Math.max(26, width * 2), color: '#ffe8cf' });
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    setHudMessage(`${abilityName} fired!`);
    return true;
  }

  function castCrossfireFlareAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Crossfire Flare';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    if(!(range > 0) || !(speed > 0) || !(width > 0) || !(damage > 0)){
      setHudMessage(`${abilityName} needs range, width, speed, and damage configured.`);
      return false;
    }
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const perpX = -dirY;
    const perpY = dirX;
    const directions = [
      { x: dirX, y: dirY },
      { x: -dirX, y: -dirY },
      { x: perpX, y: perpY },
      { x: -perpX, y: -perpY }
    ];
    for(const dir of directions){
      laserProjectiles.push({
        abilityId: ability.id,
        abilityName,
        startX: origin.x,
        startY: origin.y,
        dirX: dir.x,
        dirY: dir.y,
        speed,
        maxDistance: range,
        width,
        damage,
        hitMonsters: true,
        casterRef: player,
        currentX: origin.x,
        currentY: origin.y,
        shadowColor: '#ffce9b',
        outerColor: '#ff9e54',
        innerColor: '#ffd2a4',
        tipColor: '#fff2e0'
      });
    }
    flash(origin.x, origin.y, { startRadius: Math.max(12, width * 0.5), endRadius: Math.max(32, range * 0.28), color: '#ffc88f' });
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    const cooldownSeconds = abilityCooldownSeconds(ability);
    setAbilitySlotCooldown(slotIndex, cooldownSeconds);
    setHudMessage(`${abilityName} burst forth!`);
    return true;
  }

  function castDuskwaveAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Duskwave Infernum';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'coneRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a wave range.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'coneWidthPx')) || 0);
    const waveDamage = Math.max(0, Number(abilityFieldValue(ability, 'waveDamage')) || 0);
    const volleyDamage = Math.max(0, Number(abilityFieldValue(ability, 'volleyDamage')) || 0);
    const secondaryPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'secondaryPct')) || 0));
    const delay = Math.max(0, Number(abilityFieldValue(ability, 'delayMs')) || 0) / 1000;
    const volleySpeed = Math.max(0, Number(abilityFieldValue(ability, 'volleySpeedPxS')) || 0);

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      castDuration,
      elapsed: 0,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      width,
      waveDamage,
      volleyDamage,
      secondaryFraction: secondaryPct / 100,
      delay,
      volleySpeed: Math.max(volleySpeed, 900),
      waveFired: false,
      volleyLaunched: false,
      lockedTargets: []
    };

    duskwaveCasts.push(cast);
    cancelPlayerAttack(false);
    player.casting = cast;
    player.chaseTarget = null;
    player.target.x = origin.x;
    player.target.y = origin.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      fireDuskwaveWave(cast);
    } else {
      setHudMessage(`${abilityName} winding up...`);
    }
    return true;
  }

  function castSirensKissAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Siren\'s Kiss';
    const rangeRaw = abilityFieldValue(ability, 'projectileRangePx');
    const range = Math.max(0, Number(rangeRaw) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a travel range.`);
      return false;
    }
    const widthRaw = abilityFieldValue(ability, 'projectileWidthPx');
    const width = Math.max(0, Number(widthRaw) || 0);
    const speedRaw = abilityFieldValue(ability, 'projectileSpeedPxS');
    const speed = Math.max(0, Number(speedRaw) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a projectile speed.`);
      return false;
    }
    const damageRaw = abilityFieldValue(ability, 'damage');
    const damage = Math.max(0, Number(damageRaw) || 0);
    const slowPctRaw = abilityFieldValue(ability, 'slowPct');
    const slowFraction = Math.max(0, Math.min(1, (Number(slowPctRaw) || 0) / 100));
    const slowDurationRaw = abilityFieldValue(ability, 'slowDurationMs');
    const slowDuration = Math.max(0, Number(slowDurationRaw) || 0) / 1000;
    const stunDurationRaw = abilityFieldValue(ability, 'stunDurationMs');
    const stunDuration = Math.max(0, Number(stunDurationRaw) || 0) / 1000;
    const castTimeRaw = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeRaw) || 0) / 1000;

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      speed,
      width,
      damage,
      slowFraction,
      slowDuration,
      stunDuration,
      castDuration,
      elapsed: 0
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      launchSirensKissProjectile(cast);
      return true;
    }

    sirensKissCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} preparing...`);
    return true;
  }

  function launchSirensKissProjectile(cast){
    if(!cast) return false;
    const startX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    const dirLen = Math.hypot(Number(cast.dirX) || 0, Number(cast.dirY) || 0) || 1;
    const dirX = (Number(cast.dirX) || 0) / dirLen;
    const dirY = (Number(cast.dirY) || 0) / dirLen;
    const maxDistance = Math.max(0, Number(cast.range) || 0);
    const projectile = {
      startX,
      startY,
      dirX,
      dirY,
      speed: Math.max(0, Number(cast.speed) || 0),
      maxDistance: maxDistance > 0 ? maxDistance : Math.max(1, Math.hypot(dirX, dirY)),
      traveled: 0,
      width: Math.max(0, Number(cast.width) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      slowFraction: Math.max(0, Number(cast.slowFraction) || 0),
      slowDuration: Math.max(0, Number(cast.slowDuration) || 0),
      stunDuration: Math.max(0, Number(cast.stunDuration) || 0),
      abilityName: cast.abilityName || 'Siren\'s Kiss',
      casterRef: cast.casterRef || player,
      currentX: startX,
      currentY: startY,
      shadowColor: '#ff73b6',
      outerColor: '#ffb2d9',
      innerColor: '#ffe6f3',
      tipColor: '#fff6fb',
      hitStatusText: ' (knockdown + slow)'
    };
    laserProjectiles.push(projectile);
    flash(startX, startY, { startRadius: 10, endRadius: 40, color: '#ff9bcf' });
    if(cast.casterRef === player){
      setHudMessage(`${cast.abilityName || 'Kiss'} released!`);
      if(player.casting === cast){
        player.casting = null;
      }
    }
    return true;
  }

  function castShiverSpikeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Shiver Spike';
    const rangeRaw = abilityFieldValue(ability, 'projectileRangePx');
    const range = Math.max(0, Number(rangeRaw) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a travel range.`);
      return false;
    }
    const widthRaw = abilityFieldValue(ability, 'projectileWidthPx');
    const width = Math.max(0, Number(widthRaw) || 0);
    const speedRaw = abilityFieldValue(ability, 'projectileSpeedPxS');
    const speed = Math.max(0, Number(speedRaw) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a projectile speed.`);
      return false;
    }
    const damageRaw = abilityFieldValue(ability, 'damage');
    const damage = Math.max(0, Number(damageRaw) || 0);
    const chillDurationMs = Math.max(0, Number(abilityFieldValue(ability, 'chillDurationMs', { skipScaling: true })) || 0);
    const chillDuration = chillDurationMs / 1000;
    const chillDamageMultiplier = Math.max(1, Number(abilityFieldValue(ability, 'chillDamageMultiplier', { skipScaling: true })) || 1);
    const castTimeRaw = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castTimeRaw) || 0) / 1000;

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      speed,
      width,
      damage,
      chillDuration,
      chillDamageMultiplier,
      castDuration,
      elapsed: 0
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.castDuration <= 0){
      launchShiverSpikeProjectile(cast);
      return true;
    }

    shiverSpikeCasts.push(cast);
    player.casting = cast;
    setHudMessage(`${abilityName} preparing...`);
    return true;
  }

  function launchShiverSpikeProjectile(cast){
    if(!cast) return false;
    const startX = Number.isFinite(cast.startX) ? cast.startX : player.x;
    const startY = Number.isFinite(cast.startY) ? cast.startY : player.y;
    const dirLen = Math.hypot(Number(cast.dirX) || 0, Number(cast.dirY) || 0) || 1;
    const dirX = (Number(cast.dirX) || 0) / dirLen;
    const dirY = (Number(cast.dirY) || 0) / dirLen;
    const maxDistance = Math.max(0, Number(cast.range) || 0);
    const projectile = {
      startX,
      startY,
      dirX,
      dirY,
      speed: Math.max(0, Number(cast.speed) || 0),
      maxDistance: maxDistance > 0 ? maxDistance : Math.max(1, Math.hypot(dirX, dirY)),
      traveled: 0,
      width: Math.max(0, Number(cast.width) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      chillDuration: Math.max(0, Number(cast.chillDuration) || 0),
      chillDamageMultiplier: Math.max(1, Number(cast.chillDamageMultiplier) || 1),
      abilityName: cast.abilityName || 'Shiver Spike',
      casterRef: cast.casterRef || player,
      currentX: startX,
      currentY: startY,
      shadowColor: '#b7e7ff',
      outerColor: '#7dd4ff',
      innerColor: '#e4f7ff',
      tipColor: '#ffffff',
      hitStatusText: ' (chilled)'
    };
    laserProjectiles.push(projectile);
    flash(startX, startY, { startRadius: 10, endRadius: 36, color: '#b7e7ff' });
    if(cast.casterRef === player){
      setHudMessage(`${cast.abilityName || 'Shiver'} released!`);
      if(player.casting === cast){
        player.casting = null;
      }
    }
    return true;
  }

  function castGrabAbility(slotIndex, ability, options = {}){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = options.abilityName
      || (ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Grab');
    const pullCaster = options.pullCaster === true;
    const dashSpeedRaw = options && options.dashSpeed !== undefined ? options.dashSpeed : abilityFieldValue(ability, 'dashSpeedPxS');
    const dashSpeed = Math.max(0, Number(dashSpeedRaw) || 0);
    const landingOffset = Math.max(0, Number(options && options.landingOffset) || 0);
    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const rangeRaw = abilityFieldValue(ability, 'grabRange');
    const range = Math.max(0, Number(rangeRaw) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} has no range configured.`);
      return false;
    }
    const speedRaw = abilityFieldValue(ability, 'grabSpeed');
    const speed = Math.max(1, Number(speedRaw) || 0);
    const centerWidthRaw = abilityFieldValue(ability, 'grabWidthCenter');
    const edgeWidthRaw = abilityFieldValue(ability, 'grabWidthEdge');
    const widthStart = Math.max(0, Number(centerWidthRaw) || 0);
    const widthEnd = Math.max(0, Number(edgeWidthRaw) || widthStart);
    const damageRaw = abilityFieldValue(ability, 'damage');
    const damage = Math.max(0, Number(damageRaw) || 0);
    const stunRaw = abilityFieldValue(ability, 'stunDurationMs');
    const stunDuration = Math.max(0, Number(stunRaw) || 0) / 1000;
    const pullRaw = abilityFieldValue(ability, 'pullDistance');
    const pullDistance = Math.max(0, Number(pullRaw) || 0);
    const lockoutRaw = abilityFieldValue(ability, 'postHitLockoutMs');
    const postHitLockout = Math.max(0, Number(lockoutRaw) || 0) / 1000;
    const castRaw = abilityFieldValue(ability, 'castTimeMs');
    const castDuration = Math.max(0, Number(castRaw) || 0) / 1000;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      dirX,
      dirY,
      range,
      speed,
      widthStart,
      widthEnd,
      damage,
      stunDuration,
      pullDistance,
      postHitLockout,
      pullCaster,
      dashSpeed,
      landingOffset,
      channelDuration: castDuration,
      elapsed: 0,
      state: castDuration > 0 ? 'channel' : 'flying',
      distanceTraveled: 0,
      startX,
      startY,
      casterOriginX: player.x,
      casterOriginY: player.y,
      hitPointX: startX,
      hitPointY: startY,
      targetRef: null,
      lockoutRemaining: 0,
      launchAnnounced: castDuration <= 0
    };

    grabCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    const message = cast.state === 'channel' ? `${abilityName} preparing...` : `${abilityName} launched!`;
    setHudMessage(message);
    return true;
  }

  function castWrapdashAbility(slotIndex, ability){
    const dashSpeed = abilityFieldValue(ability, 'dashSpeedPxS');
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Wrapdash';
    return castGrabAbility(slotIndex, ability, {
      pullCaster: true,
      dashSpeed,
      abilityName
    });
  }

  function backlineSeizureTargetRadius(target){
    if(!target) return minionRadius;
    if(target.isPracticeDummy){
      const raw = Number(target.radius);
      return Math.max(minionRadius, Number.isFinite(raw) ? raw : minionRadius);
    }
    return minionRadius;
  }

  function findBacklineSeizureTarget(cast){
    if(!cast) return null;
    const dirX = Number(cast.dirX) || 0;
    const dirY = Number(cast.dirY) || 0;
    const range = Math.max(0, Number(cast.range) || 0);
    const startX = Number(cast.startX) || 0;
    const startY = Number(cast.startY) || 0;
    const halfWidth = Math.max(0, Number(cast.width) || 0) * 0.5;
    let best = null;
    let bestAlong = -Infinity;
    for(const m of minions){
      if(!m) continue;
      const isDummy = m.isPracticeDummy === true;
      if(!isEnemyMinionForPlayer(m) && !isDummy) continue;
      if(m.portalizing > 0 || m.hp <= 0) continue;
      if(isDummy && (m.active === false || (m.respawnTimer || 0) > 0)) continue;
      const radius = backlineSeizureTargetRadius(m);
      const relX = m.x - startX;
      const relY = m.y - startY;
      const along = relX * dirX + relY * dirY;
      if(!(along >= 0)) continue;
      if(along > range) continue;
      const closestX = startX + dirX * along;
      const closestY = startY + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      const effective = halfWidth + radius;
      if(offX * offX + offY * offY <= effective * effective){
        if(along > bestAlong){
          bestAlong = along;
          best = { target: m, along, hitX: closestX, hitY: closestY, targetRadius: radius };
        }
      }
    }
    return best;
  }

  function castBacklineSeizureAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Backline Abduction';
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const range = Math.max(0, Number(abilityFieldValue(ability, 'strikeRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} has no range configured.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'strikeWidthPx')) || 0);
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a strike width.`);
      return false;
    }
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const suppressDuration = Math.max(0, Number(abilityFieldValue(ability, 'suppressDurationMs')) || 0) / 1000;
    const slamStun = Math.max(0, Number(abilityFieldValue(ability, 'slamStunMs')) || 0) / 1000;
    const overshoot = Math.max(0, Number(abilityFieldValue(ability, 'blinkOvershootPx')) || 0);
    const postLockout = Math.max(0, Number(abilityFieldValue(ability, 'postLockoutMs')) || 0) / 1000;
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;

    const cast = {
      id: `abduct-${abilityRuntime.backlineSeizureSequence++}`,
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      dirX,
      dirY,
      range,
      width,
      damage,
      suppressDuration,
      slamStun,
      overshoot,
      postLockout,
      castDuration,
      elapsed: 0,
      state: castDuration > 0 ? 'windup' : 'seeking',
      startX: origin.x,
      startY: origin.y,
      hitPointX: origin.x,
      hitPointY: origin.y,
      targetRef: null,
      lockoutRemaining: 0,
      allowMovementWhileCasting: false
    };

    backlineSeizureCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    const message = cast.state === 'windup' ? `${abilityName} winding up...` : `${abilityName} hunting...`;
    setHudMessage(message);
    return true;
  }

  function linkLashWidthAt(cast, distance){
    const start = Math.max(0, Number(cast.widthStart) || 0);
    const rawEnd = Number(cast.widthEnd);
    const end = Number.isFinite(rawEnd) ? rawEnd : start;
    if(!(cast.range > 0)) return Math.max(0, start);
    const t = Math.max(0, Math.min(1, distance / cast.range));
    return Math.max(0, start + (end - start) * t);
  }

  function findLinkLashHitCandidate(cast, prevDistance, nextDistance){
    if(!cast) return null;
    const dirX = Number(cast.dirX) || 0;
    const dirY = Number(cast.dirY) || 0;
    const maxDistance = Math.max(0, Number(cast.range) || 0);
    let best = null;
    let bestAlong = Infinity;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.portalizing > 0 || m.hp <= 0) continue;
      const relX = m.x - cast.startX;
      const relY = m.y - cast.startY;
      const along = relX * dirX + relY * dirY;
      if(!(along >= 0)) continue;
      if(along > maxDistance) continue;
      if(along < prevDistance - minionRadius) continue;
      if(along > nextDistance + minionRadius) continue;
      const closestX = cast.startX + dirX * along;
      const closestY = cast.startY + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      const width = linkLashWidthAt(cast, along);
      const effectiveRadius = width * 0.5 + minionRadius;
      if(offX * offX + offY * offY <= effectiveRadius * effectiveRadius){
        if(along < bestAlong){
          bestAlong = along;
          best = { target: m, along, hitX: closestX, hitY: closestY };
        }
      }
    }
    return best;
  }

  function linkLashTargetAlive(target){
    return !!(target && target.hp > 0 && target.portalizing <= 0);
  }

  function applyLinkLashSlow(target, slowFraction, slowDuration){
    if(!target) return;
    if(!(slowFraction > 0 && slowDuration > 0)) return;
    const existing = typeof target.slowPct === 'number' ? target.slowPct : 0;
    target.slowPct = Math.max(existing, slowFraction);
    target.slowTimer = Math.max(target.slowTimer || 0, slowDuration);
  }

  function createLinkLashTether(cast, target, hitX, hitY){
    if(!cast || !target) return null;
    const tether = {
      id: `link-${abilityRuntime.linkLashSequence++}`,
      abilityId: cast.abilityId,
      abilityName: cast.abilityName,
      slotIndex: cast.slotIndex,
      casterRef: cast.casterRef || player,
      primaryRef: target,
      primaryHitX: hitX,
      primaryHitY: hitY,
      tetherRemaining: Math.max(0, Number(cast.tetherDuration) || 0),
      followupWindup: Math.max(0, Number(cast.followupWindup) || 0),
      followupRangeBonus: Math.max(0, Number(cast.followupRangeBonus) || 0),
      damage: Math.max(0, Number(cast.damage) || 0),
      slowFraction: Math.max(0, Math.min(1, Number(cast.slowFraction) || 0)),
      slowDuration: Math.max(0, Number(cast.slowDuration) || 0),
      displacement: Math.max(0, Number(cast.displacement) || 0),
      slamRadius: Math.max(0, Number(cast.slamRadius) || 0),
      impactDelay: Math.max(0, Number(cast.impactDelay) || 0),
      rootDuration: Math.max(0, Number(cast.rootDuration) || 0),
      slamStun: Math.max(0, Number(cast.slamStun) || 0),
      slamThreshold: 700,
      state: 'waiting',
      followupUsed: false,
      secondaryRef: null,
      impactTimer: 0,
      secondaryHitX: null,
      secondaryHitY: null
    };
    linkLashTethers.push(tether);
    return tether;
  }

  function handleLinkLashHit(cast, target, hitX, hitY){
    const damage = Math.max(0, Number(cast.damage) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(cast.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(cast.slowDuration) || 0);
    let targetAlive = !!target;
    if(target){
      const prevHp = Number(target.hp) || 0;
      if(damage > 0){
        target.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(target.x, target.y - minionRadius, damage);
      }
      targetAlive = target.hp > 0;
      if(prevHp > 0 && target.hp <= 0){
        flash(target.x, target.y, { color: '#ff8a8a' });
      }
      applyLinkLashSlow(target, slowFraction, slowDuration);
      handlePracticeDummyDamage(target, prevHp);
    }
    flash(hitX, hitY, { color: '#9ce7ff' });
    if(cast.casterRef === player){
      player.attackCooldown = 0;
    }
    if(target && targetAlive){
      createLinkLashTether(cast, target, hitX, hitY);
      if(cast.casterRef === player){
        player.selectedTarget = target;
        setHudMessage(`${cast.abilityName || 'Link Lash'} tethered a target!`);
      }
    } else if(cast.casterRef === player){
      setHudMessage(`${cast.abilityName || 'Link Lash'} hit its mark.`);
    }
  }

  function cleanseCrowdControl(target){
    if(!target) return false;
    const timers = ['slowTimer', 'stunTimer', 'knockupTimer', 'silenceTimer', 'disarmTimer', 'polymorphTimer', 'tauntTimer'];
    let cleared = false;
    for(const key of timers){
      if(Number(target[key]) > 0){
        target[key] = 0;
        cleared = true;
      }
    }
    if(Number(target.slowPct) > 0){
      target.slowPct = 0;
      cleared = true;
    }
    if(target.beingPulledBy){
      target.beingPulledBy = null;
      cleared = true;
    }
    return cleared;
  }

  function castLinkLashAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Link Lash';
    const start = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - start.x;
    let dy = aimPoint.y - start.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - start.x;
      dy = player.target.y - start.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const range = Math.max(0, Number(abilityFieldValue(ability, 'lashRange')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} has no range configured.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'lashSpeed')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a projectile speed.`);
      return false;
    }
    const widthStart = Math.max(0, Number(abilityFieldValue(ability, 'lashWidthStart')) || 0);
    const widthEnd = Math.max(0, Number(abilityFieldValue(ability, 'lashWidthEnd')) || widthStart);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowFraction = Math.max(0, Math.min(1, slowPct / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const tetherDuration = Math.max(0, Number(abilityFieldValue(ability, 'tetherDurationMs')) || 0) / 1000;
    const followupWindup = Math.max(0, Number(abilityFieldValue(ability, 'followupWindupMs')) || 0) / 1000;
    const followupRangeBonus = Math.max(0, Number(abilityFieldValue(ability, 'followupRangeBonus')) || 0);
    const displacement = Math.max(0, Number(abilityFieldValue(ability, 'displacementDistance')) || 0);
    const impactDelay = Math.max(0, Number(abilityFieldValue(ability, 'impactDelayMs')) || 0) / 1000;
    const slamRadius = Math.max(0, Number(abilityFieldValue(ability, 'slamRadiusPx')) || 0);
    const rootDuration = Math.max(0, Number(abilityFieldValue(ability, 'rootDurationMs')) || 0) / 1000;
    const slamStun = Math.max(0, Number(abilityFieldValue(ability, 'slamStunMs')) || 0) / 1000;
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      dirX,
      dirY,
      range,
      speed,
      widthStart,
      widthEnd,
      damage,
      slowFraction,
      slowDuration,
      tetherDuration,
      followupWindup,
      followupRangeBonus,
      displacement,
      impactDelay,
      slamRadius,
      rootDuration,
      slamStun,
      channelDuration: castDuration,
      elapsed: 0,
      state: castDuration > 0 ? 'channel' : 'flying',
      distanceTraveled: 0,
      startX: start.x,
      startY: start.y,
      hitPointX: start.x,
      hitPointY: start.y,
      launchAnnounced: castDuration <= 0
    };

    linkLashCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    const message = cast.state === 'channel' ? `${abilityName} winding up...` : `${abilityName} launched!`;
    setHudMessage(message);
    return true;
  }

  function refreshBoneSkewerElapsed(cast){
    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : null;
    if(!cast || !Number.isFinite(cast.startedAt) || now === null){
      return false;
    }
    const elapsed = Math.max(0, (now - cast.startedAt) / 1000);
    const castTime = Math.max(0, Number(cast.castTime) || 0);
    if(cast.state === 'windup'){
      cast.castElapsed = elapsed;
      cast.channelElapsed = 0;
    } else {
      cast.castElapsed = Math.max(Number(cast.castElapsed) || 0, Math.min(elapsed, castTime));
      cast.channelElapsed = Math.max(0, elapsed - castTime);
    }
    return true;
  }

  function resolveBoneSkewerRange(cast){
    if(!cast) return 0;
    const minRange = Math.max(0, Number(cast.rangeMin) || 0);
    const rangeMaxRaw = Number(cast.rangeMax);
    const maxRange = Math.max(minRange, Number.isFinite(rangeMaxRaw) ? Math.max(0, rangeMaxRaw) : minRange);
    const chargeTime = Math.max(0, Number(cast.rangeChargeTime) || 0);
    const elapsed = Math.max(0, Number(cast.channelElapsed) || 0);
    const t = chargeTime > 0 ? clamp01(elapsed / Math.max(chargeTime, 0.0001)) : 1;
    return minRange + (maxRange - minRange) * t;
  }

  function castBoneSkewerAbility(slotIndex, ability, context = {}){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Bone Skewer';
    const existing = boneSkewerCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      const released = releaseBoneSkewer(existing, { cause: 'recast' });
      return released ? true : false;
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const channelDuration = Math.max(0, Number(abilityFieldValue(ability, 'chargeMaxMs')) || 0) / 1000;
    const rangeChargeTime = Math.max(0, Number(abilityFieldValue(ability, 'rangeChargeTimeMs')) || 0) / 1000;
    const quickReleaseWindow = Math.max(0, Number(abilityFieldValue(ability, 'quickReleaseMs')) || 0) / 1000;
    const rangeMin = Math.max(0, Number(abilityFieldValue(ability, 'rangeMinPx')) || 0);
    const rangeMax = Math.max(rangeMin, Number(abilityFieldValue(ability, 'rangeMaxPx')) || rangeMin);
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxPerMs')) || 0);
    const widthStart = Math.max(0, Number(abilityFieldValue(ability, 'widthStartPx')) || 0);
    const widthEnd = Math.max(0, Number(abilityFieldValue(ability, 'widthEndPx')) || widthStart);
    const pullDistance = Math.max(0, Number(abilityFieldValue(ability, 'pullDistance')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowFraction = Math.max(0, Math.min(1, slowPct / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const selfSlowPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'selfSlowPct')) || 0));
    const movementSpeedMultiplier = selfSlowPct >= 100 ? 0 : Math.max(0, 1 - selfSlowPct / 100);
    const postHitLockout = Math.max(0, Number(abilityFieldValue(ability, 'postHitLockoutMs')) || 0) / 1000;
    const thrustRange = Math.max(0, Number(abilityFieldValue(ability, 'thrustRangePx')) || 0);
    const thrustWidth = Math.max(0, Number(abilityFieldValue(ability, 'thrustWidthPx')) || 0);

    const { x: originX, y: originY } = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - originX;
    let dy = aimPoint.y - originY;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - originX;
      dy = player.target.y - originY;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      state: castTime > 0 ? 'windup' : 'channel',
      castTime,
      castElapsed: 0,
      channelDuration,
      channelElapsed: 0,
      rangeMin,
      rangeMax,
      rangeChargeTime,
      quickReleaseWindow,
      projectileSpeed,
      widthStart,
      widthEnd,
      pullDistance,
      damage,
      slowFraction,
      slowDuration,
      selfSlowPct,
      postHitLockout,
      thrustRange,
      thrustWidth,
      dirX,
      dirY,
      originX,
      originY,
      startedAt: (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(),
      activatorKeyCode: context && context.triggerEvent && context.triggerEvent.code ? context.triggerEvent.code : null,
      activatorKey: context && context.triggerEvent && context.triggerEvent.key ? String(context.triggerEvent.key).toLowerCase() : null,
      allowMovementWhileCasting: true,
      movementSpeedMultiplier
    };

    boneSkewerCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'windup'){
      setHudMessage(`${abilityName} preparing...`);
    } else if(channelDuration > 0){
      setHudMessage(`${abilityName} channeling...`);
    } else {
      releaseBoneSkewer(cast, { cause: 'auto' });
    }
    return { success: true, deferCooldown: true };
  }

  function performBoneSkewerThrust(cast){
    if(!cast) return false;
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = cast.dirX || 1;
      dy = cast.dirY || 0;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;
    const range = Math.max(0, Number(cast.thrustRange) || Number(cast.rangeMin) || 0);
    if(!(range > 0)) return false;
    const widthRaw = Number(cast.thrustWidth);
    const width = Math.max(0, Number.isFinite(widthRaw) ? widthRaw : (Number(cast.widthStart) || 0));
    const half = width / 2 + minionRadius;
    const halfSq = half * half;
    let best = null;
    let bestAlong = Infinity;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const relX = m.x - origin.x;
      const relY = m.y - origin.y;
      const along = relX * dirX + relY * dirY;
      if(along < -minionRadius || along > range + minionRadius) continue;
      const closestX = origin.x + dirX * along;
      const closestY = origin.y + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY <= halfSq){
        if(along < bestAlong){
          bestAlong = along;
          best = m;
        }
      }
    }

    if(!best){
      flash(origin.x + dirX * range, origin.y + dirY * range, { startRadius: 10, endRadius: 24, color: '#9ce7ff66' });
      return false;
    }

    const prevHp = Number(best.hp) || 0;
    if(cast.damage > 0){
      best.hp = Math.max(0, prevHp - cast.damage);
      spawnHitSplat(best.x, best.y - minionRadius, cast.damage);
    }
    if(cast.slowFraction > 0 && cast.slowDuration > 0){
      const existingSlow = typeof best.slowPct === 'number' ? best.slowPct : 0;
      best.slowPct = Math.max(existingSlow, cast.slowFraction);
      best.slowTimer = Math.max(best.slowTimer || 0, cast.slowDuration);
    }
    flash(best.x, best.y, { startRadius: 12, endRadius: 34, color: '#9ce7ff' });
    if(caster === player){
      player.selectedTarget = best;
      if(cast.damage > 0){
        setHudMessage(`${cast.abilityName || 'Bone Skewer'} struck for ${Math.round(cast.damage)} damage!`);
      } else {
        setHudMessage(`${cast.abilityName || 'Bone Skewer'} struck!`);
      }
    }
    handlePracticeDummyDamage(best, prevHp);
    return true;
  }

  function releaseBoneSkewer(cast, { cause = 'manual' } = {}){
    if(!cast || cast.released) return false;
    cast.released = true;
    const idx = boneSkewerCasts.indexOf(cast);
    if(idx >= 0){
      boneSkewerCasts.splice(idx, 1);
    }
    if(player.casting === cast){
      player.casting = null;
    }
    refreshBoneSkewerElapsed(cast);
    const abilityName = cast.abilityName || 'Bone Skewer';
    const cooldownSeconds = Number.isFinite(cast.cooldownSeconds)
      ? Math.max(0, Number(cast.cooldownSeconds) || 0)
      : 0;
    const channelElapsed = Math.max(0, Number(cast.channelElapsed) || 0);
    const quickWindow = Math.max(0, Number(cast.quickReleaseWindow) || 0);

    if(channelElapsed <= quickWindow){
      const hit = performBoneSkewerThrust(cast);
      if(cast.casterRef === player && !hit){
        setHudMessage(`${abilityName} missed.`);
      }
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
      return true;
    }

    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = cast.dirX || 1;
      dy = cast.dirY || 0;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const range = resolveBoneSkewerRange(cast);
    const speed = Math.max(0, Number(cast.projectileSpeed) || 0);
    const widthStart = Math.max(0, Number(cast.widthStart) || 0);
    const widthEnd = Math.max(0, Number(cast.widthEnd) || widthStart);

    if(!(range > 0) || !(speed > 0)){
      if(caster === player){
        setHudMessage(`${abilityName} fizzled.`);
      }
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
      return false;
    }

    const hookCast = {
      slotIndex: cast.slotIndex,
      abilityId: cast.abilityId,
      abilityName,
      casterRef: caster,
      dirX,
      dirY,
      range,
      speed,
      widthStart,
      widthEnd,
      damage: cast.damage,
      stunDuration: 0,
      pullDistance: cast.pullDistance,
      postHitLockout: cast.postHitLockout,
      channelDuration: 0,
      elapsed: 0,
      state: 'flying',
      distanceTraveled: 0,
      startX: origin.x,
      startY: origin.y,
      casterOriginX: caster.x,
      casterOriginY: caster.y,
      hitPointX: origin.x,
      hitPointY: origin.y,
      targetRef: null,
      lockoutRemaining: 0,
      launchAnnounced: true,
      slowAfterHitFraction: cast.slowFraction,
      slowAfterHitDuration: cast.slowDuration
    };

    grabCasts.push(hookCast);
    player.casting = hookCast;
    cancelPlayerAttack(false);
    setHudMessage(`${abilityName} hurled!`);
    setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    return true;
  }

  function castAstralSnareAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Astral Snare';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectile_range_px')) || 0);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectile_speed_px_per_ms')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectile_width_px')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPct = Math.max(0, Number(abilityFieldValue(ability, 'slowPct')) || 0);
    const slowFraction = Math.max(0, Math.min(1, slowPct / 100));
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const stunDuration = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;
    const afterRange = Math.max(0, Number(abilityFieldValue(ability, 'afterHitRangePx')) || 0);
    const cooldownSeconds = abilityCooldownSeconds(ability);

    if(!(range > 0) || !(speed > 0)){
      setHudMessage(`${abilityName} needs range and speed configured.`);
      return false;
    }
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a bolt width.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      len = Math.hypot(dx, dy);
    }
    if(!(len > 0.0001)){
      dx = 1;
      dy = 0;
      len = 1;
    }
    const dirX = dx / len;
    const dirY = dy / len;

    const cast = {
      slotIndex,
      abilityId: ability && ability.id,
      abilityName,
      casterRef: player,
      cooldownSeconds,
      castDuration,
      elapsed: 0,
      state: castDuration > 0 ? 'windup' : 'primary',
      launched: false,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      speed,
      width,
      damage,
      slowFraction,
      slowDuration,
      stunDuration,
      afterRange,
      traveled: 0,
      trailTraveled: 0,
      primaryTarget: null,
      primaryHitX: origin.x,
      primaryHitY: origin.y,
      trailStartX: origin.x,
      trailStartY: origin.y,
      allowMovementWhileCasting: true
    };

    astralSnareCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'windup'){
      setHudMessage(`${abilityName} winding up...`);
    }
    return true;
  }

  function parsePlasmaFissionSplitTrigger(ability){
    const raw = abilityFieldValue(ability, 'split_trigger', { skipScaling: true });
    const numeric = Number.isFinite(raw) ? Math.round(raw) : 1;
    if(numeric === 0) return 'player_recast';
    if(numeric === 2) return 'end_range';
    return 'collision';
  }

  function castPlasmaFissionAbility(slotIndex, ability, context = {}){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Plasma Fission';
    const existing = plasmaFissionCasts.find(cast => cast && !cast.completed && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      if(existing.splitTriggered){
        setHudMessage(`${abilityName} already split.`);
        return false;
      }
      if(!(existing.recastWindow > 0)){
        setHudMessage(`${abilityName} cannot be recast right now.`);
        return false;
      }
      if(existing.recastRemaining !== undefined && existing.recastRemaining <= 0){
        setHudMessage(`${abilityName} recast window expired.`);
        return false;
      }
      if(!existing.projectile){
        setHudMessage(`${abilityName} is no longer in flight.`);
        return false;
      }
      const triggered = triggerPlasmaFissionSplit(existing, existing.projectile, 'player_recast', { announce: true });
      if(triggered){
        return { success: true, deferCooldown: true };
      }
      setHudMessage(`${abilityName} could not split.`);
      return false;
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const projectileSpeedConfig = abilityFieldValue(ability, 'projectile_speed_px_per_ms');
    const projectileSpeed = Math.max(0, Number(projectileSpeedConfig) || 0);
    const projectileWidthRaw = abilityFieldValue(ability, 'projectile_width_px');
    const projectileWidth = Math.max(0, Number(projectileWidthRaw) || 0);
    const projectileRangeRaw = abilityFieldValue(ability, 'projectile_range_px');
    const projectileRange = Math.max(0, Number(projectileRangeRaw) || 0);
    if(!(projectileSpeed > 0) || !(projectileRange > 0)){
      setHudMessage(`${abilityName} needs range and speed configured.`);
      return false;
    }
    const splitAngleRaw = abilityFieldValue(ability, 'split_angle_deg');
    const splitAngle = Number.isFinite(splitAngleRaw) ? (splitAngleRaw * Math.PI / 180) : 0;
    const splitSpeedConfig = abilityFieldValue(ability, 'split_speed_px_per_ms');
    let splitSpeed = Math.max(0, Number(splitSpeedConfig) || 0);
    if(!(splitSpeed > 0)) splitSpeed = projectileSpeed;
    const damageRaw = abilityFieldValue(ability, 'damage_flat');
    const damage = Math.max(0, Number(damageRaw) || 0);
    const slowPctRaw = abilityFieldValue(ability, 'slow_percent');
    const slowFraction = Math.max(0, Math.min(1, (Number(slowPctRaw) || 0) / 100));
    const slowDurationRaw = abilityFieldValue(ability, 'slow_duration_ms');
    const slowDuration = Math.max(0, Number(slowDurationRaw) || 0) / 1000;
    const recastWindowRaw = abilityFieldValue(ability, 'recast_window_ms');
    const recastWindow = Math.max(0, Number(recastWindowRaw) || 0) / 1000;
    const splitTrigger = parsePlasmaFissionSplitTrigger(ability);

    const startX = player.x;
    const startY = player.y;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - startX;
    let dy = aimPoint.y - startY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - startX;
      dy = player.target.y - startY;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const autoSplitDistance = projectileRange > 0 ? Math.min(distance, projectileRange) : distance;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      recastWindow,
      recastRemaining: recastWindow,
      splitTriggered: false,
      splitTrigger,
      splitAngle,
      splitSpeed,
      projectileWidth,
      projectileRange,
      projectileSpeed,
      damage,
      slowFraction,
      slowDuration,
      targetX: aimPoint.x,
      targetY: aimPoint.y,
      autoSplitDistance,
      startedAt: performance.now(),
      completed: false,
      projectile: null
    };

    const projectile = spawnPlasmaFissionProjectile({
      type: 'primary',
      castRef: cast,
      abilityName,
      originX: startX,
      originY: startY,
      dirX,
      dirY,
      speed: projectileSpeed,
      range: projectileRange,
      width: projectileWidth,
      damage,
      slowFraction,
      slowDuration,
      casterRef: player
    });

    if(!projectile){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }

    projectile.autoSplitDistance = autoSplitDistance;

    cast.projectile = projectile;
    plasmaFissionCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    const recastText = recastWindow > 0 ? formatSeconds(recastWindow * 1000) : null;
    if(recastText){
      setHudMessage(`${abilityName} launched â€” will auto-split near your cursor (recast within ${recastText} for manual control).`);
    } else {
      setHudMessage(`${abilityName} launched â€” will auto-split near your cursor.`);
    }
    flash(startX, startY, { startRadius: 10, endRadius: 32, color: '#b9f0ff' });
    return { success: true, deferCooldown: true };
  }

  function spawnPlasmaFissionProjectile(opts){
    if(!opts) return null;
    const range = Math.max(0, Number(opts.range) || 0);
    const speed = Math.max(0, Number(opts.speed) || 0);
    if(!(range > 0) || !(speed > 0)) return null;
    let dirX = Number(opts.dirX) || 0;
    let dirY = Number(opts.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)) return null;
    dirX /= dirLen;
    dirY /= dirLen;
    const projectile = {
      type: opts.type === 'split' ? 'split' : 'primary',
      abilityName: opts.abilityName || 'Plasma Fission',
      startX: Number(opts.originX) || 0,
      startY: Number(opts.originY) || 0,
      currentX: Number(opts.originX) || 0,
      currentY: Number(opts.originY) || 0,
      dirX,
      dirY,
      speed,
      range,
      width: Math.max(0, Number(opts.width) || 0),
      damage: Math.max(0, Number(opts.damage) || 0),
      slowFraction: Math.max(0, Math.min(1, Number(opts.slowFraction) || 0)),
      slowDuration: Math.max(0, Number(opts.slowDuration) || 0),
      traveled: 0,
      castRef: opts.castRef || null,
      casterRef: opts.casterRef || (opts.castRef ? opts.castRef.casterRef : null),
      removed: false
    };
    plasmaFissionProjectiles.push(projectile);
    return projectile;
  }

  function completePlasmaFissionCast(cast, { cause = 'complete', message = null } = {}){
    if(!cast || cast.completed) return;
    cast.completed = true;
    cast.projectile = null;
    const cooldown = Math.max(0, Number(cast.cooldownSeconds) || 0);
    setAbilitySlotCooldown(cast.slotIndex, cooldown);
    const idx = plasmaFissionCasts.indexOf(cast);
    if(idx >= 0){
      plasmaFissionCasts.splice(idx, 1);
    }
    if(message && cast.casterRef === player){
      setHudMessage(message);
    }
  }

  function triggerPlasmaFissionSplit(cast, projectile, cause = 'collision', { x, y, traveled, announce = false } = {}){
    if(!cast || cast.completed || cast.splitTriggered) return false;
    if(!projectile || projectile.type !== 'primary') return false;
    if(cause === 'player_recast' && (!(cast.recastWindow > 0) || (cast.recastRemaining !== undefined && cast.recastRemaining <= 0))){
      return false;
    }
    const currentTraveled = Number.isFinite(traveled) ? traveled : Math.max(0, Number(projectile.traveled) || 0);
    const remainingRange = Math.max(0, Number(projectile.range) || 0) - currentTraveled;
    const splitRange = Math.max(0, remainingRange);
    if(!(splitRange > 0) || !(cast.splitSpeed > 0)){
      completePlasmaFissionCast(cast, { cause, message: announce && cast.casterRef === player ? `${cast.abilityName || 'Plasma Fission'} ended.` : null });
      projectile.removed = true;
      return false;
    }
    const baseX = Number.isFinite(x) ? x : (Number.isFinite(projectile.currentX) ? projectile.currentX : projectile.startX);
    const baseY = Number.isFinite(y) ? y : (Number.isFinite(projectile.currentY) ? projectile.currentY : projectile.startY);
    const dirX = Number(projectile.dirX) || 0;
    const dirY = Number(projectile.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY) || 1;
    const normX = dirX / dirLen;
    const normY = dirY / dirLen;
    const angle = Number.isFinite(cast.splitAngle) ? cast.splitAngle : 0;
    const rotate = (angleRad) => {
      const cos = Math.cos(angleRad);
      const sin = Math.sin(angleRad);
      return {
        x: normX * cos - normY * sin,
        y: normX * sin + normY * cos
      };
    };
    const leftDir = rotate(angle);
    const rightDir = rotate(-angle);

    spawnPlasmaFissionProjectile({
      type: 'split',
      abilityName: cast.abilityName,
      originX: baseX,
      originY: baseY,
      dirX: leftDir.x,
      dirY: leftDir.y,
      speed: cast.splitSpeed,
      range: splitRange,
      width: cast.projectileWidth,
      damage: cast.damage,
      slowFraction: cast.slowFraction,
      slowDuration: cast.slowDuration,
      casterRef: cast.casterRef
    });
    spawnPlasmaFissionProjectile({
      type: 'split',
      abilityName: cast.abilityName,
      originX: baseX,
      originY: baseY,
      dirX: rightDir.x,
      dirY: rightDir.y,
      speed: cast.splitSpeed,
      range: splitRange,
      width: cast.projectileWidth,
      damage: cast.damage,
      slowFraction: cast.slowFraction,
      slowDuration: cast.slowDuration,
      casterRef: cast.casterRef
    });

    cast.splitTriggered = true;
    cast.splitCause = cause;
    cast.projectile = null;
    projectile.removed = true;
    flash(baseX, baseY, { startRadius: 12, endRadius: 38, color: '#b9f0ff' });
    const message = cast.casterRef === player ? `${cast.abilityName || 'Plasma Fission'} split!` : null;
    completePlasmaFissionCast(cast, { cause, message: announce ? message : null });
    return true;
  }

  function updatePlasmaFissionCasts(dt){
    for(let i = plasmaFissionCasts.length - 1; i >= 0; i--){
      const cast = plasmaFissionCasts[i];
      if(!cast){
        plasmaFissionCasts.splice(i, 1);
        continue;
      }
      if(cast.completed){
        plasmaFissionCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = (cast.elapsed || 0) + dt;
      if(Number.isFinite(cast.recastRemaining)){
        cast.recastRemaining = Math.max(0, cast.recastRemaining - dt);
      }
      if(!cast.projectile){
        completePlasmaFissionCast(cast, { cause: 'expired' });
      }
    }
  }

  function updatePlasmaFissionProjectiles(dt){
    for(let i = plasmaFissionProjectiles.length - 1; i >= 0; i--){
      const proj = plasmaFissionProjectiles[i];
      if(!proj || proj.removed){
        plasmaFissionProjectiles.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(proj.speed) || 0);
      const range = Math.max(0, Number(proj.range) || 0);
      if(!(speed > 0) || !(range > 0)){
        plasmaFissionProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      const nextTraveled = Math.min(range, prevTraveled + speed * dt);
      const halfWidth = Math.max(0, Number(proj.width) || 0) * 0.5;
      const effectiveRadius = halfWidth + minionRadius;
      const effectiveSq = effectiveRadius * effectiveRadius;
      let hitTarget = null;
      let hitAlong = Infinity;
      for(const m of minions){
        if(!m || !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const relX = m.x - proj.startX;
        const relY = m.y - proj.startY;
        const along = relX * proj.dirX + relY * proj.dirY;
        if(along < prevTraveled - minionRadius) continue;
        if(along > nextTraveled + minionRadius) continue;
        if(along < -minionRadius || along > range + minionRadius) continue;
        const closestX = proj.startX + proj.dirX * along;
        const closestY = proj.startY + proj.dirY * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        if(offX * offX + offY * offY <= effectiveSq && along < hitAlong){
          hitAlong = along;
          hitTarget = m;
        }
      }

      if(hitTarget){
        const hitX = proj.startX + proj.dirX * hitAlong;
        const hitY = proj.startY + proj.dirY * hitAlong;
        const prevHp = Number(hitTarget.hp) || 0;
        if(proj.damage > 0){
          hitTarget.hp = Math.max(0, prevHp - proj.damage);
          spawnHitSplat(hitTarget.x, hitTarget.y - minionRadius, proj.damage);
        }
        if(proj.slowFraction > 0){
          const existingSlow = typeof hitTarget.slowPct === 'number' ? hitTarget.slowPct : 0;
          hitTarget.slowPct = Math.max(existingSlow, proj.slowFraction);
          if(proj.slowDuration > 0){
            hitTarget.slowTimer = Math.max(hitTarget.slowTimer || 0, proj.slowDuration);
          }
        }
        handlePracticeDummyDamage(hitTarget, prevHp);
        flash(hitX, hitY, { startRadius: 10, endRadius: 30, color: '#b9f0ff' });
        const owner = proj.castRef ? proj.castRef.casterRef : proj.casterRef;
        if(owner === player){
          const dmgText = proj.damage > 0 ? ` for ${Math.round(proj.damage)} damage` : '';
          setHudMessage(`${proj.abilityName || 'Plasma Fission'} hit${dmgText}!`);
        }
        markEntityWithPlasma(hitTarget);
        if(proj.castRef && proj.type === 'primary'){
          const cast = proj.castRef;
          if(!cast.splitTriggered && cast.splitTrigger === 'collision'){
            triggerPlasmaFissionSplit(cast, proj, 'collision', { x: hitX, y: hitY, traveled: hitAlong });
          } else {
            cast.projectile = null;
            completePlasmaFissionCast(cast, { cause: 'impact' });
          }
        }
        plasmaFissionProjectiles.splice(i, 1);
        continue;
      }

      if(proj.castRef && proj.type === 'primary'){
        const cast = proj.castRef;
        if(cast && !cast.splitTriggered){
          const autoDistanceRaw = Number(cast.autoSplitDistance);
          const autoDistance = Math.max(0, Number.isFinite(autoDistanceRaw) ? autoDistanceRaw : Number(proj.autoSplitDistance) || 0);
          if(autoDistance > 0){
            const triggerDistance = Math.min(range, autoDistance);
            if(nextTraveled >= triggerDistance - 0.0001){
              const autoX = proj.startX + proj.dirX * triggerDistance;
              const autoY = proj.startY + proj.dirY * triggerDistance;
              const triggered = triggerPlasmaFissionSplit(cast, proj, 'auto', {
                x: autoX,
                y: autoY,
                traveled: triggerDistance,
                announce: true
              });
              if(triggered){
                plasmaFissionProjectiles.splice(i, 1);
                continue;
              }
            }
          }
        }
      }

      proj.traveled = nextTraveled;
      proj.currentX = proj.startX + proj.dirX * nextTraveled;
      proj.currentY = proj.startY + proj.dirY * nextTraveled;

      if(nextTraveled >= range - 0.0001){
        if(proj.castRef && proj.type === 'primary'){
          const cast = proj.castRef;
          if(!cast.splitTriggered && cast.splitTrigger === 'end_range'){
            triggerPlasmaFissionSplit(cast, proj, 'end_range', { x: proj.currentX, y: proj.currentY, traveled: range });
          } else {
            cast.projectile = null;
            completePlasmaFissionCast(cast, { cause: 'expire', message: cast.casterRef === player ? `${cast.abilityName || 'Plasma Fission'} dissipated.` : null });
          }
        }
        plasmaFissionProjectiles.splice(i, 1);
      }
    }
  }

  function drawPlasmaFissionProjectiles(){
    for(const proj of plasmaFissionProjectiles){
      if(!proj) continue;
      const headX = Number.isFinite(proj.currentX) ? proj.currentX : proj.startX;
      const headY = Number.isFinite(proj.currentY) ? proj.currentY : proj.startY;
      const tailLength = Math.min(Math.max(0, Number(proj.traveled) || 0), 220);
      const tailX = headX - proj.dirX * tailLength;
      const tailY = headY - proj.dirY * tailLength;
      const width = Math.max(2, (Number(proj.width) || 0) * 0.4 + 2);
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = proj.type === 'primary' ? 0.9 : 0.8;
      ctx.shadowColor = '#b9f0ff';
      ctx.shadowBlur = proj.type === 'primary' ? 20 : 14;
      ctx.strokeStyle = '#b9f0ffcc';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.lineWidth = Math.max(1, width * 0.45);
      ctx.strokeStyle = '#f2fbff';
      ctx.beginPath();
      ctx.moveTo(headX - proj.dirX * Math.max(6, width * 0.6), headY - proj.dirY * Math.max(6, width * 0.6));
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function portalTargetForSide(side){
    if(GameState.multiTeam && GameState.multiTeam.enabled){
      const bases = Array.isArray(GameState.multiTeamBases) ? GameState.multiTeamBases : [];
      const opponent = bases.find(b => b && b.id !== side && b.side !== side);
      if(opponent && opponent.baseZone){
        return { x: opponent.baseZone.x, y: opponent.baseZone.y };
      }
    }
    const enemySide = side === 'red' ? 'blue' : 'red';
    const enemyBase = getBaseConfig(enemySide);
    if(enemyBase && enemyBase.baseZone){
      return { x: enemyBase.baseZone.x, y: enemyBase.baseZone.y };
    }
    const fallbackSpawn = enemySide === 'red' ? redSpawns[0] : blueSpawns[0];
    if(fallbackSpawn){
      return { x: fallbackSpawn.x, y: fallbackSpawn.y };
    }
    return { x: mapState.width / 2, y: mapState.height / 2 };
  }

  function findNearestLanePathForSide(side, x, y){
    const layout = ensureLaneLayout();
    if(!layout || !layout.lanes || !layout.lanes.length){
      return null;
    }
    let best = null;
    for(const lane of layout.lanes){
      const path = lanePathForSide(lane, side);
      if(!path) continue;
      const projection = projectPointOntoLane(path, x, y);
      const dist = projection && Number.isFinite(projection.dist) ? projection.dist : Infinity;
      if(!best || dist < best.dist){
        best = {
          path,
          lane,
          laneIndex: Number.isFinite(lane.index) ? lane.index : 0,
          laneLabel: lane.label || String((lane.index || 0) + 1),
          projection,
          dist
        };
      }
    }
    return best;
  }

  function spawnMourningMarchMinion({
    kind = 'walker',
    side = player.team,
    x = 0,
    y = 0,
    hp = 1,
    damage = 0,
    guardPoint = null,
    leash = 0,
    laneRef = null,
    ownerRef = null,
    groupId = null,
    disablePortal = true,
    fanSlot = 0
  } = {}){
    const laneInfo = laneRef || findNearestLanePathForSide(side, x, y);
    const lanePath = laneInfo && laneInfo.path ? laneInfo.path : null;
    const targetBase = (lanePath && lanePath.to) ? lanePath.to : portalTargetForSide(side);
    const laneIndex = laneInfo && Number.isFinite(laneInfo.laneIndex) ? laneInfo.laneIndex : 0;
    const laneLabel = laneInfo && laneInfo.laneLabel ? laneInfo.laneLabel : String((laneIndex || 0) + 1);
    const primarySegment = lanePath && lanePath.segments && lanePath.segments[0] ? lanePath.segments[0] : null;
    const laneDir = primarySegment ? { x: primarySegment.dirX, y: primarySegment.dirY } : (()=>{ const dx = targetBase.x - x; const dy = targetBase.y - y; const len = Math.hypot(dx, dy) || 1; return { x: dx / len, y: dy / len }; })();
    const laneNormal = primarySegment ? { x: primarySegment.normalX, y: primarySegment.normalY } : { x: -laneDir.y, y: laneDir.x };
    const laneLength = lanePath && Number.isFinite(lanePath.totalLength) ? lanePath.totalLength : Math.hypot(targetBase.x - x, targetBase.y - y) || 1;
    const neutralDistance = laneLength * 0.5;
    const neutralSample = lanePath ? lanePointAtDistance(lanePath, neutralDistance) : null;
    const neutralPoint = guardPoint
      ? { x: guardPoint.x, y: guardPoint.y }
      : (neutralSample && neutralSample.point
        ? { x: neutralSample.point.x, y: neutralSample.point.y }
        : { x: x + laneDir.x * neutralDistance, y: y + laneDir.y * neutralDistance });
    const fanOffsetValue = Number.isFinite(fanSlot) ? fanSlotOffset(fanSlot) * laneFanSpacing : 0;
    const projection = lanePath ? projectPointOntoLane(lanePath, x, y) : null;
    const minion = {
      side,
      teamId: lanePath && lanePath.teamId ? lanePath.teamId : side,
      teamColor: lanePath && lanePath.teamColor ? lanePath.teamColor : teamColorForSide(side),
      x,
      y,
      to: { x: targetBase.x, y: targetBase.y },
      spawn: { x, y },
      neutralPoint,
      neutralProj: projection && Number.isFinite(projection.distance) ? projection.distance : neutralDistance,
      laneDir,
      laneFacing: Math.atan2(laneDir.y, laneDir.x),
      laneNormal,
      fanOffset: fanOffsetValue,
      laneLength,
      offsideLimit: Math.min(laneLength, neutralDistance),
      hp: Math.max(1, Number(hp) || 1),
      maxHp: Math.max(1, Number(hp) || 1),
      dmg: Math.max(0, Number(damage) || 0),
      cd: 0,
      slowPct: 0,
      slowTimer: 0,
      stunTimer: 0,
      beingPulledBy: null,
      portalizing: 0,
      inPortalZone: false,
      scored: false,
      facing: Math.atan2(laneDir.y, laneDir.x),
      nav: null,
      lanePath,
      laneIndex,
      laneLabel,
      pathDistance: 0,
      laneProjection: null,
      laneProgress: projection && Number.isFinite(projection.distance) ? projection.distance : 0,
      offLaneDistance: projection && Number.isFinite(projection.dist) ? projection.dist : 0,
      isSummonedPet: true,
      petMode: guardPoint ? 'guard' : 'push',
      guardPoint: guardPoint ? { x: guardPoint.x, y: guardPoint.y } : null,
      petLeash: Math.max(0, Number(leash) || 0),
      petGroupId: groupId,
      petKind: kind,
      petOwner: ownerRef || null,
      disablePortal: disablePortal === true
    };
    minions.push(minion);
    updateMinionLaneFrame(minion);
    return minion;
  }

  function releaseMourningMarch(cast){
    if(!cast || cast.released) return false;
    const casterSide = cast.casterRef && cast.casterRef.team ? cast.casterRef.team : player.team;
    const ref = (cast.maiden && cast.maiden.hp > 0) ? cast.maiden : (cast.guardPoint || cast.casterRef || player);
    const laneRef = findNearestLanePathForSide(casterSide, ref.x, ref.y) || (cast.lanePath ? { path: cast.lanePath, laneIndex: cast.laneIndex, laneLabel: cast.laneLabel } : null);
    const lanePath = laneRef && laneRef.path ? laneRef.path : null;
    const laneIndex = laneRef && Number.isFinite(laneRef.laneIndex) ? laneRef.laneIndex : 0;
    const laneLabel = laneRef && laneRef.laneLabel ? laneRef.laneLabel : String((laneIndex || 0) + 1);
    const target = lanePath && lanePath.to ? lanePath.to : portalTargetForSide(casterSide);
    const applyRelease = (minion, slotIndex = 0)=>{
      if(!minion) return;
      minion.petMode = 'push';
      minion.guardPoint = null;
      minion.petLeash = 0;
      minion.disablePortal = false;
      if(lanePath){
        minion.lanePath = lanePath;
        minion.laneIndex = laneIndex;
        minion.laneLabel = laneLabel;
      }
      if(target){
        minion.to = { x: target.x, y: target.y };
      }
      minion.fanOffset = Number.isFinite(slotIndex) ? fanSlotOffset(slotIndex) * laneFanSpacing : minion.fanOffset;
      updateMinionLaneFrame(minion);
    };
    applyRelease(cast.maiden, 0);
    if(Array.isArray(cast.walkers)){
      cast.walkers.forEach((walker, idx)=> applyRelease(walker, idx + 1));
    }
    cast.released = true;
    cast.releaseReady = true;
    cast.targetLaneLabel = laneLabel;
    cast.releaseAt = performance.now();
    return true;
  }

  function completeMourningMarchCast(cast, { message = null } = {}){
    if(!cast || cast.completed) return;
    cast.completed = true;
    const cooldown = Math.max(0, Number(cast.cooldownSeconds) || 0);
    setAbilitySlotCooldown(cast.slotIndex, cooldown);
    if(cast.maiden && cast.maiden.hp > 0){
      cast.maiden.hp = 0;
    }
    if(Array.isArray(cast.walkers)){
      for(const walker of cast.walkers){
        if(walker && walker.hp > 0){
          walker.hp = 0;
        }
      }
    }
    const idx = mourningMarchCasts.indexOf(cast);
    if(idx >= 0){
      mourningMarchCasts.splice(idx, 1);
    }
    if(message && cast.casterRef === player){
      setHudMessage(message);
    }
  }

  function updateMourningMarchCasts(dt){
    for(let i = mourningMarchCasts.length - 1; i >= 0; i--){
      const cast = mourningMarchCasts[i];
      if(!cast) continue;
      const casterAlive = cast.casterRef && Number.isFinite(cast.casterRef.hp) ? cast.casterRef.hp > 0 : true;
      const maidenAlive = cast.maiden && minions.includes(cast.maiden) && cast.maiden.hp > 0;
      cast.walkers = Array.isArray(cast.walkers) ? cast.walkers.filter(w => w && minions.includes(w) && w.hp > 0) : [];
      if(!casterAlive || !maidenAlive){
        completeMourningMarchCast(cast, { message: cast.casterRef === player ? `${cast.abilityName || 'Mourning March'} ended.` : null });
        continue;
      }

      cast.elapsed = (cast.elapsed || 0) + dt;
      const releaseDelay = Math.max(0, Number(cast.releaseDelay) || 0);
      if(!cast.releaseReady && cast.elapsed >= releaseDelay){
        cast.releaseReady = true;
        if(!cast.releaseAnnounced && cast.casterRef === player){
          setHudMessage(`${cast.abilityName || 'Mourning March'} can be recast to march down a lane.`);
          cast.releaseAnnounced = true;
        }
      }

      if(!cast.released){
        const guardX = cast.casterRef ? cast.casterRef.x : (cast.guardPoint ? cast.guardPoint.x : cast.maiden.x);
        const guardY = cast.casterRef ? cast.casterRef.y : (cast.guardPoint ? cast.guardPoint.y : cast.maiden.y);
        const clampedX = Math.max(minionRadius, Math.min(mapState.width - minionRadius, guardX));
        const clampedY = Math.max(minionRadius, Math.min(mapState.height - minionRadius, guardY));
        const guardPoint = { x: clampedX, y: clampedY };
        cast.guardPoint = guardPoint;
        cast.maiden.guardPoint = guardPoint;
        cast.maiden.neutralPoint = guardPoint;
        cast.maiden.petMode = 'guard';
        cast.maiden.petLeash = Math.max(0, Number(cast.guardLeash) || 0);
        cast.maiden.disablePortal = true;
        for(const walker of cast.walkers){
          if(!walker) continue;
          walker.guardPoint = guardPoint;
          walker.neutralPoint = guardPoint;
          walker.petMode = 'guard';
          walker.petLeash = Math.max(0, Number(cast.guardLeash) || 0);
          walker.disablePortal = true;
        }
      } else {
        if(cast.maiden){
          cast.maiden.disablePortal = false;
        }
        for(const walker of cast.walkers){
          if(walker){
            walker.disablePortal = false;
          }
        }
      }
    }
  }

  function findPlasmaTargetInRange(range){
    const maxRange = Math.max(0, Number(range) || 0);
    const hasRangeLimit = maxRange > 0;
    const rangeSq = hasRangeLimit ? maxRange * maxRange : Infinity;
    let candidate = null;
    let bestDistSq = Infinity;
    const evaluate = (target) => {
      if(!target || !(Number(target.hp) > 0)) return;
      if(Number(target.portalizing) > 0) return;
      if(!(Number(target.plasmaTimer) > 0)) return;
      const dx = target.x - player.x;
      const dy = target.y - player.y;
      const distSq = dx * dx + dy * dy;
      if(hasRangeLimit && distSq > rangeSq) return;
      if(distSq < bestDistSq){
        bestDistSq = distSq;
        candidate = target;
      }
    };
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      evaluate(m);
    }
    if(isMonsterAttackable(monsterState)){
      evaluate(monsterState);
    }
    return candidate;
  }

  function castMourningMarchAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Mourning March';
    const existing = mourningMarchCasts.find(cast => cast && !cast.completed && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      if(!existing.maiden || existing.maiden.hp <= 0){
        completeMourningMarchCast(existing, { message: abilityName + ' ended.' });
      } else if(existing.released){
        setHudMessage(`${abilityName} is already marching.`);
        return false;
      } else {
        if(!existing.releaseReady){
          const remaining = Math.max(0, (Math.max(0, Number(existing.releaseDelay) || 0) - (Number(existing.elapsed) || 0)) * 1000);
          const timeText = formatSeconds(remaining);
          setHudMessage(`${abilityName} recast unlocks in ${timeText}.`);
          return false;
        }
        const released = releaseMourningMarch(existing);
        if(released){
          const laneLabel = existing.targetLaneLabel || existing.laneLabel || '';
          setHudMessage(`${abilityName} released${laneLabel ? ` down lane ${laneLabel}` : ''}.`);
          return { success: true, deferCooldown: true };
        }
        setHudMessage(`${abilityName} could not release.`);
        return false;
      }
    }

    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const summonRange = Math.max(0, Number(abilityFieldValue(ability, 'summonRangePx')) || 0);
    const maidenHp = Math.max(1, Number(abilityFieldValue(ability, 'maidenHp')) || 1);
    const maidenDamage = Math.max(0, Number(abilityFieldValue(ability, 'maidenDamage')) || 0);
    const walkerCount = Math.max(0, Math.floor(Number(abilityFieldValue(ability, 'walkerCount')) || 0));
    const walkerHp = Math.max(1, Number(abilityFieldValue(ability, 'walkerHp')) || 0);
    const walkerDamage = Math.max(0, Number(abilityFieldValue(ability, 'walkerDamage')) || 0);
    const releaseDelay = Math.max(0, Number(abilityFieldValue(ability, 'releaseDelayMs')) || 0) / 1000;
    const leashRange = Math.max(0, Number(abilityFieldValue(ability, 'leashRangePx')) || 0);

    const origin = getSpellOrigin(player);
    const aim = beamAimPoint();
    let dx = aim.x - origin.x;
    let dy = aim.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(summonRange > 0 && distance > summonRange){
      const scale = summonRange / distance;
      dx *= scale;
      dy *= scale;
      distance = summonRange;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const safeRadius = Math.max(minionRadius, 6);
    targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
    targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));

    const laneRef = findNearestLanePathForSide(player.team, targetX, targetY);
    const guardPoint = { x: targetX, y: targetY };
    const groupId = abilityRuntime.mourningMarchSequence++;

    const maiden = spawnMourningMarchMinion({
      kind: 'maiden',
      side: player.team,
      x: targetX,
      y: targetY,
      hp: maidenHp,
      damage: maidenDamage,
      guardPoint,
      leash: leashRange,
      laneRef,
      ownerRef: player,
      groupId,
      disablePortal: true,
      fanSlot: 0
    });
    if(!maiden){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }

    const walkers = [];
    const ringRadius = Math.max(12, minionRadius * 2.2);
    for(let i = 0; i < walkerCount; i++){
      const angle = (Math.PI * 2 * i) / Math.max(1, walkerCount);
      const wx = targetX + Math.cos(angle) * ringRadius;
      const wy = targetY + Math.sin(angle) * ringRadius;
      const walker = spawnMourningMarchMinion({
        kind: 'walker',
        side: player.team,
        x: wx,
        y: wy,
        hp: walkerHp,
        damage: walkerDamage,
        guardPoint,
        leash: leashRange,
        laneRef,
        ownerRef: player,
        groupId,
        disablePortal: true,
        fanSlot: i + 1
      });
      if(walker){
        walkers.push(walker);
      }
    }

    const cast = {
      id: groupId,
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      cooldownSeconds,
      releaseDelay,
      guardLeash: leashRange,
      guardPoint,
      lanePath: laneRef && laneRef.path ? laneRef.path : null,
      laneIndex: laneRef && Number.isFinite(laneRef.laneIndex) ? laneRef.laneIndex : 0,
      laneLabel: laneRef && laneRef.laneLabel ? laneRef.laneLabel : null,
      maiden,
      walkers,
      elapsed: 0,
      releaseReady: releaseDelay <= 0,
      released: false,
      completed: false
    };

    mourningMarchCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    setHudMessage(`${abilityName} summoned${walkerCount > 0 ? ` with ${walkerCount} walker${walkerCount === 1 ? '' : 's'}` : ''}.`);
    flash(targetX, targetY, { startRadius: 10, endRadius: 34, color: '#9ce7ff' });
    return { success: true, deferCooldown: true };
  }

  function resolveGuardianTarget(range){
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(range > 0 && distance > range){
      const scale = range / distance;
      dx *= scale;
      dy *= scale;
      distance = range;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const safeRadius = Math.max(minionRadius, 6);
    targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
    targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
    return { x: targetX, y: targetY };
  }

  function applyGuardianImpactDamage(x, y, radius, damage){
    const safeRadius = Math.max(0, Number(radius) || 0);
    const effectiveRadius = safeRadius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;
    if(!(effectiveRadius > 0) && !(damage > 0)) return hits;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }
    return hits;
  }

  function completeEmberGuardianCast(cast, { message = null } = {}){
    if(!cast || cast.completed) return false;
    cast.completed = true;
    const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
    setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    if(cast.guardian && cast.guardian.hp > 0){
      cast.guardian.hp = 0;
    }
    const idx = emberGuardianCasts.indexOf(cast);
    if(idx >= 0){
      emberGuardianCasts.splice(idx, 1);
    }
    if(message && cast.casterRef === player){
      setHudMessage(message);
    }
    return true;
  }

  function repositionEmberGuardian(cast, targetX, targetY, { applyDamage = false } = {}){
    if(!cast || !cast.guardian) return false;
    const guardian = cast.guardian;
    const guardPoint = { x: targetX, y: targetY };
    cast.guardPoint = guardPoint;
    guardian.guardPoint = guardPoint;
    guardian.neutralPoint = guardPoint;
    guardian.petMode = 'guard';
    guardian.petLeash = Math.max(0, Number(cast.guardLeash) || 0);
    guardian.disablePortal = true;
    guardian.x = targetX;
    guardian.y = targetY;
    const laneRef = findNearestLanePathForSide(guardian.side, targetX, targetY);
    if(laneRef){
      guardian.lanePath = laneRef.path || null;
      guardian.laneIndex = laneRef.laneIndex;
      guardian.laneLabel = laneRef.laneLabel;
      guardian.to = (laneRef.path && laneRef.path.to)
        ? { x: laneRef.path.to.x, y: laneRef.path.to.y }
        : guardian.to;
    } else {
      const fallback = portalTargetForSide(guardian.side);
      if(fallback){
        guardian.to = { x: fallback.x, y: fallback.y };
      }
    }
    updateMinionLaneFrame(guardian);
    if(applyDamage){
      applyGuardianImpactDamage(targetX, targetY, cast.impactRadius, cast.damage);
    }
    flash(targetX, targetY, { startRadius: 12, endRadius: 36, color: '#ff9c3f' });
    return true;
  }

  function castCinderfallGuardianAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Cinderfall Guardian';
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const summonRange = Math.max(0, Number(abilityFieldValue(ability, 'summonRangePx')) || 0);
    const target = resolveGuardianTarget(summonRange);
    let existing = emberGuardianCasts.find(cast => cast && !cast.completed && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      if(existing.guardian && existing.guardian.hp > 0){
        repositionEmberGuardian(existing, target.x, target.y, { applyDamage: true });
        cancelPlayerAttack(false);
        player.chaseTarget = null;
        if(existing.casterRef === player){
          setHudMessage(`${abilityName} redirected.`);
        }
        return { success: true, deferCooldown: true };
      }
      completeEmberGuardianCast(existing, { message: existing.casterRef === player ? `${abilityName} ended.` : null });
      existing = null;
    }
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const petHp = Math.max(1, Number(abilityFieldValue(ability, 'petHp')) || 1);
    const petDamage = Math.max(0, Number(abilityFieldValue(ability, 'petDamage')) || 0);
    const petDurationMs = Math.max(0, Number(abilityFieldValue(ability, 'petDurationMs')) || 0);
    const guardDuration = petDurationMs > 0 ? (petDurationMs / 1000) : Infinity;
    const leashRange = Math.max(0, Number(abilityFieldValue(ability, 'petLeashPx')) || 0);

    const castId = abilityRuntime.emberGuardianSequence++;
    const laneRef = findNearestLanePathForSide(player.team, target.x, target.y);
    const guardian = spawnMourningMarchMinion({
      kind: 'guardian',
      side: player.team,
      x: target.x,
      y: target.y,
      hp: petHp,
      damage: petDamage,
      guardPoint: { x: target.x, y: target.y },
      leash: leashRange,
      laneRef,
      ownerRef: player,
      groupId: castId,
      disablePortal: true,
      fanSlot: 0
    });
    if(!guardian){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }
    applyGuardianImpactDamage(target.x, target.y, impactRadius, damage);
    flash(target.x, target.y, { startRadius: 12, endRadius: 36, color: '#ff9c3f' });

    const cast = {
      id: castId,
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      guardian,
      guardPoint: { x: target.x, y: target.y },
      guardLeash: leashRange,
      guardDuration,
      elapsed: 0,
      cooldownSeconds,
      impactRadius,
      damage,
      completed: false
    };
    emberGuardianCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    setHudMessage(`${abilityName} summoned.`);
    return { success: true, deferCooldown: true };
  }

  function updateEmberGuardianCasts(dt){
    for(let i = emberGuardianCasts.length - 1; i >= 0; i--){
      const cast = emberGuardianCasts[i];
      if(!cast){
        emberGuardianCasts.splice(i, 1);
        continue;
      }
      const guardianAlive = cast.guardian && cast.guardian.hp > 0;
      const casterAlive = cast.casterRef && Number.isFinite(cast.casterRef.hp) ? cast.casterRef.hp > 0 : true;
      if(!guardianAlive || !casterAlive){
        completeEmberGuardianCast(cast, { message: cast.casterRef === player ? `${cast.abilityName || 'Cinderfall Guardian'} ended.` : null });
        continue;
      }
      if(cast.guardDuration < Infinity){
        cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
        if(cast.elapsed >= cast.guardDuration){
          completeEmberGuardianCast(cast, { message: cast.casterRef === player ? `${cast.abilityName || 'Cinderfall Guardian'} ended.` : null });
          continue;
        }
      }
      if(cast.guardian){
        cast.guardian.disablePortal = true;
        cast.guardian.guardPoint = cast.guardPoint;
        cast.guardian.neutralPoint = cast.guardPoint;
        cast.guardian.petMode = 'guard';
        cast.guardian.petLeash = Math.max(0, Number(cast.guardLeash) || 0);
      }
    }
  }

  function castPiercingArrowAbility(slotIndex, ability, context = {}){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Piercing Arrow';
    const existing = piercingArrowCasts.find(cast => cast && cast.casterRef === player && cast.abilityId === ability.id);
    if(existing){
      setHudMessage(`${abilityName} is already charging.`);
      return false;
    }
    if(player.casting && player.casting.abilityId && player.casting.abilityId !== ability.id){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const cooldownSeconds = abilityCooldownSeconds(ability);
    const chargeMinMs = Math.max(0, Number(abilityFieldValue(ability, 'chargeMinMs')) || 0);
    const chargeMaxMsRaw = Number(abilityFieldValue(ability, 'chargeMaxMs'));
    const chargeMaxMs = Math.max(chargeMinMs, Number.isFinite(chargeMaxMsRaw) ? Math.max(0, chargeMaxMsRaw) : chargeMinMs);
    const rangeMin = Math.max(0, Number(abilityFieldValue(ability, 'rangeMinPx')) || 0);
    const rangeMax = Math.max(rangeMin, Number(abilityFieldValue(ability, 'rangeMaxPx')) || rangeMin);
    const damageMin = Math.max(0, Number(abilityFieldValue(ability, 'damageMin')) || 0);
    const damageMax = Math.max(damageMin, Number(abilityFieldValue(ability, 'damageMax')) || damageMin);
    const projectileSpeedConfig = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxPerMs')) || 0);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'widthPx')) || 0);
    const movementSlowPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'movementSlowPct')) || 0));
    const canCancel = Number(abilityFieldValue(ability, 'canCancelCharge')) > 0;

    const caster = player;
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - caster.x;
    let dy = aimPoint.y - caster.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - caster.x;
      dy = player.target.y - caster.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: caster,
      state: 'charging',
      chargeElapsed: 0,
      chargeMin: chargeMinMs / 1000,
      chargeMax: chargeMaxMs / 1000,
      rangeMin,
      rangeMax,
      damageMin,
      damageMax,
      projectileSpeed: projectileSpeedConfig,
      width,
      cooldownSeconds,
      allowMovementWhileCasting: true,
      movementSpeedMultiplier: movementSlowPct >= 100 ? 0 : Math.max(0, 1 - movementSlowPct / 100),
      movementSlowPct,
      activatorKeyCode: context && context.triggerEvent && context.triggerEvent.code ? context.triggerEvent.code : null,
      activatorKey: context && context.triggerEvent && context.triggerEvent.key ? String(context.triggerEvent.key).toLowerCase() : null,
      cancelCooldownFraction: 0.5,
      canCancel,
      dirX,
      dirY,
      initialDirX: dirX,
      initialDirY: dirY,
      startedAt: performance.now(),
      released: false
    };

    cast.chargeState = computePiercingArrowChargeState(cast);
    piercingArrowCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.chargeMax <= 0 && cast.chargeMin <= 0){
      releasePiercingArrow(cast, { cause: 'auto' });
      return true;
    }

    setHudMessage(`${abilityName} charging...`);
    return { success: true, deferCooldown: true };
  }

  function computePiercingArrowChargeState(cast){
    if(!cast){
      return {
        elapsed: 0,
        minCharge: 0,
        maxCharge: 0,
        effectiveElapsed: 0,
        normalized: 0,
        rangeMin: 0,
        rangeMax: 0,
        range: 0,
        damageMin: 0,
        damageMax: 0,
        damage: 0
      };
    }

    const elapsed = Math.max(0, Number(cast.chargeElapsed) || 0);
    const minCharge = Math.max(0, Number(cast.chargeMin) || 0);
    const maxChargeRaw = Number(cast.chargeMax);
    const maxCharge = Math.max(minCharge, Number.isFinite(maxChargeRaw) ? Math.max(0, maxChargeRaw) : 0);
    const rangeMin = Math.max(0, Number(cast.rangeMin) || 0);
    const rangeMaxRaw = Number(cast.rangeMax);
    const rangeMax = Math.max(rangeMin, Number.isFinite(rangeMaxRaw) ? Math.max(0, rangeMaxRaw) : rangeMin);
    const damageMin = Math.max(0, Number(cast.damageMin) || 0);
    const damageMaxRaw = Number(cast.damageMax);
    const damageMax = Math.max(damageMin, Number.isFinite(damageMaxRaw) ? Math.max(0, damageMaxRaw) : damageMin);

    const effectiveElapsed = maxCharge > 0
      ? Math.min(Math.max(elapsed, minCharge), maxCharge)
      : Math.max(elapsed, minCharge);

    let normalized;
    if(maxCharge > minCharge){
      const denom = Math.max(maxCharge - minCharge, 0.000001);
      normalized = (effectiveElapsed - minCharge) / denom;
    } else {
      normalized = effectiveElapsed > 0 ? 1 : 0;
    }
    normalized = Math.max(0, Math.min(1, normalized));

    const range = rangeMin + (rangeMax - rangeMin) * normalized;
    const damage = damageMin + (damageMax - damageMin) * normalized;

    return {
      elapsed,
      minCharge,
      maxCharge,
      effectiveElapsed,
      normalized,
      rangeMin,
      rangeMax,
      range,
      damageMin,
      damageMax,
      damage
    };
  }

  function clearPiercingArrowCast(cast){
    if(!cast) return;
    const idx = piercingArrowCasts.indexOf(cast);
    if(idx >= 0){
      piercingArrowCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
  }

  function releasePiercingArrow(cast, { cause = 'release' } = {}){
    if(!cast || cast.released) return false;
    cast.released = true;
    clearPiercingArrowCast(cast);

    const abilityName = cast.abilityName || 'Piercing Arrow';
    const cooldownSeconds = Number.isFinite(cast.cooldownSeconds) ? Math.max(0, Number(cast.cooldownSeconds) || 0) : 0;

    if(Number.isFinite(cast.startedAt)){
      const elapsedSeconds = Math.max(0, (performance.now() - cast.startedAt) / 1000);
      cast.chargeElapsed = Math.max(Number(cast.chargeElapsed) || 0, elapsedSeconds);
    }

    const state = computePiercingArrowChargeState(cast);
    cast.chargeState = state;
    const range = state.range;
    const damage = state.damage;
    const projectileSpeed = Math.max(0, Number(cast.projectileSpeed) || 0);
    const width = Math.max(0, Number(cast.width) || 0);

    const caster = cast.casterRef || player;
    const { x: originX, y: originY } = getSpellOrigin(caster);

    let dirX = Number.isFinite(cast.dirX) ? cast.dirX : (Number.isFinite(cast.initialDirX) ? cast.initialDirX : 1);
    let dirY = Number.isFinite(cast.dirY) ? cast.dirY : (Number.isFinite(cast.initialDirY) ? cast.initialDirY : 0);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - originX;
    let dy = aimPoint.y - originY;
    let len = Math.hypot(dx, dy);
    if(!(len > 0.0001)){
      dx = player.target.x - originX;
      dy = player.target.y - originY;
      len = Math.hypot(dx, dy);
    }
    if(len > 0.0001){
      dirX = dx / len;
      dirY = dy / len;
    } else {
      const dirLen = Math.hypot(dirX, dirY);
      if(dirLen > 0.0001){
        dirX /= dirLen;
        dirY /= dirLen;
      } else {
        dirX = 1;
        dirY = 0;
      }
    }

    if(!(range > 0) || !(projectileSpeed > 0)){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
      if(caster === player){
        setHudMessage(`${abilityName} fizzled.`);
      }
      return false;
    }

    const projectile = spawnPiercingArrowProjectile({
      abilityName,
      originX,
      originY,
      dirX,
      dirY,
      range,
      speed: projectileSpeed,
      width,
      damage,
      casterRef: caster
    });

    if(!projectile){
      setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
      if(caster === player){
        setHudMessage(`${abilityName} fizzled.`);
      }
      return false;
    }

    flash(originX, originY, { startRadius: 12, endRadius: 36, color: '#9de0ff' });
    if(caster === player){
      const damageText = Math.round(damage);
      const rangeText = Math.round(range);
      if(cause === 'auto' && state.maxCharge > 0){
        setHudMessage(`${abilityName} auto-fired at max charge â€” ${damageText} dmg, ${rangeText}px range.`);
      } else {
        setHudMessage(`${abilityName} fired â€” ${damageText} dmg, ${rangeText}px range.`);
      }
    }
    setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
    return true;
  }

  function cancelPiercingArrowCast(cast){
    if(!cast || cast.released) return false;
    cast.released = true;
    clearPiercingArrowCast(cast);
    const abilityName = cast.abilityName || 'Piercing Arrow';
    const cooldownSeconds = Number.isFinite(cast.cooldownSeconds) ? Math.max(0, Number(cast.cooldownSeconds) || 0) : 0;
    const fractionRaw = Number.isFinite(cast.cancelCooldownFraction) ? cast.cancelCooldownFraction : 0.5;
    const fraction = Math.max(0, Math.min(1, Number(fractionRaw) || 0));
    const cooldown = cooldownSeconds * fraction;
    setAbilitySlotCooldown(cast.slotIndex, cooldown);
    if(cast.casterRef === player){
      const refundPct = Math.round((1 - fraction) * 100);
      if(refundPct > 0){
        setHudMessage(`${abilityName} cancelled â€” ${refundPct}% cooldown refunded.`);
      } else {
        setHudMessage(`${abilityName} cancelled.`);
      }
    }
    return true;
  }

  function spawnPiercingArrowProjectile(opts){
    if(!opts) return null;
    const range = Math.max(0, Number(opts.range) || 0);
    const speed = Math.max(0, Number(opts.speed) || 0);
    if(!(range > 0) || !(speed > 0)) return null;
    let dirX = Number(opts.dirX) || 0;
    let dirY = Number(opts.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)) return null;
    dirX /= dirLen;
    dirY /= dirLen;
    const projectile = {
      abilityName: opts.abilityName || 'Piercing Arrow',
      startX: Number(opts.originX) || 0,
      startY: Number(opts.originY) || 0,
      currentX: Number(opts.originX) || 0,
      currentY: Number(opts.originY) || 0,
      dirX,
      dirY,
      speed,
      range,
      width: Math.max(0, Number(opts.width) || 0),
      damage: Math.max(0, Number(opts.damage) || 0),
      traveled: 0,
      casterRef: opts.casterRef || null,
      hitTargets: new Set(),
      announcedHit: false
    };
    piercingArrowProjectiles.push(projectile);
    return projectile;
  }

  function applyPiercingArrowHit(projectile, target){
    if(!projectile || !target) return;
    const prevHp = Number(target.hp) || 0;
    if(Number(projectile.damage) > 0){
      target.hp = Math.max(0, prevHp - projectile.damage);
      spawnHitSplat(target.x, target.y - minionRadius, projectile.damage);
    }
    flash(target.x, target.y, { startRadius: 10, endRadius: 32, color: '#cbe9ff' });
    if(!projectile.announcedHit && projectile.casterRef === player){
      const dmgValue = Math.round(Number(projectile.damage) || 0);
      if(dmgValue > 0){
        setHudMessage(`${projectile.abilityName || 'Piercing Arrow'} hit for ${dmgValue} damage!`);
      } else {
        setHudMessage(`${projectile.abilityName || 'Piercing Arrow'} hit!`);
      }
      projectile.announcedHit = true;
    }
    handlePracticeDummyDamage(target, prevHp);
  }

  function castEdgeflareMarkAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Edgeflare Mark';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 1200);
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 1700);
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 160);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'bonusDamage')) || 220);
    const markDuration = Math.max(0, Number(abilityFieldValue(ability, 'markDurationMs')) || 4000) / 1000;
    const { x: originX, y: originY } = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - originX;
    let dy = aimPoint.y - originY;
    let len = Math.hypot(dx, dy);
    if(len <= 0.0001){
      dx = player.target.x - originX;
      dy = player.target.y - originY;
      len = Math.hypot(dx, dy);
    }
    if(len <= 0.0001){
      dx = 1;
      dy = 0;
      len = 1;
    }
    dx /= len;
    dy /= len;
    const projectile = spawnEdgeFluxProjectile({
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      startX: originX,
      startY: originY,
      dirX: dx,
      dirY: dy,
      range,
      speed,
      width,
      bonusDamage: damage,
      markDuration
    });
    if(!projectile){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    flash(originX, originY, { startRadius: 8, endRadius: 32, color: '#cde5ff' });
    setHudMessage(`${abilityName} flung a tracer!`);
    return true;
  }

  function resolveFocusedLockshotTarget(maxRange){
    const rangeValue = Number(maxRange);
    const limitRange = rangeValue > 0 ? rangeValue : Infinity;
    const limitRangeSq = limitRange < Infinity ? limitRange * limitRange : Infinity;
    const isWithinRange = (target) => {
      if(!target || !Number.isFinite(target.x) || !Number.isFinite(target.y)) return false;
      if(limitRange >= Infinity) return true;
      const dx = target.x - player.x;
      const dy = target.y - player.y;
      return dx * dx + dy * dy <= limitRangeSq;
    };
    const candidates = [player.selectedTarget, player.attackTarget, player.chaseTarget];
    for(const candidate of candidates){
      if(candidate && isAutoAttackTarget(candidate) && isWithinRange(candidate)){
        return candidate;
      }
    }
    if(limitRange > 0){
      const aimPoint = beamAimPoint();
      const aimed = findNearestEnemyMinionWithinRange(aimPoint.x, aimPoint.y, limitRange);
      if(aimed) return aimed;
      if(isMonsterAttackable(monsterState)){
        const dx = aimPoint.x - monsterState.x;
        const dy = aimPoint.y - monsterState.y;
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
        if(dx * dx + dy * dy <= limitRangeSq + monsterRadius * monsterRadius){
          return monsterState;
        }
      }
    } else {
      const aimPoint = beamAimPoint();
      const aimed = findNearestEnemyMinion(aimPoint.x, aimPoint.y);
      if(aimed) return aimed;
    }
    const fallbackMinion = limitRange > 0
      ? findNearestEnemyMinionWithinRange(player.x, player.y, limitRange)
      : findNearestEnemyMinion(player.x, player.y);
    if(fallbackMinion){
      return fallbackMinion;
    }
    if(isMonsterAttackable(monsterState)){
      const dx = player.x - monsterState.x;
      const dy = player.y - monsterState.y;
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
      if(limitRange >= Infinity || dx * dx + dy * dy <= limitRangeSq + monsterRadius * monsterRadius){
        return monsterState;
      }
    }
    return null;
  }

  function castFocusedLockshotAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Focused Lockshot';
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const target = resolveFocusedLockshotTarget(projectileRange);
    if(!target){
      setHudMessage(`No enemy champion in range for ${abilityName}.`);
      return false;
    }
    const channelMs = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0);
    const channelDuration = channelMs / 1000;
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const cancelCooldownSeconds = Math.max(0, Number(abilityFieldValue(ability, 'cancelCooldownMs')) || 0) / 1000;
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      targetRef: target,
      channelElapsed: 0,
      channelDuration,
      projectileRange,
      projectileSpeed,
      projectileWidth,
      projectileDamage: damage,
      cooldownSeconds,
      cancelCooldownSeconds,
      allowMovementWhileCasting: false
    };
    focusedLockshotCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    if(channelDuration <= 0){
      releaseFocusedLockshot(cast);
      return { success: true, deferCooldown: true };
    }
    setHudMessage(`${abilityName} locking on...`);
    return { success: true, deferCooldown: true };
  }

  function completeFocusedLockshotCast(cast, { reason = 'complete', message = null } = {}){
    if(!cast){
      return false;
    }
    const idx = focusedLockshotCasts.indexOf(cast);
    if(idx >= 0){
      focusedLockshotCasts.splice(idx, 1);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const cooldown = reason === 'cancel'
      ? Math.max(0, Number(cast.cancelCooldownSeconds) || 0)
      : Math.max(0, Number(cast.cooldownSeconds) || 0);
    if(Number.isFinite(cast.slotIndex)){
      setAbilitySlotCooldown(cast.slotIndex, cooldown);
    }
    if(cast.casterRef === player && message){
      setHudMessage(message);
    }
    return true;
  }

  function releaseFocusedLockshot(cast){
    if(!cast){
      return false;
    }
    const abilityName = cast.abilityName || 'Focused Lockshot';
    const projectile = spawnFocusedLockshotProjectile(cast);
    completeFocusedLockshotCast(cast, {
      reason: 'complete',
      message: projectile ? `${abilityName} fired.` : `${abilityName} fizzled.`
    });
    return Boolean(projectile);
  }

  function cancelFocusedLockshotCast(cast, options = {}){
    if(!cast){
      return false;
    }
    const abilityName = cast.abilityName || 'Focused Lockshot';
    const message = options.message || `${abilityName} lost its lock.`;
    completeFocusedLockshotCast(cast, { reason: 'cancel', message });
    return true;
  }

  function spawnFocusedLockshotProjectile(cast){
    if(!cast){
      return null;
    }
    const range = Math.max(0, Number(cast.projectileRange) || 0);
    const speed = Math.max(0, Number(cast.projectileSpeed) || 0);
    const width = Math.max(0, Number(cast.projectileWidth) || 0);
    const damage = Math.max(0, Number(cast.projectileDamage) || 0);
    if(!(range > 0) || !(speed > 0)){
      return null;
    }
    const caster = cast.casterRef || player;
    const origin = getSpellOrigin(caster);
    const startX = Number(origin.x) || 0;
    const startY = Number(origin.y) || 0;
    let dirX = 1;
    let dirY = 0;
    const target = cast.targetRef && isAutoAttackTarget(cast.targetRef) ? cast.targetRef : null;
    if(target){
      const dx = target.x - startX;
      const dy = target.y - startY;
      const len = Math.hypot(dx, dy);
      if(len > 0.0001){
        dirX = dx / len;
        dirY = dy / len;
      }
    }
    const projectile = {
      abilityName: cast.abilityName,
      casterRef: caster,
      startX,
      startY,
      x: startX,
      y: startY,
      prevX: startX,
      prevY: startY,
      dirX,
      dirY,
      speed,
      range,
      traveled: 0,
      width,
      damage,
      targetRef: target
    };
    focusedLockshotProjectiles.push(projectile);
    flash(startX, startY, { startRadius: Math.max(6, width * 0.4), endRadius: Math.max(18, width * 0.7), color: '#ffd27a' });
    return projectile;
  }

  function applyFocusedLockshotHit(projectile, target){
    if(!projectile || !target) return;
    const prevHp = Number(target.hp) || 0;
    const damage = Math.max(0, Number(projectile.damage) || 0);
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      const targetRadius = target === monsterState
        ? Math.max(minionRadius, monsterAttackRadius(target))
        : (target.isPracticeDummy ? Math.max(minionRadius, Number(target.radius) || minionRadius) : minionRadius);
      spawnHitSplat(target.x, target.y - targetRadius, damage);
    }
    flash(target.x, target.y, { startRadius: 10, endRadius: 32, color: '#ffd27a' });
    if(projectile.casterRef === player){
      const dmgValue = Math.round(damage);
      if(dmgValue > 0){
        setHudMessage(`${projectile.abilityName || 'Lockshot'} hit for ${dmgValue} damage!`);
      } else {
        setHudMessage(`${projectile.abilityName || 'Lockshot'} hit!`);
      }
    }
    if(prevHp > 0 && target.hp <= 0 && !target.isPracticeDummy){
      addGold(goldState.perKill);
    }
    handlePracticeDummyDamage(target, prevHp);
    if(target === monsterState){
      updateMonsterHud();
    }
  }

  function castPiercingBloomAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Piercing Bloom';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a speed.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const expandedWidth = Math.max(width, Number(abilityFieldValue(ability, 'expandedWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const secondaryPct = Math.max(0, Math.min(100, Number(abilityFieldValue(ability, 'secondaryDamagePct')) || 0));
    const secondaryDamage = damage * (secondaryPct / 100);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      range,
      speed,
      width,
      expandedWidth,
      damage,
      secondaryDamage,
      secondaryDamagePct: secondaryPct,
      cooldownSeconds: abilityCooldownSeconds(ability),
      castDuration: castTime,
      elapsed: 0
    };
    if(castTime > 0){
      expandingShotCasts.push(cast);
      player.casting = cast;
      cancelPlayerAttack(false);
      player.chaseTarget = null;
      player.target.x = player.x;
      player.target.y = player.y;
      player.navGoal = null;
      player.nav = null;
      setHudMessage(`${abilityName} charging...`);
    } else {
      firePiercingBloom(cast);
    }
    return true;
  }

  function firePiercingBloom(cast){
    if(!cast) return false;
    const originX = Number(cast.startX) || 0;
    const originY = Number(cast.startY) || 0;
    const abilityName = cast.abilityName || 'Piercing Bloom';
    const projectile = spawnPiercingBloomProjectile({
      abilityName,
      originX,
      originY,
      dirX: cast.dirX,
      dirY: cast.dirY,
      range: cast.range,
      speed: cast.speed,
      width: cast.width,
      expandedWidth: cast.expandedWidth,
      damage: cast.damage,
      secondaryDamage: cast.secondaryDamage,
      casterRef: cast.casterRef || player
    });
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(!projectile){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }
    setHudMessage(`${abilityName} fired.`);
    return true;
  }

  function spawnPiercingBloomProjectile(opts){
    if(!opts) return null;
    const range = Math.max(0, Number(opts.range) || 0);
    const speed = Math.max(0, Number(opts.speed) || 0);
    if(!(range > 0) || !(speed > 0)) return null;
    let dirX = Number(opts.dirX) || 0;
    let dirY = Number(opts.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)) return null;
    dirX /= dirLen;
    dirY /= dirLen;
    const width = Math.max(0, Number(opts.width) || 0);
    const expandedWidth = Math.max(width, Number(opts.expandedWidth) || 0);
    const projectile = {
      abilityName: opts.abilityName || 'Piercing Bloom',
      slotIndex: opts.slotIndex || null,
      startX: Number(opts.originX) || 0,
      startY: Number(opts.originY) || 0,
      currentX: Number(opts.originX) || 0,
      currentY: Number(opts.originY) || 0,
      dirX,
      dirY,
      range,
      speed,
      width,
      expandedWidth,
      primaryDamage: Math.max(0, Number(opts.damage) || 0),
      secondaryDamage: Math.max(0, Number(opts.secondaryDamage) || 0),
      casterRef: opts.casterRef || null,
      traveled: 0,
      hitTargets: new Set(),
      primaryHit: false,
      announcedHit: false
    };
    expandingShotProjectiles.push(projectile);
    return projectile;
  }

  function applyPiercingBloomHit(projectile, target, damage){
    if(!projectile || !target) return;
    const prevHp = Number(target.hp) || 0;
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(target.x, target.y - minionRadius, damage);
    }
    flash(target.x, target.y, { startRadius: 10, endRadius: 34, color: '#ffd27a' });
    if(!projectile.announcedHit && projectile.casterRef === player){
      const damageText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      setHudMessage(`${projectile.abilityName || 'Piercing Bloom'} hit${damageText}!`);
      projectile.announcedHit = true;
    }
    handlePracticeDummyDamage(target, prevHp);
  }

  function castGaleThrustAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Gale Thrust';
    const range = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    if(!(range > 0)){
      setHudMessage(`${abilityName} needs a range.`);
      return false;
    }
    const speed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    if(!(speed > 0)){
      setHudMessage(`${abilityName} needs a speed.`);
      return false;
    }
    const width = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    if(!(width > 0)){
      setHudMessage(`${abilityName} needs a width.`);
      return false;
    }
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const stackDuration = Math.max(0, Number(abilityFieldValue(ability, 'stackDurationMs')) || 0) / 1000;
    const empoweredRadius = Math.max(0, Number(abilityFieldValue(ability, 'empoweredRadiusPx')) || 0);
    const empoweredDamage = Math.max(0, Number(abilityFieldValue(ability, 'empoweredDamage')) || 0);
    const empoweredKnockup = Math.max(0, Number(abilityFieldValue(ability, 'empoweredKnockupMs')) || 0) / 1000;
    const empowered = abilityRuntime.galeThrustStacks >= GALE_THRUST_MAX_STACKS;

    const origin = getSpellOrigin(player);
    const aimPoint = beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      lockedDirX: dirX,
      lockedDirY: dirY,
      range,
      speed,
      width,
      damage,
      stackDuration,
      empoweredRadius,
      empoweredDamage,
      empoweredKnockup,
      empowered,
      castDuration,
      elapsed: 0
    };

    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(castDuration > 0){
      galeThrustCasts.push(cast);
      player.casting = cast;
      setHudMessage(`${abilityName} gathering wind...`);
    } else {
      launchGaleThrustCast(cast);
    }
    return true;
  }

  function launchGaleThrustCast(cast){
    if(!cast) return false;
    let result = false;
    if(cast.empowered){
      result = releaseGaleThrustWhirlwind(cast);
    } else {
      result = spawnGaleThrustLaser(cast);
    }
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    return result;
  }

  function spawnGaleThrustLaser(cast){
    if(!cast) return false;
    const origin = resolveCastOrigin(cast);
    let dirX = Number(cast.lockedDirX || cast.dirX) || 0;
    let dirY = Number(cast.lockedDirY || cast.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY);
    if(dirLen <= 0.0001){
      dirX = 1;
      dirY = 0;
    } else {
      dirX /= dirLen;
      dirY /= dirLen;
    }

    const range = Math.max(0, Number(cast.range) || 0);
    const speed = Math.max(0, Number(cast.speed) || 0);
    if(!(range > 0) || !(speed > 0)){
      setHudMessage(`${cast.abilityName || 'Gale Thrust'} fizzled.`);
      return false;
    }
    const width = Math.max(0, Number(cast.width) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);

    const laser = {
      abilityName: cast.abilityName,
      slotIndex: cast.slotIndex,
      abilityId: cast.abilityId,
      startX: origin.x,
      startY: origin.y,
      dirX,
      dirY,
      speed,
      maxDistance: range,
      traveled: 0,
      width,
      damage,
      casterRef: cast.casterRef || player,
      currentX: origin.x,
      currentY: origin.y,
      galeThrustStackDuration: Math.max(0, Number(cast.stackDuration) || 0)
    };
    laserProjectiles.push(laser);
    flash(origin.x, origin.y, { startRadius: 12, endRadius: Math.max(width, 48), color: '#9ce7ff' });
    if(cast.casterRef === player){
      setHudMessage(`${cast.abilityName || 'Gale Thrust'} surges forward!`);
    }
    return true;
  }

  function releaseGaleThrustWhirlwind(cast){
    if(!cast) return false;
    const abilityName = cast.abilityName || 'Gale Thrust';
    const origin = resolveCastOrigin(cast);
    const radius = Math.max(0, Number(cast.empoweredRadius) || 0);
    if(!(radius > 0)){
      setHudMessage(`${abilityName} fizzled.`);
      return false;
    }
    const damage = Math.max(0, Number(cast.empoweredDamage) || 0);
    const knockup = Math.max(0, Number(cast.empoweredKnockup) || 0);
    const radiusSq = radius * radius;
    let hits = 0;

    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m) || m.hp <= 0) continue;
      const dx = m.x - origin.x;
      const dy = m.y - origin.y;
      if(dx * dx + dy * dy > radiusSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      if(knockup > 0){
        m.knockupTimer = Math.max(m.knockupTimer || 0, knockup);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }

    if(isMonsterAttackable(monsterState)){
      const dx = monsterState.x - origin.x;
      const dy = monsterState.y - origin.y;
      if(dx * dx + dy * dy <= radiusSq){
        const prevHp = Number(monsterState.hp) || 0;
        if(damage > 0){
          monsterState.hp = Math.max(0, prevHp - damage);
          const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
          spawnHitSplat(monsterState.x, monsterState.y - monsterRadius, damage);
          updateMonsterHud();
        }
        if(knockup > 0){
          monsterState.knockupTimer = Math.max(monsterState.knockupTimer || 0, knockup);
        }
        hits++;
      }
    }

    flash(origin.x, origin.y, { startRadius: 16, endRadius: radius + 32, color: '#89e1ff' });
    if(hits > 0){
      setHudMessage(`${abilityName} whipped ${hits} foe${hits === 1 ? '' : 's'} upward!`);
    } else {
      setHudMessage(`${abilityName} whirled but struck nothing.`);
    }
    abilityRuntime.galeThrustStacks = 0;
    abilityRuntime.galeThrustStackTimer = 0;
    return hits > 0;
  }

  function grantGaleThrustStack(duration){
    if(!(duration > 0)){
      return false;
    }
    const prevStacks = Math.max(0, Math.floor(Number(abilityRuntime.galeThrustStacks) || 0));
    if(prevStacks >= GALE_THRUST_MAX_STACKS){
      abilityRuntime.galeThrustStackTimer = Math.max(abilityRuntime.galeThrustStackTimer || 0, duration);
      return false;
    }
    const nextStacks = Math.min(GALE_THRUST_MAX_STACKS, prevStacks + 1);
    abilityRuntime.galeThrustStacks = nextStacks;
    abilityRuntime.galeThrustStackTimer = duration;
    const abilityRef = abilityDefinitions.gale_thrust;
    const abilityName = abilityRef && (abilityRef.shortName || abilityRef.name)
      ? (abilityRef.shortName || abilityRef.name)
      : 'Gale Thrust';
    if(nextStacks >= GALE_THRUST_MAX_STACKS){
      setHudMessage(`${abilityName} is empowered!`);
    } else {
      setHudMessage(`${abilityName} stacked (${nextStacks}/${GALE_THRUST_MAX_STACKS}).`);
    }
    return true;
  }

  function cancelActivePiercingArrowCharge(){
    for(let i = piercingArrowCasts.length - 1; i >= 0; i--){
      const cast = piercingArrowCasts[i];
      if(!cast || cast.released) continue;
      if(cast.casterRef !== player) continue;
      if(!cast.canCancel) continue;
      cancelPiercingArrowCast(cast);
      return true;
    }
    return false;
  }

  function resolveLaserConeCastGeometry(cast){
    if(!cast) return null;
    const caster = cast.casterRef;
    let { x: startX, y: startY } = resolveCastOrigin(cast);
    let dirX = Number(cast.lockedDirX);
    let dirY = Number(cast.lockedDirY);
    let dirLen = Math.hypot(dirX, dirY);
    if(!(dirLen > 0.0001)){
      const targetX = Number.isFinite(cast.targetX) ? cast.targetX : (startX + 1);
      const targetY = Number.isFinite(cast.targetY) ? cast.targetY : startY;
      dirX = targetX - startX;
      dirY = targetY - startY;
      dirLen = Math.hypot(dirX, dirY);
    }
    if(!(dirLen > 0.0001)){
      dirX = 1;
      dirY = 0;
      dirLen = 1;
    }
    const normX = dirX / dirLen;
    const normY = dirY / dirLen;
    const distance = Math.max(1, Number(cast.distance) || 0);
    const coneWidth = Math.max(0, Number(cast.coneWidth) || 0);
    const count = Math.max(0, Math.floor(Number(cast.count) || 0));
    const projectileWidth = Math.max(0, Number(cast.projectileWidth) || 0);
    const spacing = count > 1 ? coneWidth / (count - 1) : 0;
    const fallbackThickness = coneWidth > 0 ? spacing * 0.6 : distance * 0.04;
    const thicknessBase = projectileWidth > 0 ? projectileWidth : (fallbackThickness || 16);
    const thickness = Math.max(1, Math.min(1000, thicknessBase));

    cast.startX = startX;
    cast.startY = startY;

    return {
      startX,
      startY,
      dirX: normX,
      dirY: normY,
      distance,
      coneWidth,
      count,
      spacing,
      thickness
    };
  }

  function fireLaserConeCast(cast){
    const geom = resolveLaserConeCastGeometry(cast);
    if(!geom || geom.count <= 0){
      setHudMessage('Laser Cone has no lasers configured.');
      if(cast && cast.casterRef === player && player.casting === cast){
        player.casting = null;
      }
      return false;
    }
    const speed = Math.max(1, Number(cast.speed) || 0);
    const totalDamage = Math.max(0, Number(cast.damage) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(cast.slowFraction) || 0));
    const slowDurationSeconds = Math.max(0, Number(cast.slowDuration) || 0);
    const abilityName = cast && cast.abilityName ? cast.abilityName : 'Laser Cone';
    const perpX = -geom.dirY;
    const perpY = geom.dirX;
    let lasersSpawned = 0;
    for(let i=0;i<geom.count;i++){
      const fraction = geom.count > 1 ? (i / (geom.count - 1)) : 0.5;
      const offsetFromCenter = (fraction - 0.5) * geom.coneWidth;
      const targetX = geom.startX + geom.dirX * geom.distance + perpX * offsetFromCenter;
      const targetY = geom.startY + geom.dirY * geom.distance + perpY * offsetFromCenter;
      let tx = targetX - geom.startX;
      let ty = targetY - geom.startY;
      let len = Math.hypot(tx, ty);
      if(!(len > 0.0001)){
        tx = geom.dirX;
        ty = geom.dirY;
        len = 1;
      }
      const dirX = tx / len;
      const dirY = ty / len;
      const maxDistance = Math.max(1, len);
      laserProjectiles.push({
        startX: geom.startX,
        startY: geom.startY,
        dirX,
        dirY,
        speed,
        maxDistance,
        traveled: 0,
        width: geom.thickness,
        damage: totalDamage,
        slowFraction,
        slowDuration: slowDurationSeconds,
        slowMinDistance: cast ? cast.slowMinDistance : null,
        casterRef: cast ? cast.casterRef : null,
        abilityName,
        currentX: geom.startX,
        currentY: geom.startY
      });
      lasersSpawned++;
    }
    if(lasersSpawned <= 0){
      setHudMessage('Laser Cone fizzled.');
      if(cast && cast.casterRef === player && player.casting === cast){
        player.casting = null;
      }
      return false;
    }
    cancelPlayerAttack(false);
    flash(geom.startX, geom.startY, { startRadius: 10, endRadius: 42, color: '#7fe3ff' });
    setHudMessage(`${abilityName} fired!`);
    if(cast && cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    return true;
  }

  function fireDuskwaveWave(cast){
    if(!cast || cast.waveFired) return;
    const range = Math.max(1, Number(cast.range) || 0);
    const widthHalf = Math.max(0, Number(cast.width) || 0) * 0.5;
    const perpX = -cast.dirY;
    const perpY = cast.dirX;
    const waveDamage = Math.max(0, Number(cast.waveDamage) || 0);
    const locked = [];
    const seen = new Set();

    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const relX = m.x - cast.startX;
      const relY = m.y - cast.startY;
      const along = relX * cast.dirX + relY * cast.dirY;
      if(along < -minionRadius || along > range + minionRadius) continue;
      const lateral = Math.abs(relX * perpX + relY * perpY);
      if(lateral > widthHalf + minionRadius) continue;
      if(seen.has(m)) continue;
      seen.add(m);
      const prevHp = Number(m.hp) || 0;
      if(waveDamage > 0){
        m.hp = Math.max(0, prevHp - waveDamage);
        spawnHitSplat(m.x, m.y - minionRadius, waveDamage);
        handlePracticeDummyDamage(m, prevHp);
      }
      locked.push({ targetRef: m, lastX: m.x, lastY: m.y });
    }

    if(!locked.length){
      locked.push({
        targetRef: null,
        lastX: cast.startX + cast.dirX * range,
        lastY: cast.startY + cast.dirY * range
      });
    }

    cast.lockedTargets = locked;
    cast.waveFired = true;
    cast.delayElapsed = 0;
    const flashDistance = Math.max(40, range * 0.5);
    flash(cast.startX + cast.dirX * flashDistance, cast.startY + cast.dirY * flashDistance, {
      startRadius: Math.max(widthHalf, 14),
      endRadius: Math.max(flashDistance, range * 0.6),
      color: '#ff6b2a'
    });

    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
      setHudMessage(`${cast.abilityName || 'Duskwave'} pulse released!`);
    }
  }

  function spawnDuskwaveVolleys(cast){
    if(!cast || !Array.isArray(cast.lockedTargets)) return;
    const abilityName = cast.abilityName || 'Duskwave';
    const speed = Math.max(0, Number(cast.volleySpeed) || 0) || 900;
    const baseRange = Math.max(0, Number(cast.range) || 0);
    const diag = Math.hypot(mapState.width, mapState.height);
    const maxDistance = Math.max(baseRange * 1.2, diag, 900);
    const width = Math.max(8, (Number(cast.width) || 0) * 0.25, 12);
    const secondaryDamage = cast.secondaryFraction ? (cast.volleyDamage * cast.secondaryFraction) : 0;
    const entries = cast.lockedTargets.length ? cast.lockedTargets : [{
      targetRef: null,
      lastX: cast.startX + cast.dirX * baseRange,
      lastY: cast.startY + cast.dirY * baseRange
    }];

    for(const entry of entries){
      const target = entry.targetRef && entry.targetRef.hp > 0 ? entry.targetRef : null;
      const destX = target ? target.x : (Number(entry.lastX) || (cast.startX + cast.dirX * baseRange));
      const destY = target ? target.y : (Number(entry.lastY) || (cast.startY + cast.dirY * baseRange));
      let dx = destX - cast.startX;
      let dy = destY - cast.startY;
      let dist = Math.hypot(dx, dy);
      if(!(dist > 0.0001)){
        dx = cast.dirX;
        dy = cast.dirY;
        dist = 1;
      }
      const dirX = dx / dist;
      const dirY = dy / dist;
      duskwaveVolleys.push({
        abilityName,
        casterRef: cast.casterRef || null,
        startX: cast.startX,
        startY: cast.startY,
        x: cast.startX,
        y: cast.startY,
        prevX: cast.startX,
        prevY: cast.startY,
        dirX,
        dirY,
        speed,
        range: Math.max(maxDistance, dist * 1.5),
        traveled: 0,
        width,
        primaryDamage: cast.volleyDamage,
        secondaryDamage,
        targetRef: target,
        hitTargets: new Set(),
        primaryHitDone: false,
        color: '#ff9a41',
        trailColor: '#ffd089'
      });
    }
  }

  function applyDuskwaveVolleyDamage(volley, target, damage, primaryHit){
    if(!volley || !target || damage <= 0) return;
    if(volley.hitTargets.has(target)) return;
    volley.hitTargets.add(target);
    const prevHp = Number(target.hp) || 0;
    target.hp = Math.max(0, prevHp - damage);
    spawnHitSplat(target.x, target.y - minionRadius, damage);
    handlePracticeDummyDamage(target, prevHp);
    flash(target.x, target.y, { startRadius: 6, endRadius: 26, color: '#ff9a41' });
    if(primaryHit && volley.casterRef === player && !volley.primaryMessageSent){
      volley.primaryMessageSent = true;
      setHudMessage(`${volley.abilityName || 'Duskwave'} bolts strike!`);
    }
  }

  function applyGraviticSlow(target, strongPct, strongDuration, weakPct, weakDuration){
    if(!target || target.hp <= 0) return;
    const normalizedStrong = Math.max(0, Math.min(1, strongPct || 0));
    const normalizedWeak = Math.max(0, Math.min(1, weakPct || 0));
    const strongTime = Math.max(0, strongDuration || 0);
    const weakTime = Math.max(0, weakDuration || 0);
    if(normalizedStrong <= 0 || strongTime <= 0){
      return;
    }
    const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
    target.slowPct = Math.max(existingSlow, normalizedStrong);
    target.slowTimer = Math.max(target.slowTimer || 0, strongTime);
    for(let i = graviticSlowDecays.length - 1; i >= 0; i--){
      const existing = graviticSlowDecays[i];
      if(existing && existing.target === target){
        graviticSlowDecays.splice(i, 1);
      }
    }
    if(weakTime > 0 && normalizedWeak > 0){
      graviticSlowDecays.push({
        target,
        strongDuration: strongTime,
        weakDuration: weakTime,
        weakPct: normalizedWeak,
        state: 'strong',
        timer: strongTime
      });
    }
  }

  function launchGravityProjectile(cast){
    if(!cast || !cast.data) return false;
    const data = cast.data;
    const strongDurationBase = Math.max(0, Number(data.slowDuration) || 0);
    const decayDelay = Math.max(0, Number(data.decayDelay) || 0);
    const strongSlowDuration = decayDelay > 0 ? Math.min(decayDelay, strongDurationBase) : strongDurationBase;
    const weakSlowDuration = Math.max(0, Number(data.weakSlowDuration) || 0);
    const projectile = {
      startX: data.startX,
      startY: data.startY,
      dirX: data.dirX,
      dirY: data.dirY,
      speed: data.speed,
      maxDistance: data.maxDistance,
      traveled: 0,
      width: data.width,
      damage: data.damage,
      slowPct: data.slowPct,
      strongSlowDuration,
      weakSlowPct: data.weakSlowPct,
      weakSlowDuration,
      rootDuration: data.rootDuration,
      hitTargets: new Set(),
      abilityName: cast.abilityName
    };
    gravityProjectiles.push(projectile);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    flash(projectile.startX, projectile.startY, { startRadius: 12, endRadius: Math.max(32, projectile.width || 32), color: '#91f0ff' });
    setHudMessage(`${cast.abilityName || 'Gravity Surge'} launched!`);
    return true;
  }

  function castGravitySurgeAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Gravitic Surge';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castTime = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const projectileSpeed = Math.max(0, Number(abilityFieldValue(ability, 'projectileSpeedPxS')) || 0);
    const projectileRange = Math.max(0, Number(abilityFieldValue(ability, 'projectileRangePx')) || 0);
    const projectileWidth = Math.max(0, Number(abilityFieldValue(ability, 'projectileWidthPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const slowPct = Math.max(0, (Number(abilityFieldValue(ability, 'slowPct')) || 0) / 100);
    const slowDuration = Math.max(0, Number(abilityFieldValue(ability, 'slowDurationMs')) || 0) / 1000;
    const decayDelay = Math.max(0, Number(abilityFieldValue(ability, 'slowDecayDelayMs')) || 0) / 1000;
    const weakSlowPct = Math.max(0, (Number(abilityFieldValue(ability, 'weakSlowPct')) || 0) / 100);
    const weakSlowDuration = Math.max(0, Number(abilityFieldValue(ability, 'weakSlowDurationMs')) || 0) / 1000;
    const rootDuration = Math.max(0, Number(abilityFieldValue(ability, 'rootDurationMs')) || 0) / 1000;
    if(!(projectileSpeed > 0) || !(projectileRange > 0)){
      setHudMessage(`${abilityName} needs a projectile configured.`);
      return false;
    }
    const origin = getSpellOrigin(player);
    const aim = beamAimPoint();
    let dx = aim.x - origin.x;
    let dy = aim.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    const dirX = dx / distance;
    const dirY = dy / distance;
    const cast = {
      slotIndex,
      abilityId: ability && ability.id ? ability.id : 'gravity_surge',
      abilityName,
      casterRef: player,
      castDuration: castTime,
      elapsed: 0,
      cooldownSeconds,
      data: {
        startX: origin.x,
        startY: origin.y,
        dirX,
        dirY,
        speed: projectileSpeed,
        maxDistance: projectileRange,
        width: projectileWidth,
        damage,
        slowPct,
        slowDuration,
        decayDelay,
        weakSlowPct,
        weakSlowDuration,
        rootDuration
      }
    };
    if(castTime <= 0){
      return launchGravityProjectile(cast);
    }
    graviticCasts.push(cast);
    player.casting = cast;
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setHudMessage(`${abilityName} readying...`);
    return true;
  }

  function updateGraviticCasts(dt){
    if(!graviticCasts.length) return;
    for(let i = graviticCasts.length - 1; i >= 0; i--){
      const cast = graviticCasts[i];
      if(!cast){
        graviticCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(caster && Number(caster.hp) <= 0){
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
        graviticCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchGravityProjectile(cast);
        graviticCasts.splice(i, 1);
      }
    }
  }

  function updateGravityProjectiles(dt){
    for(let i = gravityProjectiles.length - 1; i >= 0; i--){
      const proj = gravityProjectiles[i];
      if(!proj){
        gravityProjectiles.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(proj.speed) || 0);
      const maxDistance = Math.max(0, Number(proj.maxDistance) || 0);
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      let nextTraveled = prevTraveled + speed * dt;
      if(speed <= 0){
        nextTraveled = maxDistance;
      }
      const clamped = maxDistance > 0 ? Math.min(nextTraveled, maxDistance) : nextTraveled;
      const halfWidth = Math.max(0, (Number(proj.width) || 0) / 2);
      const effectiveRadius = halfWidth + minionRadius;
      const effectiveRadiusSq = effectiveRadius * effectiveRadius;
      const hitTargets = proj.hitTargets || new Set();
      let hitAny = false;
      for(const m of minions){
        if(!m || !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        if(hitTargets.has(m)) continue;
        const relX = m.x - proj.startX;
        const relY = m.y - proj.startY;
        const along = relX * proj.dirX + relY * proj.dirY;
        if(along < prevTraveled || along > clamped) continue;
        const closestX = proj.startX + proj.dirX * along;
        const closestY = proj.startY + proj.dirY * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        const distSq = offX * offX + offY * offY;
        if(distSq <= effectiveRadiusSq){
          const preHp = Math.max(0, Number(m.hp) || 0);
          if(proj.damage > 0){
            m.hp = Math.max(0, preHp - proj.damage);
            spawnHitSplat(m.x, m.y - minionRadius, proj.damage);
          }
          if(Number(proj.slowPct) > 0){
            applyGraviticSlow(m, proj.slowPct, proj.strongSlowDuration, proj.weakSlowPct, proj.weakSlowDuration);
          }
          if(proj.rootDuration > 0){
            m.stunTimer = Math.max(m.stunTimer || 0, proj.rootDuration);
          }
          if(preHp > 0 && m.hp <= 0){
            flash(m.x, m.y, { color: '#ff8a8a' });
          }
          handlePracticeDummyDamage(m, preHp);
          hitTargets.add(m);
          hitAny = true;
        }
      }
      const monster = monsterState;
      if(monster && isMonsterAttackable(monster) && !hitTargets.has(monster)){
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
        const effective = halfWidth + monsterRadius;
        const effectiveSq = effective * effective;
        const relX = monster.x - proj.startX;
        const relY = monster.y - proj.startY;
        const along = relX * proj.dirX + relY * proj.dirY;
        if(along >= prevTraveled && (maxDistance <= 0 || along <= clamped)){
          const closestX = proj.startX + proj.dirX * along;
          const closestY = proj.startY + proj.dirY * along;
          const offX = monster.x - closestX;
          const offY = monster.y - closestY;
          const distSq = offX * offX + offY * offY;
          if(distSq <= effectiveSq){
            const preHp = Math.max(0, Number(monster.hp) || 0);
            if(proj.damage > 0){
              monster.hp = Math.max(0, preHp - proj.damage);
              spawnHitSplat(monster.x, monster.y - monsterRadius, proj.damage);
              updateMonsterHud();
            }
            if(Number(proj.slowPct) > 0){
              applyGraviticSlow(monster, proj.slowPct, proj.strongSlowDuration, proj.weakSlowPct, proj.weakSlowDuration);
            }
            if(proj.rootDuration > 0){
              monster.stunTimer = Math.max(monster.stunTimer || 0, proj.rootDuration);
            }
            hitTargets.add(monster);
            if(preHp > 0 && monster.hp <= 0){
              flash(monster.x, monster.y, { color: '#ff8a8a' });
            }
            hitAny = true;
          }
        }
      }
      proj.traveled = clamped;
      if(maxDistance > 0 && clamped >= maxDistance - 0.001){
        gravityProjectiles.splice(i, 1);
        continue;
      }
    }
  }

  function updateGraviticSlowDecays(dt){
    if(!graviticSlowDecays.length) return;
    for(let i = graviticSlowDecays.length - 1; i >= 0; i--){
      const entry = graviticSlowDecays[i];
      if(!entry || !entry.target){
        graviticSlowDecays.splice(i, 1);
        continue;
      }
      const target = entry.target;
      if(target.hp <= 0 && !target.isPracticeDummy){
        graviticSlowDecays.splice(i, 1);
        continue;
      }
      entry.timer = Math.max(0, (entry.timer || 0) - dt);
      if(entry.state === 'strong'){
        if(entry.timer <= 0){
          entry.state = 'weak';
          entry.timer = Math.max(0, entry.weakDuration);
          if(entry.weakDuration > 0 && entry.weakPct > 0){
            const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
            target.slowPct = Math.max(existingSlow, entry.weakPct);
            target.slowTimer = Math.max(target.slowTimer || 0, entry.weakDuration);
          }
          if(entry.timer <= 0){
            graviticSlowDecays.splice(i, 1);
          }
        }
      } else if(entry.state === 'weak'){
        if(entry.timer <= 0){
          graviticSlowDecays.splice(i, 1);
        }
      }
    }
  }

  function drawGravityProjectiles(){
    if(!gravityProjectiles.length) return;
    ctx.save();
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#a1f0ff';
    ctx.lineWidth = 3;
    for(const proj of gravityProjectiles){
      if(!proj) continue;
      const endX = proj.startX + proj.dirX * (proj.traveled || 0);
      const endY = proj.startY + proj.dirY * (proj.traveled || 0);
      ctx.beginPath();
      ctx.moveTo(proj.startX, proj.startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(endX, endY, Math.max(4, (proj.width || 8) / 2), 0, Math.PI * 2);
      ctx.fillStyle = '#8ad6ff';
      ctx.fill();
    }
    ctx.restore();
  }

  function drawAstralSnareCasts(){
    if(!astralSnareCasts.length) return;
    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#a1d5ff';
    ctx.fillStyle = '#e6f3ff';
    for(const cast of astralSnareCasts){
      if(!cast) continue;
      const startX = Number(cast.startX) || 0;
      const startY = Number(cast.startY) || 0;
      const dirX = Number(cast.dirX) || 0;
      const dirY = Number(cast.dirY) || 0;
      let endX = startX;
      let endY = startY;
      if(cast.state === 'primary'){
        const dist = Math.max(0, Number(cast.traveled) || 0);
        endX = startX + dirX * dist;
        endY = startY + dirY * dist;
      } else if(cast.state === 'after'){
        const trailX = Number(cast.trailStartX) || startX;
        const trailY = Number(cast.trailStartY) || startY;
        const dist = Math.max(0, Number(cast.trailTraveled) || 0);
        ctx.beginPath();
        ctx.moveTo(trailX, trailY);
        ctx.lineTo(trailX + dirX * dist, trailY + dirY * dist);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(trailX + dirX * dist, trailY + dirY * dist, 5, 0, Math.PI * 2);
        ctx.fill();
        continue;
      } else {
        continue;
      }
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(endX, endY, 6, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function grabWidthAt(cast, distance){
    if(!cast) return 0;
    const start = Number(cast.widthStart) || 0;
    const rawEnd = Number(cast.widthEnd);
    const end = Number.isFinite(rawEnd) ? rawEnd : start;
    if(!(cast.range > 0)) return Math.max(0, start);
    const t = Math.max(0, Math.min(1, distance / cast.range));
    return Math.max(0, start + (end - start) * t);
  }

  function findGrabHitCandidate(cast, prevDistance, nextDistance){
    if(!cast) return null;
    const dirX = Number(cast.dirX) || 0;
    const dirY = Number(cast.dirY) || 0;
    const maxDistance = Math.max(0, Number(cast.range) || 0);
    let best = null;
    let bestAlong = Infinity;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.portalizing > 0 || m.hp <= 0) continue;
      const relX = m.x - cast.startX;
      const relY = m.y - cast.startY;
      const along = relX * dirX + relY * dirY;
      if(!(along >= 0)) continue;
      if(along > maxDistance) continue;
      if(along < prevDistance - minionRadius) continue;
      if(along > nextDistance + minionRadius) continue;
      const closestX = cast.startX + dirX * along;
      const closestY = cast.startY + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      const width = grabWidthAt(cast, along);
      const effectiveRadius = width * 0.5 + minionRadius;
      if(offX * offX + offY * offY <= effectiveRadius * effectiveRadius){
        if(along < bestAlong){
          bestAlong = along;
          best = { target: m, along, hitX: closestX, hitY: closestY };
        }
      }
    }
    return best;
  }

  function releaseGrabbedTarget(cast){
    if(!cast) return;
    const target = cast.targetRef;
    if(target && target.beingPulledBy === cast){
      target.beingPulledBy = null;
    }
    cast.targetRef = null;
  }

  function concludeGrabCast(cast, index){
    releaseGrabbedTarget(cast);
    if(cast && cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(index)){
      grabCasts.splice(index, 1);
    }
  }

  function updateGrabCasts(dt){
    for(let i = grabCasts.length - 1; i >= 0; i--){
      const cast = grabCasts[i];
      if(!cast){
        grabCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const state = cast.state || 'flying';
      if(state === 'channel'){
        const duration = Math.max(0, Number(cast.channelDuration) || 0);
        cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
        if(cast.elapsed >= duration){
          cast.elapsed = 0;
          if(caster){
            const casterOrigin = getSpellOrigin(caster);
            if(Number.isFinite(casterOrigin.x)) cast.startX = casterOrigin.x;
            if(Number.isFinite(casterOrigin.y)) cast.startY = casterOrigin.y;
          } else {
            const fallback = getSpellOrigin(player);
            cast.startX = fallback.x;
            cast.startY = fallback.y;
          }
          cast.casterOriginX = cast.startX;
          cast.casterOriginY = cast.startY;
          cast.hitPointX = cast.startX;
          cast.hitPointY = cast.startY;
          cast.distanceTraveled = 0;
          cast.state = 'flying';
          if(!cast.launchAnnounced && caster === player){
            setHudMessage(`${cast.abilityName || 'Grab'} launched!`);
          }
          cast.launchAnnounced = true;
        }
        continue;
      }

      if(state === 'flying'){
        const prevDistance = Number(cast.distanceTraveled) || 0;
        const speed = Math.max(0, Number(cast.speed) || 0);
        const maxDistance = Math.max(0, Number(cast.range) || 0);
        const nextDistance = Math.min(maxDistance, prevDistance + speed * dt);
        cast.distanceTraveled = nextDistance;
        cast.hitPointX = cast.startX + cast.dirX * nextDistance;
        cast.hitPointY = cast.startY + cast.dirY * nextDistance;
        const hit = findGrabHitCandidate(cast, prevDistance, nextDistance);
        if(hit){
          cast.distanceTraveled = Math.min(hit.along, maxDistance);
          cast.hitPointX = hit.hitX;
          cast.hitPointY = hit.hitY;
          const target = hit.target;
          let targetAlive = !!target;
          if(target){
            const preHp = Number(target.hp) || 0;
            if(cast.damage > 0){
              target.hp = Math.max(0, preHp - cast.damage);
              spawnHitSplat(target.x, target.y - minionRadius, cast.damage);
            }
            targetAlive = target.hp > 0;
            if(preHp > 0 && target.hp <= 0){
              flash(target.x, target.y, { color: '#ff8a8a' });
            }
            handlePracticeDummyDamage(target, preHp);
          }
          flash(cast.hitPointX, cast.hitPointY, { color: '#9ce7ff' });
          if(target && targetAlive){
            cast.targetRef = target;
            target.beingPulledBy = cast;
            cast.casterOriginX = Number.isFinite(cast.casterOriginX) ? cast.casterOriginX : cast.startX;
            cast.casterOriginY = Number.isFinite(cast.casterOriginY) ? cast.casterOriginY : cast.startY;
            if(cast.slowAfterHitFraction > 0 && cast.slowAfterHitDuration > 0){
              const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
              target.slowPct = Math.max(existingSlow, cast.slowAfterHitFraction);
              target.slowTimer = Math.max(target.slowTimer || 0, cast.slowAfterHitDuration);
            }
            const baseStun = Math.max(0, cast.stunDuration || 0);
            if(cast.pullCaster){
              const startX = caster ? caster.x : cast.casterOriginX;
              const startY = caster ? caster.y : cast.casterOriginY;
              const casterRadius = caster && Number.isFinite(caster.r) ? caster.r : minionRadius;
              const dxTarget = target.x - startX;
              const dyTarget = target.y - startY;
              const distanceToTarget = Math.hypot(dxTarget, dyTarget) || 1;
              const dirToTargetX = dxTarget / distanceToTarget;
              const dirToTargetY = dyTarget / distanceToTarget;
              const landingGapBase = cast.landingOffset > 0 ? cast.landingOffset : (casterRadius + minionRadius * 0.5);
              const landingGap = Math.min(distanceToTarget * 0.8, Math.max(0, landingGapBase));
              const destX = target.x - dirToTargetX * landingGap;
              const destY = target.y - dirToTargetY * landingGap;
              cast.pullStartX = startX;
              cast.pullStartY = startY;
              const clampedDestX = Math.max(casterRadius, Math.min(mapState.width - casterRadius, destX));
              const clampedDestY = Math.max(casterRadius, Math.min(mapState.height - casterRadius, destY));
              cast.pullDestX = clampedDestX;
              cast.pullDestY = clampedDestY;
              const distanceToDest = Math.hypot(clampedDestX - startX, clampedDestY - startY);
              const pullSpeed = Math.max(240, (cast.dashSpeed > 0 ? cast.dashSpeed : speed * 0.9));
              cast.pullDuration = pullSpeed > 0 ? Math.min(0.9, Math.max(0.12, distanceToDest / pullSpeed)) : 0.2;
              cast.pullElapsed = 0;
              cast.pullStuckTime = 0;
              const totalStun = Math.max(baseStun, cast.pullDuration || 0);
              if(totalStun > 0){
                target.stunTimer = Math.max(target.stunTimer || 0, totalStun);
              }
            } else {
              const pullDistance = Math.max(0, Number(cast.pullDistance) || 0);
              cast.pullStartX = target.x;
              cast.pullStartY = target.y;
              cast.pullDestX = cast.casterOriginX + cast.dirX * pullDistance;
              cast.pullDestY = cast.casterOriginY + cast.dirY * pullDistance;
              const distanceToDest = Math.hypot(cast.pullDestX - target.x, cast.pullDestY - target.y);
              const pullSpeed = Math.max(240, speed * 0.6);
              cast.pullDuration = pullSpeed > 0 ? Math.min(0.9, Math.max(0.12, distanceToDest / pullSpeed)) : 0.2;
              cast.pullElapsed = 0;
              cast.pullStuckTime = 0;
              const totalStun = Math.max(baseStun, cast.pullDuration || 0);
              if(totalStun > 0){
                target.stunTimer = Math.max(target.stunTimer || 0, totalStun);
              }
            }
            cast.state = 'pulling';
            cast.lockoutRemaining = cast.postHitLockout;
            if(caster === player){
              player.selectedTarget = target;
              setHudMessage(`${cast.abilityName || 'Grab'} connected!`);
            }
          } else {
            cast.state = 'recover';
            cast.lockoutRemaining = cast.postHitLockout;
            if(caster === player){
              const text = target
                ? `${cast.abilityName || 'Grab'} executed the target.`
                : `${cast.abilityName || 'Grab'} missed.`;
              setHudMessage(text);
            }
          }
          continue;
        }
        if(nextDistance >= maxDistance){
          cast.state = 'recover';
          cast.lockoutRemaining = cast.postHitLockout;
          if(caster === player){
            setHudMessage(`${cast.abilityName || 'Grab'} missed.`);
          }
        }
        continue;
      }

      if(state === 'pulling'){
        const pullCaster = cast.pullCaster === true;
        const target = cast.targetRef;
        const targetAlive = target && target.hp > 0;
        if(pullCaster){
          const mover = caster || player;
          if(target && target.beingPulledBy === cast && !targetAlive){
            target.beingPulledBy = null;
          }
          if(!mover){
            cast.state = 'recover';
            cast.lockoutRemaining = cast.postHitLockout;
            continue;
          }
          cast.pullElapsed = Math.max(0, (cast.pullElapsed || 0) + dt);
          const duration = Math.max(0.0001, Number(cast.pullDuration) || 0.0001);
          const rawProgress = Math.max(0, Math.min(1, cast.pullElapsed / duration));
          const eased = rawProgress * rawProgress * (3 - 2 * rawProgress);
          const destX = targetAlive ? cast.pullDestX : (Number.isFinite(cast.pullDestX) ? cast.pullDestX : mover.x);
          const destY = targetAlive ? cast.pullDestY : (Number.isFinite(cast.pullDestY) ? cast.pullDestY : mover.y);
          const desiredX = cast.pullStartX + (destX - cast.pullStartX) * eased;
          const desiredY = cast.pullStartY + (destY - cast.pullStartY) * eased;
          const moveX = desiredX - mover.x;
          const moveY = desiredY - mover.y;
          const moverRadius = mover && Number.isFinite(mover.r) ? mover.r : minionRadius;
          const moved = moveCircleWithCollision(mover.x, mover.y, moveX, moveY, moverRadius);
          const actualMove = Math.hypot(moved.x - mover.x, moved.y - mover.y);
          mover.x = Math.max(moverRadius, Math.min(mapState.width - moverRadius, moved.x));
          mover.y = Math.max(moverRadius, Math.min(mapState.height - moverRadius, moved.y));
          cast.casterOriginX = mover.x;
          cast.casterOriginY = mover.y;
          cast.hitPointX = targetAlive && target ? target.x : (Number.isFinite(cast.hitPointX) ? cast.hitPointX : destX);
          cast.hitPointY = targetAlive && target ? target.y : (Number.isFinite(cast.hitPointY) ? cast.hitPointY : destY);
          if(actualMove < 0.05){
            cast.pullStuckTime = (cast.pullStuckTime || 0) + dt;
          } else {
            cast.pullStuckTime = 0;
          }
          if(rawProgress >= 1 || (cast.pullStuckTime || 0) > 0.2){
            if(target && target.beingPulledBy === cast){
              target.beingPulledBy = null;
            }
            cast.state = 'recover';
            cast.lockoutRemaining = cast.postHitLockout;
            if(mover === player){
              if(targetAlive){
                player.selectedTarget = target;
                if(player.attackDamage > 0){
                  applyPlayerAttackDamage(target);
                  applyQuiverstormFlurryDamage(target);
                  const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
                  setPlayerAttackCooldownFromPeriod(attackPeriod);
                  player.attackTarget = null;
                  player.attackWindup = 0;
                }
              }
              setHudMessage(`${cast.abilityName || 'Grab'} pull complete.`);
            }
          }
          continue;
        }
        if(!target || target.hp <= 0){
          if(target && target.beingPulledBy === cast){
            target.beingPulledBy = null;
          }
          cast.targetRef = null;
          cast.state = 'recover';
          cast.lockoutRemaining = cast.postHitLockout;
          if(caster === player){
            setHudMessage(`${cast.abilityName || 'Grab'} released its target.`);
          }
          continue;
        }
        cast.pullElapsed = Math.max(0, (cast.pullElapsed || 0) + dt);
        const duration = Math.max(0.0001, Number(cast.pullDuration) || 0.0001);
        const rawProgress = Math.max(0, Math.min(1, cast.pullElapsed / duration));
        const eased = rawProgress * rawProgress * (3 - 2 * rawProgress);
        const desiredX = cast.pullStartX + (cast.pullDestX - cast.pullStartX) * eased;
        const desiredY = cast.pullStartY + (cast.pullDestY - cast.pullStartY) * eased;
        const moveX = desiredX - target.x;
        const moveY = desiredY - target.y;
        const moved = moveCircleWithCollision(target.x, target.y, moveX, moveY, minionRadius);
        const actualMove = Math.hypot(moved.x - target.x, moved.y - target.y);
        target.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, moved.x));
        target.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, moved.y));
        cast.hitPointX = target.x;
        cast.hitPointY = target.y;
        if(actualMove < 0.05){
          cast.pullStuckTime = (cast.pullStuckTime || 0) + dt;
        } else {
          cast.pullStuckTime = 0;
        }
        if(rawProgress >= 1 || (cast.pullStuckTime || 0) > 0.2){
          if(target.beingPulledBy === cast){
            target.beingPulledBy = null;
          }
          if(caster === player && target.hp > 0 && player.attackDamage > 0){
            applyPlayerAttackDamage(target);
            applyQuiverstormFlurryDamage(target);
            const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
            setPlayerAttackCooldownFromPeriod(attackPeriod);
            player.attackTarget = null;
            player.attackWindup = 0;
          }
          cast.targetRef = null;
          cast.state = 'recover';
          cast.lockoutRemaining = cast.postHitLockout;
          if(caster === player){
            setHudMessage(`${cast.abilityName || 'Grab'} pull complete.`);
          }
        }
        continue;
      }

      if(state === 'recover'){
        cast.lockoutRemaining = Math.max(0, (cast.lockoutRemaining || 0) - dt);
        if(cast.lockoutRemaining <= 0){
          concludeGrabCast(cast, i);
        }
        continue;
      }

      concludeGrabCast(cast, i);
    }
  }

  function releaseBacklineSeizureTarget(cast){
    if(!cast) return;
    const target = cast.targetRef;
    if(target && target.beingPulledBy === cast){
      target.beingPulledBy = null;
    }
    cast.targetRef = null;
  }

  function concludeBacklineSeizure(cast, index){
    releaseBacklineSeizureTarget(cast);
    if(cast && cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(index)){
      backlineSeizureCasts.splice(index, 1);
    }
  }

  function beginBacklineSeizure(cast, hit){
    if(!cast || !hit || !hit.target) return false;
    const caster = cast.casterRef || player;
    const casterRadius = caster && Number.isFinite(caster.r) ? Math.max(minionRadius, Number(caster.r) || minionRadius) : minionRadius;
    const target = hit.target;
    const targetRadius = Math.max(minionRadius, Number(hit.targetRadius) || backlineSeizureTargetRadius(target));
    const overshoot = Math.max(0, Number(cast.overshoot) || 0);
    const behindDistance = targetRadius + casterRadius + overshoot;
    const destX = target.x + cast.dirX * behindDistance;
    const destY = target.y + cast.dirY * behindDistance;
    const moved = moveCircleWithCollision(caster.x, caster.y, destX - caster.x, destY - caster.y, casterRadius);
    caster.x = Math.max(casterRadius, Math.min(mapState.width - casterRadius, moved.x));
    caster.y = Math.max(casterRadius, Math.min(mapState.height - casterRadius, moved.y));
    if(caster === player){
      player.target.x = caster.x;
      player.target.y = caster.y;
      player.navGoal = null;
      player.nav = null;
      player.chaseTarget = null;
    }
    cast.targetRef = target;
    cast.targetRadius = targetRadius;
    cast.hitPointX = target.x;
    cast.hitPointY = target.y;
    cast.suppressRemaining = Math.max(0, Number(cast.suppressDuration) || 0);
    cast.holdDistance = Math.max(targetRadius + casterRadius + 6, 16);
    target.beingPulledBy = cast;
    const totalControl = Math.max(0, cast.suppressRemaining + Math.max(0, Number(cast.slamStun) || 0));
    if(totalControl > 0){
      target.stunTimer = Math.max(target.stunTimer || 0, totalControl);
    }
    flash(caster.x, caster.y, { startRadius: 12, endRadius: 40, color: '#ff9f7a' });
    cast.state = 'seizing';
    if(caster === player){
      player.selectedTarget = target;
      setHudMessage(`${cast.abilityName || 'Abduction'} seized a target!`);
    }
    return true;
  }

  function holdBacklineTarget(cast){
    const target = cast.targetRef;
    const caster = cast.casterRef || player;
    if(!target || !caster) return false;
    const dirX = Number(cast.dirX) || 0;
    const dirY = Number(cast.dirY) || 0;
    const holdDistance = Math.max(0, Number(cast.holdDistance) || 0);
    const radius = Math.max(minionRadius, Number(cast.targetRadius) || minionRadius);
    const desiredX = caster.x - dirX * holdDistance;
    const desiredY = caster.y - dirY * holdDistance;
    const moved = moveCircleWithCollision(target.x, target.y, desiredX - target.x, desiredY - target.y, radius);
    target.x = Math.max(radius, Math.min(mapState.width - radius, moved.x));
    target.y = Math.max(radius, Math.min(mapState.height - radius, moved.y));
    cast.hitPointX = target.x;
    cast.hitPointY = target.y;
    target.beingPulledBy = cast;
    return true;
  }

  function slamBacklineTarget(cast){
    const target = cast.targetRef;
    const caster = cast.casterRef || player;
    const damage = Math.max(0, Number(cast.damage) || 0);
    const slamStun = Math.max(0, Number(cast.slamStun) || 0);
    if(target){
      const prevHp = Number(target.hp) || 0;
      if(damage > 0){
        target.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(target.x, target.y - minionRadius, damage);
      }
      if(slamStun > 0){
        target.stunTimer = Math.max(target.stunTimer || 0, slamStun);
      }
      flash(target.x, target.y, { startRadius: 14, endRadius: 48, color: '#ffb25f' });
      handlePracticeDummyDamage(target, prevHp);
      releaseBacklineSeizureTarget(cast);
    }
    if(caster === player){
      const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      setHudMessage(`${cast.abilityName || 'Abduction'} slammed its target${dmgText}.`);
    }
  }

  function updateBacklineSeizureCasts(dt){
    for(let i = backlineSeizureCasts.length - 1; i >= 0; i--){
      const cast = backlineSeizureCasts[i];
      if(!cast){
        backlineSeizureCasts.splice(i, 1);
        continue;
      }
      const state = cast.state || 'seeking';
      if(state === 'windup'){
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
        if(cast.elapsed >= duration){
          cast.elapsed = 0;
          cast.state = 'seeking';
        }
        continue;
      }

      if(state === 'seeking'){
        const hit = findBacklineSeizureTarget(cast);
        if(hit){
          beginBacklineSeizure(cast, hit);
        } else {
          cast.state = 'recover';
          cast.lockoutRemaining = Math.max(0, Number(cast.postLockout) || 0);
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Abduction'} found no targets.`);
          }
        }
        continue;
      }

      if(state === 'seizing'){
        const target = cast.targetRef;
        const caster = cast.casterRef || player;
        if(!target || target.hp <= 0){
          releaseBacklineSeizureTarget(cast);
          cast.state = 'recover';
          cast.lockoutRemaining = Math.max(cast.lockoutRemaining || 0, Number(cast.postLockout) || 0);
          if(caster === player){
            setHudMessage(`${cast.abilityName || 'Abduction'} released its target.`);
          }
          continue;
        }
        holdBacklineTarget(cast);
        cast.suppressRemaining = Math.max(0, (cast.suppressRemaining || 0) - dt);
        if(cast.suppressRemaining <= 0){
          slamBacklineTarget(cast);
          cast.state = 'recover';
          cast.lockoutRemaining = Math.max(cast.lockoutRemaining || 0, Number(cast.postLockout) || 0);
        }
        continue;
      }

      if(state === 'recover'){
        cast.lockoutRemaining = Math.max(0, (cast.lockoutRemaining || 0) - dt);
        if(cast.lockoutRemaining <= 0){
          concludeBacklineSeizure(cast, i);
        }
        continue;
      }

      concludeBacklineSeizure(cast, i);
    }
  }

  function concludeLinkLashCast(cast, index){
    if(cast && cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    if(Number.isFinite(index)){
      linkLashCasts.splice(index, 1);
    }
  }

  function updateLinkLashCasts(dt){
    for(let i = linkLashCasts.length - 1; i >= 0; i--){
      const cast = linkLashCasts[i];
      if(!cast){
        linkLashCasts.splice(i, 1);
        continue;
      }
      const state = cast.state || 'flying';
      if(state === 'channel'){
        const duration = Math.max(0, Number(cast.channelDuration) || 0);
        cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
        if(cast.elapsed >= duration){
          cast.elapsed = 0;
          cast.state = 'flying';
          if(!cast.launchAnnounced && cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Link Lash'} launched!`);
          }
          cast.launchAnnounced = true;
        }
        continue;
      }

      if(state === 'flying'){
        const prevDistance = Number(cast.distanceTraveled) || 0;
        const speed = Math.max(0, Number(cast.speed) || 0);
        const maxDistance = Math.max(0, Number(cast.range) || 0);
        const nextDistance = Math.min(maxDistance, prevDistance + speed * dt);
        cast.distanceTraveled = nextDistance;
        cast.hitPointX = cast.startX + cast.dirX * nextDistance;
        cast.hitPointY = cast.startY + cast.dirY * nextDistance;
        const hit = findLinkLashHitCandidate(cast, prevDistance, nextDistance);
        if(hit){
          cast.distanceTraveled = Math.min(hit.along, maxDistance);
          cast.hitPointX = hit.hitX;
          cast.hitPointY = hit.hitY;
          handleLinkLashHit(cast, hit.target, hit.hitX, hit.hitY);
          concludeLinkLashCast(cast, i);
          continue;
        }
        if(nextDistance >= maxDistance){
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Link Lash'} missed.`);
          }
          concludeLinkLashCast(cast, i);
        }
        continue;
      }

      concludeLinkLashCast(cast, i);
    }
  }

  function activeLinkLashFollowup(){
    for(let i = linkLashTethers.length - 1; i >= 0; i--){
      const tether = linkLashTethers[i];
      if(!tether || tether.state !== 'waiting' || tether.followupUsed) continue;
      if(!(tether.tetherRemaining > 0)) continue;
      const primaryAlive = linkLashTargetAlive(tether.primaryRef);
      if(!primaryAlive){
        linkLashTethers.splice(i, 1);
        continue;
      }
      if(tether.casterRef !== player) continue;
      return tether;
    }
    return null;
  }

  function resolveLinkLashImpact(tether){
    if(!tether) return false;
    const primary = tether.primaryRef;
    const secondary = tether.secondaryRef;
    if(!linkLashTargetAlive(primary) || !linkLashTargetAlive(secondary)){
      tether.state = 'finished';
      return false;
    }
    const dx = secondary.x - primary.x;
    const dy = secondary.y - primary.y;
    const distance = Math.hypot(dx, dy) || 1;
    const dirX = dx / distance;
    const dirY = dy / distance;
    const halfMove = Math.max(0, Number(tether.displacement) || 0) * 0.5;
    const moveAmount = Math.min(distance / 2, halfMove);
    if(moveAmount > 0){
      const movedPrimary = moveCircleWithCollision(primary.x, primary.y, dirX * moveAmount, dirY * moveAmount, minionRadius);
      const movedSecondary = moveCircleWithCollision(secondary.x, secondary.y, -dirX * moveAmount, -dirY * moveAmount, minionRadius);
      primary.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, movedPrimary.x));
      primary.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, movedPrimary.y));
      secondary.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, movedSecondary.x));
      secondary.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, movedSecondary.y));
    }
    const slamThreshold = Number.isFinite(tether.slamThreshold) ? tether.slamThreshold : 700;
    const postDistance = Math.hypot(secondary.x - primary.x, secondary.y - primary.y);
    const doSlam = postDistance <= slamThreshold;
    const rootDuration = Math.max(0, Number(tether.rootDuration) || 0);
    if(rootDuration > 0){
      primary.stunTimer = Math.max(primary.stunTimer || 0, rootDuration);
      secondary.stunTimer = Math.max(secondary.stunTimer || 0, rootDuration);
    }
    if(doSlam){
      const midX = (primary.x + secondary.x) / 2;
      const midY = (primary.y + secondary.y) / 2;
      applyLinkLashImpact(tether, midX, midY);
    }
    tether.state = 'finished';
    return true;
  }

  function resolveLinkLashFollowup(tether, target){
    if(!tether || tether.state !== 'waiting' || tether.followupUsed) return false;
    if(!linkLashTargetAlive(target)) return false;
    if(!linkLashTargetAlive(tether.primaryRef)){
      tether.state = 'finished';
      return false;
    }
    tether.followupUsed = true;
    tether.secondaryRef = target;
    tether.secondaryHitX = target.x;
    tether.secondaryHitY = target.y;
    const damage = Math.max(0, Number(tether.damage) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(tether.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(tether.slowDuration) || 0);
    const prevHp = Number(target.hp) || 0;
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(target.x, target.y - minionRadius, damage);
    }
    applyLinkLashSlow(target, slowFraction, slowDuration);
    handlePracticeDummyDamage(target, prevHp);
    flash(target.x, target.y, { color: '#9ce7ff' });
    if(target === tether.primaryRef){
      tether.state = 'finished';
      return true;
    }
    const rootDuration = Math.max(0, Number(tether.rootDuration) || 0);
    if(rootDuration > 0){
      tether.primaryRef.stunTimer = Math.max(tether.primaryRef.stunTimer || 0, rootDuration);
      target.stunTimer = Math.max(target.stunTimer || 0, rootDuration);
    }
    if(tether.impactDelay > 0){
      tether.state = 'impactDelay';
      tether.impactTimer = tether.impactDelay;
    } else {
      tether.state = 'impact';
      resolveLinkLashImpact(tether);
    }
    if(tether.casterRef === player){
      const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      setHudMessage(`${tether.abilityName || 'Link Lash'} follow-up hit${dmgText}.`);
    }
    return true;
  }

  function applyLinkLashImpact(tether, x, y){
    if(!tether) return;
    const radius = Math.max(0, Number(tether.slamRadius) || 0);
    const stunDuration = Math.max(0, Number(tether.slamStun) || 0);
    const slowFraction = Math.max(0, Math.min(1, Number(tether.slowFraction) || 0));
    const slowDuration = Math.max(0, Number(tether.slowDuration) || 0);
    const damage = Math.max(0, Number(tether.damage) || 0);
    const effective = radius + minionRadius;
    const effectiveSq = effective * effective;
    let hits = 0;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.portalizing > 0 || m.hp <= 0) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      if(stunDuration > 0){
        m.stunTimer = Math.max(m.stunTimer || 0, stunDuration);
      }
      applyLinkLashSlow(m, slowFraction, slowDuration);
      handlePracticeDummyDamage(m, prevHp);
      hits += 1;
    }
    flash(x, y, { startRadius: Math.max(12, radius * 0.35), endRadius: Math.max(radius, radius + 60, 40), color: '#9fe3ff' });
    if(tether.casterRef === player){
      const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      const hitText = hits > 0 ? `${hits} target${hits === 1 ? '' : 's'}${dmgText}` : 'no targets';
      setHudMessage(`${tether.abilityName || 'Link Lash'} slam hit ${hitText}.`);
    }
  }

  function updateLinkLashTethers(dt){
    for(let i = linkLashTethers.length - 1; i >= 0; i--){
      const tether = linkLashTethers[i];
      if(!tether){
        linkLashTethers.splice(i, 1);
        continue;
      }
      tether.tetherRemaining = Math.max(0, (tether.tetherRemaining || 0) - dt);
      if(!linkLashTargetAlive(tether.primaryRef)){
        linkLashTethers.splice(i, 1);
        continue;
      }
      if(tether.state === 'impactDelay'){
        tether.impactTimer = Math.max(0, (tether.impactTimer || 0) - dt);
        if(tether.impactTimer <= 0){
          resolveLinkLashImpact(tether);
        }
      }
      const expired = tether.state === 'waiting' && tether.tetherRemaining <= 0;
      if(expired || tether.state === 'finished'){
        linkLashTethers.splice(i, 1);
      }
    }
  }

  function updateBoneSkewerCasts(dt){
    for(let i = boneSkewerCasts.length - 1; i >= 0; i--){
      const cast = boneSkewerCasts[i];
      if(!cast){
        boneSkewerCasts.splice(i, 1);
        continue;
      }
      const cooldownSeconds = Number.isFinite(cast.cooldownSeconds)
        ? Math.max(0, Number(cast.cooldownSeconds) || 0)
        : 0;
      const usedClock = refreshBoneSkewerElapsed(cast);
      if(!usedClock){
        if(cast.state === 'windup'){
          cast.castElapsed = Math.max(0, (Number(cast.castElapsed) || 0) + dt);
        } else if(cast.state === 'channel'){
          cast.channelElapsed = Math.max(0, (Number(cast.channelElapsed) || 0) + dt);
        }
      }

      if(cast.state === 'windup'){
        const duration = Math.max(0, Number(cast.castTime) || 0);
        if(duration <= 0 || (cast.castElapsed || 0) >= duration){
          const overflow = Math.max(0, (cast.castElapsed || 0) - duration);
          cast.state = 'channel';
          cast.channelElapsed = Math.max(Number(cast.channelElapsed) || 0, overflow);
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Bone Skewer'} channeling...`);
          }
        }
        continue;
      }

      if(cast.state === 'channel'){
        const maxChannel = Math.max(0, Number(cast.channelDuration) || 0);
        if(maxChannel > 0 && cast.channelElapsed >= maxChannel){
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Bone Skewer'} cancelled (channel ended).`);
          }
          setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
          if(player.casting === cast){
            player.casting = null;
          }
          boneSkewerCasts.splice(i, 1);
          continue;
        }
        continue;
      }

      boneSkewerCasts.splice(i, 1);
    }
  }

  function findAstralSnareHitCandidate(cast, baseX, baseY, prevDistance, nextDistance, excludeTarget){
    if(!cast) return null;
    const dirX = Number(cast.dirX) || 0;
    const dirY = Number(cast.dirY) || 0;
    if(Math.hypot(dirX, dirY) < 0.0001) return null;
    const halfWidth = Math.max(0, Number(cast.width) || 0) * 0.5 + minionRadius;
    const effectiveSq = halfWidth * halfWidth;
    let best = null;
    let bestAlong = Infinity;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      if(excludeTarget && excludeTarget === m) continue;
      const relX = m.x - baseX;
      const relY = m.y - baseY;
      const along = relX * dirX + relY * dirY;
      if(along < prevDistance - minionRadius) continue;
      if(along > nextDistance + minionRadius) continue;
      if(along < -minionRadius) continue;
      const closestX = baseX + dirX * along;
      const closestY = baseY + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY <= effectiveSq){
        if(along < bestAlong){
          bestAlong = along;
          best = { target: m, along, hitX: closestX, hitY: closestY };
        }
      }
    }
    return best;
  }

  function stunAstralSnarePrimaryTarget(cast){
    if(!cast) return;
    const target = cast.primaryTarget;
    const stunDuration = Math.max(0, Number(cast.stunDuration) || 0);
    if(!target || target.hp <= 0 || stunDuration <= 0) return;
    target.stunTimer = Math.max(target.stunTimer || 0, stunDuration);
  }

  function updateAstralSnareCasts(dt){
    for(let i = astralSnareCasts.length - 1; i >= 0; i--){
      const cast = astralSnareCasts[i];
      if(!cast){
        astralSnareCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(cast.state === 'windup'){
        const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
        if(interrupted){
          if(caster === player && player.casting === cast){
            player.casting = null;
            setHudMessage(`${cast.abilityName || 'Astral Snare'} interrupted.`);
          }
          astralSnareCasts.splice(i, 1);
          continue;
        }
        if(caster){
          const origin = getSpellOrigin(caster);
          if(Number.isFinite(origin.x)) cast.startX = origin.x;
          if(Number.isFinite(origin.y)) cast.startY = origin.y;
        }
        cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        if(duration <= 0 || cast.elapsed >= duration){
          cast.state = 'primary';
          cast.elapsed = 0;
          if(caster){
            const origin = getSpellOrigin(caster);
            if(Number.isFinite(origin.x)) cast.startX = origin.x;
            if(Number.isFinite(origin.y)) cast.startY = origin.y;
          }
        }
        continue;
      }
      if(cast.state === 'primary'){
        if(!cast.launched){
          const cooldownSeconds = Math.max(0, Number(cast.cooldownSeconds) || 0);
          setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
          cast.launched = true;
          if(caster === player && player.casting === cast){
            player.casting = null;
          }
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Astral Snare'} launched!`);
          }
        }
        const speed = Math.max(0, Number(cast.speed) || 0);
        const maxRange = Math.max(0, Number(cast.range) || 0);
        const prevDistance = Math.max(0, Number(cast.traveled) || 0);
        const nextDistance = Math.min(maxRange, prevDistance + speed * dt);
        cast.traveled = nextDistance;
        const hit = findAstralSnareHitCandidate(cast, cast.startX, cast.startY, prevDistance, nextDistance);
        if(hit){
          const target = hit.target;
          const prevHp = Number(target.hp) || 0;
          if(cast.damage > 0){
            target.hp = Math.max(0, prevHp - cast.damage);
            spawnHitSplat(target.x, target.y - minionRadius, cast.damage);
          }
          if(cast.slowFraction > 0 && cast.slowDuration > 0){
            const existingSlow = typeof target.slowPct === 'number' ? target.slowPct : 0;
            target.slowPct = Math.max(existingSlow, cast.slowFraction);
            target.slowTimer = Math.max(target.slowTimer || 0, cast.slowDuration);
          }
          flash(hit.hitX, hit.hitY, { color: '#b0e0ff' });
          handlePracticeDummyDamage(target, prevHp);
          cast.primaryTarget = target;
          cast.primaryHitX = hit.hitX;
          cast.primaryHitY = hit.hitY;
          cast.trailStartX = hit.hitX;
          cast.trailStartY = hit.hitY;
          if(cast.afterRange <= 0){
            stunAstralSnarePrimaryTarget(cast);
            if(cast.casterRef === player){
              if(target && target.hp > 0){
                player.selectedTarget = target;
                setHudMessage(`${cast.abilityName || 'Astral Snare'} stunned the tethered target!`);
              } else {
                setHudMessage(`${cast.abilityName || 'Astral Snare'} finished its path.`);
              }
            }
            astralSnareCasts.splice(i, 1);
            continue;
          }
          cast.state = 'after';
          cast.trailTraveled = 0;
          if(cast.casterRef === player){
            player.selectedTarget = target;
            setHudMessage(`${cast.abilityName || 'Astral Snare'} connected!`);
          }
          continue;
        }
        if(nextDistance >= maxRange - 0.0001){
          if(caster === player && player.casting === cast){
            player.casting = null;
          }
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Astral Snare'} missed.`);
          }
          astralSnareCasts.splice(i, 1);
          continue;
        }
        continue;
      }
      if(cast.state === 'after'){
        const afterRange = Math.max(0, Number(cast.afterRange) || 0);
        if(!(afterRange > 0)){
          stunAstralSnarePrimaryTarget(cast);
          if(cast.casterRef === player){
            if(cast.primaryTarget && cast.primaryTarget.hp > 0){
              player.selectedTarget = cast.primaryTarget;
              setHudMessage(`${cast.abilityName || 'Astral Snare'} slammed the tethered target!`);
            } else {
              setHudMessage(`${cast.abilityName || 'Astral Snare'} faded.`);
            }
          }
          astralSnareCasts.splice(i, 1);
          continue;
        }
        const prevTrail = Math.max(0, Number(cast.trailTraveled) || 0);
        const speed = Math.max(0, Number(cast.speed) || 0);
        const nextTrail = Math.min(afterRange, prevTrail + speed * dt);
        cast.trailTraveled = nextTrail;
        const secondaryHit = findAstralSnareHitCandidate(cast, cast.trailStartX, cast.trailStartY, prevTrail, nextTrail, cast.primaryTarget);
        if(secondaryHit){
          const target = secondaryHit.target;
          const prevHp = Number(target.hp) || 0;
          if(cast.damage > 0){
            target.hp = Math.max(0, prevHp - cast.damage);
            spawnHitSplat(target.x, target.y - minionRadius, cast.damage);
          }
          handlePracticeDummyDamage(target, prevHp);
          const stunDuration = Math.max(0, Number(cast.stunDuration) || 0);
          if(stunDuration > 0){
            stunAstralSnarePrimaryTarget(cast);
            target.stunTimer = Math.max(target.stunTimer || 0, stunDuration);
          }
          flash(secondaryHit.hitX, secondaryHit.hitY, { color: '#d1b3ff' });
          if(cast.casterRef === player){
            player.selectedTarget = target;
            setHudMessage(`${cast.abilityName || 'Astral Snare'} stunned two targets!`);
          }
          astralSnareCasts.splice(i, 1);
          continue;
        }
        if(nextTrail >= afterRange - 0.0001){
          stunAstralSnarePrimaryTarget(cast);
          const impactX = cast.trailStartX + cast.dirX * nextTrail;
          const impactY = cast.trailStartY + cast.dirY * nextTrail;
          flash(impactX, impactY, { color: '#d1b3ff' });
          if(cast.casterRef === player && cast.primaryTarget && cast.primaryTarget.hp > 0){
            player.selectedTarget = cast.primaryTarget;
            setHudMessage(`${cast.abilityName || 'Astral Snare'} slammed the tethered target!`);
          }
          astralSnareCasts.splice(i, 1);
          continue;
        }
        continue;
      }
    }
  }

  function updatePiercingArrowCasts(dt){
    for(let i = piercingArrowCasts.length - 1; i >= 0; i--){
      const cast = piercingArrowCasts[i];
      if(!cast){
        piercingArrowCasts.splice(i, 1);
        continue;
      }
      if(Number.isFinite(cast.startedAt)){
        cast.chargeElapsed = Math.max(0, (performance.now() - cast.startedAt) / 1000);
      } else {
        cast.chargeElapsed = Math.max(0, (Number(cast.chargeElapsed) || 0) + dt);
      }
      const caster = cast.casterRef || player;
      const { x: originX, y: originY } = getSpellOrigin(caster);
      const aimPoint = beamAimPoint();
      let dx = aimPoint.x - originX;
      let dy = aimPoint.y - originY;
      let len = Math.hypot(dx, dy);
      if(!(len > 0.0001)){
        dx = player.target.x - originX;
        dy = player.target.y - originY;
        len = Math.hypot(dx, dy);
      }
      if(len > 0.0001){
        cast.dirX = dx / len;
        cast.dirY = dy / len;
      }
      const state = computePiercingArrowChargeState(cast);
      cast.chargeState = state;
      if(!(state.maxCharge > 0)){
        releasePiercingArrow(cast, { cause: 'auto' });
        continue;
      }
      if(cast.chargeElapsed >= state.maxCharge - 0.0001){
        releasePiercingArrow(cast, { cause: 'auto' });
      }
    }
  }

  function fireBeamCast(cast){
    if(!cast) return;
    const geom = resolveBeamCastGeometry(cast);
    const lengthBase = Math.max(1, Number(cast.fireLength) || 0);
    const length = cast.dynamicLength ? Math.max(1, geom.distanceToTarget) : lengthBase;
    const abilityName = cast.abilityName || 'Beam';
    const startX = geom.startX;
    const startY = geom.startY;
    const dirX = geom.dirX;
    const dirY = geom.dirY;
    const endX = startX + dirX * length;
    const endY = startY + dirY * length;
    const beamHalfWidth = Math.max((Number(cast.width) || 0) / 2, 0);
    const effectiveRadius = beamHalfWidth + minionRadius;
    const effectiveRadiusSq = effectiveRadius * effectiveRadius;
    const victims = [];
    let hitPointX = endX;
    let hitPointY = endY;
    let farthestAlong = -Infinity;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const relX = m.x - startX;
      const relY = m.y - startY;
      const along = relX * dirX + relY * dirY;
      if(along < 0 || along > length) continue;
      const closestX = startX + dirX * along;
      const closestY = startY + dirY * along;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      const distSq = offX * offX + offY * offY;
      if(distSq <= effectiveRadiusSq){
        victims.push({ target: m, along, hitX: closestX, hitY: closestY });
        if(along > farthestAlong){
          farthestAlong = along;
          hitPointX = closestX;
          hitPointY = closestY;
        }
      }
    }

    if(victims.length){
      for(const { target } of victims){
        const prevHp = Number(target.hp) || 0;
        if(cast.damage > 0){
          target.hp = Math.max(0, prevHp - cast.damage);
          spawnHitSplat(target.x, target.y - minionRadius, cast.damage);
        }
        if(cast.slowFraction > 0){
          const existing = typeof target.slowPct === 'number' ? target.slowPct : 0;
          target.slowPct = Math.max(existing, cast.slowFraction);
          target.slowTimer = Math.max(target.slowTimer || 0, BEAM_SLOW_DURATION);
        }
        handlePracticeDummyDamage(target, prevHp);
      }
    }

    const primaryTarget = victims.length === 1 ? victims[0].target : null;
    const visualEndX = victims.length ? hitPointX : endX;
    const visualEndY = victims.length ? hitPointY : endY;
    spawnBeamVisual(startX, startY, primaryTarget, length, Math.max(1, cast.width), {
      endX: visualEndX,
      endY: visualEndY,
      dirX,
      dirY
    });
    flash(visualEndX, visualEndY);

    if(victims.length){
      if(victims.length === 1){
        const damageText = cast.damage > 0 ? ` for ${Math.round(cast.damage)} damage` : '';
        setHudMessage(`${abilityName} hit${damageText}!`);
      } else {
        setHudMessage(`${abilityName} hit ${victims.length} targets!`);
      }
    } else {
      setHudMessage(`${abilityName} fired.`);
    }

    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
  }

  function updateBulwarkCrashCasts(dt){
    for(let i = bulwarkCrashCasts.length - 1; i >= 0; i--){
      const cast = bulwarkCrashCasts[i];
      if(!cast){
        bulwarkCrashCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        endBulwarkCrashCast(cast, { reason: 'interrupted' });
        bulwarkCrashCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const braceDuration = Math.max(0, Number(cast.braceDuration) || 0);
      const lockoutDuration = Math.max(0, Math.min(braceDuration || Number.MAX_SAFE_INTEGER, Number(cast.lockoutDuration) || 0));
      if(cast.state === 'lockout' && cast.elapsed >= lockoutDuration){
        cast.state = 'bracing';
      }
      if(cast.elapsed >= braceDuration){
        bulwarkCrashCasts.splice(i, 1);
        fireBulwarkCrashCast(cast);
      }
    }
  }

  function updateBedrockBurstCasts(dt){
    for(let i = bedrockBurstCasts.length - 1; i >= 0; i--){
      const cast = bedrockBurstCasts[i];
      if(!cast){
        bedrockBurstCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        bedrockBurstCasts.splice(i, 1);
        continue;
      }
      if(caster){
        const casterOrigin = getSpellOrigin(caster);
        if(Number.isFinite(casterOrigin.x)) cast.startX = casterOrigin.x;
        if(Number.isFinite(casterOrigin.y)) cast.startY = casterOrigin.y;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        bedrockBurstCasts.splice(i, 1);
        fireBedrockBurstCast(cast);
      }
    }
  }

  function updateRagePulseCasts(dt){
    for(let i = ragePulseCasts.length - 1; i >= 0; i--){
      const cast = ragePulseCasts[i];
      if(!cast){
        ragePulseCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        ragePulseCasts.splice(i, 1);
        continue;
      }
      if(caster){
        const casterOrigin = getSpellOrigin(caster);
        if(Number.isFinite(casterOrigin.x)) cast.startX = casterOrigin.x;
        if(Number.isFinite(casterOrigin.y)) cast.startY = casterOrigin.y;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        ragePulseCasts.splice(i, 1);
        fireRagePulseCast(cast);
      }
    }
  }

  function updateSlamCasts(dt){
    for(let i = slamCasts.length - 1; i >= 0; i--){
      const cast = slamCasts[i];
      if(!cast){
        slamCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef;
      if(caster){
        const casterOrigin = getSpellOrigin(caster);
        if(Number.isFinite(casterOrigin.x)) cast.startX = casterOrigin.x;
        if(Number.isFinite(casterOrigin.y)) cast.startY = casterOrigin.y;
      } else {
        const fallback = getSpellOrigin(player);
        cast.startX = fallback.x;
        cast.startY = fallback.y;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        slamCasts.splice(i, 1);
        fireSlamCast(cast);
      }
    }
  }

  function updateSlamFissures(dt){
    for(let i = slamFissures.length - 1; i >= 0; i--){
      const fissure = slamFissures[i];
      if(!fissure){
        slamFissures.splice(i, 1);
        continue;
      }
      if(fissure.state === 'travel'){
        const maxLength = Math.max(0, Number(fissure.maxLength) || 0);
        const speed = Math.max(0, Number(fissure.speed) || 0);
        const prevDistance = Math.max(0, Number(fissure.distance) || 0);
        if(!(speed > 0) || !(maxLength > 0)){
          fissure.state = 'done';
          fissure.distance = Math.min(prevDistance, maxLength);
          fissure.fadeRemaining = fissure.fadeDuration || 0.45;
        } else {
          const targetDistance = Math.min(maxLength, prevDistance + speed * dt);
          const halfWidth = Math.max(0, Number(fissure.width) || 0) * 0.5;
          let newDistance = prevDistance;
          let blocked = false;
          let segmentStart = prevDistance;
          const stepSize = Math.max(8, halfWidth * 0.75 + 6);
          const steps = Math.max(1, Math.ceil(Math.abs(targetDistance - prevDistance) / stepSize));
          for(let s = 1; s <= steps; s++){
            const fraction = s / steps;
            const candidate = prevDistance + (targetDistance - prevDistance) * fraction;
            const cx = fissure.startX + fissure.dirX * candidate;
            const cy = fissure.startY + fissure.dirY * candidate;
            if(circleCollides(cx, cy, halfWidth)){
              blocked = true;
              break;
            }
            processSlamFissureSegment(fissure, segmentStart, candidate);
            segmentStart = candidate;
            newDistance = candidate;
          }
          fissure.distance = newDistance;
          fissure.headX = fissure.startX + fissure.dirX * newDistance;
          fissure.headY = fissure.startY + fissure.dirY * newDistance;
          if(fissure.iceFieldRef){
            fissure.iceFieldRef.length = Math.min(fissure.iceFieldRef.maxLength, newDistance);
          }
          if(blocked || newDistance >= maxLength - 0.0001){
            fissure.state = 'done';
            fissure.fadeRemaining = fissure.fadeDuration || 0.45;
          }
        }
      } else {
        fissure.fadeRemaining = Math.max(0, (Number(fissure.fadeRemaining) || 0) - dt);
        if(fissure.fadeRemaining <= 0){
          if(fissure.iceFieldRef && fissure.iceFieldRef.owner === fissure){
            fissure.iceFieldRef.owner = null;
          }
          slamFissures.splice(i, 1);
        }
      }
    }
  }

  function updateSlamIceFields(dt){
    for(let i = slamIceFields.length - 1; i >= 0; i--){
      const field = slamIceFields[i];
      if(!field){
        slamIceFields.splice(i, 1);
        continue;
      }
      field.age = Math.max(0, (Number(field.age) || 0) + dt);
      if(field.owner){
        const ownerLength = Math.max(0, Number(field.owner.distance) || 0);
        field.length = Math.max(field.length || 0, Math.min(field.maxLength, ownerLength));
      }
      if(!(field.tickInterval > 0)) field.tickInterval = 0.1;
      field.tickTimer = (Number(field.tickTimer) || field.tickInterval) - dt;
      while(field.tickTimer <= 0){
        field.tickTimer += field.tickInterval;
        applySlamIceFieldTick(field);
        if(field.tickTimer <= 0) field.tickTimer += field.tickInterval;
      }
      if(field.duration > 0 && field.age >= field.duration){
        slamIceFields.splice(i, 1);
      }
    }
  }

  function updateSlamImpacts(dt){
    for(let i = slamImpacts.length - 1; i >= 0; i--){
      const impact = slamImpacts[i];
      if(!impact){
        slamImpacts.splice(i, 1);
        continue;
      }
      const lifetime = Math.max(0.05, Number(impact.lifetime) || 0.5);
      impact.age = (Number(impact.age) || 0) + dt;
      if(impact.age >= lifetime){
        slamImpacts.splice(i, 1);
      }
    }
  }

  function updateShatterburstOrbCasts(dt){
    for(let i = shatterburstOrbCasts.length - 1; i >= 0; i--){
      const cast = shatterburstOrbCasts[i];
      if(!cast){
        shatterburstOrbCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        shatterburstOrbCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        const launched = launchShatterburstOrb(cast);
        shatterburstOrbCasts.splice(i, 1);
        if(!launched && caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateReboundOrbCasts(dt){
    for(let i = reboundOrbCasts.length - 1; i >= 0; i--){
      const cast = reboundOrbCasts[i];
      if(!cast){
        reboundOrbCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        reboundOrbCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchReboundOrb(cast);
        reboundOrbCasts.splice(i, 1);
      }
    }
  }

  function updateCycloneCasts(dt){
    for(let i = cycloneCasts.length - 1; i >= 0; i--){
      const cast = cycloneCasts[i];
      if(!cast){
        cycloneCasts.splice(i, 1);
        continue;
      }
      if(cast.completed){
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Cyclone Axes'} interrupted.`);
        }
        finishCycloneAxesCast(cast, { reason: 'fizzled' });
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      if(!cast.launched){
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        if(duration <= 0 || cast.elapsed >= duration){
          const launched = launchCycloneAxes(cast);
          if(!launched){
            finishCycloneAxesCast(cast, { reason: 'fizzled' });
          }
        }
        continue;
      }
      if(!cast.recastAvailable){
        const delay = Math.max(0, Number(cast.recastDelay) || 0);
        if(delay > 0){
          cast.recastTimer = Math.min(delay, (Number(cast.recastTimer) || 0) + dt);
          if(cast.recastTimer >= delay){
            cast.recastAvailable = true;
          }
        } else {
          cast.recastAvailable = true;
        }
      }
    }
  }

  function updateBeamCasts(dt){
    for(let i = beamCasts.length - 1; i >= 0; i--){
      const cast = beamCasts[i];
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      if(cast.castDuration > 0 && cast.elapsed >= cast.castDuration){
        fireBeamCast(cast);
        beamCasts.splice(i, 1);
        if(player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateExpandingShotCasts(dt){
    for(let i = expandingShotCasts.length - 1; i >= 0; i--){
      const cast = expandingShotCasts[i];
      if(!cast){
        expandingShotCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        firePiercingBloom(cast);
        expandingShotCasts.splice(i, 1);
      }
    }
  }

  function updateLuminousDartCasts(dt){
    for(let i = luminousDartCasts.length - 1; i >= 0; i--){
      const cast = luminousDartCasts[i];
      if(!cast){
        luminousDartCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        luminousDartCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchLuminousDart(cast);
        luminousDartCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updatePlunderShotCasts(dt){
    for(let i = plunderShotCasts.length - 1; i >= 0; i--){
      const cast = plunderShotCasts[i];
      if(!cast){
        plunderShotCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        plunderShotCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchPlunderShot(cast);
        plunderShotCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateShadowTalonCasts(dt){
    for(let i = shadowTalonCasts.length - 1; i >= 0; i--){
      const cast = shadowTalonCasts[i];
      if(!cast){
        shadowTalonCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        shadowTalonCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchShadowTalonBolt(cast);
        shadowTalonCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateShadowTalonRecasts(dt){
    for(let i = shadowTalonRecasts.length - 1; i >= 0; i--){
      const recast = shadowTalonRecasts[i];
      if(!recast){
        shadowTalonRecasts.splice(i, 1);
        continue;
      }
      recast.timer = Math.max(0, (Number(recast.timer) || 0) - dt);
      if(recast.timer <= 0 && recast.remaining > 0){
        launchShadowTalonRecast(recast);
        recast.remaining = Math.max(0, recast.remaining - 1);
        recast.timer = Math.max(0.01, Number(recast.interval) || 0.01);
        if(recast.remaining <= 0){
          shadowTalonRecasts.splice(i, 1);
        }
      }
    }
  }

  function updatePestilentTossCasts(dt){
    for(let i = pestilentTossCasts.length - 1; i >= 0; i--){
      const cast = pestilentTossCasts[i];
      if(!cast){
        pestilentTossCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0 || caster.polymorphTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        pestilentTossCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        const launched = executePestilentToss(cast);
        pestilentTossCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateSirensKissCasts(dt){
    for(let i = sirensKissCasts.length - 1; i >= 0; i--){
      const cast = sirensKissCasts[i];
      if(!cast){
        sirensKissCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        sirensKissCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchSirensKissProjectile(cast);
        sirensKissCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateShiverSpikeCasts(dt){
    for(let i = shiverSpikeCasts.length - 1; i >= 0; i--){
      const cast = shiverSpikeCasts[i];
      if(!cast){
        shiverSpikeCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        shiverSpikeCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        launchShiverSpikeProjectile(cast);
        shiverSpikeCasts.splice(i, 1);
        if(caster === player && player.casting === cast){
          player.casting = null;
        }
      }
    }
  }

  function updateSkullRushCasts(dt){
    for(let i = skullRushCasts.length - 1; i >= 0; i--){
      const cast = skullRushCasts[i];
      if(!cast){
        skullRushCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        skullRushCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        executeSkullRush(cast);
        skullRushCasts.splice(i, 1);
      }
    }
  }

  function updateRiptideLungeCasts(dt){
    for(let i = riptideLungeCasts.length - 1; i >= 0; i--){
      const cast = riptideLungeCasts[i];
      if(!cast){
        riptideLungeCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        riptideLungeCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        executeRiptideLunge(cast);
        riptideLungeCasts.splice(i, 1);
      }
    }
  }

  function updateLaserConeCasts(dt){
    for(let i = laserConeCasts.length - 1; i >= 0; i--){
      const cast = laserConeCasts[i];
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      if(duration <= 0 || cast.elapsed >= duration){
        fireLaserConeCast(cast);
        laserConeCasts.splice(i, 1);
      }
    }
  }

  function updateDuskwaveCasts(dt){
    for(let i = duskwaveCasts.length - 1; i >= 0; i--){
      const cast = duskwaveCasts[i];
      if(!cast){
        duskwaveCasts.splice(i, 1);
        continue;
      }
      if(!cast.waveFired){
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
        if(duration <= 0 || cast.elapsed >= duration){
          fireDuskwaveWave(cast);
        }
        continue;
      }
      if(cast.volleyLaunched){
        duskwaveCasts.splice(i, 1);
        continue;
      }
      cast.delayElapsed = Math.max(0, (cast.delayElapsed || 0) + dt);
      const delay = Math.max(0, Number(cast.delay) || 0);
      if(cast.delayElapsed >= delay){
        spawnDuskwaveVolleys(cast);
        cast.volleyLaunched = true;
        duskwaveCasts.splice(i, 1);
      }
    }
  }

  function updateFlameChomperTraps(dt){
    if(!flameChomperTraps.length) return;
    const rootClaims = new Map();
    for(let i = 0; i < flameChomperTraps.length; ){
      const trap = flameChomperTraps[i];
      if(!trap){
        flameChomperTraps.splice(i, 1);
        continue;
      }
      trap.age = Math.max(0, (Number(trap.age) || 0) + dt);
      if(trap.justPlaced && trap.age > 0.05){
        trap.justPlaced = false;
      }
      const armDelay = Math.max(0, Number(trap.armDelay) || 0);
      if(!trap.armed && trap.age >= armDelay){
        trap.armed = true;
      }
      const lifetime = Math.max(0, Number(trap.lifeAfterArm) || 0);
      const maxAge = Number.isFinite(trap.maxAge) ? Math.max(0, Number(trap.maxAge) || 0) : (armDelay + lifetime);
      const triggerRadiusValue = Math.max(0, Number(trap.triggerRadius) || 0);
      const aoeRadiusValue = Math.max(triggerRadiusValue, Number(trap.aoeRadius) || 0);
      let removed = false;
      if(!trap.armed && trap.destructible && triggerRadiusValue > 0){
        const triggerSq = triggerRadiusValue * triggerRadiusValue;
        for(const m of minions){
          if(!m || !isEnemyMinionForPlayer(m) || m.hp <= 0 || m.portalizing > 0) continue;
          const dx = m.x - trap.x;
          const dy = m.y - trap.y;
          if(dx * dx + dy * dy <= triggerSq){
            flash(trap.x, trap.y, { startRadius: Math.max(8, triggerRadiusValue * 0.5), endRadius: Math.max(triggerRadiusValue, (Number(trap.radius) || 0) + 16), color: '#9aa2a8' });
            removed = true;
            break;
          }
        }
      }
      if(trap.armed){
        if(maxAge > 0 && trap.age >= maxAge){
          flash(trap.x, trap.y, { startRadius: Math.max(8, triggerRadiusValue * 0.5), endRadius: Math.max(triggerRadiusValue, (Number(trap.radius) || 0) + 24), color: '#ffbfa1' });
          removed = true;
        } else if(trap.canTriggerByMinions){
          const triggerSq = triggerRadiusValue * triggerRadiusValue;
          const aoeSq = aoeRadiusValue * aoeRadiusValue;
          let primary = null;
          let primaryDistSq = Infinity;
          const victims = [];
          for(const m of minions){
            if(!isEnemyMinionForPlayer(m)) continue;
            if(m.hp <= 0 || m.portalizing > 0) continue;
            const dx = m.x - trap.x;
            const dy = m.y - trap.y;
            const distSq = dx * dx + dy * dy;
            if(distSq <= aoeSq){
              victims.push({ target: m, distSq });
            }
            if(distSq <= triggerSq && distSq < primaryDistSq){
              primaryDistSq = distSq;
              primary = m;
            }
          }
          if(primary){
            const baseDamage = Math.max(0, Number(trap.damage) || 0);
            const dotDamage = Math.max(0, Number(trap.tickDamage) || 0);
            const dotTicks = Math.max(1, Number(trap.tickCount) || 1);
            const totalDamage = baseDamage + dotDamage * dotTicks;
            const subseqMultiplier = Number.isFinite(trap.subsequentHitMultiplier)
              ? Math.max(0, Math.min(1, Number(trap.subsequentHitMultiplier)))
              : 1;
            const hitMemoryMs = Math.max(TRAP_HIT_MEMORY_MIN_MS, Math.round(Number(trap.hitMemoryMs) || 0));
            let highestDamageDealt = 0;
            if(totalDamage > 0){
              for(const { target } of victims){
                const hitInfo = subseqMultiplier < 1
                  ? registerTrapHit(target, trap.abilityId || trap.id || 'trap', hitMemoryMs)
                  : { isSubsequent: false };
                const appliedMultiplier = hitInfo && hitInfo.isSubsequent ? subseqMultiplier : 1;
                const appliedDamage = totalDamage * appliedMultiplier;
                const prevHp = Number(target.hp) || 0;
                target.hp = Math.max(0, prevHp - appliedDamage);
                highestDamageDealt = Math.max(highestDamageDealt, appliedDamage);
                spawnHitSplat(target.x, target.y - minionRadius, appliedDamage);
                handlePracticeDummyDamage(target, prevHp);
              }
            }
            const slowPct = Math.max(0, Number(trap.slowPct) || 0);
            const slowDuration = Math.max(0, Number(trap.slowDuration) || 0);
            if(slowPct > 0 && slowDuration > 0){
              for(const { target } of victims){
                const existing = typeof target.slowPct === 'number' ? target.slowPct : 0;
                target.slowPct = Math.max(existing, slowPct);
                target.slowTimer = Math.max(Number(target.slowTimer) || 0, slowDuration);
              }
            }
            const rootDuration = Math.max(0, Number(trap.rootDuration) || 0);
            if(trap.rootPrimaryOnly){
              if(!rootClaims.has(primary) && rootDuration > 0){
                const existing = typeof primary.stunTimer === 'number' ? primary.stunTimer : 0;
                primary.stunTimer = Math.max(existing, rootDuration);
              }
              if(!rootClaims.has(primary)){
                rootClaims.set(primary, trap);
              }
            } else if(rootDuration > 0){
              for(const { target } of victims){
                const existing = typeof target.stunTimer === 'number' ? target.stunTimer : 0;
                target.stunTimer = Math.max(existing, rootDuration);
              }
            }
            const effectColor = totalDamage > 0 ? '#ff915a' : '#ffb37a';
            flash(trap.x, trap.y, { startRadius: Math.max(12, triggerRadiusValue * 0.8), endRadius: Math.max(aoeRadiusValue, triggerRadiusValue + 48), color: effectColor });
            const messageDamage = highestDamageDealt > 0 ? highestDamageDealt : totalDamage;
            if(messageDamage > 0){
              setHudMessage(`${trap.abilityName || 'Trap'} detonated for ${Math.round(messageDamage)} damage!`);
            } else {
              setHudMessage(`${trap.abilityName || 'Trap'} detonated!`);
            }
            if(trap.triggerRevealDuration > 0 && trap.revealRadius > 0){
              spawnTrapVisionSource(trap.x, trap.y, trap.revealRadius, trap.triggerRevealDuration);
            }
            removed = true;
          }
        }
      } else if(maxAge > 0 && trap.age >= maxAge){
        removed = true;
      }

      if(removed){
        flameChomperTraps.splice(i, 1);
        continue;
      }

      i++;
    }
  }

  function applySpectralStockadeBarrier(stockade, { initial = false } = {}){
    if(!stockade) return;
    const radius = Math.max(0, Number(stockade.radius) || 0);
    const thickness = Math.max(8, Number(stockade.thickness) || 0);
    const halfThickness = thickness * 0.5;
    const innerRadius = Math.max(0, radius - halfThickness);
    const outerRadius = radius + halfThickness;
    const shoveDistance = Math.max(0, Number(stockade.shoveDistance) || 0);
    const innerPullRadius = Math.max(0, Number(stockade.innerPullRadius) || 0);
    const buffer = Math.max(6, minionRadius * 0.75);
    const mapW = Number.isFinite(mapState && mapState.width) ? mapState.width : 5000;
    const mapH = Number.isFinite(mapState && mapState.height) ? mapState.height : 5000;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dx = m.x - stockade.x;
      const dy = m.y - stockade.y;
      const dist = Math.hypot(dx, dy);
      const dirX = dist > 0.0001 ? dx / dist : 1;
      const dirY = dist > 0.0001 ? dy / dist : 0;
      const innerLimit = Math.max(targetRadius + buffer, innerRadius - buffer);
      const outerLimit = outerRadius + buffer + targetRadius;
      if(initial){
        if(innerPullRadius > 0 && dist <= innerPullRadius){
          const pullTarget = Math.max(targetRadius + buffer, Math.min(innerLimit, innerPullRadius * 0.6));
          const moveDist = Math.max(0, dist - pullTarget + shoveDistance);
          if(moveDist > 0){
            const moved = moveCircleWithCollision(m.x, m.y, -dirX * moveDist, -dirY * moveDist, targetRadius);
            m.x = Math.max(targetRadius, Math.min(mapW - targetRadius, moved.x));
            m.y = Math.max(targetRadius, Math.min(mapH - targetRadius, moved.y));
          }
        } else if(dist <= outerLimit){
          const pushTarget = Math.max(outerRadius + buffer + shoveDistance, dist + shoveDistance);
          const moveDist = Math.max(0, pushTarget - dist);
          if(moveDist > 0){
            const moved = moveCircleWithCollision(m.x, m.y, dirX * moveDist, dirY * moveDist, targetRadius);
            m.x = Math.max(targetRadius, Math.min(mapW - targetRadius, moved.x));
            m.y = Math.max(targetRadius, Math.min(mapH - targetRadius, moved.y));
          }
        }
      } else if(dist > innerRadius - targetRadius && dist < outerRadius + targetRadius){
        if(dist >= radius){
          const desired = outerRadius + buffer;
          const moveDist = Math.max(0, desired - dist);
          if(moveDist > 0){
            const moved = moveCircleWithCollision(m.x, m.y, dirX * moveDist, dirY * moveDist, targetRadius);
            m.x = Math.max(targetRadius, Math.min(mapW - targetRadius, moved.x));
            m.y = Math.max(targetRadius, Math.min(mapH - targetRadius, moved.y));
          }
        } else {
          const desired = innerLimit;
          const moveDist = Math.max(0, dist - desired);
          if(moveDist > 0){
            const moved = moveCircleWithCollision(m.x, m.y, -dirX * moveDist, -dirY * moveDist, targetRadius);
            m.x = Math.max(targetRadius, Math.min(mapW - targetRadius, moved.x));
            m.y = Math.max(targetRadius, Math.min(mapH - targetRadius, moved.y));
          }
        }
      }
    }
  }

  function applyGlacialUpliftBarrier(wall, { initial = false } = {}){
    if(!wall) return;
    const halfLength = Math.max(20, Number(wall.length) || 0) * 0.5;
    const halfThickness = Math.max(6, Number(wall.thickness) || 0) * 0.5;
    const shoveDistance = Math.max(0, Number(wall.shoveDistance) || 0);
    const buffer = Math.max(6, minionRadius * 0.75);
    const wallDirX = Number.isFinite(wall.dirX) ? wall.dirX : 1;
    const wallDirY = Number.isFinite(wall.dirY) ? wall.dirY : 0;
    const normalX = Number.isFinite(wall.normalX) ? wall.normalX : -wallDirY;
    const normalY = Number.isFinite(wall.normalY) ? wall.normalY : wallDirX;
    const mapW = Number.isFinite(mapState && mapState.width) ? mapState.width : 5000;
    const mapH = Number.isFinite(mapState && mapState.height) ? mapState.height : 5000;

    function shoveUnit(unit, radius){
      if(!unit || !(radius > 0)) return;
      const dx = unit.x - wall.x;
      const dy = unit.y - wall.y;
      const along = dx * wallDirX + dy * wallDirY;
      if(Math.abs(along) > halfLength + radius + buffer) return;
      const off = dx * normalX + dy * normalY;
      const maxOffset = halfThickness + radius + buffer;
      if(Math.abs(off) > maxOffset) return;
      const side = off >= 0 ? 1 : -1;
      const overlap = maxOffset - Math.abs(off);
      const push = Math.max(0, overlap + (initial ? shoveDistance : 0));
      if(!(push > 0)) return;
      const moveX = normalX * side * push;
      const moveY = normalY * side * push;
      const moved = moveCircleWithCollision(unit.x, unit.y, moveX, moveY, radius);
      unit.x = Math.max(radius, Math.min(mapW - radius, moved.x));
      unit.y = Math.max(radius, Math.min(mapH - radius, moved.y));
    }

    const playerRadius = player && Number.isFinite(player.r) ? player.r : minionRadius;
    shoveUnit(player, playerRadius);
    for(const m of minions){
      if(!m || m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = m.isPracticeDummy === true
        ? Math.max(minionRadius, Number(m.radius) || minionRadius)
        : minionRadius;
      shoveUnit(m, targetRadius);
    }
    const monster = monsterState;
    if(monster && isMonsterAttackable(monster)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monster));
      shoveUnit(monster, monsterRadius);
    }
  }

  function activateSpectralStockade(cast){
    if(!cast) return;
    const wall = {
      ...cast,
      age: 0,
      activeFor: 0,
      state: 'active'
    };
    spectralStockades.push(wall);
    applySpectralStockadeBarrier(wall, { initial: true });
    const halfThickness = Math.max(4, Number(wall.thickness) || 0) * 0.5;
    const startRadius = Math.max(12, wall.radius - halfThickness);
    const endRadius = Math.max(wall.radius + halfThickness + 32, wall.radius + 24);
    flash(wall.x, wall.y, { startRadius, endRadius, color: '#9ad7ff' });
  }

  function updateSpectralStockadeCasts(dt){
    if(!spectralStockadeCasts.length) return;
    for(let i = spectralStockadeCasts.length - 1; i >= 0; i--){
      const cast = spectralStockadeCasts[i];
      if(!cast){
        spectralStockadeCasts.splice(i, 1);
        continue;
      }
      cast.age = Math.max(0, (Number(cast.age) || 0) + dt);
      const delay = Math.max(0, Number(cast.riseDelay) || 0);
      if(cast.age >= delay){
        spectralStockadeCasts.splice(i, 1);
        activateSpectralStockade(cast);
      }
    }
  }

  function updateSpectralStockades(dt){
    if(!spectralStockades.length) return;
    for(let i = spectralStockades.length - 1; i >= 0; i--){
      const wall = spectralStockades[i];
      if(!wall){
        spectralStockades.splice(i, 1);
        continue;
      }
      wall.activeFor = Math.max(0, (Number(wall.activeFor) || 0) + dt);
      applySpectralStockadeBarrier(wall, { initial: false });
      const duration = Math.max(0, Number(wall.duration) || 0);
      if(duration > 0 && wall.activeFor >= duration){
        spectralStockades.splice(i, 1);
      }
    }
  }

  function activateGlacialUplift(cast){
    if(!cast) return;
    const wall = {
      ...cast,
      id: cast.id || `uplift-${abilityRuntime.glacialUpliftSequence++}`,
      age: 0
    };
    glacialUpliftWalls.push(wall);
    applyGlacialUpliftBarrier(wall, { initial: true });
    const halfLen = Math.max(20, Number(wall.length) || 0) * 0.5;
    const halfThick = Math.max(6, Number(wall.thickness) || 0) * 0.5;
    const flashRadius = Math.max(halfLen + halfThick + 12, 32);
    flash(wall.x, wall.y, { startRadius: flashRadius * 0.6, endRadius: flashRadius + 32, color: '#aee8ff' });
    if(wall.casterRef === player){
      setHudMessage(`${wall.abilityName || 'Glacial Uplift'} raised!`);
    }
  }

  function updateGlacialUpliftCasts(dt){
    if(!glacialUpliftCasts.length) return;
    for(let i = glacialUpliftCasts.length - 1; i >= 0; i--){
      const cast = glacialUpliftCasts[i];
      if(!cast){
        glacialUpliftCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      const ready = duration <= 0 || cast.elapsed >= duration;
      if(ready){
        glacialUpliftCasts.splice(i, 1);
        if(cast.casterRef === player && player.casting === cast){
          player.casting = null;
        }
        activateGlacialUplift(cast);
      }
    }
  }

  function updateGlacialUpliftWalls(dt){
    if(!glacialUpliftWalls.length) return;
    for(let i = glacialUpliftWalls.length - 1; i >= 0; i--){
      const wall = glacialUpliftWalls[i];
      if(!wall){
        glacialUpliftWalls.splice(i, 1);
        continue;
      }
      wall.age = Math.max(0, (Number(wall.age) || 0) + dt);
      applyGlacialUpliftBarrier(wall, { initial: false });
      const duration = Math.max(0, Number(wall.duration) || 0);
      if(duration > 0 && wall.age >= duration){
        glacialUpliftWalls.splice(i, 1);
      }
    }
  }

  function updateCleaveCrushCasts(dt){
    for(let i = cleaveCrushCasts.length - 1; i >= 0; i--){
      const cast = cleaveCrushCasts[i];
      if(!cast){
        cleaveCrushCasts.splice(i, 1);
        continue;
      }
      if(cast.completed){
        cleaveCrushCasts.splice(i, 1);
        continue;
      }
      const state = cast.state || 'sweepWindup';
      if(state === 'sweepWindup' || state === 'slamWindup'){
        cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
        const lockout = Math.max(0, Number(cast.lockout) || 0);
        if(cast.elapsed >= lockout){
          if(state === 'sweepWindup'){
            resolveCleaveCrushSweep(cast);
          } else {
            resolveCleaveCrushSlam(cast);
          }
        }
      } else if(state === 'recastReady'){
        const remaining = Number.isFinite(cast.recastRemaining) ? cast.recastRemaining : cast.recastWindow;
        cast.recastRemaining = Math.max(0, remaining - dt);
        if(cast.recastRemaining <= 0){
          completeCleaveCrush(cast, 'expired');
        }
      }
    }
  }

  function updateBoltburstRushCasts(dt){
    for(let i = boltburstRushCasts.length - 1; i >= 0; i--){
      const state = boltburstRushCasts[i];
      if(!state){
        boltburstRushCasts.splice(i, 1);
        continue;
      }
      if(state.completed){
        boltburstRushCasts.splice(i, 1);
        continue;
      }
      if(Number.isFinite(state.lockoutRemaining)){
        state.lockoutRemaining = Math.max(0, state.lockoutRemaining - dt);
      }
      if(state.recastWindow > 0){
        const remaining = Number.isFinite(state.recastRemaining) ? state.recastRemaining : state.recastWindow;
        state.recastRemaining = Math.max(0, remaining - dt);
        if(state.recastRemaining <= 0){
          completeBoltburstRush(state, 'expired');
          continue;
        }
      }
      if(!(Number(state.remainingDashes) > 0)){
        completeBoltburstRush(state, 'complete');
      }
    }
  }

  function updateEmberWaltzCasts(dt){
    if(!emberWaltzCasts.length) return;
    const activeCastIds = new Set();
    for(const flame of emberWaltzFlames){
      if(flame && flame.castId !== undefined && flame.castId !== null){
        activeCastIds.add(flame.castId);
      }
    }
    for(let i = emberWaltzCasts.length - 1; i >= 0; i--){
      const cast = emberWaltzCasts[i];
      if(!cast){
        emberWaltzCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const lifetime = Math.max(0, Number(cast.lifetime) || 0);
      if(lifetime > 0 && cast.elapsed >= lifetime && !activeCastIds.has(cast.id)){
        emberWaltzCasts.splice(i, 1);
      }
    }
  }

  function updateEmberWaltzFlames(dt){
    for(let i = emberWaltzFlames.length - 1; i >= 0; i--){
      const flame = emberWaltzFlames[i];
      if(!flame){
        emberWaltzFlames.splice(i, 1);
        continue;
      }
      flame.age = Math.max(0, (Number(flame.age) || 0) + dt);
      const lifetime = Math.max(0, Number(flame.lifetime) || 0);
      if(lifetime > 0 && flame.age >= lifetime){
        emberWaltzFlames.splice(i, 1);
        continue;
      }
      const origin = getSpellOrigin(player);
      const prevX = Number.isFinite(flame.x) ? flame.x : origin.x;
      const prevY = Number.isFinite(flame.y) ? flame.y : origin.y;
      flame.prevX = prevX;
      flame.prevY = prevY;
      const orbitRadius = Math.max(0, Number(flame.orbitRadius) || 0);
      if(flame.state === 'orbit'){
        const angularSpeed = Math.max(0, Number(flame.angularSpeed) || EMBER_WALTZ_SPIN_SPEED);
        const nextAngle = (Number.isFinite(flame.angle) ? flame.angle : 0) + angularSpeed * dt;
        flame.angle = nextAngle;
        flame.x = origin.x + Math.cos(nextAngle) * orbitRadius;
        flame.y = origin.y + Math.sin(nextAngle) * orbitRadius;
        if(flame.age >= Math.max(0, Number(flame.seekDelay) || 0)){
          const target = findEmberWaltzTarget(flame.x, flame.y, flame.seekRange);
          if(target){
            flame.state = 'seek';
            flame.targetRef = target;
          }
        }
      } else {
        let target = flame.targetRef;
        if(target && target.hp <= 0){
          target = null;
          flame.targetRef = null;
        }
        if(!target){
          const reacquired = findEmberWaltzTarget(flame.x, flame.y, flame.seekRange);
          if(reacquired){
            target = reacquired;
            flame.targetRef = reacquired;
          }
        }
        const speed = Math.max(0, Number(flame.speed) || 0);
        if(target){
          const dx = target.x - flame.x;
          const dy = target.y - flame.y;
          const dist = Math.hypot(dx, dy);
          let dirX = Number(flame.dirX) || 0;
          let dirY = Number(flame.dirY) || 0;
          if(dist > 0.0001){
            dirX = dx / dist;
            dirY = dy / dist;
            flame.dirX = dirX;
            flame.dirY = dirY;
          }
          const travel = Math.min(dist, speed * dt);
          flame.x += dirX * travel;
          flame.y += dirY * travel;
          const remaining = Math.hypot(target.x - flame.x, target.y - flame.y);
          const impactRadius = emberWaltzTargetRadius(target) + 4;
          if(dist <= impactRadius || remaining <= impactRadius){
            applyEmberWaltzHit(flame, target);
            emberWaltzFlames.splice(i, 1);
            continue;
          }
        } else if(speed > 0){
          flame.x += (Number(flame.dirX) || 1) * speed * dt * 0.1;
          flame.y += (Number(flame.dirY) || 0) * speed * dt * 0.1;
        }
      }
    }
  }

  function updateSkyhookSwingCasts(dt){
    for(let i = skyhookSwingCasts.length - 1; i >= 0; i--){
      const swing = skyhookSwingCasts[i];
      if(!swing){
        skyhookSwingCasts.splice(i, 1);
        continue;
      }
      const caster = swing.casterRef || player;
      if(swing.completed){
        skyhookSwingCasts.splice(i, 1);
        continue;
      }

      if(swing.phase === 'hook'){
        swing.hookElapsed = Math.max(0, (Number(swing.hookElapsed) || 0) + dt);
        const duration = Math.max(0, Number(swing.hookDuration) || 0);
        swing.hookProgress = duration > 0 ? Math.max(0, Math.min(1, swing.hookElapsed / Math.max(duration, 0.0001))) : 1;
        if(swing.hookProgress >= 1){
          swing.phase = 'prep';
          swing.prepRemaining = Math.max(0, Number(swing.prepRemaining) || 0);
          if(caster === player){
            setHudMessage(`${swing.abilityName || 'Swing'} latched! Recast to swing.`);
          }
        }
        continue;
      }

      const controlled = (caster && ((Number(caster.stunTimer) > 0) || (Number(caster.knockupTimer) > 0) || (Number(caster.polymorphTimer) > 0)));
      if(swing.phase === 'prep'){
        if(controlled){
          finishSkyhookSwing(swing, { reason: 'control', skipFinalShot: true });
          continue;
        }
        swing.prepRemaining = Math.max(0, (Number(swing.prepRemaining) || 0) - dt);
        if(swing.prepRemaining <= 0){
          finishSkyhookSwing(swing, { reason: 'expired', skipFinalShot: true });
        }
        continue;
      }

      if(swing.phase === 'swing'){
        if(controlled){
          finishSkyhookSwing(swing, { reason: 'control' });
          continue;
        }
        swing.swingElapsed = Math.max(0, (Number(swing.swingElapsed) || 0) + dt);
        const unlock = Math.max(0, Number(swing.recastUnlock) || 0);
        if(!swing.allowLanding && swing.swingElapsed >= unlock){
          swing.allowLanding = true;
        }
        const radius = Math.max(player.r + 6, Number(swing.radius) || 0);
        const tangential = Math.max(0, Number(swing.swingSpeed) || 0);
        const angular = radius > 0 ? tangential / radius : 0;
        const prevX = Number.isFinite(swing.currentX) ? swing.currentX : caster.x;
        const prevY = Number.isFinite(swing.currentY) ? swing.currentY : caster.y;
        const baseAngle = Number.isFinite(swing.angle) ? swing.angle : Math.atan2(prevY - swing.anchorY, prevX - swing.anchorX);
        const nextAngle = baseAngle + angular * dt * (swing.clockwise ? -1 : 1);
        const desiredX = swing.anchorX + Math.cos(nextAngle) * radius;
        const desiredY = swing.anchorY + Math.sin(nextAngle) * radius;
        const moveX = desiredX - prevX;
        const moveY = desiredY - prevY;
        const moved = moveCircleWithCollision(prevX, prevY, moveX, moveY, caster.r || player.r);
        const intended = Math.hypot(moveX, moveY);
        const traveled = Math.hypot(moved.x - prevX, moved.y - prevY);
        swing.currentX = moved.x;
        swing.currentY = moved.y;
        swing.angle = Math.atan2(moved.y - swing.anchorY, moved.x - swing.anchorX);
        if(caster === player){
          player.x = moved.x;
          player.y = moved.y;
          player.target.x = moved.x;
          player.target.y = moved.y;
          player.navGoal = null;
          player.nav = null;
          player.chaseTarget = null;
        }
        const blocked = intended > 0.01 && traveled < intended * 0.35;
        if(blocked){
          finishSkyhookSwing(swing, { reason: 'blocked' });
          continue;
        }
        const swingDuration = Math.max(0, Number(swing.swingDuration) || 0);
        if(swingDuration > 0 && swing.swingElapsed >= swingDuration){
          finishSkyhookSwing(swing, { reason: 'expired' });
          continue;
        }
        const interval = Math.max(0, Number(swing.shotInterval) || 0);
        if(interval > 0){
          swing.shotTimer = Math.max(0, (Number(swing.shotTimer) || 0) + dt);
          while(swing.shotTimer >= interval){
            swing.shotTimer -= interval;
            fireSkyhookShot(swing, { finalShot: false });
          }
        }
      }
    }
  }

  function updateSnapbackEchoes(dt){
    for(let i = snapbackEchoes.length - 1; i >= 0; i--){
      const echo = snapbackEchoes[i];
      if(!echo){
        snapbackEchoes.splice(i, 1);
        continue;
      }
      let state = echo.state || 'delay';
      if(state === 'delay'){
        echo.delayRemaining = Math.max(0, (Number(echo.delayRemaining) || 0) - dt);
        if(echo.delayRemaining > 0){
          continue;
        }
        echo.state = 'return';
        state = 'return';
      }
      if(state === 'return'){
        const startX = Number.isFinite(echo.x) ? echo.x : echo.startX;
        const startY = Number.isFinite(echo.y) ? echo.y : echo.startY;
        const caster = echo.casterRef || player;
        const targetOrigin = getSpellOrigin(caster);
        const speed = Math.max(0, Number(echo.speed) || 0);
        if(!(speed > 0)){
          snapbackEchoes.splice(i, 1);
          continue;
        }
        const dx = targetOrigin.x - startX;
        const dy = targetOrigin.y - startY;
        const dist = Math.hypot(dx, dy);
        if(!(dist > 0.0001)){
          applySnapbackArrival(echo, targetOrigin.x, targetOrigin.y);
          snapbackEchoes.splice(i, 1);
          continue;
        }
        const dirX = dx / dist;
        const dirY = dy / dist;
        const travel = Math.min(dist, speed * dt);
        const nextX = startX + dirX * travel;
        const nextY = startY + dirY * travel;
        applySnapbackSegmentHits(echo, startX, startY, nextX, nextY);
        echo.prevX = startX;
        echo.prevY = startY;
        echo.x = nextX;
        echo.y = nextY;
        if(travel + 0.0001 >= dist){
          applySnapbackArrival(echo, targetOrigin.x, targetOrigin.y);
          snapbackEchoes.splice(i, 1);
        }
        continue;
      }
      snapbackEchoes.splice(i, 1);
    }
  }

  function updateChronoLoopGrenades(dt){
    for(let i = chronoLoopGrenades.length - 1; i >= 0; i--){
      const loop = chronoLoopGrenades[i];
      if(!loop){
        chronoLoopGrenades.splice(i, 1);
        continue;
      }
      if(loop.state === 'outbound'){
        const speed = Math.max(0, Number(loop.speed) || 0);
        if(!(speed > 0)){
          chronoLoopGrenades.splice(i, 1);
          continue;
        }
        const dirX = Number(loop.dirX) || 1;
        const dirY = Number(loop.dirY) || 0;
        const travel = Math.max(0, speed * dt);
        const remaining = Math.max(0, Number(loop.maxDistance) || 0) - (Number(loop.distanceTraveled) || 0);
        const actualTravel = remaining > 0 ? Math.min(travel, remaining) : travel;
        const nextX = (Number(loop.x) || Number(loop.startX) || 0) + dirX * actualTravel;
        const nextY = (Number(loop.y) || Number(loop.startY) || 0) + dirY * actualTravel;
        const { hits } = collectTwinstrikeSegmentHits(loop.x, loop.y, nextX, nextY, loop.width);
        let triggered = false;
        for(const entry of hits){
          const target = entry && entry.target;
          if(!target || loop.hitTargetsOutbound.has(target)) continue;
          applyChronoLoopDamage(loop, target, Number(loop.outboundDamage) || 0);
          loop.hitTargetsOutbound.add(target);
          loop.outboundHitCount = (loop.outboundHitCount || 0) + 1;
          triggered = true;
        }
        loop.x = nextX;
        loop.y = nextY;
        loop.distanceTraveled = (Number(loop.distanceTraveled) || 0) + actualTravel;
        const reachedDistance = Number(loop.maxDistance) > 0 && loop.distanceTraveled >= loop.maxDistance;
        if(triggered || reachedDistance){
          if(loop.fieldDistance > 0 || loop.fieldTimer > 0 || loop.fieldRadius > 0){
            startChronoLoopField(loop);
          } else {
            startChronoLoopReturn(loop);
          }
        }
        continue;
      }
      if(loop.state === 'field'){
        const fieldSpeed = Math.max(0, Number(loop.speed) || 0);
        const travel = Math.max(0, fieldSpeed * dt);
        let actualTravel = travel;
        if(Number(loop.fieldRemaining) > 0){
          actualTravel = Math.min(travel, loop.fieldRemaining);
          loop.fieldRemaining = Math.max(0, loop.fieldRemaining - actualTravel);
        }
        const dirX = Number(loop.dirX) || 1;
        const dirY = Number(loop.dirY) || 0;
        const posX = Number(loop.x) || Number(loop.startX) || 0;
        const posY = Number(loop.y) || Number(loop.startY) || 0;
        loop.x = posX + dirX * actualTravel;
        loop.y = posY + dirY * actualTravel;
        loop.fieldTimer = Math.max(0, (Number(loop.fieldTimer) || 0) - dt);
        applyChronoLoopFieldSlow(loop);
        if((loop.fieldRemaining <= 0 && loop.fieldTimer <= 0) || loop.fieldRemaining <= 0 || loop.fieldTimer <= 0){
          startChronoLoopReturn(loop);
        }
        continue;
      }
      if(loop.state === 'return'){
        const speedReturn = Math.max(0, Number(loop.speed) || 0);
        if(!(speedReturn > 0)){
          chronoLoopGrenades.splice(i, 1);
          continue;
        }
        const caster = loop.casterRef || player;
        const origin = getSpellOrigin(caster);
        const startX = Number(loop.x) || Number(loop.startX) || 0;
        const startY = Number(loop.y) || Number(loop.startY) || 0;
        let dx = origin.x - startX;
        let dy = origin.y - startY;
        const dist = Math.hypot(dx, dy);
        if(!(dist > 0.0001)){
          finishChronoLoop(loop, i, origin.x, origin.y);
          continue;
        }
        const travel = Math.min(speedReturn * dt, dist);
        const nextX = startX + (dx / dist) * travel;
        const nextY = startY + (dy / dist) * travel;
        const { hits } = collectTwinstrikeSegmentHits(startX, startY, nextX, nextY, loop.width);
        for(const entry of hits){
          const target = entry && entry.target;
          if(!target || loop.hitTargetsReturn.has(target)) continue;
          applyChronoLoopDamage(loop, target, Number(loop.returnDamage) || 0);
          loop.hitTargetsReturn.add(target);
          loop.returnHitCount = (loop.returnHitCount || 0) + 1;
        }
        loop.x = nextX;
        loop.y = nextY;
        if(travel + 0.0001 >= dist){
          finishChronoLoop(loop, i, origin.x, origin.y);
        }
        continue;
      }
      chronoLoopGrenades.splice(i, 1);
    }
  }

  function updateTwinstrikeCasts(dt){
    for(let i = twinstrikeCasts.length - 1; i >= 0; i--){
      const cast = twinstrikeCasts[i];
      if(!cast){
        twinstrikeCasts.splice(i, 1);
        continue;
      }
      const state = cast.state || 'recast_ready';
      if(state === 'windup'){
        cast.windupRemaining = Math.max(0, (Number(cast.windupRemaining) || 0) - dt);
        if(cast.windupRemaining <= 0){
          const hitCount = executeTwinstrikeDash(cast, 'first');
          if(hitCount === false){
            completeTwinstrikeCast(cast, 'failed_first', { applyCooldown: false });
          } else {
            afterTwinstrikeFirstDash(cast, hitCount);
          }
        }
        continue;
      }
      if(state === 'recast_locked' || state === 'recast_ready'){
        if(Number.isFinite(cast.recastRemaining)){
          cast.recastRemaining = Math.max(0, cast.recastRemaining - dt);
          if(cast.recastRemaining <= 0){
            completeTwinstrikeCast(cast, 'expired', {
              message: cast.casterRef === player ? `${cast.abilityName || 'Twinstrike'} recast window closed.` : null
            });
            continue;
          }
        }
        if(state === 'recast_locked'){
          cast.recastUnlockRemaining = Math.max(0, (Number(cast.recastUnlockRemaining) || 0) - dt);
          if(cast.recastUnlockRemaining <= 0){
            cast.state = 'recast_ready';
            if(cast.casterRef === player && !cast.recastReadyNotified){
              const windowText = cast.recastRemaining > 0 ? formatSeconds(cast.recastRemaining * 1000) : null;
              setHudMessage(`${cast.abilityName || 'Twinstrike'} recast ready${windowText ? ` (${windowText} left)` : ''}.`);
              cast.recastReadyNotified = true;
            }
          }
        }
        continue;
      }
      if(state === 'complete'){
        twinstrikeCasts.splice(i, 1);
      }
    }
  }

  function updateTwinstrikeTrails(dt){
    for(let i = twinstrikeTrails.length - 1; i >= 0; i--){
      const trail = twinstrikeTrails[i];
      if(!trail){
        twinstrikeTrails.splice(i, 1);
        continue;
      }
      trail.age = Math.max(0, (Number(trail.age) || 0) + dt);
      const duration = Math.max(0, Number(trail.duration) || 0.4);
      if(trail.age >= duration){
        twinstrikeTrails.splice(i, 1);
      }
    }
  }

  function updateScatterChargeCasts(dt){
    for(let i = scatterChargeCasts.length - 1; i >= 0; i--){
      const cast = scatterChargeCasts[i];
      if(!cast){
        scatterChargeCasts.splice(i, 1);
        continue;
      }
      if(cast.casterRef){
        const casterOrigin = getSpellOrigin(cast.casterRef);
        cast.originX = casterOrigin.x;
        cast.originY = casterOrigin.y;
      }
      cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(duration <= 0 || cast.elapsed >= duration){
        scatterChargeCasts.splice(i, 1);
        launchScatterCharge(cast);
      }
    }
  }

  function updateScatterCharges(dt){
    for(let i = scatterCharges.length - 1; i >= 0; i--){
      const charge = scatterCharges[i];
      if(!charge){
        scatterCharges.splice(i, 1);
        continue;
      }
      if(charge.detonated){
        scatterCharges.splice(i, 1);
        continue;
      }
      if(charge.state === 'flying'){
        const travelDistance = Math.max(0, Number(charge.travelDistance) || 0);
        const speed = Math.max(0, Number(charge.speed) || 0);
        const prevTraveled = Math.max(0, Number(charge.traveled) || 0);
        const nextTraveled = Math.min(travelDistance, speed > 0 ? prevTraveled + speed * dt : travelDistance);
        const dirX = Number(charge.dirX) || 0;
        const dirY = Number(charge.dirY) || 0;
        charge.traveled = nextTraveled;
        charge.currentX = charge.startX + dirX * nextTraveled;
        charge.currentY = charge.startY + dirY * nextTraveled;
        if(nextTraveled >= travelDistance - 0.0001){
          charge.state = 'armed';
          charge.age = 0;
          charge.currentX = charge.destX;
          charge.currentY = charge.destY;
          if(charge.detonateOnLanding || charge.lifetime <= 0){
            detonateScatterCharge(charge, { cause: 'landing' });
            continue;
          }
        }
      } else {
        charge.age = Math.max(0, (Number(charge.age) || 0) + dt);
        if(charge.lifetime > 0 && charge.age >= charge.lifetime){
          detonateScatterCharge(charge, { cause: 'timeout' });
          continue;
        }
      }
    }
  }

  function updateSlingshotCrashCasts(dt){
    for(let i = slingshotCrashCasts.length - 1; i >= 0; i--){
      const cast = slingshotCrashCasts[i];
      if(!cast){
        slingshotCrashCasts.splice(i, 1);
        continue;
      }
      cast.chargeElapsed = Math.max(0, (Number(cast.chargeElapsed) || 0) + dt);
      const maxCharge = Math.max(0, Number(cast.chargeDuration) || 0);
      if(!(maxCharge > 0)){
        const launched = launchSlingshotCrash(cast, { auto: true });
        if(launched && Number(cast.cooldownSeconds) > 0){
          setAbilitySlotCooldown(cast.slotIndex, Math.max(0, Number(cast.cooldownSeconds) || 0));
        }
        continue;
      }
      if(cast.chargeElapsed >= maxCharge){
        launchSlingshotCrash(cast, { timedOut: true });
      }
    }
  }

  function updateSpringquakeCasts(dt){
    for(let i = springquakeCasts.length - 1; i >= 0; i--){
      const cast = springquakeCasts[i];
      if(!cast){
        springquakeCasts.splice(i, 1);
        continue;
      }
      if(cast.ended){
        springquakeCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.polymorphTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        endSpringquakeCast(cast, { reason: 'interrupted' });
        springquakeCasts.splice(i, 1);
        continue;
      }
      const totalBounces = Math.max(1, Math.floor(Number(cast.bounceCount) || 0));
      cast.bounceCount = totalBounces;
      if(cast.state === 'windup'){
        cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        if(cast.elapsed >= duration){
          beginSpringquakeActive(cast);
        }
        continue;
      }
      if(cast.state !== 'active'){
        springquakeCasts.splice(i, 1);
        continue;
      }
      cast.activeElapsed = Math.max(0, (Number(cast.activeElapsed) || 0) + dt);
      const totalDuration = Math.max(0, Number(cast.totalDuration) || 0);
      const moveStart = Number.isFinite(cast.moveSpeedStart) ? Math.max(0, cast.moveSpeedStart) : 1;
      const moveEnd = Number.isFinite(cast.moveSpeedEnd) ? Math.max(0, cast.moveSpeedEnd) : moveStart;
      const rampT = totalDuration > 0 ? Math.min(1, cast.activeElapsed / totalDuration) : 1;
      cast.movementSpeedMultiplier = moveStart + (moveEnd - moveStart) * rampT;
      if(!Number.isFinite(cast.nextBounceTime)){
        cast.nextBounceTime = cast.bouncesFired > 0 ? cast.bounceInterval * cast.bouncesFired : cast.bounceInterval;
      }
      while(cast.bouncesFired < totalBounces && cast.activeElapsed + 1e-4 >= cast.nextBounceTime){
        performSpringquakeBounce(cast);
        cast.bouncesFired += 1;
        cast.nextBounceTime += cast.bounceInterval;
      }

      const buffer = Math.max(0, Number(cast.bounceInterval) || 0) * 0.25;
      const finished = cast.bouncesFired >= totalBounces || cast.activeElapsed >= totalDuration + buffer;
      if(finished){
        endSpringquakeCast(cast, { reason: 'complete' });
        springquakeCasts.splice(i, 1);
      }
    }
  }

  function updateShadowPursuitCasts(dt){
    playerRuntime.shadowPursuitMoveMult = 1;
    playerRuntime.shadowPursuitActive = false;
    for(let i = shadowPursuitCasts.length - 1; i >= 0; i--){
      const cast = shadowPursuitCasts[i];
      if(!cast){
        shadowPursuitCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0){
        endVeilHuntCast(cast, { reason: 'dead', silent: true });
        shadowPursuitCasts.splice(i, 1);
        continue;
      }
      if(cast.state === 'windup'){
        cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        if(cast.elapsed >= duration){
          beginVeilHuntActive(cast);
        }
        continue;
      }
      if(cast.state !== 'active'){
        shadowPursuitCasts.splice(i, 1);
        continue;
      }
      cast.activeElapsed = Math.max(0, (Number(cast.activeElapsed) || 0) + dt);
      const recastDelay = Math.max(0, Number(cast.recastDelay) || 0);
      if(!cast.recastReady && cast.activeElapsed >= recastDelay){
        cast.recastReady = true;
      }
      const nearCover = isVeilHuntNearCover(caster, cast.nearCoverRange);
      cast.nearCover = nearCover;
      if(nearCover){
        cast.awayTimer = 0;
      } else {
        cast.awayTimer = Math.max(0, (Number(cast.awayTimer) || 0) + dt);
      }
      const linger = Math.max(0, Number(cast.lingerDuration) || 0);
      if(linger > 0 && cast.awayTimer >= linger){
        endVeilHuntCast(cast, { reason: 'outOfCover' });
        shadowPursuitCasts.splice(i, 1);
        continue;
      }
      const trailRange = Math.max(0, Number(cast.trailRange) || 0);
      cast.trackedTarget = findVeilHuntTarget(caster, trailRange);
      const hasTarget = !!(cast.trackedTarget && (cast.trackedTarget.hp === undefined || Number(cast.trackedTarget.hp) > 0));
      const baseSpeed = Math.max(1, Number(caster.speed) || 1);
      const moveMult = hasTarget && cast.speedBonus > 0
        ? 1 + Math.max(0, Number(cast.speedBonus) || 0) / baseSpeed
        : 1;
      cast.moveMult = moveMult;
      if(caster === player){
        playerRuntime.shadowPursuitActive = true;
        playerRuntime.shadowPursuitMoveMult = Math.max(playerRuntime.shadowPursuitMoveMult || 1, moveMult);
      }
    }
    if(!playerRuntime.shadowPursuitActive){
      playerRuntime.shadowPursuitMoveMult = 1;
    }
  }

  function updateChargingGaleCasts(dt){
    for(let i = chargingGaleCasts.length - 1; i >= 0; i--){
      const cast = chargingGaleCasts[i];
      if(!cast){
        chargingGaleCasts.splice(i, 1);
        continue;
      }
      const cooldownSeconds = Number.isFinite(cast.cooldownSeconds)
        ? Math.max(0, Number(cast.cooldownSeconds) || 0)
        : 0;
      let justStartedCharging = false;
      if(cast.state === 'windup'){
        const duration = Math.max(0, Number(cast.castTime) || 0);
        cast.castElapsed = Math.max(0, (Number(cast.castElapsed) || 0) + dt);
        if(duration <= 0 || cast.castElapsed >= duration){
          const overflow = Math.max(0, cast.castElapsed - duration);
          cast.state = 'charging';
          cast.chargeElapsed = overflow;
          justStartedCharging = true;
          if(cast.casterRef === player){
            setHudMessage(`${cast.abilityName || 'Charging Gale'} charging...`);
          }
        } else {
          continue;
        }
      }
      if(!justStartedCharging){
        cast.chargeElapsed = Math.max(0, (Number(cast.chargeElapsed) || 0) + dt);
      }
      const maxCharge = Math.max(0, Number(cast.chargeDuration) || 0);
      if(!(maxCharge > 0)){
        if(releaseChargingGale(cast)){
          setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
        }
        continue;
      }
      if(cast.chargeElapsed >= maxCharge){
        if(releaseChargingGale(cast)){
          setAbilitySlotCooldown(cast.slotIndex, cooldownSeconds);
        }
      }
    }
  }

  function updateScoutflareBombCasts(dt){
    if(!scoutflareBombCasts.length) return;
    for(let i = scoutflareBombCasts.length - 1; i >= 0; i--){
      const cast = scoutflareBombCasts[i];
      if(!cast){
        scoutflareBombCasts.splice(i, 1);
        continue;
      }
      const remaining = Number.isFinite(cast.fuseRemaining)
        ? Number(cast.fuseRemaining)
        : (Number.isFinite(cast.fuseSeconds) ? Number(cast.fuseSeconds) : null);
      if(remaining !== null){
        const nextFuse = Math.max(0, remaining - dt);
        cast.fuseRemaining = nextFuse;
        if(nextFuse <= 0){
          detonateScoutflareBomb(cast);
          scoutflareBombCasts.splice(i, 1);
          continue;
        }
      }
    }
  }

  function applyScoutflareBombDamage(cast, impactX, impactY){
    if(!cast) return;
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const damage = Math.max(0, Number(cast.impactDamage || cast.damage) || 0);
    if(!(radius > 0) || !(damage > 0)) return;
    const radiusSq = (radius + minionRadius) * (radius + minionRadius);
    let hits = 0;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const dx = m.x - impactX;
      const dy = m.y - impactY;
      if(dx * dx + dy * dy > radiusSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(prevHp <= 0) continue;
      m.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(m.x, m.y - minionRadius, damage);
      hits++;
    }
    if(isMonsterAttackable(monsterState)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
      const dx = monsterState.x - impactX;
      const dy = monsterState.y - impactY;
      if(dx * dx + dy * dy <= (radius + monsterRadius) * (radius + monsterRadius)){
        const prevHp = Number(monsterState.hp) || 0;
        if(prevHp > 0){
          monsterState.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monsterState.x, monsterState.y - monsterRadius, damage);
          hits++;
          updateMonsterHud();
        }
      }
    }
    if(hits > 0 && cast.casterRef === player){
      const abilityName = cast.abilityName || 'Scoutflare';
      const plural = hits === 1 ? '' : 's';
      setHudMessage(`${abilityName} hit ${hits} target${plural}.`);
    }
  }

  function detonateScoutflareBomb(cast){
    if(!cast) return;
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const impactX = Number.isFinite(cast.targetX) ? cast.targetX : (Number.isFinite(cast.projectileX) ? cast.projectileX : cast.originX);
    const impactY = Number.isFinite(cast.targetY) ? cast.targetY : (Number.isFinite(cast.projectileY) ? cast.projectileY : cast.originY);
    const visionRadius = Math.max(0, Number(cast.impactVisionRadius) || 0);
    const visionDuration = Math.max(0, Number(cast.impactVisionDuration) || 0);
    if(visionRadius > 0 && visionDuration > 0){
      spawnScoutflareVisionSource(impactX, impactY, visionRadius, visionDuration);
    }
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const endRadius = Math.max(radius + 20, radius * 1.4);
    flash(impactX, impactY, { startRadius: Math.max(12, radius * 0.35), endRadius, color: '#ffd27f' });
    applyScoutflareBombDamage(cast, impactX, impactY);
  }

  function drawScoutflareTelegraphs(){
    if(!scoutflareBombCasts.length) return;
    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#ffd27f66';
    for(const cast of scoutflareBombCasts){
      if(!cast) continue;
      const radius = Math.max(0, Number(cast.impactRadius) || 0);
      if(!(radius > 0)) continue;
      const targetX = Number.isFinite(cast.targetX) ? cast.targetX : (Number.isFinite(cast.projectileX) ? cast.projectileX : cast.originX);
      const targetY = Number.isFinite(cast.targetY) ? cast.targetY : (Number.isFinite(cast.projectileY) ? cast.projectileY : cast.originY);
      if(!Number.isFinite(targetX) || !Number.isFinite(targetY)) continue;
      ctx.beginPath();
      ctx.arc(targetX, targetY, radius, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawScoutflareProjectiles(){
    if(!scoutflareProjectiles.length) return;
    ctx.save();
    ctx.fillStyle = '#ffd27f';
    for(const proj of scoutflareProjectiles){
      if(!proj) continue;
      const px = Number.isFinite(proj.x) ? proj.x : Number(proj.currentX);
      const py = Number.isFinite(proj.y) ? proj.y : Number(proj.currentY);
      const pr = Math.max(3, Number(proj.radius) || 6);
      if(!Number.isFinite(px) || !Number.isFinite(py)) continue;
      ctx.beginPath();
      ctx.arc(px, py, pr, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function castConvergingGaleAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Converging Gale';
    const cooldownSeconds = abilityCooldownSeconds(ability);
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'targetRangePx')) || 0);
    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a target range.`);
      return false;
    }
    const blastDamage = Math.max(0, Number(abilityFieldValue(ability, 'blastDamage')) || 0);
    const blastWidth = Math.max(0, Number(abilityFieldValue(ability, 'blastWidthPx')) || 0);
    const blastSpeed = Math.max(0, Number(abilityFieldValue(ability, 'blastSpeedPxS')) || 0);
    const blastArcRadius = Math.max(0, Number(abilityFieldValue(ability, 'blastArcRadiusPx')) || 0);
    const blastSideOffset = Math.max(0, Number(abilityFieldValue(ability, 'blastSideOffsetPx')) || 0);
    if(!(blastWidth > 0) || !(blastSpeed > 0)){
      setHudMessage(`${abilityName} needs blast tuning.`);
      return false;
    }
    const tornadoRadius = Math.max(0, Number(abilityFieldValue(ability, 'tornadoRadiusPx')) || 0);
    const tornadoDurationMs = Math.max(0, Number(abilityFieldValue(ability, 'tornadoDurationMs')) || 0);
    const tornadoTickIntervalMs = Math.max(0, Number(abilityFieldValue(ability, 'tornadoTickIntervalMs')) || 0);
    if(!(tornadoRadius > 0) || !(tornadoDurationMs > 0) || !(tornadoTickIntervalMs > 0)){
      setHudMessage(`${abilityName} needs tornado tuning.`);
      return false;
    }
    const tornadoHitPct = Math.max(0, Number(abilityFieldValue(ability, 'tornadoHitPct')) || 0);
    const tornadoMonsterCap = Math.max(0, Number(abilityFieldValue(ability, 'tornadoMonsterCap')) || 0);
    const tornadoMoveSpeed = Math.max(0, Number(abilityFieldValue(ability, 'tornadoMoveSpeedPxS')) || 0);

    const origin = getSpellOrigin(player);
    const aimPoint = typeof skillshotAimPoint === 'function' ? skillshotAimPoint() : beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(maxRange > 0 && distance > maxRange){
      const scale = maxRange / distance;
      dx *= scale;
      dy *= scale;
      distance = maxRange;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      const clampRadius = Math.max(blastSideOffset, tornadoRadius);
      targetX = Math.max(clampRadius, Math.min(mapState.width - clampRadius, targetX));
      targetY = Math.max(clampRadius, Math.min(mapState.height - clampRadius, targetY));
      const adjDx = targetX - origin.x;
      const adjDy = targetY - origin.y;
      const adjDist = Math.hypot(adjDx, adjDy);
      if(adjDist > 0.0001){
        dx = adjDx;
        dy = adjDy;
        distance = adjDist;
      }
    }
    const dirLen = Math.hypot(dx, dy) || 1;
    const dirX = dx / dirLen;
    const dirY = dy / dirLen;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      abilityRef: ability,
      casterRef: player,
      targetX,
      targetY,
      dirX,
      dirY,
      castDuration,
      elapsed: 0,
      state: castDuration > 0 ? 'windup' : 'ready',
      cooldownSeconds,
      blastDamage,
      blastWidth,
      blastSpeed,
      blastArcRadius,
      blastSideOffset,
      tornadoRadius,
      tornadoDurationMs,
      tornadoTickIntervalMs,
      tornadoHitPct,
      tornadoMonsterCap,
      tornadoMoveSpeed
    };

    convergingGaleCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    if(cast.state === 'windup'){
      player.casting = cast;
      setHudMessage(`${abilityName} charging...`);
    } else {
      launchConvergingGale(cast);
    }
    return true;
  }

  function launchConvergingGale(cast){
    if(!cast) return false;
    const ability = cast.abilityRef;
    const caster = cast.casterRef || player;
    if(!caster || !ability) return false;
    const abilityName = cast.abilityName || 'Converging Gale';
    const origin = getSpellOrigin(caster);
    const targetX = Number.isFinite(cast.targetX) ? cast.targetX : origin.x;
    const targetY = Number.isFinite(cast.targetY) ? cast.targetY : origin.y;
    const dirX = Number(cast.dirX) || 1;
    const dirY = Number(cast.dirY) || 0;
    const dirLen = Math.hypot(dirX, dirY) || 1;
    const normDirX = dirX / dirLen;
    const normDirY = dirY / dirLen;
    const perpX = -normDirY;
    const perpY = normDirX;

    const blastDamage = Math.max(0, Number(cast.blastDamage) || 0);
    const blastWidth = Math.max(0, Number(cast.blastWidth) || 0);
    const blastSpeed = Math.max(0, Number(cast.blastSpeed) || 0);
    const blastArcRadius = Math.max(0, Number(cast.blastArcRadius) || 0);
    const blastSideOffset = Math.max(0, Number(cast.blastSideOffset) || 0);
    const tornadoRadius = Math.max(0, Number(cast.tornadoRadius) || 0);
    const tornadoDuration = Math.max(0, Number(cast.tornadoDurationMs) || 0) / 1000;
    const tornadoTickInterval = Math.max(0.01, Number(cast.tornadoTickIntervalMs) || 0) / 1000;
    const tornadoMoveSpeed = Math.max(0, Number(cast.tornadoMoveSpeed) || 0);
    const tornadoHitPct = Math.max(0, Number(cast.tornadoHitPct) || 0);
    const tornadoMonsterCap = Math.max(0, Number(cast.tornadoMonsterCap) || 0);

    if(!(blastWidth > 0) || !(blastSpeed > 0) || !(blastDamage > 0)){
      setHudMessage(caster === player, `${abilityName} fizzled.`);
      if(caster === player && player.casting === cast){
        player.casting = null;
      }
      const idx = convergingGaleCasts.indexOf(cast);
      if(idx >= 0){
        convergingGaleCasts.splice(idx, 1);
      }
      return false;
    }

    const trigger = {
      id: `gale-${abilityRuntime.convergingGaleSequence++}`,
      abilityId: cast.abilityId,
      abilityName,
      casterRef: caster,
      targetX,
      targetY,
      dirX: normDirX,
      dirY: normDirY,
      radius: tornadoRadius,
      duration: tornadoDuration,
      tickInterval: tornadoTickInterval,
      damageFrac: tornadoHitPct / 100,
      monsterCap: tornadoMonsterCap,
      moveSpeed: tornadoMoveSpeed,
      pending: 0,
      launched: false
    };

    let spawned = 0;
    for(const side of [-1, 1]){
      const startX = origin.x + perpX * blastSideOffset * side;
      const startY = origin.y + perpY * blastSideOffset * side;
      const dx = targetX - startX;
      const dy = targetY - startY;
      const dist = Math.hypot(dx, dy);
      if(!(dist > 0.0001)){
        continue;
      }
      const travelTime = blastSpeed > 0 ? dist / blastSpeed : 0.0001;
      const blast = {
        id: `${trigger.id}-${side === 1 ? 'right' : 'left'}`,
        abilityId: cast.abilityId,
        abilityName,
        casterRef: caster,
        startX,
        startY,
        prevX: startX,
        prevY: startY,
        currentX: startX,
        currentY: startY,
        targetX,
        targetY,
        dirX: normDirX,
        dirY: normDirY,
        perpX,
        perpY,
        sideSign: side,
        distance: dist,
        travelTime: Math.max(0.0001, travelTime),
        elapsed: 0,
        width: blastWidth,
        damage: blastDamage,
        arcRadius: blastArcRadius,
        hitTargets: new Set(),
        monsterHits: new Set(),
        triggerRef: trigger
      };
      convergingGaleBlasts.push(blast);
      spawned++;
    }

    if(!spawned){
      setHudMessage(caster === player, `${abilityName} fizzled.`);
      if(caster === player && player.casting === cast){
        player.casting = null;
      }
      return false;
    }

    trigger.pending = spawned;
    if(Number.isFinite(cast.slotIndex)){
      const cd = Math.max(0, Number(cast.cooldownSeconds) || abilityCooldownSeconds(ability));
      setAbilitySlotCooldown(cast.slotIndex, cd);
    }
    const idx = convergingGaleCasts.indexOf(cast);
    if(idx >= 0){
      convergingGaleCasts.splice(idx, 1);
    }
    if(caster === player && player.casting === cast){
      player.casting = null;
    }
    flash(origin.x, origin.y, { startRadius: 12, endRadius: 34, color: '#bde7ff' });
    if(caster === player){
      setHudMessage(`${abilityName} blasts unleashed!`);
    }
    return true;
  }

  function applyConvergingGaleBlastHit(blast, target, hitX, hitY, targetRadius){
    if(!blast || !target) return false;
    const damage = Math.max(0, Number(blast.damage) || 0);
    if(!(damage > 0)){
      return false;
    }
    const prevHp = Number(target.hp) || 0;
    target.hp = Math.max(0, prevHp - damage);
    if(typeof targetRadius !== 'number'){
      targetRadius = minionRadius;
    }
    spawnHitSplat(target.x, target.y - targetRadius, damage);
    handlePracticeDummyDamage(target, prevHp);
    if(blast.hitTargets && typeof blast.hitTargets.add === 'function'){
      blast.hitTargets.add(target);
    }
    flash(hitX, hitY, { startRadius: 8, endRadius: 20, color: '#bde7ff' });
    return true;
  }

  function applyConvergingGaleMonsterHit(blast, monster, hitX, hitY){
    if(!blast || !monster) return false;
    const damage = Math.max(0, Number(blast.damage) || 0);
    if(!(damage > 0)){
      return false;
    }
    const prevHp = Math.max(0, Number(monster.hp) || 0);
    monster.hp = Math.max(0, prevHp - damage);
    const radius = Math.max(minionRadius, monsterAttackRadius(monster));
    spawnHitSplat(monster.x, monster.y - radius, damage);
    updateMonsterHud();
    if(blast.monsterHits && typeof blast.monsterHits.add === 'function'){
      blast.monsterHits.add(monster);
    }
    flash(hitX, hitY, { startRadius: 10, endRadius: 24, color: '#d1f2ff' });
    return true;
  }

  function spawnConvergingGaleTornado(trigger){
    if(!trigger || trigger.launched) return false;
    trigger.launched = true;
    if(!(trigger.radius > 0) || !(trigger.duration > 0) || !(trigger.tickInterval > 0)){
      return false;
    }
    const tornado = {
      abilityId: trigger.abilityId,
      abilityName: trigger.abilityName,
      casterRef: trigger.casterRef,
      centerX: trigger.targetX,
      centerY: trigger.targetY,
      dirX: trigger.dirX,
      dirY: trigger.dirY,
      radius: trigger.radius,
      duration: trigger.duration,
      elapsed: 0,
      tickInterval: trigger.tickInterval,
      tickTimer: 0,
      damageFrac: Math.max(0, Number(trigger.damageFrac) || 0),
      monsterCap: trigger.monsterCap,
      moveSpeed: trigger.moveSpeed
    };
    convergingGaleTornadoes.push(tornado);
    flash(trigger.targetX, trigger.targetY, { startRadius: Math.max(12, tornado.radius * 0.3), endRadius: tornado.radius + 28, color: '#9fe8ff' });
    if(trigger.casterRef === player){
      setHudMessage(`${trigger.abilityName || 'Converging Gale'} hurricane formed!`);
    }
    return true;
  }

  function applyConvergingGaleTornadoDamage(tornado){
    if(!tornado) return 0;
    const radius = Math.max(0, Number(tornado.radius) || 0);
    if(!(radius > 0)) return 0;
    const damageFrac = Math.max(0, Number(tornado.damageFrac) || 0);
    if(!(damageFrac > 0)) return 0;
    const effectiveRadius = radius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;
    for(const m of minions){
      if(!m || !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const dx = m.x - tornado.centerX;
      const dy = m.y - tornado.centerY;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      const maxHp = Math.max(0, Number(m.maxHp) || 0);
      const damage = Math.max(0, Math.round(maxHp * damageFrac));
      if(damage <= 0) continue;
      m.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(m.x, m.y - minionRadius, damage);
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }
    if(monsterState && isMonsterAttackable(monsterState)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monsterState));
      const dx = monsterState.x - tornado.centerX;
      const dy = monsterState.y - tornado.centerY;
      const limit = radius + monsterRadius;
      if(dx * dx + dy * dy <= limit * limit){
        const prevHp = Math.max(0, Number(monsterState.hp) || 0);
        const maxHp = Math.max(0, Number(monsterState.maxHp) || 0);
        const baseDamage = Math.max(0, Math.round(maxHp * damageFrac));
        const capped = tornado.monsterCap > 0 ? Math.min(baseDamage, tornado.monsterCap) : baseDamage;
        if(capped > 0){
          monsterState.hp = Math.max(0, prevHp - capped);
          spawnHitSplat(monsterState.x, monsterState.y - monsterRadius, capped);
          updateMonsterHud();
          hits++;
        }
      }
    }
    return hits;
  }

  function drawConvergingGaleEffects(){
    if(!convergingGaleBlasts.length && !convergingGaleTornadoes.length) return;
    ctx.save();
    for(const blast of convergingGaleBlasts){
      if(!blast) continue;
      const radius = Math.max(4, (blast.width || 0) * 0.4);
      if(!circleInCamera(blast.currentX, blast.currentY, radius + 14)) continue;
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = '#bde7ff';
      ctx.lineWidth = Math.max(2, blast.width);
      ctx.beginPath();
      ctx.moveTo(blast.prevX, blast.prevY);
      ctx.lineTo(blast.currentX, blast.currentY);
      ctx.stroke();
      ctx.fillStyle = '#d8f3ff';
      ctx.beginPath();
      ctx.arc(blast.currentX, blast.currentY, radius, 0, Math.PI * 2);
      ctx.fill();
    }
    for(const tornado of convergingGaleTornadoes){
      if(!tornado) continue;
      const radius = Math.max(0, Number(tornado.radius) || 0);
      if(!(radius > 0) || !circleInCamera(tornado.centerX, tornado.centerY, radius + 16)) continue;
      ctx.globalAlpha = 0.25 + 0.2 * Math.sin((Number(tornado.elapsed) || 0) * 4);
      ctx.strokeStyle = '#9fe8ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(tornado.centerX, tornado.centerY, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#9fe8ff';
      ctx.beginPath();
      ctx.arc(tornado.centerX, tornado.centerY, radius * 0.85, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function castCelestialCrashAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }

    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Celestial Crash';
    const baseDelay = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0);
    const empoweredDelay = Math.max(0, Number(abilityFieldValue(ability, 'empoweredCastTimeMs')) || 0);
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const impactRadius = Math.max(0, Number(abilityFieldValue(ability, 'impactRadius')) || 0);
    const baseDamage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const stunDuration = Math.max(0, Number(abilityFieldValue(ability, 'stunDurationMs')) || 0) / 1000;
    const stardustPerHit = Math.max(0, Number(abilityFieldValue(ability, 'stardustPerHit')) || 0);
    const stardustThreshold = Math.max(0, Number(abilityFieldValue(ability, 'stardustThreshold')) || 0);
    const empoweredRadius = Math.max(impactRadius, Number(abilityFieldValue(ability, 'empoweredRadius')) || 0);
    const empoweredDamage = Math.max(0, Number(abilityFieldValue(ability, 'empoweredDamage')) || 0);
    const shockRadius = Math.max(0, Number(abilityFieldValue(ability, 'shockRadius')) || 0);
    const shockDamage = Math.max(0, Number(abilityFieldValue(ability, 'shockDamage')) || 0);
    const shockSlowPct = Math.max(0, Number(abilityFieldValue(ability, 'shockSlowPct')) || 0);
    const shockSlowDuration = Math.max(0, Number(abilityFieldValue(ability, 'shockSlowDurationMs')) || 0) / 1000;
    const shockDuration = Math.max(0, Number(abilityFieldValue(ability, 'shockDurationMs')) || 0) / 1000;

    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a target range.`);
      return false;
    }
    if(!(impactRadius > 0)){
      setHudMessage(`${abilityName} needs an impact radius.`);
      return false;
    }
    if(!(baseDamage > 0)){
      setHudMessage(`${abilityName} needs impact damage.`);
      return false;
    }

    const empowered = stardustThreshold > 0 && Number(celestialStardust.points) >= stardustThreshold;
    const castDuration = (empowered ? empoweredDelay : baseDelay) / 1000;
    const damage = empowered ? (empoweredDamage > 0 ? empoweredDamage : baseDamage) : baseDamage;
    const radius = empowered ? (empoweredRadius > 0 ? empoweredRadius : impactRadius) : impactRadius;

    const origin = getSpellOrigin(player);
    const aimPoint = typeof skillshotAimPoint === 'function' ? skillshotAimPoint() : beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(maxRange > 0 && distance > maxRange){
      const scale = maxRange / distance;
      dx *= scale;
      dy *= scale;
      distance = maxRange;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      const clampRadius = Math.max(radius, 0);
      targetX = Math.max(clampRadius, Math.min(mapState.width - clampRadius, targetX));
      targetY = Math.max(clampRadius, Math.min(mapState.height - clampRadius, targetY));
      const adjDx = targetX - origin.x;
      const adjDy = targetY - origin.y;
      const adjDist = Math.hypot(adjDx, adjDy);
      if(adjDist > 0.0001){
        dx = adjDx;
        dy = adjDy;
        distance = adjDist;
      }
    }
    const dirLen = Math.hypot(dx, dy) || 1;
    const dirX = dx / dirLen;
    const dirY = dy / dirLen;

    const cast = {
      slotIndex,
      abilityId: ability.id,
      abilityName,
      casterRef: player,
      targetX,
      targetY,
      dirX,
      dirY,
      distance,
      impactRadius: radius,
      damage,
      stunDuration,
      castDuration,
      elapsed: 0,
      state: castDuration > 0 ? 'windup' : 'impact',
      empowered,
      stardustPerHit,
      stardustThreshold,
      shockRadius,
      shockDamage,
      shockSlowPct,
      shockSlowDuration,
      shockDuration
    };

    celestialCrashCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(cast.state === 'windup'){
      player.casting = cast;
      setHudMessage(`${abilityName} descending...`);
    } else {
      detonateCelestialCrash(cast);
    }

    return true;
  }

  function detonateCelestialCrash(cast){
    if(!cast) return;
    const abilityName = cast.abilityName || 'Celestial Crash';
    if(cast.casterRef === player && player.casting === cast){
      player.casting = null;
    }
    const impactX = Number.isFinite(cast.targetX) ? cast.targetX : (cast.casterRef && Number.isFinite(cast.casterRef.x) ? cast.casterRef.x : player.x);
    const impactY = Number.isFinite(cast.targetY) ? cast.targetY : (cast.casterRef && Number.isFinite(cast.casterRef.y) ? cast.casterRef.y : player.y);
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    if(!(radius > 0)){
      return;
    }
    flash(impactX, impactY, { startRadius: Math.max(18, radius * 0.5), endRadius: radius + 40, color: '#ffd7ff' });
    const result = applyCelestialImpactDamage(cast, impactX, impactY);
    const hits = Math.max(0, Number(result.hits) || 0);
    let message = '';
    if(hits > 0){
      message = `${abilityName} ${cast.empowered ? 'descended' : 'struck'} ${hits} target${hits === 1 ? '' : 's'}`;
    } else {
      message = `${abilityName} ${cast.empowered ? 'descended' : 'landed'} but hit nothing`;
    }
    const extras = [];
    if(cast.empowered){
      if(cast.shockRadius > 0 && (cast.shockDamage > 0 || cast.shockSlowPct > 0)){
        spawnCelestialShockwave(cast, impactX, impactY);
      }
      if(cast.shockRadius > 0){
        extras.push('The Skies Descend spreads its shockwave.');
      }
      celestialStardust.points = 0;
      celestialStardust.ready = false;
    } else if(Number(cast.stardustPerHit) > 0 && Number(cast.stardustThreshold) > 0){
      const previousPoints = Number(celestialStardust.points) || 0;
      const gain = cast.stardustPerHit * hits;
      const nextPoints = previousPoints + gain;
      celestialStardust.points = nextPoints;
      if(!celestialStardust.ready && nextPoints >= cast.stardustThreshold){
        celestialStardust.ready = true;
        extras.push('Stardust saturates, empowering the next cast.');
      }
    }
    if(cast.casterRef === player){
      const finalMessage = extras.length ? `${message}. ${extras.join(' ')}` : `${message}.`;
      setHudMessage(finalMessage);
    }
  }

  function applyCelestialImpactDamage(cast, centerX, centerY){
    const radius = Math.max(0, Number(cast.impactRadius) || 0);
    const damage = Math.max(0, Number(cast.damage) || 0);
    const stunSeconds = Math.max(0, Number(cast.stunDuration) || 0);
    const result = { hits: 0, victims: new Set() };
    if(!(radius > 0)){
      cast.impactVictims = result.victims;
      return result;
    }
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dx = m.x - centerX;
      const dy = m.y - centerY;
      const effective = radius + targetRadius;
      if(dx * dx + dy * dy > effective * effective) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      if(stunSeconds > 0){
        const existingStun = Number(m.stunTimer) || 0;
        m.stunTimer = Math.max(existingStun, stunSeconds);
      }
      handlePracticeDummyDamage(m, prevHp);
      result.hits += 1;
      result.victims.add(m);
    }
    if(monsterState && isMonsterAttackable(monsterState)){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monsterState));
      const dx = monsterState.x - centerX;
      const dy = monsterState.y - centerY;
      const effective = radius + monsterRadius;
      if(dx * dx + dy * dy <= effective * effective){
        const prevHp = Math.max(0, Number(monsterState.hp) || 0);
        if(damage > 0){
          monsterState.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monsterState.x, monsterState.y - monsterRadius, damage);
          updateMonsterHud();
        }
        if(stunSeconds > 0){
          const existingStun = Number(monsterState.stunTimer) || 0;
          monsterState.stunTimer = Math.max(existingStun, stunSeconds);
        }
        result.hits += 1;
        result.victims.add(monsterState);
      }
    }
    cast.impactVictims = result.victims;
    return result;
  }

  function spawnCelestialShockwave(cast, centerX, centerY){
    const radius = Math.max(0, Number(cast.shockRadius) || 0);
    const duration = Math.max(0, Number(cast.shockDuration) || 0);
    if(!(radius > 0) || !(duration > 0)) return;
    const damage = Math.max(0, Number(cast.shockDamage) || 0);
    const slowFraction = Math.max(0, Math.min(1, (Number(cast.shockSlowPct) || 0) / 100));
    const slowDuration = Math.max(0, Number(cast.shockSlowDuration) || 0);
    const shock = {
      casterRef: cast.casterRef,
      x: centerX,
      y: centerY,
      radius,
      damage,
      slowFraction,
      slowDuration,
      duration,
      elapsed: 0,
      immuneTargets: cast.impactVictims ? new Set(cast.impactVictims) : new Set()
    };
    applyCelestialShockwaveDamage(shock);
    celestialShockwaves.push(shock);
  }

  function applyCelestialShockwaveDamage(wave){
    const radius = Math.max(0, Number(wave.radius) || 0);
    const damage = Math.max(0, Number(wave.damage) || 0);
    const slowFraction = Math.max(0, Number(wave.slowFraction) || 0);
    const slowSeconds = Math.max(0, Number(wave.slowDuration) || 0);
    if(!(radius > 0) || (damage <= 0 && slowFraction <= 0)){
      return;
    }
    const immune = wave.immuneTargets;
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      if(immune && immune.has(m)) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const dx = m.x - wave.x;
      const dy = m.y - wave.y;
      const effective = radius + targetRadius;
      if(dx * dx + dy * dy > effective * effective) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - targetRadius, damage);
      }
      if(slowFraction > 0 && slowSeconds > 0){
        const existingSlow = Number(m.slowPct) || 0;
        m.slowPct = Math.max(existingSlow, slowFraction);
        m.slowTimer = Math.max(Number(m.slowTimer) || 0, slowSeconds);
      }
      handlePracticeDummyDamage(m, prevHp);
    }
    if(monsterState && isMonsterAttackable(monsterState) && (!immune || !immune.has(monsterState))){
      const monsterRadius = Math.max(minionRadius, monsterAttackRadius(monsterState));
      const dx = monsterState.x - wave.x;
      const dy = monsterState.y - wave.y;
      const effective = radius + monsterRadius;
      if(dx * dx + dy * dy <= effective * effective){
        const prevHp = Math.max(0, Number(monsterState.hp) || 0);
        if(damage > 0){
          monsterState.hp = Math.max(0, prevHp - damage);
          spawnHitSplat(monsterState.x, monsterState.y - monsterRadius, damage);
          updateMonsterHud();
        }
        if(slowFraction > 0 && slowSeconds > 0){
          const existingSlow = Number(monsterState.slowPct) || 0;
          monsterState.slowPct = Math.max(existingSlow, slowFraction);
          monsterState.slowTimer = Math.max(Number(monsterState.slowTimer) || 0, slowSeconds);
        }
      }
    }
  }

  function updateCelestialCrashCasts(dt){
    for(let i = celestialCrashCasts.length - 1; i >= 0; i--){
      const cast = celestialCrashCasts[i];
      if(!cast){
        celestialCrashCasts.splice(i, 1);
        continue;
      }
      if(cast.state === 'windup'){
        const duration = Math.max(0, Number(cast.castDuration) || 0);
        cast.elapsed = Math.max(0, (Number(cast.elapsed) || 0) + dt);
        if(duration <= 0 || cast.elapsed >= duration){
          if(cast.casterRef === player && player.casting === cast){
            player.casting = null;
          }
          detonateCelestialCrash(cast);
          celestialCrashCasts.splice(i, 1);
        }
      }
    }
  }

  function updateCelestialShockwaves(dt){
    for(let i = celestialShockwaves.length - 1; i >= 0; i--){
      const wave = celestialShockwaves[i];
      if(!wave){
        celestialShockwaves.splice(i, 1);
        continue;
      }
      const duration = Math.max(0, Number(wave.duration) || 0);
      wave.elapsed = Math.max(0, (Number(wave.elapsed) || 0) + dt);
      if(duration <= 0 || wave.elapsed >= duration){
        celestialShockwaves.splice(i, 1);
      }
    }
  }

  function drawCelestialCrashTelegraphs(){
    if(!celestialCrashCasts.length) return;
    for(const cast of celestialCrashCasts){
      if(!cast || cast.state !== 'windup') continue;
      const tx = Number.isFinite(cast.targetX) ? cast.targetX : player.x;
      const ty = Number.isFinite(cast.targetY) ? cast.targetY : player.y;
      const radius = Math.max(0, Number(cast.impactRadius) || 0);
      if(!(radius > 0) || !circleInCamera(tx, ty, radius + 24)) continue;
      const duration = Math.max(0.0001, Number(cast.castDuration) || 0);
      const progress = duration > 0 ? Math.min(1, Number(cast.elapsed) / duration) : 1;
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.2 * progress;
      ctx.strokeStyle = '#ffd7ff';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.arc(tx, ty, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.15 * (1 - progress) + 0.05;
      ctx.fillStyle = '#ffd7ff';
      ctx.beginPath();
      ctx.arc(tx, ty, radius * (0.6 + 0.25 * (1 - progress)), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawCelestialShockwaves(){
    if(!celestialShockwaves.length) return;
    for(const wave of celestialShockwaves){
      if(!wave) continue;
      const radius = Math.max(0, Number(wave.radius) || 0);
      if(!(radius > 0)) continue;
      const duration = Math.max(0, Number(wave.duration) || 0);
      const elapsed = Math.max(0, Number(wave.elapsed) || 0);
      const progress = duration > 0 ? Math.min(1, elapsed / duration) : 1;
      const drawRadius = radius * progress;
      if(drawRadius <= 0 || !circleInCamera(wave.x, wave.y, drawRadius + 12)) continue;
      ctx.save();
      ctx.globalAlpha = Math.max(0, 0.4 * (1 - progress));
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#8ad8ff';
      ctx.beginPath();
      ctx.arc(wave.x, wave.y, drawRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = Math.max(0, 0.25 * (1 - progress));
      ctx.fillStyle = '#8ad8ff';
      ctx.beginPath();
      ctx.arc(wave.x, wave.y, drawRadius * 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function castGlacialUpliftAbility(slotIndex, ability){
    if(player.casting){
      setHudMessage(`${player.casting.abilityName || 'Spell'} is already casting.`);
      return false;
    }
    const abilityName = ability && (ability.shortName || ability.name) ? (ability.shortName || ability.name) : 'Glacial Uplift';
    const castDuration = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const wallLength = Math.max(0, Number(abilityFieldValue(ability, 'wallLengthPx')) || 0);
    const wallThickness = Math.max(6, Number(abilityFieldValue(ability, 'wallThicknessPx')) || 0);
    const wallDuration = Math.max(0, Number(abilityFieldValue(ability, 'wallDurationMs')) || 0) / 1000;
    const shoveDistance = Math.max(0, Number(abilityFieldValue(ability, 'shoveDistancePx')) || 0);
    const segmentCountRaw = Math.max(0, Number(abilityFieldValue(ability, 'segmentCount')) || 0);
    const segmentCount = Math.max(1, Math.min(24, Math.round(segmentCountRaw)));

    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a cast range configured.`);
      return false;
    }
    if(!(wallLength > 0)){
      setHudMessage(`${abilityName} needs a wall length configured.`);
      return false;
    }
    if(!(wallThickness > 0)){
      setHudMessage(`${abilityName} needs a wall thickness configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = typeof skillshotAimPoint === 'function' ? skillshotAimPoint() : beamAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(distance > maxRange){
      const scale = maxRange / distance;
      dx *= scale;
      dy *= scale;
      distance = maxRange;
    }
    let dirX = dx / distance;
    let dirY = dy / distance;
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const halfLength = wallLength * 0.5;
    const clampRadius = Math.max(minionRadius, Math.hypot(halfLength, wallThickness * 0.5) + 12);
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      targetX = Math.max(clampRadius, Math.min(mapState.width - clampRadius, targetX));
      targetY = Math.max(clampRadius, Math.min(mapState.height - clampRadius, targetY));
      const clampedDx = targetX - origin.x;
      const clampedDy = targetY - origin.y;
      const clampedDist = Math.hypot(clampedDx, clampedDy);
      if(clampedDist > 0.0001){
        dirX = clampedDx / clampedDist;
        dirY = clampedDy / clampedDist;
        distance = clampedDist;
      }
    }
    const wallDirX = -dirY;
    const wallDirY = dirX;
    const wallDirLen = Math.hypot(wallDirX, wallDirY) || 1;
    const wallDirNormX = wallDirX / wallDirLen;
    const wallDirNormY = wallDirY / wallDirLen;
    const normalLen = Math.hypot(dirX, dirY) || 1;
    const normalX = dirX / normalLen;
    const normalY = dirY / normalLen;

    const cast = {
      id: `uplift-cast-${abilityRuntime.glacialUpliftSequence++}`,
      slotIndex,
      abilityId: ability && ability.id,
      abilityName,
      casterRef: player,
      x: targetX,
      y: targetY,
      dirX: wallDirNormX,
      dirY: wallDirNormY,
      normalX,
      normalY,
      length: wallLength,
      thickness: wallThickness,
      duration: wallDuration,
      shoveDistance,
      segmentCount,
      castDuration,
      elapsed: 0
    };

    glacialUpliftCasts.push(cast);
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;

    if(castDuration > 0){
      player.casting = cast;
      setHudMessage(`${abilityName} forming...`);
    } else {
      activateGlacialUplift(cast);
      setHudMessage(`${abilityName} raised!`);
    }
    return true;
  }

  function castSpectralStockadeAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Spectral Stockade';
    const castTimeSeconds = Math.max(0, Number(abilityFieldValue(ability, 'castTimeMs')) || 0) / 1000;
    const riseDelaySeconds = Math.max(0, Number(abilityFieldValue(ability, 'riseDelayMs')) || 0) / 1000;
    const totalDelay = castTimeSeconds + riseDelaySeconds;
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'wallRadiusPx')) || 0);
    const thicknessRaw = Math.max(0, Number(abilityFieldValue(ability, 'wallThicknessPx')) || 0);
    const thickness = Math.max(8, thicknessRaw);
    const durationSeconds = Math.max(0, Number(abilityFieldValue(ability, 'durationMs')) || 0) / 1000;
    const maxRange = Math.max(0, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const shoveDistance = Math.max(0, Number(abilityFieldValue(ability, 'shoveDistancePx')) || 0);
    const innerPullRadius = Math.max(0, Number(abilityFieldValue(ability, 'innerPullRadiusPx')) || 0);
    const segmentCountRaw = Math.max(0, Number(abilityFieldValue(ability, 'segmentCount')) || 0);
    const segmentCount = Math.max(3, Math.min(24, Math.round(segmentCountRaw)));

    if(!(radius > 0)){
      setHudMessage(`${abilityName} needs a ring radius configured.`);
      return false;
    }
    if(!(maxRange > 0)){
      setHudMessage(`${abilityName} needs a cast range configured.`);
      return false;
    }

    const origin = getSpellOrigin(player);
    const aimPoint = skillshotAimPoint();
    let dx = aimPoint.x - origin.x;
    let dy = aimPoint.y - origin.y;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = player.target.x - origin.x;
      dy = player.target.y - origin.y;
      distance = Math.hypot(dx, dy);
    }
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    if(distance > maxRange){
      const scale = maxRange / distance;
      dx *= scale;
      dy *= scale;
      distance = maxRange;
    }
    let targetX = origin.x + dx;
    let targetY = origin.y + dy;
    const clampRadius = Math.max(radius + thickness * 0.5 + minionRadius, 8);
    if(mapState && Number.isFinite(mapState.width) && Number.isFinite(mapState.height)){
      targetX = Math.max(clampRadius, Math.min(mapState.width - clampRadius, targetX));
      targetY = Math.max(clampRadius, Math.min(mapState.height - clampRadius, targetY));
    }

    const stockade = {
      id: abilityRuntime.stockadeSequence++,
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: player,
      x: targetX,
      y: targetY,
      radius,
      thickness,
      riseDelay: totalDelay,
      duration: durationSeconds,
      shoveDistance,
      innerPullRadius,
      segmentCount,
      age: 0
    };

    spectralStockadeCasts.push(stockade);
    flash(targetX, targetY, { startRadius: Math.max(10, radius * 0.35), endRadius: Math.max(radius + thickness * 0.5, radius + 28), color: '#9ad7ff' });
    cancelPlayerAttack(false);
    player.chaseTarget = null;
    player.target.x = player.x;
    player.target.y = player.y;
    player.navGoal = null;
    player.nav = null;
    setHudMessage(`${abilityName} forming...`);
    return true;
  }

  function activeArcaneRiteModeForCaster(caster){
    if(!caster) return null;
    for(const mode of arcaneRiteModes){
      if(!mode || mode.ended) continue;
      if(mode.casterRef === caster) return mode;
    }
    return null;
  }

  function castRiteArcaneAbility(slotIndex, ability){
    const abilityName = ability && (ability.shortName || ability.name)
      ? (ability.shortName || ability.name)
      : 'Rite of the Arcane';
    const caster = player;
    const existing = activeArcaneRiteModeForCaster(caster);
    if(existing && existing.abilityId === ability.id){
      setHudMessage(`${abilityName} is already active.`);
      return false;
    }

    const charges = Math.max(0, Math.round(Number(abilityFieldValue(ability, 'modeCharges')) || 0));
    if(!(charges > 0)){
      setHudMessage(`${abilityName} requires charges to activate.`);
      return false;
    }

    const durationMs = Math.max(0, Number(abilityFieldValue(ability, 'modeDurationMs')) || 0);
    const duration = durationMs / 1000;
    if(!(duration > 0)){
      setHudMessage(`${abilityName} fizzled â€” duration is zero.`);
      return false;
    }

    const minRange = Math.max(0, Number(abilityFieldValue(ability, 'minRangePx')) || 0);
    const maxRange = Math.max(minRange, Number(abilityFieldValue(ability, 'maxRangePx')) || 0);
    const radius = Math.max(0, Number(abilityFieldValue(ability, 'aoeRadiusPx')) || 0);
    const damage = Math.max(0, Number(abilityFieldValue(ability, 'damage')) || 0);
    const explosionDelayMs = Math.max(0, Number(abilityFieldValue(ability, 'explosionDelayMs')) || 0);
    const cancelOnStun = Number(abilityFieldValue(ability, 'cancelOnStun')) > 0;
    const cancelOnSilence = Number(abilityFieldValue(ability, 'cancelOnSilence')) > 0;
    const cooldownSeconds = abilityCooldownSeconds(ability);

    const mode = {
      abilityId: ability.id,
      abilityName,
      slotIndex,
      casterRef: caster,
      duration,
      elapsed: 0,
      chargesRemaining: charges,
      explosionDelay: explosionDelayMs / 1000,
      minRange,
      maxRange,
      radius,
      damage,
      cooldownSeconds,
      cancelOnStun,
      cancelOnSilence,
      ended: false,
      cooldownApplied: false
    };
    arcaneRiteModes.push(mode);
    cancelPlayerAttack(false);
    const plural = charges === 1 ? '' : 's';
    setHudMessage(`${abilityName} ready â€” ${charges} charge${plural}.`);
    return { success: true, deferCooldown: true };
  }

  function scheduleArcaneRiteExplosion(mode, targetX, targetY){
    if(!mode || mode.ended) return false;
    if(!(mode.chargesRemaining > 0)) return false;
    const caster = mode.casterRef || player;
    const { x: originX, y: originY } = getSpellOrigin(caster);
    let dx = targetX - originX;
    let dy = targetY - originY;
    let distance = Math.hypot(dx, dy);
    if(!(distance > 0.0001)){
      dx = 1;
      dy = 0;
      distance = 1;
    }
    let desiredDistance = distance;
    if(Number.isFinite(mode.maxRange) && mode.maxRange > 0){
      desiredDistance = Math.min(desiredDistance, mode.maxRange);
    }
    if(Number.isFinite(mode.minRange) && mode.minRange > 0){
      desiredDistance = Math.max(desiredDistance, mode.minRange);
    }
    const normX = dx / distance;
    const normY = dy / distance;
    const finalX = originX + normX * desiredDistance;
    const finalY = originY + normY * desiredDistance;
    const explosion = {
      modeRef: mode,
      abilityName: mode.abilityName,
      casterRef: caster,
      x: finalX,
      y: finalY,
      radius: Math.max(0, Number(mode.radius) || 0),
      damage: Math.max(0, Number(mode.damage) || 0),
      delay: Math.max(0, Number(mode.explosionDelay) || 0),
      elapsed: 0
    };
    arcaneRiteExplosions.push(explosion);
    mode.chargesRemaining = Math.max(0, Number(mode.chargesRemaining) - 1);
    if(caster === player){
      const chargesLeft = mode.chargesRemaining;
      const plural = chargesLeft === 1 ? '' : 's';
      const message = chargesLeft > 0
        ? `${mode.abilityName || 'Artillery'} queued â€” ${chargesLeft} charge${plural} left.`
        : `${mode.abilityName || 'Artillery'} last charge fired!`;
      setHudMessage(message);
    }
    if(mode.chargesRemaining <= 0){
      endArcaneRiteMode(mode, { reason: 'charges', silent: true });
    }
    return true;
  }

  function endArcaneRiteMode(mode, options = {}){
    if(!mode || mode.ended) return;
    mode.ended = true;
    const idx = arcaneRiteModes.indexOf(mode);
    if(idx !== -1){
      arcaneRiteModes.splice(idx, 1);
    }
    if(!mode.cooldownApplied && Number.isFinite(mode.slotIndex)){
      setAbilitySlotCooldown(mode.slotIndex, Math.max(0, Number(mode.cooldownSeconds) || 0));
      mode.cooldownApplied = true;
    }
    const caster = mode.casterRef;
    if(caster === player && !options.silent){
      const abilityName = mode.abilityName || 'Rite of the Arcane';
      let message;
      switch(options.reason){
        case 'duration':
          message = `${abilityName} ended.`;
          break;
        case 'stun':
          message = `${abilityName} cancelled by control!`;
          break;
        case 'silence':
          message = `${abilityName} interrupted.`;
          break;
        case 'charges':
          message = `${abilityName} expended all charges.`;
          break;
        default:
          message = `${abilityName} ended.`;
          break;
      }
      setHudMessage(message);
    }
  }

  function updateArcaneRiteModes(dt){
    for(let i = arcaneRiteModes.length - 1; i >= 0; i--){
      const mode = arcaneRiteModes[i];
      if(!mode || mode.ended){
        arcaneRiteModes.splice(i, 1);
        continue;
      }
      mode.elapsed = Math.max(0, (Number(mode.elapsed) || 0) + dt);
      const caster = mode.casterRef;
      if(mode.cancelOnStun && caster && Number(caster.stunTimer) > 0){
        endArcaneRiteMode(mode, { reason: 'stun' });
        continue;
      }
      if(mode.cancelOnSilence && caster && Number(caster.silenceTimer) > 0){
        endArcaneRiteMode(mode, { reason: 'silence' });
        continue;
      }
      if(mode.duration > 0 && mode.elapsed >= mode.duration){
        endArcaneRiteMode(mode, { reason: 'duration' });
      }
    }
  }

  function updateArcaneRiteExplosions(dt){
    for(let i = arcaneRiteExplosions.length - 1; i >= 0; i--){
      const blast = arcaneRiteExplosions[i];
      if(!blast){
        arcaneRiteExplosions.splice(i, 1);
        continue;
      }
      blast.elapsed = Math.max(0, (Number(blast.elapsed) || 0) + dt);
      const delay = Math.max(0, Number(blast.delay) || 0);
      if(delay <= 0 || blast.elapsed >= delay){
        triggerArcaneRiteExplosion(blast);
        arcaneRiteExplosions.splice(i, 1);
      }
    }
  }

  function triggerArcaneRiteExplosion(blast){
    if(!blast) return;
    const radius = Math.max(0, Number(blast.radius) || 0);
    const abilityName = blast.abilityName || (blast.modeRef && blast.modeRef.abilityName) || 'Rite of the Arcane';
    const startRadius = radius > 0 ? Math.max(18, radius * 0.35) : 18;
    const endRadius = radius > 0 ? Math.max(radius, radius + 60) : 48;
    flash(blast.x, blast.y, { startRadius, endRadius, color: '#c99bff' });
    const hits = applyArcaneRiteExplosionDamage(blast);
    if(blast.casterRef === player){
      if(hits > 0){
        setHudMessage(`${abilityName} struck ${hits} target${hits === 1 ? '' : 's'}!`);
      } else {
        setHudMessage(`${abilityName} detonated.`);
      }
    }
  }

  function applyArcaneRiteExplosionDamage(blast){
    const radius = Math.max(0, Number(blast.radius) || 0);
    const damage = Math.max(0, Number(blast.damage) || 0);
    if(!(radius > 0) && damage <= 0) return 0;
    const effectiveRadius = radius + minionRadius;
    const effectiveSq = effectiveRadius * effectiveRadius;
    let hits = 0;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const dx = m.x - blast.x;
      const dy = m.y - blast.y;
      if(dx * dx + dy * dy > effectiveSq) continue;
      const prevHp = Number(m.hp) || 0;
      if(damage > 0){
        m.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(m.x, m.y - minionRadius, damage);
      }
      handlePracticeDummyDamage(m, prevHp);
      hits++;
    }
    return hits;
  }

  function drawArcaneRiteModeIndicators(){
    const mode = activeArcaneRiteModeForCaster(player);
    if(!mode || mode.ended) return;
    const caster = mode.casterRef || player;
    const duration = Math.max(0.0001, Number(mode.duration) || 0.0001);
    const elapsed = Math.max(0, Number(mode.elapsed) || 0);
    const remaining = Math.max(0, Math.min(1, 1 - (elapsed / duration)));
    const baseRadius = (caster && Number.isFinite(caster.r) ? caster.r : player.r) + 18;
    const maxRange = Math.max(0, Number(mode.maxRange) || 0);
    const minRange = Math.max(0, Number(mode.minRange) || 0);
    const maxRadius = Math.max(baseRadius, maxRange, minRange);
    if(!circleInCamera(caster.x, caster.y, maxRadius + 16)) return;
    ctx.save();
    ctx.lineWidth = 2.5;
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = '#c99bff';
    ctx.beginPath();
    ctx.arc(caster.x, caster.y, baseRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.arc(caster.x, caster.y, baseRadius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * (1 - remaining));
    ctx.stroke();
    ctx.restore();
    if(maxRange > 0){
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.setLineDash([12, 8]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#c99bff';
      ctx.beginPath();
      ctx.arc(caster.x, caster.y, maxRange, 0, Math.PI * 2);
      ctx.stroke();
      if(minRange > 0){
        ctx.strokeStyle = '#c99bff88';
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, minRange, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawArcaneRiteTelegraphs(){
    for(const blast of arcaneRiteExplosions){
      if(!blast) continue;
      const delay = Math.max(0.0001, Number(blast.delay) || 0.0001);
      const elapsed = Math.max(0, Number(blast.elapsed) || 0);
      const progress = Math.max(0, Math.min(1, elapsed / delay));
      const radius = Math.max(12, Number(blast.radius) || 0);
      if(!circleInCamera(blast.x, blast.y, radius + 12)) continue;
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.45 * progress;
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#c99bff';
      ctx.beginPath();
      ctx.arc(blast.x, blast.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.28 + 0.4 * progress;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(blast.x, blast.y, radius * (0.55 + 0.35 * (1 - progress)), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawFlameChomperTraps(){
    if(!flameChomperTraps.length) return;
    for(const trap of flameChomperTraps){
      if(!trap) continue;
      const radius = Math.max(6, Number(trap.radius) || 0);
      const armed = !!trap.armed;
      const armDelay = Math.max(0, Number(trap.armDelay) || 0);
      const triggerRadius = Math.max(0, Number(trap.triggerRadius) || 0);
      const maxRadius = Math.max(radius + 10, triggerRadius + 6);
      if(!circleInCamera(trap.x, trap.y, maxRadius)) continue;
      const progress = armed ? 1 : (armDelay > 0 ? Math.max(0, Math.min(1, (Number(trap.age) || 0) / armDelay)) : 1);
      ctx.save();
      ctx.beginPath();
      ctx.globalAlpha = armed ? 0.9 : 0.8;
      ctx.fillStyle = armed ? '#ff7c43' : '#f5c971';
      ctx.arc(trap.x, trap.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = armed ? '#ffd1a6' : '#ffe4b8';
      ctx.globalAlpha = 1;
      ctx.stroke();
      if(!armed && armDelay > 0){
        ctx.beginPath();
        ctx.strokeStyle = '#ffb66a';
        ctx.lineWidth = 3;
        ctx.arc(trap.x, trap.y, radius + 4, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress);
        ctx.stroke();
      }
      if(trap.showArmedRing){
        const ringRadius = Math.max(radius + 6, Math.max(0, Number(trap.triggerRadius) || 0) * 0.9);
        ctx.beginPath();
        ctx.setLineDash([4, 6]);
        ctx.lineWidth = 2;
        ctx.globalAlpha = armed ? 0.6 : 0.35;
        ctx.strokeStyle = armed ? '#ff9f6f' : '#f4cfa0';
        ctx.arc(trap.x, trap.y, ringRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
      }
      if(trap.showTriggerRadius && triggerRadius > 0){
        ctx.beginPath();
        ctx.globalAlpha = armed ? 0.18 : 0.12;
        ctx.fillStyle = armed ? '#ff996622' : '#ffd9a022';
        ctx.arc(trap.x, trap.y, triggerRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.globalAlpha = armed ? 0.45 : 0.3;
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = armed ? '#ff9966' : '#ffbb88';
        ctx.arc(trap.x, trap.y, triggerRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }
  }

  function renderSpectralStockadeRing(entry, { state = 'rising', progress = 1, activeProgress = 0 } = {}){
    if(!entry) return;
    const radius = Math.max(0, Number(entry.radius) || 0);
    const thickness = Math.max(8, Number(entry.thickness) || 0);
    const halfThickness = thickness * 0.5;
    const outerRadius = radius + halfThickness;
    const innerRadius = Math.max(0, radius - halfThickness);
    const maxRadius = Math.max(outerRadius, radius) + 32;
    if(!circleInCamera(entry.x, entry.y, maxRadius)) return;
    const segments = Math.max(3, Math.floor(Number(entry.segmentCount) || 0));
    const arcStep = (Math.PI * 2) / segments;
    const arcSpan = Math.max(arcStep * 0.42, arcStep - arcStep * 0.22);
    const now = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();
    const rotation = now * 0.0004;
    const innerAlpha = state === 'active'
      ? 0.14 + 0.12 * (1 - activeProgress)
      : 0.08 + 0.18 * progress;
    const strokeAlpha = state === 'active' ? 0.7 : 0.5 + 0.35 * progress;
    const outerAlpha = state === 'active' ? 0.45 : 0.32 + 0.28 * progress;
    const baseStroke = state === 'active' ? '#8cd2ff' : '#b8e4ff';
    const accentStroke = state === 'active' ? '#baf3ff' : '#e4f6ff';
    ctx.save();
    ctx.translate(entry.x, entry.y);
    ctx.rotate(rotation);
    ctx.globalAlpha = innerAlpha;
    ctx.fillStyle = '#7cc7ff';
    ctx.beginPath();
    ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = strokeAlpha;
    ctx.lineCap = 'round';
    ctx.lineWidth = Math.max(4, thickness * (state === 'active' ? 0.8 : Math.max(0.35, progress * 0.8)));
    for(let i = 0; i < segments; i++){
      const start = arcStep * i + (arcStep - arcSpan) * 0.5;
      ctx.strokeStyle = i % 2 === 0 ? baseStroke : accentStroke;
      ctx.beginPath();
      ctx.arc(0, 0, radius, start, start + arcSpan);
      ctx.stroke();
    }
    ctx.setLineDash([8, 10]);
    ctx.lineWidth = Math.max(2, thickness * 0.35);
    ctx.globalAlpha = outerAlpha;
    ctx.strokeStyle = accentStroke;
    ctx.beginPath();
    ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawSpectralStockades(){
    if(!spectralStockadeCasts.length && !spectralStockades.length) return;
    for(const cast of spectralStockadeCasts){
      if(!cast) continue;
      const delay = Math.max(0, Number(cast.riseDelay) || 0);
      const progress = delay > 0 ? Math.max(0, Math.min(1, (Number(cast.age) || 0) / delay)) : 1;
      renderSpectralStockadeRing(cast, { state: 'rising', progress, activeProgress: 0 });
    }
    for(const wall of spectralStockades){
      if(!wall) continue;
      const duration = Math.max(0, Number(wall.duration) || 0);
      const activeProgress = duration > 0 ? Math.max(0, Math.min(1, (Number(wall.activeFor) || 0) / duration)) : 0;
      renderSpectralStockadeRing(wall, { state: 'active', progress: 1, activeProgress });
    }
  }

  function renderGlacialUpliftWall(entry, { state = 'rising', progress = 1 } = {}){
    if(!entry) return;
    const length = Math.max(0, Number(entry.length) || 0);
    const thickness = Math.max(6, Number(entry.thickness) || 0);
    const halfLen = length * 0.5;
    const halfThick = thickness * 0.5;
    const wallDirX = Number.isFinite(entry.dirX) ? entry.dirX : 1;
    const wallDirY = Number.isFinite(entry.dirY) ? entry.dirY : 0;
    const angle = Math.atan2(wallDirY, wallDirX);
    const maxRadius = Math.hypot(halfLen, halfThick) + 24;
    if(!circleInCamera(entry.x, entry.y, maxRadius)) return;
    const segments = Math.max(1, Math.floor(Number(entry.segmentCount) || 0));
    const activeAlpha = state === 'active' ? 0.85 : 0.45 + 0.45 * progress;
    const fillAlpha = state === 'active' ? 0.25 : 0.12 + 0.28 * progress;
    const stroke = state === 'active' ? '#b8ecff' : '#d4f5ff';
    const accent = state === 'active' ? '#86d8ff' : '#a8e6ff';
    ctx.save();
    ctx.translate(entry.x, entry.y);
    ctx.rotate(angle);
    ctx.globalAlpha = fillAlpha;
    ctx.fillStyle = '#b8ecff';
    ctx.beginPath();
    ctx.rect(-halfLen, -halfThick, length, thickness);
    ctx.fill();
    ctx.globalAlpha = activeAlpha;
    ctx.lineWidth = Math.max(3, Math.min(8, thickness * 0.4));
    ctx.strokeStyle = stroke;
    ctx.beginPath();
    ctx.rect(-halfLen, -halfThick, length, thickness);
    ctx.stroke();
    if(segments > 1){
      ctx.globalAlpha = Math.max(0.35, activeAlpha - 0.25);
      ctx.strokeStyle = accent;
      ctx.lineWidth = Math.max(2, thickness * 0.25);
      ctx.setLineDash([6, 6]);
      const step = length / segments;
      for(let i = 1; i < segments; i++){
        const x = -halfLen + step * i;
        ctx.beginPath();
        ctx.moveTo(x, -halfThick);
        ctx.lineTo(x, halfThick);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }
    ctx.restore();
  }

  function drawGlacialUpliftWalls(){
    if(!glacialUpliftCasts.length && !glacialUpliftWalls.length) return;
    for(const cast of glacialUpliftCasts){
      if(!cast) continue;
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      const progress = duration > 0 ? Math.max(0, Math.min(1, (Number(cast.elapsed) || 0) / duration)) : 1;
      renderGlacialUpliftWall(cast, { state: 'rising', progress });
    }
    for(const wall of glacialUpliftWalls){
      if(!wall) continue;
      const duration = Math.max(0, Number(wall.duration) || 0);
      const progress = duration > 0 ? Math.max(0, Math.min(1, (Number(wall.age) || 0) / duration)) : 0;
      renderGlacialUpliftWall(wall, { state: 'active', progress: 1 - progress * 0.5 });
    }
  }

  function drawScatterCharges(){
    if(!scatterCharges.length) return;
    for(const charge of scatterCharges){
      if(!charge) continue;
      const blastRadius = Math.max(0, Number(charge.radius) || 0);
      const baseRadius = Math.max(6, Math.min(22, blastRadius * 0.2 + 6));
      const x = Number.isFinite(charge.currentX) ? charge.currentX : (Number.isFinite(charge.destX) ? charge.destX : 0);
      const y = Number.isFinite(charge.currentY) ? charge.currentY : (Number.isFinite(charge.destY) ? charge.destY : 0);
      const maxRadius = Math.max(blastRadius, baseRadius) + 14;
      if(!circleInCamera(x, y, maxRadius)) continue;
      const armed = charge.state !== 'flying';
      const fuse = Math.max(0, Number(charge.lifetime) || 0);
      const age = Math.max(0, Number(charge.age) || 0);
      const fusePct = armed && fuse > 0 ? Math.max(0, Math.min(1, age / Math.max(fuse, 0.0001))) : 0;
      ctx.save();
      if(armed){
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = '#ffb347';
        ctx.beginPath();
        ctx.arc(x, y, baseRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ff7b2f';
        ctx.stroke();
        if(blastRadius > 0){
          ctx.beginPath();
          ctx.setLineDash([5, 6]);
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = '#ffe6b3';
          ctx.arc(x, y, blastRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        if(fuse > 0){
          ctx.beginPath();
          ctx.globalAlpha = 0.95;
          ctx.strokeStyle = '#fff4d6';
          ctx.lineWidth = 3;
          ctx.arc(x, y, baseRadius + 6, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * (1 - fusePct), true);
          ctx.stroke();
        }
      } else {
        const tailX = Number.isFinite(charge.startX) ? charge.startX : x;
        const tailY = Number.isFinite(charge.startY) ? charge.startY : y;
        ctx.globalAlpha = 0.85;
        ctx.strokeStyle = '#ffd27a';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillStyle = '#ffb347';
        ctx.arc(x, y, baseRadius * 0.85, 0, Math.PI * 2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ff7b2f';
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawBulwarkCrashCasts(){
    if(!bulwarkCrashCasts.length) return;
    for(const cast of bulwarkCrashCasts){
      if(!cast || cast.ended) continue;
      const caster = cast.casterRef || player;
      const origin = getSpellOrigin(caster);
      const x = Number.isFinite(origin.x) ? origin.x : (caster && Number.isFinite(caster.x) ? caster.x : player.x);
      const y = Number.isFinite(origin.y) ? origin.y : (caster && Number.isFinite(caster.y) ? caster.y : player.y);
      const radius = Math.max(0, Number(cast.impactRadius) || 0);
      if(!(radius > 0)) continue;
      if(!circleInCamera(x, y, radius + 24)) continue;
      const braceDuration = Math.max(0, Number(cast.braceDuration) || 0);
      const elapsed = Math.max(0, Number(cast.elapsed) || 0);
      const progress = braceDuration > 0 ? clamp01(elapsed / braceDuration) : 1;
      const color = cast.shieldAbsorbed ? '#ffb870' : '#ffe7a8';
      ctx.save();
      ctx.globalAlpha = 0.16 + 0.1 * progress;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.setLineDash([10, 6]);
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#d18f4f';
      ctx.beginPath();
      const startAngle = -Math.PI / 2;
      ctx.arc(x, y, radius + 8, startAngle, startAngle + Math.PI * 2 * progress);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSpringquakeFields(){
    if(!springquakeCasts.length) return;
    for(const cast of springquakeCasts){
      if(!cast || cast.state !== 'active') continue;
      const caster = cast.casterRef || player;
      const origin = getSpellOrigin(caster);
      const x = Number.isFinite(origin.x) ? origin.x : (caster && Number.isFinite(caster.x) ? caster.x : player.x);
      const y = Number.isFinite(origin.y) ? origin.y : (caster && Number.isFinite(caster.y) ? caster.y : player.y);
      const radius = Math.max(0, Number(cast.bounceRadius) || 0);
      if(!(radius > 0)) continue;
      if(!circleInCamera(x, y, radius + 20)) continue;
      const interval = Math.max(0, Number(cast.bounceInterval) || 0);
      const elapsed = Math.max(0, Number(cast.activeElapsed) || 0);
      const nextBounce = Number.isFinite(cast.nextBounceTime) ? cast.nextBounceTime : interval;
      const remaining = interval > 0 ? Math.max(0, nextBounce - elapsed) : 0;
      const pulse = interval > 0 ? Math.max(0, Math.min(1, remaining / interval)) : 0;
      const alpha = Math.max(0.12, Math.min(0.35, 0.18 + 0.15 * (1 - pulse)));
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.setLineDash([8, 8]);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#7be3a2';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.lineWidth = 2;
      ctx.globalAlpha = alpha * 0.75;
      ctx.strokeStyle = '#4bb574';
      ctx.beginPath();
      ctx.arc(x, y, Math.max(12, radius * 0.35), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSlamFissures(){
    for(const fissure of slamFissures){
      if(!fissure) continue;
      const distance = Math.max(0, Number(fissure.distance) || 0);
      const width = Math.max(0, Number(fissure.width) || 0);
      if(!(distance > 0) || !(width > 0)) continue;
      const dirX = Number(fissure.dirX) || 0;
      const dirY = Number(fissure.dirY) || 0;
      const endX = fissure.startX + dirX * distance;
      const endY = fissure.startY + dirY * distance;
      if(!rectIntersectsCamera(fissure.startX, fissure.startY, endX, endY, width)) continue;
      const angle = Math.atan2(fissure.dirY, fissure.dirX);
      let alpha = 0.6;
      if(fissure.state === 'done'){
        const fadeDuration = Math.max(0.0001, Number(fissure.fadeDuration) || 0.0001);
        const remaining = Math.max(0, Number(fissure.fadeRemaining) || 0);
        alpha = 0.2 + 0.45 * Math.max(0, Math.min(1, remaining / fadeDuration));
      }
      ctx.save();
      ctx.translate(fissure.startX, fissure.startY);
      ctx.rotate(angle);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#8fe3ff55';
      ctx.fillRect(0, -width / 2, distance, width);
      ctx.globalAlpha = alpha * 0.9;
      ctx.strokeStyle = '#d4f6ff';
      ctx.lineWidth = Math.max(2, width * 0.18);
      ctx.beginPath();
      ctx.moveTo(0, -width / 2);
      ctx.lineTo(distance, -width / 2);
      ctx.moveTo(0, width / 2);
      ctx.lineTo(distance, width / 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSlamImpacts(){
    for(const impact of slamImpacts){
      if(!impact) continue;
      const lifetime = Math.max(0.0001, Number(impact.lifetime) || 0.5);
      const age = Math.max(0, Number(impact.age) || 0);
      const progress = Math.max(0, Math.min(1, age / lifetime));
      const alpha = 1 - progress;
      if(alpha <= 0) continue;
      const baseRadius = Math.max(24, Number(impact.radius) || 0);
      if(!circleInCamera(impact.x, impact.y, baseRadius * 1.5)) continue;
      ctx.save();
      ctx.globalAlpha = alpha * 0.35;
      ctx.fillStyle = '#9fe7ff';
      ctx.beginPath();
      ctx.arc(impact.x, impact.y, baseRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = alpha * 0.55;
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#d9f7ff';
      ctx.beginPath();
      ctx.arc(impact.x, impact.y, baseRadius * (0.7 + 0.4 * progress), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSlamCasts(){
    for(const cast of slamCasts){
      if(!cast) continue;
      const { x: originX, y: originY } = resolveCastOrigin(cast);
      const duration = Math.max(0.0001, Number(cast.castDuration) || 0.0001);
      const elapsed = Math.max(0, Number(cast.elapsed) || 0);
      const progress = Math.max(0, Math.min(1, elapsed / duration));
      const eased = progress * progress * (3 - 2 * progress);
      const radius = Math.max(0, Number(cast.impactRadius) || 0);
      const length = Math.max(0, Number(cast.fissureLength) || 0);
      const width = Math.max(0, Number(cast.fissureWidth) || 0);
      const maxExtent = Math.max(radius, length) + width;
      if(maxExtent > 0 && !circleInCamera(originX, originY, maxExtent)) continue;
      if(radius > 0){
        ctx.save();
        ctx.globalAlpha = 0.25 + 0.35 * eased;
        ctx.lineWidth = 2 + 3 * eased;
        ctx.strokeStyle = '#8fe3ff';
        ctx.beginPath();
        ctx.arc(originX, originY, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      if(length > 0 && width > 0){
        const angle = Math.atan2(cast.dirY, cast.dirX);
        ctx.save();
        ctx.translate(originX, originY);
        ctx.rotate(angle);
        ctx.globalAlpha = 0.12 + 0.2 * eased;
        ctx.fillStyle = '#55cfff33';
        ctx.fillRect(0, -width / 2, length, width);
        ctx.restore();
      }
    }
  }

  function drawBeamCasts(){
    for(const cast of beamCasts){
      const duration = Math.max(0.0001, cast.castDuration || 0.0001);
      const progressRaw = Math.max(0, Math.min(1, (cast.elapsed || 0) / duration));
      const eased = progressRaw * progressRaw * (3 - 2 * progressRaw);
      const geom = resolveBeamCastGeometry(cast);
      const previewLengthBase = Math.max(1, cast.previewLength || cast.fireLength || 1);
      const length = cast.dynamicLength ? Math.max(1, geom.distanceToTarget) : previewLengthBase;
      const endX = geom.startX + geom.dirX * length;
      const endY = geom.startY + geom.dirY * length;
      const drawWidth = Math.max(1.5, Math.max(cast.width || 0, 2) * (0.5 + eased * 0.6));
      if(!rectIntersectsCamera(geom.startX, geom.startY, endX, endY, drawWidth * 2)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.35 + 0.55 * eased;
      ctx.shadowBlur = 16 + 24 * eased;
      ctx.shadowColor = '#2aa9ff';
      ctx.lineWidth = drawWidth;
      ctx.strokeStyle = '#59c6ff';
      ctx.beginPath();
      ctx.moveTo(geom.startX, geom.startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.55 + 0.35 * eased;
      ctx.lineWidth = Math.max(1, drawWidth * 0.55);
      ctx.strokeStyle = '#d3f3ff';
      ctx.beginPath();
      ctx.moveTo(geom.startX, geom.startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 0.35 + 0.45 * eased;
      ctx.fillStyle = '#59c6ff';
      ctx.beginPath();
      ctx.arc(geom.startX, geom.startY, 6 + eased * 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function spawnBeamVisual(startX, startY, target, length, width, options = {}){
    const safeLength = Math.max(0, Number(length) || 0);
    const safeWidth = Math.max(1, Number(width) || 1);
    const dirX = Number.isFinite(options.dirX) ? options.dirX : 1;
    const dirY = Number.isFinite(options.dirY) ? options.dirY : 0;
    const defaultEndX = startX + dirX * (safeLength || 1);
    const defaultEndY = startY + dirY * (safeLength || 1);
    const endX = Number.isFinite(options.endX) ? options.endX : (target ? target.x : defaultEndX);
    const endY = Number.isFinite(options.endY) ? options.endY : (target ? target.y : defaultEndY);
    const lifetime = Number.isFinite(options.lifetime) ? options.lifetime : 0.35;
    activeBeams.push({
      startX,
      startY,
      targetRef: target || null,
      targetX: endX,
      targetY: endY,
      length: safeLength,
      width: safeWidth,
      age: 0,
      lifetime,
      staticEnd: !target && Number.isFinite(options.endX) && Number.isFinite(options.endY)
    });
  }

  function updateBeams(dt){
    for(let i = activeBeams.length - 1; i >= 0; i--){
      const beam = activeBeams[i];
      beam.age += dt;
      if(beam.targetRef && beam.targetRef.hp > 0){
        beam.targetX = beam.targetRef.x;
        beam.targetY = beam.targetRef.y;
      }
      if(beam.age >= beam.lifetime || (beam.targetRef && beam.targetRef.hp <= 0)){
        activeBeams.splice(i, 1);
      }
    }
  }

  function drawBeams(){
    for(const beam of activeBeams){
      const lifetime = Math.max(0.001, beam.lifetime);
      const alpha = Math.max(0, 1 - beam.age / lifetime);
      if(alpha <= 0) continue;
      const tx = beam.targetX;
      const ty = beam.targetY;
      const dx = tx - beam.startX;
      const dy = ty - beam.startY;
      const distance = Math.hypot(dx, dy) || 1;
      const maxLength = beam.length > 0 ? Math.min(distance, beam.length) : distance;
      const nx = dx / distance;
      const ny = dy / distance;
      const endX = beam.startX + nx * maxLength;
      const endY = beam.startY + ny * maxLength;
      if(!rectIntersectsCamera(beam.startX, beam.startY, endX, endY, Math.max(beam.width, 8))) continue;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.lineCap = 'round';
      ctx.shadowColor = '#2aa9ff';
      ctx.shadowBlur = 18;
      ctx.lineWidth = Math.max(1, beam.width);
      ctx.strokeStyle = '#7fe3ff';
      ctx.beginPath();
      ctx.moveTo(beam.startX, beam.startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.lineWidth = Math.max(1, beam.width * 0.55);
      ctx.strokeStyle = '#d8f6ff';
      ctx.beginPath();
      ctx.moveTo(beam.startX, beam.startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function setAbilityHotkeyBinding(slotIndex, key, code){
    ensureAbilityHotkeys();
    if(slotIndex < 0 || slotIndex >= abilityHotkeys.length) return null;
    const label = formatAbilityKeyLabel(key, code);
    const normalizedKey = typeof key === 'string' ? key.toLowerCase() : '';
    const normalizedCode = typeof code === 'string' ? code : '';
    for(let i=0;i<abilityBarState.count;i++){
      if(i === slotIndex) continue;
      const other = abilityHotkeys[i] || defaultAbilityBinding(i);
      if(!other) continue;
      const otherCode = other.code || '';
      const otherKey = other.key ? other.key.toLowerCase() : '';
      if(normalizedCode && otherCode === normalizedCode){
        abilityHotkeys[i] = { key: '', code: '', label: 'â€”' };
        continue;
      }
      if(!normalizedCode && normalizedKey && otherKey && otherKey === normalizedKey){
        abilityHotkeys[i] = { key: '', code: '', label: 'â€”' };
      }
    }
    abilityHotkeys[slotIndex] = {
      key: typeof key === 'string' ? key : '',
      code: normalizedCode,
      label
    };
    return abilityHotkeys[slotIndex];
  }

  function findAbilitySlotForEvent(ev){
    if(abilityBarState.count <= 0) return -1;
    const code = ev.code;
    if(code){
      for(let i=0;i<abilityBarState.count;i++){
        const binding = getAbilityBinding(i);
        if(binding && binding.code && binding.code === code) return i;
      }
    }
    const key = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
    if(!key) return -1;
    for(let i=0;i<abilityBarState.count;i++){
      const binding = getAbilityBinding(i);
      if(!binding) continue;
      if(binding.code && code && binding.code === code) continue;
      if(binding.key && binding.key.toLowerCase() === key) return i;
    }
    return -1;
  }

  function isTypingTarget(target){
    if(!(target instanceof HTMLElement)) return false;
    const tag = target.tagName;
    if(tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
    return target.isContentEditable === true;
  }

  function resolveAbilityCast(slotIndex, options = {}){
    const requestedModeRaw = options && typeof options.castMode === 'string' ? options.castMode : null;
    const requestedMode = requestedModeRaw ? normalizeCastType(requestedModeRaw) : null;
    const resolution = { success: false, slotIndex, castMode: requestedMode || 'quick', supportsIndicator: false };
    if(slotIndex < 0 || slotIndex >= abilityBarState.count){
      resolution.reason = 'invalidSlot';
      resolution.message = 'Invalid ability slot.';
      return resolution;
    }
    const abilityId = abilityAssignments[slotIndex];
    if(!abilityId){
      resolution.reason = 'unassigned';
      resolution.message = `No spell assigned to slot ${slotIndex + 1}.`;
      return resolution;
    }
    const ability = getAbilityDefinition(abilityId);
    if(!ability){
      resolution.reason = 'missingAbility';
      resolution.message = 'Ability definition not found.';
      return resolution;
    }
    const state = getAbilitySlotState(slotIndex);
    if(state && state.cooldown > 0){
      resolution.reason = 'cooldown';
      resolution.message = `${ability.shortName || ability.name} is on cooldown.`;
      return resolution;
    }
    const handler = abilityHandlers[ability.id];
    if(typeof handler !== 'function'){
      resolution.reason = 'noHandler';
      resolution.message = `${ability.name} is not yet usable.`;
      return resolution;
    }
    const profile = getSkillshotIndicatorProfile(ability);
    const supportsIndicator = !!profile;
    let castMode = requestedMode || resolveAbilityCastType(ability);
    if((castMode === 'normal' || castMode === 'quickIndicator') && !supportsIndicator){
      castMode = 'quick';
    }
    resolution.success = true;
    resolution.reason = null;
    resolution.message = null;
    resolution.ability = ability;
    resolution.abilityId = abilityId;
    resolution.state = state;
    resolution.handler = handler;
    resolution.castMode = castMode;
    resolution.supportsIndicator = supportsIndicator;
    resolution.indicatorProfile = profile;
    return resolution;
  }

  function activateAbilitySlot(slotIndex, options = {}){
    const { preview = false, silent = false } = options || {};
    const resolution = resolveAbilityCast(slotIndex, options);
    if(!resolution.success){
      if(!silent && resolution.message){
        setHudMessage(resolution.message);
      }
      return false;
    }
    if(preview){
      return true;
    }
    const ability = resolution.ability;
    const handler = resolution.handler;
    const result = handler(slotIndex, ability, options);
    const success = result === true || (result && typeof result === 'object' && result.success === true);
    if(success){
      if(ability){
        cancelShadowPursuitForCaster(player, 'cast');
      }
      const defer = result && typeof result === 'object' && result.deferCooldown;
      let cooldownSeconds = abilityCooldownSeconds(ability);
      if(result && typeof result === 'object' && Number.isFinite(result.cooldownSeconds)){
        cooldownSeconds = Math.max(0, Number(result.cooldownSeconds) || 0);
      }
      if(!defer){
        setAbilitySlotCooldown(slotIndex, cooldownSeconds);
      }
    }
    return success;
  }

  if(abilityRepoClose){
    abilityRepoClose.addEventListener('click', ()=> closeAbilityRepository());
  }
  if(btnSaveSpells){
    btnSaveSpells.addEventListener('click', ()=> saveSpellConfigurations());
  }

  function handleAbilityKeyUp(ev){
    const indicator = spellCastingRuntime.activeIndicator;
    if(indicator && indicator.mode === 'quickIndicator' && eventMatchesIndicatorTrigger(indicator, ev)){
      indicator.pendingCast = true;
      confirmSkillshotIndicator({ cause: 'key', event: ev });
    }
    const code = typeof ev.code === 'string' ? ev.code : '';
    const key = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
    if(!code && !key) return;
    for(let i = piercingArrowCasts.length - 1; i >= 0; i--){
      const cast = piercingArrowCasts[i];
      if(!cast || cast.released) continue;
      let shouldRelease = false;
      if(cast.activatorKeyCode && code){
        shouldRelease = cast.activatorKeyCode === code;
      } else if(!cast.activatorKeyCode && cast.activatorKey && key){
        shouldRelease = cast.activatorKey === key;
      }
      if(shouldRelease){
        releasePiercingArrow(cast, { cause: 'keyRelease' });
      }
    }
    for(let i = boneSkewerCasts.length - 1; i >= 0; i--){
      const cast = boneSkewerCasts[i];
      if(!cast || cast.released) continue;
      let shouldRelease = false;
      if(cast.activatorKeyCode && code){
        shouldRelease = cast.activatorKeyCode === code;
      } else if(!cast.activatorKeyCode && cast.activatorKey && key){
        shouldRelease = cast.activatorKey === key;
      }
      if(shouldRelease){
        releaseBoneSkewer(cast, { cause: 'keyRelease' });
      }
    }
  }

  document.addEventListener('keydown', (ev)=>{
    const typing = isTypingTarget(ev.target);
    if(!spellCastingRuntime.captureMode && !abilityBarState.hotkeyMode){
      handleSpellCastModifierKeyDown(ev);
    }
    if(ev.key === 'Escape'){
      if(cancelSpellCastBindingCapture()){
        ev.preventDefault();
        return;
      }
      if(cancelSkillshotIndicator({ reason: 'escape' })){
        ev.preventDefault();
        return;
      }
      if(pingWheelCapture){
        ev.preventDefault();
        pingWheelCapture = false;
        updatePingWheelBindingDisplay();
        return;
      }
      if(pingWheelRuntime.active){
        ev.preventDefault();
        cancelPingWheel();
        return;
      }
      if(cameraLockCapture){
        ev.preventDefault();
        cameraLockCapture = false;
        camera.lockCapture = cameraLockCapture;
        updateCameraLockBindingDisplay();
        return;
      }
      if(attackMoveCapture){
        ev.preventDefault();
        attackMoveCapture = false;
        updateAttackMoveBindingDisplay();
        return;
      }
      if(cancelActivePiercingArrowCharge()){
        ev.preventDefault();
        return;
      }
      if(abilityBarState.hotkeyMode){
        ev.preventDefault();
        if(abilityBarState.hotkeyCaptureIndex !== null){
          stopAbilityHotkeyCapture();
        } else {
          exitAbilityHotkeyMode();
        }
        return;
      }
      if(isAbilityRepoOpen()){
        ev.preventDefault();
        closeAbilityRepository();
        return;
      }
      if(!typing){
        ev.preventDefault();
        enterAbilityHotkeyMode();
      }
      return;
    }

    if(prayerKeyCaptureId){
      if(DISALLOWED_HOTKEY_KEYS.has(ev.key)){
        ev.preventDefault();
        setHudMessage('Choose a different key (modifier keys cannot be used).');
        return;
      }
      ev.preventDefault();
      setPrayerBinding(prayerKeyCaptureId, ev.key, ev.code);
      stopPrayerKeyCapture({ silent: false });
      updatePrayerButtons();
      return;
    }

    if(abilityBarState.hotkeyMode){
      if(abilityBarState.hotkeyCaptureIndex !== null && !typing){
        if(DISALLOWED_HOTKEY_KEYS.has(ev.key)){
          ev.preventDefault();
          setHudMessage('Choose a different key (modifier keys cannot be used).');
          return;
        }
        if(ev.key){
          ev.preventDefault();
          const slotIndex = abilityBarState.hotkeyCaptureIndex;
          const binding = setAbilityHotkeyBinding(slotIndex, ev.key, ev.code);
          stopAbilityHotkeyCapture({silent: true});
          if(binding){
            setHudMessage(`Slot ${slotIndex + 1} bound to ${binding.label}.`);
          }
        }
      }
      return;
    }

    if(spellCastingRuntime.captureMode){
      if(DISALLOWED_HOTKEY_KEYS.has(ev.key)){
        ev.preventDefault();
        setHudMessage('Choose a different key (modifier keys cannot be used).');
        return;
      }
      ev.preventDefault();
      const kind = spellCastingRuntime.captureMode;
      setSpellCastModifierBinding(kind, ev.key, ev.code);
      spellCastingRuntime.captureMode = null;
      const binding = getSpellCastBinding(kind);
      if(binding && binding.label){
        const label = kind === 'normal' ? 'Normal cast' : (kind === 'quick' ? 'Quick cast' : 'Quick indicator');
        setHudMessage(`${label} modifier bound to ${binding.label}.`);
      }
      return;
    }

    if(pingWheelCapture){
      if(typing){
        return;
      }
      if(DISALLOWED_HOTKEY_KEYS.has(ev.key)){
        ev.preventDefault();
        setHudMessage('Choose a different key for the ping wheel (modifier keys are ignored).');
        return;
      }
      ev.preventDefault();
      setPingWheelBinding(ev.key, ev.code);
      pingWheelCapture = false;
      updatePingWheelBindingDisplay();
      if(pingWheelBinding && pingWheelBinding.label){
        setHudMessage(`Ping wheel bound to ${pingWheelBinding.label}.`);
      }
      return;
    }

    if(attackMoveCapture){
      if(typing){
        return;
      }
      if(DISALLOWED_HOTKEY_KEYS.has(ev.key)){
        ev.preventDefault();
        setHudMessage('Choose a different key for attack move (modifier keys are ignored).');
        return;
      }
      ev.preventDefault();
      setAttackMoveBinding(ev.key, ev.code);
      attackMoveCapture = false;
      updateAttackMoveBindingDisplay();
      if(attackMoveBinding && attackMoveBinding.label){
        setHudMessage(`Attack move bound to ${attackMoveBinding.label}.`);
      }
      return;
    }

    if(cameraLockCapture){
      if(typing){
        return;
      }
      if(DISALLOWED_HOTKEY_KEYS.has(ev.key)){
        ev.preventDefault();
        setHudMessage('Choose a different key for the camera lock (modifier keys are ignored).');
        return;
      }
      ev.preventDefault();
      setCameraLockBinding(ev.key, ev.code);
      cameraLockCapture = false;
      camera.lockCapture = cameraLockCapture;
      updateCameraLockBindingDisplay();
      if(cameraLockBinding && cameraLockBinding.label){
        setHudMessage(`Camera lock toggled with ${cameraLockBinding.label}.`);
      }
      return;
    }

    if(typing) return;
    if(ev.repeat) return;
    if(ev.altKey || ev.ctrlKey || ev.metaKey) return;

    const prayerId = findPrayerForEvent(ev);
    if(prayerId){
      ev.preventDefault();
      togglePrayer(prayerId);
      return;
    }

    if(matchesCameraLockKey(ev)){
      ev.preventDefault();
      toggleCameraLock();
      return;
    }

    if(matchesPingWheelKey(ev)){
      ev.preventDefault();
      if(!pingWheelRuntime.active){
        openPingWheel();
      }
      return;
    }

    if(matchesAttackMoveKey(ev)){
      ev.preventDefault();
      executeAttackMove();
      return;
    }

    if(ev.code === 'KeyB'){
      ev.preventDefault();
      toggleRecall();
      return;
    }

    if(ev.code === 'Digit0' || ev.code === 'Numpad0' || ev.key === '0'){
      ev.preventDefault();
      cycleAbilityAssignment();
      return;
    }

    const slotIndex = findAbilitySlotForEvent(ev);
    if(slotIndex >= 0){
      ev.preventDefault();
      handleAbilityActivationRequest(slotIndex, ev);
      return;
    }

    if(ev.code === 'KeyT'){
      ev.preventDefault();
      triggerPlayerTaunt();
      return;
    }
  });
  document.addEventListener('keyup', (ev)=>{
    if(pingWheelRuntime.keyHeld && matchesPingWheelKey(ev)){
      ev.preventDefault();
      closePingWheel({ trigger: true });
      return;
    }
    if(ev.altKey || ev.ctrlKey || ev.metaKey) return;
    if(ev.repeat) return;
    handleSpellCastModifierKeyUp(ev);
    handleAbilityKeyUp(ev);
  });
  document.addEventListener('click', (ev)=>{
    if(!isAbilityRepoOpen()) return;
    const target = ev.target instanceof Element ? ev.target : null;
    if(target && abilityRepoEl && abilityRepoEl.contains(target)) return;
    if(target && target.closest('.abilitySlot')) return;
    closeAbilityRepository();
  });

  const settingsPanelPairs = [
    { button: btnMinions, pane: minionsPane },
    { button: btnTurrets, pane: turretPane },
    { button: btnPlayer, pane: playerPane },
    { button: btnPracticeDummy, pane: practiceDummyPane },
    { button: btnPrayers, pane: prayerPane },
    { button: btnMonsters, pane: monsterPane },
    { button: btnHealth, pane: healthPane },
    {
      button: btnAnimation,
      pane: animationPane,
      onToggle: ({ playerRuntime }) => {
        if(playerRuntime && playerRuntime.animationController){
          playerRuntime.animationController.updateRendererSize();
        }
      }
    },
    { button: btnColliders, pane: colliderPane },
    { button: btnPerf, pane: perfPane },
    { button: btnGameState, pane: gameStatePane },
    { button: btnVision, pane: visionPane },
    { button: btnCamera, pane: cameraPane },
    { button: btnCursor, pane: cursorPane },
    { button: btnPings, pane: pingPane },
    { button: btnKeybinds, pane: keybindPane },
    { button: btnAbilityBar, pane: abilityPane },
    { button: btnMinimap, pane: minimapPane },
    { button: btnScoring, pane: scoringPane },
    { button: btnGold, pane: goldPane },
    { button: btnScore, pane: scorePane },
    { button: btnUiLayout, pane: uiLayoutPane }
  ];
  const settingsPanelApi = initSettingsPanel({
    app,
    sbHide,
    sbFab,
    submenuPairs: settingsPanelPairs,
    syncMenuMeasurements,
    playerRuntime
  });
  const settingsSearch = createSettingsSearch({
    settingsSearchOverlay,
    settingsSearchInput,
    settingsSearchResultsEl,
    settingsSearchEmptyEl,
    settingsSearchEmptyPrimary,
    settingsSearchEmptySecondary,
    settingsSearchStatusEl,
    settingsSearchFacetsEl,
    settingsSearchRecentsEl,
    settingsSearchHelpBtn,
    settingsSearchHelpEl,
    settingsSearchHelpClose,
    settingsSearchAskBtn,
    deriveSettingHelp,
    showSettingHelp,
    setMenuState: settingsPanelApi && settingsPanelApi.setMenuState
  });
  window.searchSettings = settingsSearch.searchSettings;
  initMobaSettingsMenu({
    sbContent,
    settingsGenreSelect,
    syncMenuMeasurements
  });

  // State
  const CAMERA_WIDTH = 1920;
  const CAMERA_HEIGHT = 1080;
  const BASE_CAMERA_WIDTH = CAMERA_WIDTH;
  const BASE_CAMERA_HEIGHT = CAMERA_HEIGHT;
  const hitboxCanvas = document.createElement('canvas');
  const hitboxCtx = hitboxCanvas.getContext('2d');

  function defaultSpawnPosition(side){
    const baseMargin = Math.max(PORTAL_R + 20, minionRadius + 10);
    const width = mapState.width;
    const height = mapState.height;
    const marginX = Math.min(baseMargin, width / 2 || 0);
    const marginY = Math.min(baseMargin, height / 2 || 0);
    const clampCoord = (value, max) => {
      if(!(max > 0)) return 0;
      return Math.max(0, Math.min(max, value));
    };
    const x = side === 'blue' ? marginX : width - marginX;
    const y = side === 'blue' ? height - marginY : marginY;
    return {
      x: clampCoord(x, width),
      y: clampCoord(y, height),
      userPlaced: false
    };
  }
  function ensureDefaultSpawns(force = false){
    if(force || !blueSpawns[0]){
      if(!force || !blueSpawns[0] || !blueSpawns[0].userPlaced){
        blueSpawns[0] = defaultSpawnPosition('blue');
        blueSpawns.length = 1;
      }
    }
    if(force || !redSpawns[0]){
      if(!force || !redSpawns[0] || !redSpawns[0].userPlaced){
        redSpawns[0] = defaultSpawnPosition('red');
        redSpawns.length = 1;
      }
    }
    invalidateLaneLayout({ resetMinions: true });
  }

  const camera = cameraState;
  let cameraFollowLagMs = camera.followLagMs;
  let cameraLeadDistance = camera.leadDistance;
  let cameraHorizontalOffsetPercent = camera.horizontalOffsetPercent;
  let cameraVerticalOffsetPercent = camera.verticalOffsetPercent;
  let cameraEdgeScrollMargin = camera.edgeScrollMargin;
  let cameraEdgeScrollSpeed = camera.edgeScrollSpeed;
  let cameraRecenterDelayMs = camera.recenterDelayMs;
  let cameraManualLeash = camera.manualLeash;
  let cameraWheelSensitivity = camera.wheelSensitivity;
  let cameraZoomInLocked = camera.zoomInLocked;
  let cameraZoomInLimit = camera.zoomInLimit;
  let cameraZoomOutLocked = camera.zoomOutLocked;
  let cameraZoomOutLimit = camera.zoomOutLimit;
  const CAMERA_RETURN_RATE = 3.8;
  const CAMERA_ZOOM_MIN = 0;
  const CAMERA_ZOOM_MAX = 5;
  let cameraLockBinding = camera.lockBinding ? { ...camera.lockBinding } : { key: ' ', code: 'Space', label: 'Space' };
  let cameraLockCapture = camera.lockCapture;
  let attackMoveBinding = keybindState && keybindState.attackMove ? { ...keybindState.attackMove } : { key: '', code: '', label: formatAbilityKeyLabel('', '') };
  keybindState.attackMove = { ...attackMoveBinding };
  let attackMoveCapture = false;
  let pingWheelBinding = keybindState && keybindState.pingWheel ? { ...keybindState.pingWheel } : { key: 'g', code: 'KeyG', label: 'G' };
  keybindState.pingWheel = { ...pingWheelBinding };
  let pingWheelCapture = false;
  const pingWheelRuntime = {
    active: false,
    keyHeld: false,
    anchorX: 0,
    anchorY: 0,
    pointerX: 0,
    pointerY: 0,
    pointerDistance: 0,
    selection: null
  };
  let lastUnlockedCameraMode = camera.lastUnlockedMode;
  let cameraLastManualMoveAt = camera.lastManualMoveAt;
  let cameraDragActive = camera.drag.active;
  let cameraDragPointerId = camera.drag.pointerId;
  let cameraDragLast = camera.drag.last;
  let lastPlayerVelocityX = camera.lastPlayerVelocity.x;
  let lastPlayerVelocityY = camera.lastPlayerVelocity.y;
  let lastCameraTransformX = camera.lastTransform.x;
  let lastCameraTransformY = camera.lastTransform.y;
  let lastCameraTransformScale = camera.lastTransform.scale;
  function cameraRight(){ return camera.x + camera.width; }
  function cameraBottom(){ return camera.y + camera.height; }
  function circleInCamera(x, y, radius = 0){
    if(!Number.isFinite(x) || !Number.isFinite(y)) return false;
    const r = Math.max(0, radius);
    const left = x - r;
    const right = x + r;
    const top = y - r;
    const bottom = y + r;
    return right >= camera.x && left <= cameraRight() && bottom >= camera.y && top <= cameraBottom();
  }
  function rectIntersectsCamera(minX, minY, maxX, maxY, padding = 0){
    if(!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)){
      return false;
    }
    const pad = Math.max(0, padding);
    const left = Math.min(minX, maxX) - pad;
    const right = Math.max(minX, maxX) + pad;
    const top = Math.min(minY, maxY) - pad;
    const bottom = Math.max(minY, maxY) + pad;
    return right >= camera.x && left <= cameraRight() && bottom >= camera.y && top <= cameraBottom();
  }
  function clampCameraToBounds(){
    const maxX = Math.max(0, mapState.width - camera.width);
    const maxY = Math.max(0, mapState.height - camera.height);
    if(!Number.isFinite(camera.x)) camera.x = 0;
    if(!Number.isFinite(camera.y)) camera.y = 0;
    camera.x = Math.max(0, Math.min(maxX, camera.x));
    camera.y = Math.max(0, Math.min(maxY, camera.y));
  }
  function applyCameraTransform(force = false){
    if(!view){
      return;
    }
    const scale = Math.max(0.001, Number(camera.scale) || 1);
    const tx = -camera.x * scale;
    const ty = -camera.y * scale;
    if(!force && tx === lastCameraTransformX && ty === lastCameraTransformY && scale === lastCameraTransformScale){
      return;
    }
    lastCameraTransformX = tx;
    lastCameraTransformY = ty;
    lastCameraTransformScale = scale;
    camera.lastTransform.x = lastCameraTransformX;
    camera.lastTransform.y = lastCameraTransformY;
    camera.lastTransform.scale = lastCameraTransformScale;
    const matrix = `matrix(${scale}, 0, 0, ${scale}, ${tx}, ${ty})`;
    view.style.transformOrigin = 'top left';
    view.style.transform = matrix;
    if(canvas){
      const inverseScale = 1 / scale;
      const canvasTx = camera.x;
      const canvasTy = camera.y;
      const canvasMatrix = `matrix(${inverseScale}, 0, 0, ${inverseScale}, ${canvasTx}, ${canvasTy})`;
      canvas.style.transformOrigin = 'top left';
      canvas.style.transform = canvasMatrix;
    }
  }
  function cameraLeadVector(){
    const leadDistance = Math.max(0, Number(cameraLeadDistance) || 0);
    if(leadDistance <= 0){
      return { x: 0, y: 0 };
    }
    const speed = Math.hypot(lastPlayerVelocityX, lastPlayerVelocityY);
    if(speed < 0.01){
      return { x: 0, y: 0 };
    }
    const cappedLead = Math.min(leadDistance, camera.width * 0.45);
    const nx = lastPlayerVelocityX / speed;
    const ny = lastPlayerVelocityY / speed;
    return { x: nx * cappedLead, y: ny * cappedLead };
  }

  function clampManualOffset(){
    if(camera.mode === 'locked'){
      camera.manualOffsetX = 0;
      camera.manualOffsetY = 0;
      return;
    }
    if(camera.mode !== 'semi'){
      return;
    }
    const leash = Math.max(0, Number(cameraManualLeash) || 0);
    if(!(leash > 0)){
      return;
    }
    const dist = Math.hypot(camera.manualOffsetX, camera.manualOffsetY);
    if(dist <= leash){
      return;
    }
    const scale = leash / dist;
    camera.manualOffsetX *= scale;
    camera.manualOffsetY *= scale;
  }
  function updateCamera(centerOnPlayer = true, dt = 0, options = {}){
    if(typeof centerOnPlayer === 'object' && centerOnPlayer !== null){
      options = centerOnPlayer;
      centerOnPlayer = options.centerOnPlayer !== undefined ? !!options.centerOnPlayer : true;
      dt = Number(options.dt) || 0;
    } else if(typeof dt === 'object' && dt !== null){
      options = dt;
      dt = Number(options.dt) || 0;
    }
    let playerRef = null;
    try {
      playerRef = player;
    } catch (err) {
      playerRef = null;
    }
    if(centerOnPlayer && playerRef){
      camera.followX = playerRef.x;
      camera.followY = playerRef.y;
    }
    const lead = cameraLeadVector();
    const now = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
    let anchorX = camera.followX + lead.x;
    let anchorY = camera.followY + lead.y;
    const horizontalBias = Math.max(-100, Math.min(100, Number(cameraHorizontalOffsetPercent) || 0));
    const verticalBias = Math.max(-100, Math.min(100, Number(cameraVerticalOffsetPercent) || 0));
    if(horizontalBias !== 0){
      anchorX += camera.width * (horizontalBias / 100);
    }
    if(verticalBias !== 0){
      anchorY += camera.height * (verticalBias / 100);
    }
    if(camera.mode === 'locked'){
      camera.manualOffsetX = 0;
      camera.manualOffsetY = 0;
    } else {
      if(camera.mode === 'semi' && dt > 0){
        if(now - cameraLastManualMoveAt > cameraRecenterDelayMs){
          const decay = Math.exp(-CAMERA_RETURN_RATE * dt);
          camera.manualOffsetX *= decay;
          camera.manualOffsetY *= decay;
          if(Math.abs(camera.manualOffsetX) < 0.01) camera.manualOffsetX = 0;
          if(Math.abs(camera.manualOffsetY) < 0.01) camera.manualOffsetY = 0;
        }
      }
      clampManualOffset();
      anchorX += camera.manualOffsetX;
      anchorY += camera.manualOffsetY;
    }
    let targetX = anchorX - camera.width / 2;
    let targetY = anchorY - camera.height / 2;
    const maxX = Math.max(0, mapState.width - camera.width);
    const maxY = Math.max(0, mapState.height - camera.height);
    targetX = Math.max(0, Math.min(maxX, targetX));
    targetY = Math.max(0, Math.min(maxY, targetY));
    if(camera.mode !== 'locked'){
      const clampedCenterX = targetX + camera.width / 2;
      const clampedCenterY = targetY + camera.height / 2;
      const adjustX = clampedCenterX - anchorX;
      const adjustY = clampedCenterY - anchorY;
      if(adjustX !== 0 || adjustY !== 0){
        camera.manualOffsetX += adjustX;
        camera.manualOffsetY += adjustY;
        clampManualOffset();
      }
    }
    const force = options && options.force;
    if(force){
      camera.x = targetX;
      camera.y = targetY;
    } else {
      const lagSeconds = Math.max(0, Number(cameraFollowLagMs) || 0) / 1000;
      let blend = 1;
      if(lagSeconds > 0 && dt > 0){
        blend = Math.min(1, dt / (lagSeconds + dt));
      }
      camera.x += (targetX - camera.x) * blend;
      camera.y += (targetY - camera.y) * blend;
    }
    clampCameraToBounds();
    applyCameraTransform(force);
  }

  function setCameraMode(mode, { syncInput = true, silent = false } = {}){
    const normalized = typeof mode === 'string' ? mode.toLowerCase() : '';
    let target = 'semi';
    if(normalized === 'locked'){
      target = 'locked';
    } else if(normalized === 'free' || normalized === 'unlocked'){
      target = 'free';
    } else if(normalized === 'semi' || normalized === 'semi-locked'){
      target = 'semi';
    }
    if(camera.mode === target){
      if(syncInput && cameraModeSelect && cameraModeSelect.value !== target){
        cameraModeSelect.value = target;
      }
      return;
    }
    if(target !== 'locked'){
      lastUnlockedCameraMode = target;
      camera.lastUnlockedMode = lastUnlockedCameraMode;
    }
    camera.mode = target;
    if(cameraModeSelect && syncInput && cameraModeSelect.value !== target){
      cameraModeSelect.value = target;
    }
    if(target === 'locked'){
      camera.manualOffsetX = 0;
      camera.manualOffsetY = 0;
    }
    if(!silent){
      updateCamera(true, 0, { force: true });
    }
  }

  function toggleCameraLock(){
    if(camera.mode === 'locked'){
      const next = lastUnlockedCameraMode === 'free' ? 'free' : 'semi';
      setCameraMode(next, { syncInput: true });
      cameraLastManualMoveAt = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
      camera.lastManualMoveAt = cameraLastManualMoveAt;
    } else {
      lastUnlockedCameraMode = camera.mode;
      camera.lastUnlockedMode = lastUnlockedCameraMode;
      setCameraMode('locked', { syncInput: true });
      recenterCamera({ force: true });
    }
  }

  function applyManualCameraOffset(offsetX, offsetY, { immediate = false } = {}){
    if(camera.mode === 'locked'){
      return;
    }
    const dx = Number(offsetX) || 0;
    const dy = Number(offsetY) || 0;
    if(dx === 0 && dy === 0){
      return;
    }
    camera.manualOffsetX += dx;
    camera.manualOffsetY += dy;
    clampManualOffset();
    cameraLastManualMoveAt = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
    camera.lastManualMoveAt = cameraLastManualMoveAt;
    if(immediate){
      updateCamera(false, 0, { force: true });
    }
  }

  function recenterCamera({ force = true } = {}){
    camera.manualOffsetX = 0;
    camera.manualOffsetY = 0;
    cameraLastManualMoveAt = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
    camera.lastManualMoveAt = cameraLastManualMoveAt;
    updateCamera(true, 0, { force });
  }

  function setCameraFollowLag(value, { syncInput = true } = {}){
    const numeric = Math.max(0, Math.min(3000, Number(value) || 0));
    cameraFollowLagMs = numeric;
    camera.followLagMs = numeric;
    if(cameraFollowLagInput && syncInput){
      cameraFollowLagInput.value = String(Math.round(numeric));
    }
    if(cameraFollowLagDisplay){
      cameraFollowLagDisplay.textContent = numeric <= 0 ? 'Instant' : `${Math.round(numeric)}ms`;
    }
  }

  function setCameraLead(value, { syncInput = true } = {}){
    const numeric = Math.max(0, Math.min(3000, Number(value) || 0));
    cameraLeadDistance = numeric;
    camera.leadDistance = numeric;
    if(cameraLeadInput && syncInput){
      cameraLeadInput.value = String(Math.round(numeric));
    }
    if(cameraLeadDisplay){
      cameraLeadDisplay.textContent = `${Math.round(numeric)}px`;
    }
    updateCamera(true, 0, { force: true });
  }

  function setCameraHorizontalOffset(value, { syncInput = true } = {}){
    let numeric = Number(value);
    if(!Number.isFinite(numeric)){
      numeric = 0;
    }
    numeric = Math.max(-100, Math.min(100, numeric));
    cameraHorizontalOffsetPercent = numeric;
    camera.horizontalOffsetPercent = numeric;
    if(cameraHorizontalOffsetInput){
      const rounded = String(Math.round(numeric));
      if(syncInput || cameraHorizontalOffsetInput.value !== rounded){
        cameraHorizontalOffsetInput.value = rounded;
      }
    }
    if(cameraHorizontalOffsetDisplay){
      const rounded = Math.round(numeric);
      if(Math.abs(rounded) < 1){
        cameraHorizontalOffsetDisplay.textContent = 'Centered';
      } else if(rounded > 0){
        cameraHorizontalOffsetDisplay.textContent = `Right ${rounded}%`;
      } else {
        cameraHorizontalOffsetDisplay.textContent = `Left ${Math.abs(rounded)}%`;
      }
    }
    updateCamera(true, 0, { force: true });
  }

  function setCameraVerticalOffset(value, { syncInput = true } = {}){
    let numeric = Number(value);
    if(!Number.isFinite(numeric)){
      numeric = 0;
    }
    numeric = Math.max(-100, Math.min(100, numeric));
    cameraVerticalOffsetPercent = numeric;
    camera.verticalOffsetPercent = numeric;
    if(cameraVerticalOffsetInput){
      const rounded = String(Math.round(numeric));
      if(syncInput || cameraVerticalOffsetInput.value !== rounded){
        cameraVerticalOffsetInput.value = rounded;
      }
    }
    if(cameraVerticalOffsetDisplay){
      const rounded = Math.round(numeric);
      if(Math.abs(rounded) < 1){
        cameraVerticalOffsetDisplay.textContent = 'Centered';
      } else if(rounded > 0){
        cameraVerticalOffsetDisplay.textContent = `Down ${rounded}%`;
      } else {
        cameraVerticalOffsetDisplay.textContent = `Up ${Math.abs(rounded)}%`;
      }
    }
    updateCamera(true, 0, { force: true });
  }

  function setCameraEdgeMargin(value, { syncInput = true } = {}){
    const numeric = Math.max(0, Math.min(3000, Number(value) || 0));
    cameraEdgeScrollMargin = numeric;
    camera.edgeScrollMargin = numeric;
    if(cameraEdgeMarginInput && syncInput){
      cameraEdgeMarginInput.value = String(Math.round(numeric));
    }
    if(cameraEdgeMarginDisplay){
      cameraEdgeMarginDisplay.textContent = `${Math.round(numeric)}px`;
    }
  }

  function setCameraEdgeSpeed(value, { syncInput = true } = {}){
    const numeric = Math.max(0, Math.min(3000, Number(value) || 0));
    cameraEdgeScrollSpeed = numeric;
    camera.edgeScrollSpeed = numeric;
    if(cameraEdgeSpeedInput && syncInput){
      cameraEdgeSpeedInput.value = String(Math.round(numeric));
    }
    if(cameraEdgeSpeedDisplay){
      cameraEdgeSpeedDisplay.textContent = numeric <= 0 ? 'Off' : `${Math.round(numeric)}px/s`;
    }
  }

  function setCameraRecenterDelay(value, { syncInput = true } = {}){
    const numeric = Math.max(0, Math.min(3000, Number(value) || 0));
    cameraRecenterDelayMs = numeric;
    camera.recenterDelayMs = numeric;
    if(cameraRecenterDelayInput && syncInput){
      cameraRecenterDelayInput.value = String(Math.round(numeric));
    }
    if(cameraRecenterDelayDisplay){
      const seconds = numeric / 1000;
      if(seconds <= 0){
        cameraRecenterDelayDisplay.textContent = '0s';
      } else if(seconds >= 1){
        cameraRecenterDelayDisplay.textContent = `${seconds.toFixed(2)}s`;
      } else {
        cameraRecenterDelayDisplay.textContent = `${seconds.toFixed(2)}s`;
      }
    }
  }

  function setCameraManualLeash(value, { syncInput = true } = {}){
    const numeric = Math.max(0, Math.min(3000, Number(value) || 0));
    cameraManualLeash = numeric;
    camera.manualLeash = numeric;
    if(cameraManualLeashInput && syncInput){
      cameraManualLeashInput.value = String(Math.round(numeric));
    }
    if(cameraManualLeashDisplay){
      cameraManualLeashDisplay.textContent = numeric <= 0 ? 'Unlimited' : `${Math.round(numeric)}px`;
    }
    clampManualOffset();
    updateCamera(true, 0, { force: true });
  }

  function applyZoomLockLimits(percent){
    let clamped = Number(percent);
    if(!Number.isFinite(clamped)){
      clamped = camera.scale * 100;
    }
    clamped = Math.max(CAMERA_ZOOM_MIN * 100, Math.min(CAMERA_ZOOM_MAX * 100, clamped));
    if(cameraZoomInLocked && Number.isFinite(cameraZoomInLimit)){
      clamped = Math.min(clamped, cameraZoomInLimit);
    }
    if(cameraZoomOutLocked && Number.isFinite(cameraZoomOutLimit)){
      clamped = Math.max(clamped, cameraZoomOutLimit);
    }
    return clamped;
  }

  function updateZoomLockButton(btn, locked){
    if(!btn){
      return;
    }
    btn.textContent = locked ? 'Locked' : 'Unlocked';
    btn.setAttribute('aria-pressed', locked ? 'true' : 'false');
  }

  function setCameraZoomInLock(value, limitOverride = null){
    const locked = !!value;
    cameraZoomInLocked = locked;
    camera.zoomInLocked = locked;
    if(locked){
      if(limitOverride != null && Number.isFinite(Number(limitOverride))){
        cameraZoomInLimit = Number(limitOverride);
      } else {
        cameraZoomInLimit = applyZoomLockLimits(Math.round(camera.scale * 100));
      }
    } else {
      cameraZoomInLimit = null;
    }
    camera.zoomInLimit = cameraZoomInLimit;
    updateZoomLockButton(cameraZoomInLockBtn, locked);
    if(locked){
      setCameraZoom(camera.scale * 100, { syncInput: true, instant: true });
    }
  }

  function setCameraZoomOutLock(value, limitOverride = null){
    const locked = !!value;
    cameraZoomOutLocked = locked;
    camera.zoomOutLocked = locked;
    if(locked){
      if(limitOverride != null && Number.isFinite(Number(limitOverride))){
        cameraZoomOutLimit = Number(limitOverride);
      } else {
        cameraZoomOutLimit = applyZoomLockLimits(Math.round(camera.scale * 100));
      }
    } else {
      cameraZoomOutLimit = null;
    }
    camera.zoomOutLimit = cameraZoomOutLimit;
    updateZoomLockButton(cameraZoomOutLockBtn, locked);
    if(locked){
      setCameraZoom(camera.scale * 100, { syncInput: true, instant: true });
    }
  }

  function setCameraZoom(value, { syncInput = true, instant = false } = {}){
    let numeric = Number(value);
    if(!Number.isFinite(numeric)){
      numeric = camera.scale * 100;
    }
    if(Math.abs(numeric) <= 2){
      numeric = numeric * 100;
    }
    const percent = applyZoomLockLimits(numeric);
    const nextScale = Math.max(0.001, percent / 100);
    const previousScale = camera.scale;
    camera.scale = nextScale;
    syncCameraDimensions();
    if(cameraZoomInput){
      const rounded = String(Math.round(percent));
      if(syncInput || cameraZoomInput.value !== rounded){
        cameraZoomInput.value = rounded;
      }
    }
    if(cameraZoomDisplay){
      cameraZoomDisplay.textContent = `${Math.round(percent)}%`;
    }
    clampCameraToBounds();
    updateCamera(true, 0, { force: instant });
    renderMinimap(true);
    return Math.abs(camera.scale - previousScale) > 1e-6;
  }

  function setCameraWheelSensitivity(value, { syncInput = true } = {}){
    const numeric = Math.max(0, Number(value) || 0);
    cameraWheelSensitivity = numeric;
    camera.wheelSensitivity = numeric;
    if(cameraWheelSensitivityInput && syncInput){
      cameraWheelSensitivityInput.value = String(Math.round(numeric));
    }
    if(cameraWheelSensitivityDisplay){
      cameraWheelSensitivityDisplay.textContent = numeric <= 0 ? 'Off' : `${Math.round(numeric)}%/step`;
    }
  }

  function updateCameraLockBindingDisplay(){
    if(!cameraLockBindBtn){
      return;
    }
    if(cameraLockCapture){
      cameraLockBindBtn.textContent = 'Press a key...';
    } else {
      cameraLockBindBtn.textContent = cameraLockBinding && cameraLockBinding.label ? cameraLockBinding.label : 'â€”';
    }
  }

  function setCameraLockBinding(key, code){
    const label = formatAbilityKeyLabel(key, code);
    cameraLockBinding = {
      key: typeof key === 'string' ? key : '',
      code: typeof code === 'string' ? code : '',
      label
    };
    camera.lockBinding = { ...cameraLockBinding };
    updateCameraLockBindingDisplay();
  }

  function matchesCameraLockKey(ev){
    if(!cameraLockBinding){
      return false;
    }
    const bindingCode = cameraLockBinding.code;
    if(bindingCode && ev.code === bindingCode){
      return true;
    }
    const bindingKey = cameraLockBinding.key ? cameraLockBinding.key.toLowerCase() : '';
    if(bindingCode){
      return false;
    }
    if(!bindingKey){
      return false;
    }
    const eventKey = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
    return eventKey === bindingKey;
  }

  function refreshCursorToggleButtons(){
    if(cursorToggleBtn){
      cursorToggleBtn.textContent = cursorState.enabled ? 'Enabled' : 'Disabled';
      cursorToggleBtn.classList.toggle('is-active', cursorState.enabled);
    }
    if(cursorOutlineToggle){
      cursorOutlineToggle.textContent = cursorState.outlineEnabled ? 'Enabled' : 'Disabled';
      cursorOutlineToggle.classList.toggle('is-active', cursorState.outlineEnabled);
    }
  }

  function refreshStageCursor(){
    if(stage){
      stage.setAttribute('data-cursor-enabled', String(cursorState.enabled));
    }
    if(!stageCursorEl){
      return;
    }
    const visible = cursorState.enabled && stagePointerState.inside;
    stageCursorEl.dataset.visible = visible ? 'true' : 'false';
    if(visible){
      const x = Number(stagePointerState.x) || 0;
      const y = Number(stagePointerState.y) || 0;
      stageCursorEl.style.transform = `translate(${x}px, ${y}px)`;
    }
  }

  function setCursorEnabled(value, { syncInput = true } = {}){
    cursorState.enabled = !!value;
    if(syncInput){
      refreshCursorToggleButtons();
    }
    if(!cursorState.enabled){
      clearHoverTarget();
    }
    refreshStageCursor();
  }

  function setCursorOutlineEnabled(value, { syncInput = true } = {}){
    cursorState.outlineEnabled = !!value;
    if(syncInput){
      refreshCursorToggleButtons();
    }
    if(!cursorState.outlineEnabled){
      clearHoverTarget();
    }
  }

  function setCursorEmoji(value, { syncInput = true } = {}){
    const sanitized = sanitizeEmojiInput(value, cursorState.emoji || 'ðŸŽ¯');
    cursorState.emoji = sanitized;
    if(cursorEmojiInput && syncInput){
      cursorEmojiInput.value = sanitized;
    }
    if(stageCursorIcon){
      stageCursorIcon.textContent = sanitized;
    }
  }

  function setCursorHoverColor(value, { syncInput = true } = {}){
    const sanitized = sanitizeHexColor(value, cursorState.hoverColor || '#7fe3ff');
    cursorState.hoverColor = sanitized;
    if(cursorHoverColorInput && syncInput){
      cursorHoverColorInput.value = sanitized;
    }
    if(typeof rootStyle !== 'undefined' && rootStyle){
      rootStyle.setProperty('--cursor-hover-color', sanitized);
    }
  }

  function setHoverTarget(target, type){
    if(target && type){
      cursorRuntime.hoverTarget = { ref: target, type };
    } else {
      cursorRuntime.hoverTarget = null;
    }
  }

  function clearHoverTarget(){
    cursorRuntime.hoverTarget = null;
  }

  function updateHoverTargetFromPosition(x, y){
    if(!cursorState.outlineEnabled){
      clearHoverTarget();
      return;
    }
    const dummyActive = practiceDummy && practiceDummy.active !== false && !(practiceDummy.respawnTimer > 0);
    if(dummyActive && isPointerInsidePracticeDummy(x, y)){
      setHoverTarget(practiceDummy, 'dummy');
      return;
    }
    const target = findAutoAttackTargetAt(x, y);
    if(target){
      if(target === monsterState){
        setHoverTarget(monsterState, 'monster');
      } else if(target.isPracticeDummy){
        setHoverTarget(target, 'dummy');
      } else {
        setHoverTarget(target, 'minion');
      }
      return;
    }
    clearHoverTarget();
  }

  function updateAttackMoveBindingDisplay(){
    if(!attackMoveBindBtn){
      return;
    }
    if(attackMoveCapture){
      attackMoveBindBtn.textContent = 'Press a key...';
    } else {
      attackMoveBindBtn.textContent = attackMoveBinding && attackMoveBinding.label ? attackMoveBinding.label : formatAbilityKeyLabel('', '');
    }
    attackMoveBindBtn.classList.toggle('is-active', attackMoveCapture);
  }

  function setAttackMoveBinding(key, code){
    const bindingKey = typeof key === 'string' ? key : '';
    const bindingCode = typeof code === 'string' ? code : '';
    const label = formatAbilityKeyLabel(bindingKey, bindingCode);
    attackMoveBinding = { key: bindingKey, code: bindingCode, label };
    keybindState.attackMove = { ...attackMoveBinding };
    updateAttackMoveBindingDisplay();
  }

  function matchesAttackMoveKey(ev){
    if(!attackMoveBinding){
      return false;
    }
    const bindingCode = attackMoveBinding.code;
    if(bindingCode && ev.code === bindingCode){
      return true;
    }
    const bindingKey = attackMoveBinding.key ? attackMoveBinding.key.toLowerCase() : '';
    if(bindingCode){
      return false;
    }
    if(!bindingKey){
      return false;
    }
    const eventKey = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
    return eventKey === bindingKey;
  }

  function findClosestAttackMoveTarget(x, y){
    let bestTarget = null;
    let bestType = null;
    let bestDistSq = Infinity;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      const distSq = dx * dx + dy * dy;
      if(distSq < bestDistSq){
        bestDistSq = distSq;
        bestTarget = m;
        bestType = 'minion';
      }
    }
    if(isMonsterAttackable(monsterState)){
      const dx = monsterState.x - x;
      const dy = monsterState.y - y;
      const distSq = dx * dx + dy * dy;
      if(distSq < bestDistSq){
        bestDistSq = distSq;
        bestTarget = monsterState;
        bestType = 'monster';
      }
    }
    return bestTarget ? { ref: bestTarget, type: bestType } : null;
  }

  function executeAttackMove(){
    if(isPlayerRecalling()){
      cancelRecall('move');
    }
    const coords = abilityRuntime.lastPointerWorld
      ? { x: abilityRuntime.lastPointerWorld.x, y: abilityRuntime.lastPointerWorld.y }
      : { x: player.x, y: player.y };
    const targetInfo = findClosestAttackMoveTarget(coords.x, coords.y);
    let message = 'Moving to cursor.';
    if(targetInfo){
      commandPlayerAttack(targetInfo.ref);
      message = targetInfo.type === 'monster' ? 'Engaging the monster.' : 'Engaging the nearest enemy.';
    } else {
      cancelPlayerAttack();
    }
    issuePlayerMoveOrder(coords.x, coords.y, { flashPulse: true, updateHud: false });
    setHudMessage(`Attack move: ${message}`);
    updateHoverTargetFromPosition(coords.x, coords.y);
  }

  function updatePingWheelBindingDisplay(){
    if(!pingWheelBindBtn){
      return;
    }
    if(pingWheelCapture){
      pingWheelBindBtn.textContent = 'Press a key...';
    } else {
      pingWheelBindBtn.textContent = pingWheelBinding && pingWheelBinding.label ? pingWheelBinding.label : 'â€”';
    }
    pingWheelBindBtn.classList.toggle('is-active', pingWheelCapture);
  }

  function setPingWheelBinding(key, code){
    const bindingKey = typeof key === 'string' ? key : '';
    const bindingCode = typeof code === 'string' ? code : '';
    const label = formatAbilityKeyLabel(bindingKey, bindingCode);
    pingWheelBinding = { key: bindingKey, code: bindingCode, label };
    keybindState.pingWheel = { ...pingWheelBinding };
    updatePingWheelBindingDisplay();
  }

  function matchesPingWheelKey(ev){
    if(!pingWheelBinding){
      return false;
    }
    const bindingCode = pingWheelBinding.code;
    if(bindingCode && ev.code === bindingCode){
      return true;
    }
    const bindingKey = pingWheelBinding.key ? pingWheelBinding.key.toLowerCase() : '';
    if(bindingCode){
      return false;
    }
    if(!bindingKey){
      return false;
    }
    const eventKey = typeof ev.key === 'string' ? ev.key.toLowerCase() : '';
    return eventKey === bindingKey;
  }

  function cancelPingWheel(){
    pingWheelRuntime.active = false;
    pingWheelRuntime.keyHeld = false;
    pingWheelRuntime.selection = null;
    pingWheelRuntime.pointerDistance = 0;
  }

  function setPingWheelPointer(x, y){
    if(!pingWheelRuntime.active){
      return;
    }
    pingWheelRuntime.pointerX = x;
    pingWheelRuntime.pointerY = y;
  }

  function resolvePingWheelSelection(){
    if(!pingWheelRuntime.active){
      pingWheelRuntime.selection = null;
      pingWheelRuntime.pointerDistance = 0;
      return null;
    }
    const dx = pingWheelRuntime.pointerX - pingWheelRuntime.anchorX;
    const dy = pingWheelRuntime.pointerY - pingWheelRuntime.anchorY;
    const cameraScale = Math.max(0.001, Number(camera.scale) || 1);
    const distance = Math.hypot(dx, dy);
    pingWheelRuntime.pointerDistance = distance;
    const minDistance = 48 / cameraScale;
    if(distance < minDistance){
      pingWheelRuntime.selection = null;
      return null;
    }
    const angle = Math.atan2(dy, dx);
    let type;
    if(angle > -Math.PI / 4 && angle <= Math.PI / 4){
      type = 'target';
    } else if(angle > Math.PI / 4 && angle <= 3 * Math.PI / 4){
      type = 'assistMe';
    } else if(angle > -3 * Math.PI / 4 && angle <= -Math.PI / 4){
      type = 'onMyWay';
    } else {
      type = 'enemyMissing';
    }
    pingWheelRuntime.selection = type;
    return type;
  }

  function openPingWheel(){
    const source = stagePointerState.inside && Number.isFinite(stagePointerState.worldX) && Number.isFinite(stagePointerState.worldY)
      ? { x: stagePointerState.worldX, y: stagePointerState.worldY }
      : (abilityRuntime.lastPointerWorld && Number.isFinite(abilityRuntime.lastPointerWorld.x) && Number.isFinite(abilityRuntime.lastPointerWorld.y)
        ? { x: abilityRuntime.lastPointerWorld.x, y: abilityRuntime.lastPointerWorld.y }
        : { x: player.x, y: player.y });
    pingWheelRuntime.active = true;
    pingWheelRuntime.keyHeld = true;
    pingWheelRuntime.anchorX = source.x;
    pingWheelRuntime.anchorY = source.y;
    pingWheelRuntime.pointerX = source.x;
    pingWheelRuntime.pointerY = source.y;
    pingWheelRuntime.selection = null;
    pingWheelRuntime.pointerDistance = 0;
    abilityRuntime.lastPointerWorld = { x: source.x, y: source.y };
  }

  function closePingWheel({ trigger = false } = {}){
    const wasActive = pingWheelRuntime.active;
    const selection = resolvePingWheelSelection();
    const choice = selection || 'target';
    const coords = { x: pingWheelRuntime.pointerX, y: pingWheelRuntime.pointerY };
    cancelPingWheel();
    if(trigger && wasActive){
      triggerPing(choice, { coords, viaWheel: true });
    }
  }

  function setPingEmoji(type, value, { syncInput = true } = {}){
    if(!pingState || !pingState.types || !Object.prototype.hasOwnProperty.call(pingState.types, type)){
      return;
    }
    const sanitized = sanitizeEmojiInput(value, pingState.types[type]);
    pingState.types[type] = sanitized;
    if(syncInput && pingInputs[type]){
      pingInputs[type].value = sanitized;
    }
  }

  function triggerPing(type, options = {}){
    if(!pingState || !pingState.types){
      return;
    }
    const emoji = pingState.types[type] || 'â—';
    let coords;
    if(options && options.coords && Number.isFinite(options.coords.x) && Number.isFinite(options.coords.y)){
      coords = { x: options.coords.x, y: options.coords.y };
    } else if(abilityRuntime.lastPointerWorld && Number.isFinite(abilityRuntime.lastPointerWorld.x) && Number.isFinite(abilityRuntime.lastPointerWorld.y)){
      coords = { x: abilityRuntime.lastPointerWorld.x, y: abilityRuntime.lastPointerWorld.y };
    } else {
      coords = { x: player.x, y: player.y };
    }
    const clampedX = Math.max(0, Math.min(mapState.width, coords.x));
    const clampedY = Math.max(0, Math.min(mapState.height, coords.y));
    abilityRuntime.lastPointerWorld = { x: clampedX, y: clampedY };
    activePings.push({ type, emoji, x: clampedX, y: clampedY, age: 0, lifetime: 1.8 });
    const color = PING_VISUALS[type] || '#7fe3ff';
    flash(clampedX, clampedY, { startRadius: 24, endRadius: 72, color });
    setHudMessage(`Ping dropped: ${emoji}`);
  }

  function updatePings(dt){
    for(let i = activePings.length - 1; i >= 0; i--){
      const ping = activePings[i];
      ping.age += dt;
      const lifetime = Math.max(0.5, Number(ping.lifetime) || 1.8);
      if(ping.age >= lifetime){
        activePings.splice(i, 1);
      }
    }
  }

  function drawPings(){
    if(!activePings.length){
      return;
    }
    for(const ping of activePings){
      const color = PING_VISUALS[ping.type] || '#7fe3ff';
      const lifetime = Math.max(0.5, Number(ping.lifetime) || 1.8);
      const progress = Math.max(0, Math.min(1, ping.age / lifetime));
      const alpha = 1 - progress;
      const pulse = Math.sin(progress * Math.PI);
      const radius = 24 + pulse * 12;
      if(!circleInCamera(ping.x, ping.y, radius + 24)){
        continue;
      }
      ctx.save();
      ctx.globalAlpha = Math.max(0.2, alpha);
      ctx.lineWidth = 3;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.arc(ping.x, ping.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.font = 'bold 28px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#05121a';
      ctx.strokeText(ping.emoji, ping.x, ping.y + 1);
      ctx.fillStyle = color;
      ctx.fillText(ping.emoji, ping.x, ping.y + 1);
      ctx.restore();
    }
  }

  function drawPingWheel(){
    if(!pingWheelRuntime.active){
      return;
    }
    const selection = resolvePingWheelSelection();
    const activeType = selection || 'target';
    const dx = pingWheelRuntime.pointerX - pingWheelRuntime.anchorX;
    const dy = pingWheelRuntime.pointerY - pingWheelRuntime.anchorY;
    const cameraScale = Math.max(0.001, Number(camera.scale) || 1);
    const radius = 140 / cameraScale;
    const innerRadius = 46 / cameraScale;
    const haloRadius = radius + 18 / cameraScale;
    const strokeWidth = 2.2 / cameraScale;
    const pointerDistance = pingWheelRuntime.pointerDistance;
    const segments = [
      { type: 'onMyWay', start: -3 * Math.PI / 4, end: -Math.PI / 4, label: 'On my way' },
      { type: 'target', start: -Math.PI / 4, end: Math.PI / 4, label: 'Target' },
      { type: 'assistMe', start: Math.PI / 4, end: 3 * Math.PI / 4, label: 'Assist me' },
      { type: 'enemyMissing', start: 3 * Math.PI / 4, end: 5 * Math.PI / 4, label: 'Enemy missing' }
    ];
    const centerX = pingWheelRuntime.anchorX;
    const centerY = pingWheelRuntime.anchorY;
    ctx.save();
    ctx.translate(centerX, centerY);

    ctx.beginPath();
    ctx.arc(0, 0, haloRadius, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(7, 12, 22, 0.78)';
    ctx.fill();

    for(const segment of segments){
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, segment.start, segment.end);
      ctx.closePath();
      const baseColor = PING_VISUALS[segment.type] || '#7fe3ff';
      const fillSuffix = segment.type === activeType ? 'cc' : '33';
      const strokeSuffix = segment.type === activeType ? 'ff' : '77';
      const fillColor = baseColor.length === 7 ? `${baseColor}${fillSuffix}` : baseColor;
      const strokeColor = baseColor.length === 7 ? `${baseColor}${strokeSuffix}` : baseColor;
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.lineWidth = strokeWidth;
      ctx.strokeStyle = strokeColor;
      ctx.stroke();

      const midAngle = (segment.start + segment.end) / 2;
      const emojiRadius = (radius + innerRadius) / 2;
      const labelRadius = radius + 28 / cameraScale;
      const emoji = pingState.types && pingState.types[segment.type] ? pingState.types[segment.type] : 'â—';
      ctx.fillStyle = '#f6fbff';
      ctx.font = `bold ${Math.max(22, Math.round(34 / cameraScale))}px system-ui`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, Math.cos(midAngle) * emojiRadius, Math.sin(midAngle) * emojiRadius);
      ctx.fillStyle = '#b9c7dd';
      ctx.font = `500 ${Math.max(11, Math.round(13 / cameraScale))}px system-ui`;
      ctx.fillText(segment.label, Math.cos(midAngle) * labelRadius, Math.sin(midAngle) * labelRadius);
    }

    ctx.beginPath();
    ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(11, 18, 30, 0.92)';
    ctx.fill();
    ctx.lineWidth = strokeWidth;
    ctx.strokeStyle = '#23324a';
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-innerRadius * 0.55, 0);
    ctx.lineTo(innerRadius * 0.55, 0);
    ctx.moveTo(0, -innerRadius * 0.55);
    ctx.lineTo(0, innerRadius * 0.55);
    ctx.strokeStyle = '#314968';
    ctx.lineWidth = 1.6 / cameraScale;
    ctx.stroke();

    if(pointerDistance > 0){
      const cappedDistance = Math.min(radius, pointerDistance);
      const norm = pointerDistance > 0 ? cappedDistance / pointerDistance : 0;
      const lineX = dx * norm;
      const lineY = dy * norm;
      const pointerColor = PING_VISUALS[activeType] || '#7fe3ff';
      ctx.strokeStyle = pointerColor;
      ctx.lineWidth = 2.6 / cameraScale;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(lineX, lineY);
      ctx.stroke();
      ctx.fillStyle = pointerColor;
      ctx.beginPath();
      ctx.arc(lineX, lineY, 5 / cameraScale, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function updateStagePointerState(ev){
    if(!stage){
      return;
    }
    const rect = stage.getBoundingClientRect();
    stagePointerState.width = rect && Number.isFinite(rect.width) ? rect.width : 0;
    stagePointerState.height = rect && Number.isFinite(rect.height) ? rect.height : 0;
    if(ev){
      const localX = ev.clientX - rect.left;
      const localY = ev.clientY - rect.top;
      stagePointerState.x = localX;
      stagePointerState.y = localY;
      stagePointerState.inside = localX >= 0 && localX <= stagePointerState.width && localY >= 0 && localY <= stagePointerState.height;
      const coords = stagePointerPosition(ev);
      stagePointerState.worldX = coords.x;
      stagePointerState.worldY = coords.y;
      if(pingWheelRuntime.active){
        setPingWheelPointer(coords.x, coords.y);
      }
    }
    refreshStageCursor();
  }

  function applyEdgeScroll(dt){
    if(cameraDragActive){
      return;
    }
    if(camera.mode === 'locked'){
      return;
    }
    if(!(cameraEdgeScrollMargin > 0) || !(cameraEdgeScrollSpeed > 0)){
      return;
    }
    if(!stagePointerState.inside){
      return;
    }
    const width = stagePointerState.width;
    const height = stagePointerState.height;
    if(!(width > 0) || !(height > 0)){
      return;
    }
    const margin = Math.min(cameraEdgeScrollMargin, Math.min(width, height) / 2);
    if(margin <= 0){
      return;
    }
    const x = stagePointerState.x;
    const y = stagePointerState.y;
    let vx = 0;
    let vy = 0;
    if(x < margin){
      vx = -(1 - Math.max(0, x) / margin);
    } else if(x > width - margin){
      vx = (1 - Math.max(0, width - x) / margin);
    }
    if(y < margin){
      vy = -(1 - Math.max(0, y) / margin);
    } else if(y > height - margin){
      vy = (1 - Math.max(0, height - y) / margin);
    }
    if(vx === 0 && vy === 0){
      return;
    }
    const distance = Math.max(0, cameraEdgeScrollSpeed) * Math.max(0, dt);
    if(distance <= 0){
      return;
    }
    const magnitude = Math.hypot(vx, vy) || 1;
    applyManualCameraOffset((vx / magnitude) * distance, (vy / magnitude) * distance);
  }

  function startCameraDrag(ev){
    if(camera.mode === 'locked'){
      setCameraMode(lastUnlockedCameraMode === 'free' ? 'free' : 'semi', { syncInput: true });
    }
    cameraDragActive = true;
    camera.drag.active = true;
    cameraDragPointerId = Number.isFinite(ev.pointerId) ? ev.pointerId : null;
    camera.drag.pointerId = cameraDragPointerId;
    cameraDragLast = { clientX: ev.clientX, clientY: ev.clientY };
    camera.drag.last = cameraDragLast ? { ...cameraDragLast } : null;
    cameraLastManualMoveAt = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
    camera.lastManualMoveAt = cameraLastManualMoveAt;
    if(stage && cameraDragPointerId !== null){
      try {
        stage.setPointerCapture(cameraDragPointerId);
      } catch (err) {
        /* ignore */
      }
    }
  }

  function stopCameraDrag(){
    if(!cameraDragActive){
      return;
    }
    if(stage && cameraDragPointerId !== null){
      try {
        stage.releasePointerCapture(cameraDragPointerId);
      } catch (err) {
        /* ignore */
      }
    }
    cameraDragActive = false;
    camera.drag.active = false;
    cameraDragPointerId = null;
    camera.drag.pointerId = null;
    cameraDragLast = null;
    camera.drag.last = null;
  }

  function initializeCameraControls(){
    setCameraMode(camera.mode, { syncInput: true, silent: true });
    setCameraFollowLag(cameraFollowLagMs);
    setCameraLead(cameraLeadDistance);
    setCameraHorizontalOffset(cameraHorizontalOffsetPercent);
    setCameraVerticalOffset(cameraVerticalOffsetPercent);
    setCameraEdgeMargin(cameraEdgeScrollMargin);
    setCameraEdgeSpeed(cameraEdgeScrollSpeed);
    setCameraRecenterDelay(cameraRecenterDelayMs);
    setCameraManualLeash(cameraManualLeash);
    setCameraZoom(camera.scale * 100, { syncInput: true, instant: true });
    setCameraWheelSensitivity(cameraWheelSensitivity);
    setCameraZoomInLock(cameraZoomInLocked);
    setCameraZoomOutLock(cameraZoomOutLocked);
    updateCameraLockBindingDisplay();

    if(cameraModeSelect){
      cameraModeSelect.addEventListener('change', (ev)=> setCameraMode(ev.target.value));
    }
    if(cameraFollowLagInput){
      cameraFollowLagInput.addEventListener('input', (ev)=> setCameraFollowLag(ev.target.value, { syncInput: false }));
    }
    if(cameraLeadInput){
      cameraLeadInput.addEventListener('input', (ev)=> setCameraLead(ev.target.value, { syncInput: false }));
    }
    if(cameraHorizontalOffsetInput){
      cameraHorizontalOffsetInput.addEventListener('input', (ev)=> setCameraHorizontalOffset(ev.target.value, { syncInput: false }));
    }
    if(cameraVerticalOffsetInput){
      cameraVerticalOffsetInput.addEventListener('input', (ev)=> setCameraVerticalOffset(ev.target.value, { syncInput: false }));
    }
    if(cameraEdgeMarginInput){
      cameraEdgeMarginInput.addEventListener('input', (ev)=> setCameraEdgeMargin(ev.target.value, { syncInput: false }));
    }
    if(cameraEdgeSpeedInput){
      cameraEdgeSpeedInput.addEventListener('input', (ev)=> setCameraEdgeSpeed(ev.target.value, { syncInput: false }));
    }
    if(cameraRecenterDelayInput){
      cameraRecenterDelayInput.addEventListener('input', (ev)=> setCameraRecenterDelay(ev.target.value, { syncInput: false }));
    }
    if(cameraZoomInput){
      cameraZoomInput.addEventListener('input', (ev)=> setCameraZoom(ev.target.value, { syncInput: false }));
    }
    if(cameraManualLeashInput){
      cameraManualLeashInput.addEventListener('input', (ev)=> setCameraManualLeash(ev.target.value, { syncInput: false }));
    }
    if(cameraWheelSensitivityInput){
      cameraWheelSensitivityInput.addEventListener('input', (ev)=> setCameraWheelSensitivity(ev.target.value, { syncInput: false }));
    }
    if(cameraZoomInLockBtn){
      cameraZoomInLockBtn.addEventListener('click', () => setCameraZoomInLock(!cameraZoomInLocked));
    }
    if(cameraZoomOutLockBtn){
      cameraZoomOutLockBtn.addEventListener('click', () => setCameraZoomOutLock(!cameraZoomOutLocked));
    }
    if(cameraLockBindBtn){
      cameraLockBindBtn.addEventListener('click', () => {
        cameraLockCapture = !cameraLockCapture;
        camera.lockCapture = cameraLockCapture;
        updateCameraLockBindingDisplay();
        if(cameraLockCapture){
          setHudMessage('Press a key to toggle the camera lock.');
        }
      });
    }
    if(cameraRecenterBtn){
      cameraRecenterBtn.addEventListener('click', () => recenterCamera({ force: true }));
    }
  }
  const pulses = [];
  const turretShots = [];
  const laserProjectiles = [];
  const galeThrustCasts = [];
  const GALE_THRUST_MAX_STACKS = 2;
  const graviticCasts = [];
  const gravityProjectiles = [];
  const graviticSlowDecays = [];
  const blinkingBoltProjectiles = [];
  const chargingGaleProjectiles = [];
  const projectiles = [];
  const edgeFluxProjectiles = [];
  const edgeFluxMarks = [];
  const hitsplats = [];
  const bedrockBurstCasts = [];
  const groundbreakerCasts = [];
  const ragePulseCasts = [];
  const slamCasts = [];
  const slamFissures = [];
  const slamIceFields = [];
  const slamImpacts = [];
  const SPELL_ORIGIN_SLIDER_CENTER = 1000;
  const PLAYER_PROJECTILE_SPEED = 700; // px per second
  const MONSTER_SPEED_BOOST_DURATION = 3; // seconds
  function flash(x, y, opts){
    const start = opts && Number.isFinite(opts.startRadius) ? Math.max(0, opts.startRadius) : 12;
    const endCandidate = opts && Number.isFinite(opts.endRadius) ? Math.max(0, opts.endRadius) : (start + 40);
    const end = Math.max(start, endCandidate);
    const color = opts && typeof opts.color === 'string' && opts.color.trim() ? opts.color : '#7fe3ff';
    pulses.push({ x, y, t: 0, startRadius: start, endRadius: end, color });
  }

  function getSpellOrigin(entity){
    const subject = entity || player;
    const baseX = Number(subject && subject.x);
    const baseY = Number(subject && subject.y);
    const hasBaseX = Number.isFinite(baseX);
    const hasBaseY = Number.isFinite(baseY);
    let x = hasBaseX ? baseX : 0;
    let y = hasBaseY ? baseY : 0;
    if(subject && Object.prototype.hasOwnProperty.call(subject, 'spellOriginLengthOffset')){
      const offsetLength = Number(subject.spellOriginLengthOffset);
      if(Number.isFinite(offsetLength)){
        y -= offsetLength;
      }
    }
    if(subject && Object.prototype.hasOwnProperty.call(subject, 'spellOriginWidthOffset')){
      const offsetWidth = Number(subject.spellOriginWidthOffset);
      if(Number.isFinite(offsetWidth)){
        x += offsetWidth;
      }
    }
    return { x, y };
  }

  function resolveCastOrigin(cast){
    const fallback = getSpellOrigin(player);
    let x = fallback.x;
    let y = fallback.y;
    if(cast){
      if(Number.isFinite(Number(cast.startX))){
        x = Number(cast.startX);
      }
      if(Number.isFinite(Number(cast.startY))){
        y = Number(cast.startY);
      }
      if(cast.casterRef){
        const casterOrigin = getSpellOrigin(cast.casterRef);
        if(Number.isFinite(casterOrigin.x)) x = casterOrigin.x;
        if(Number.isFinite(casterOrigin.y)) y = casterOrigin.y;
      }
    }
    return { x, y };
  }

  // Player
  player = Object.assign(player, {
    x: mapState.width / 2,
    y: mapState.height / 2,
    r:10,
    hurtboxVisible: GameState.player.hurtboxVisible !== false,
    hurtboxShape: GameState.player.hurtboxShape || 'capsule',
    hurtboxLength: Number.isFinite(GameState.player.hurtboxLength) ? GameState.player.hurtboxLength : 32,
    hurtboxWidth: Number.isFinite(GameState.player.hurtboxWidth) ? GameState.player.hurtboxWidth : 20,
    color:'#2aa9ff',
    team:'blue',
    hitboxVisible:true,
    hitboxShape:'capsule',
    hitboxLength:32,
    hitboxWidth:20,
    spellOriginLengthOffset:0,
    spellOriginWidthOffset:0,
    speed: Number.isFinite(GameState.player.speed) ? GameState.player.speed : 1000,
    hp:1000,
    maxHp:1000,
    mp: Math.max(0, Number(GameState.player.mp) || 400),
    maxMp: Math.max(1, Number(GameState.player.maxMp) || 400),
    attackRange:200,
    attackRangeOpacity:0.14,
    attackSpeedMs:1000,
    attackWindupMs:250,
    attackDamage:10,
    attackCooldown:0,
    attackWindup:0,
    attackOverride:null,
    attackTarget:null,
    selectedTarget:null,
    chaseTarget:null,
    hitSplatSize:28,
    moveCircleStart:12,
    moveCircleEnd:52,
    moveCircleColor:'#7fe3ff',
    slowPct:0,
    slowTimer:0,
    ghostTimer:0,
    chillTimer: Math.max(0, Number(GameState.player.chillTimer) || 0),
    stunTimer:0,
    knockupTimer:0,
    silenceTimer:0,
    disarmTimer:0,
    polymorphTimer:0,
    damageReductionTimer: Math.max(0, Number(GameState.player.damageReductionTimer) || 0),
    damageReductionFraction: Math.max(0, Math.min(1, Number(GameState.player.damageReductionFraction) || 0)),
    combatLockTimer: Math.max(0, Number(GameState.player.combatLockTimer) || 0),
    homeguardTimer: Math.max(0, Number(GameState.player.homeguardTimer) || 0),
    recallTimer: Math.max(0, Number(GameState.player.recallTimer) || 0),
    baseInvulnTimer: Math.max(0, Number(GameState.player.baseInvulnTimer) || 0),
    baseRegenProgress: Math.max(0, Number(GameState.player.baseRegenProgress) || 0),
    isInBaseZone: GameState.player.isInBaseZone === true,
    isInFountain: GameState.player.isInFountain === true,
    recall: (GameState.player.recall && typeof GameState.player.recall === 'object')
      ? GameState.player.recall
      : (GameState.player.recall = { state: 'idle', timer: 0, lastStateChange: 0 }),
    inventory: playerInventoryState,
    shop: playerShopState,
    casting:null,
    tauntTimer:0,
    hasteTimer: GameState.player.hasteTimer || 0,
    hastePct: GameState.player.hastePct || 0,
    hasteDecayRate: Math.max(0, Number(GameState.player.hasteDecayRate) || 0),
    hasteMinPct: Math.max(0, Number(GameState.player.hasteMinPct) || 0),
    activePrayer: GameState.prayers.active || null,
    target:{x: mapState.width / 2, y: mapState.height / 2},
    nav:null,
    navGoal:null
  });
  player.maxMp = Math.max(1, Number(player.maxMp) || 400);
  player.mp = Math.max(0, Math.min(player.maxMp, Number(player.mp) || player.maxMp));
  if(!player.recall || typeof player.recall !== 'object'){
    player.recall = { state: 'idle', timer: 0, lastStateChange: 0 };
  }
  if(typeof player.recall.state !== 'string'){ player.recall.state = 'idle'; }
  player.recall.timer = Math.max(0, Number(player.recall.timer) || 0);
  player.recall.lastStateChange = Number.isFinite(player.recall.lastStateChange)
    ? player.recall.lastStateChange
    : (typeof performance !== 'undefined' ? performance.now() : Date.now());
  player.recall.anchorX = Number.isFinite(player.recall.anchorX) ? player.recall.anchorX : null;
  player.recall.anchorY = Number.isFinite(player.recall.anchorY) ? player.recall.anchorY : null;
  player.recall.duration = Math.max(0, Number(player.recall.duration) || 8);
  player.recall.interruptReason = typeof player.recall.interruptReason === 'string'
    ? player.recall.interruptReason
    : null;
  player.hurtboxVisible = player.hurtboxVisible !== false;
  player.hurtboxShape = typeof player.hurtboxShape === 'string' ? player.hurtboxShape : 'capsule';
  player.hurtboxLength = Number.isFinite(player.hurtboxLength) ? player.hurtboxLength : 32;
  player.hurtboxWidth = Number.isFinite(player.hurtboxWidth) ? player.hurtboxWidth : 20;
  normalizePlayerControlState(player);
  normalizePracticeDummyState();
  camera.followX = player.x;
  camera.followY = player.y;
  function updatePlayerFacingFromVector(dx, dy){
    if(!Number.isFinite(dx) || !Number.isFinite(dy)){
      return false;
    }
    const length = Math.hypot(dx, dy);
    if(!(length > 0.001)){
      return false;
    }
    const angle = Math.atan2(dx, dy);
    if(!Number.isFinite(angle)){
      return false;
    }
    GameState.player.facingRadians = angle;
    return true;
  }
  function updatePlayerFacingTowards(target, { originX, originY } = {}){
    if(!target){
      return false;
    }
    const tx = Number(target.x);
    const ty = Number(target.y);
    if(!Number.isFinite(tx) || !Number.isFinite(ty)){
      return false;
    }
    if(!Number.isFinite(originX) || !Number.isFinite(originY)){
      const origin = getSpellOrigin(player);
      originX = origin.x;
      originY = origin.y;
    }
    return updatePlayerFacingFromVector(tx - originX, ty - originY);
  }
  function updatePlayerFacingFromCast(cast){
    if(!cast){
      return false;
    }
    if(cast.targetRef && updatePlayerFacingTowards(cast.targetRef)){
      return true;
    }
    const pairs = [
      ['targetX', 'targetY'],
      ['destX', 'destY'],
      ['endX', 'endY'],
      ['aimX', 'aimY']
    ];
    for(const [keyX, keyY] of pairs){
      const x = Number(cast[keyX]);
      const y = Number(cast[keyY]);
      if(Number.isFinite(x) && Number.isFinite(y) && updatePlayerFacingFromVector(x - player.x, y - player.y)){
        return true;
      }
    }
    const dirCandidates = [
      [cast.dirX, cast.dirY],
      [cast.initialDirX, cast.initialDirY],
      [cast.aimDirX, cast.aimDirY]
    ];
    for(const [rawDx, rawDy] of dirCandidates){
      const dx = Number(rawDx);
      const dy = Number(rawDy);
      if(Number.isFinite(dx) || Number.isFinite(dy)){
        const safeDx = Number.isFinite(dx) ? dx : 0;
        const safeDy = Number.isFinite(dy) ? dy : 0;
        if(updatePlayerFacingFromVector(safeDx, safeDy)){
          return true;
        }
      }
    }
    return false;
  }
  function colorForTeam(team){ return team === 'red' ? '#ff5577' : '#2aa9ff'; }
  function teamColorForSide(side, fallback = '#32d97c'){
    if(GameState.multiTeam && GameState.multiTeam.enabled){
      const bases = Array.isArray(GameState.multiTeamBases) ? GameState.multiTeamBases : [];
      const base = bases.find(entry => entry && entry.id === side);
      if(base && typeof base.color === 'string'){
        return sanitizeHexColor(base.color, fallback);
      }
      const colors = Array.isArray(GameState.multiTeam.colors) ? GameState.multiTeam.colors : null;
      if(colors && colors.length){
        const idxMatch = String(side ?? '').match(/(\d+)/);
        const idx = idxMatch ? Number(idxMatch[1]) : NaN;
        if(Number.isFinite(idx) && colors[idx]){
          return sanitizeHexColor(colors[idx], fallback);
        }
      }
    }
    if(side === 'red') return '#ff5577';
    if(side === 'blue') return '#2aa9ff';
    return fallback;
  }
  function setPlayerTeam(team){
    const normalized = team === 'red' ? 'red' : 'blue';
    player.team = normalized;
    player.color = colorForTeam(normalized);
    if(hudVitals){
      hudVitals.dataset.team = normalized;
    }
    if(playerFloatHud){
      playerFloatHud.dataset.team = normalized;
    }
    if(playerTeamSelect && playerTeamSelect.value !== normalized){
      playerTeamSelect.value = normalized;
    }
    if((player.selectedTarget && player.selectedTarget.side === player.team) ||
       (player.attackTarget && player.attackTarget.side === player.team)){
      cancelPlayerAttack();
    }
    recenterCamera({ force: true });
  }
  function cancelPlayerAttack(clearSelection = true){
    player.attackTarget = null;
    player.attackWindup = 0;
    player.attackOverride = null;
    if(clearSelection){
      player.selectedTarget = null;
      player.chaseTarget = null;
    }
  }

  const RECALL_CHANNEL_SECONDS = 8;
  const PLAYER_COMBAT_LOCK_DURATION = 3.5;
  const SHOP_REFUND_RATE = 0.7;
  const SHOP_UNDO_LIMIT = 20;
  const SHOP_CATALOG = new Map([
    ['boots', { id: 'boots', name: 'Scout Boots', cost: 300, uniqueTag: 'boots', tags: ['boots'] }],
    ['longsword', { id: 'longsword', name: 'Longsword', cost: 350, tags: ['weapon'] }],
    ['dagger', { id: 'dagger', name: 'Dagger', cost: 300, tags: ['attack-speed'] }],
    ['pickaxe', { id: 'pickaxe', name: 'Pickaxe', cost: 875, components: ['longsword', 'dagger'], tags: ['weapon'] }],
    ['bf-sword', { id: 'bf-sword', name: 'B.F. Sword', cost: 1300, components: ['longsword', 'longsword'], tags: ['weapon'] }],
    ['mythic-core', {
      id: 'mythic-core',
      name: 'Mythic Core',
      cost: 3200,
      components: ['pickaxe', 'boots'],
      uniqueTag: 'mythic',
      tags: ['mythic'],
      excludesTags: ['mythic']
    }]
  ]);

  function getShopItem(itemId){
    if(typeof itemId !== 'string'){ return null; }
    const key = itemId.trim().toLowerCase();
    if(!key){ return null; }
    return SHOP_CATALOG.get(key) || null;
  }

  function distanceSq(ax, ay, bx, by){
    const dx = (Number(ax) || 0) - (Number(bx) || 0);
    const dy = (Number(ay) || 0) - (Number(by) || 0);
    return dx * dx + dy * dy;
  }

  function circleContains(px, py, circle){
    if(!circle){
      return false;
    }
    const radius = Math.max(0, Number(circle.radius) || 0);
    if(!(radius > 0)){
      return false;
    }
    const cx = Number(circle.x) || 0;
    const cy = Number(circle.y) || 0;
    return distanceSq(px, py, cx, cy) <= radius * radius;
  }

  function getBaseConfig(side){
    if(GameState.multiTeam && GameState.multiTeam.enabled){
      const bases = Array.isArray(GameState.multiTeamBases) ? GameState.multiTeamBases : [];
      if(!bases.length){
        return null;
      }
      if(!side){
        return bases[0] || null;
      }
      return bases.find(b => b && (b.id === side || b.side === side)) || null;
    }
    if(!GameState.bases || typeof GameState.bases !== 'object'){
      return null;
    }
    return GameState.bases[side === 'red' ? 'red' : 'blue'] || null;
  }
  function allBaseConfigs(){
    if(GameState.multiTeam && GameState.multiTeam.enabled){
      return (Array.isArray(GameState.multiTeamBases) ? GameState.multiTeamBases : []).filter(Boolean);
    }
    if(GameState.bases && typeof GameState.bases === 'object'){
      return Object.values(GameState.bases).filter(Boolean);
    }
    return [];
  }

  function onEnterBaseZone(base){
    player.shop.stayTimer = 0;
    setHudMessage(`${base.side === player.team ? 'Allied' : 'Enemy'} base zone entered.`);
  }

  function onExitBaseZone(base){
    player.shop.stayTimer = 0;
    if(player.shop.undoStack && player.shop.undoStack.length){
      player.shop.undoStack.length = 0;
    }
    setHudMessage(`${base.side === player.team ? 'Allied' : 'Enemy'} base zone exited.`);
  }

  function applyBaseRegen(base, interval){
    if(!base){
      return;
    }
    const regen = base.regenPerSecond || {};
    const hpRegen = Math.max(0, Number(regen.hp) || 0);
    const mpRegen = Math.max(0, Number(regen.mp) || 0);
    if(hpRegen > 0){
      const nextHp = Math.min(player.maxHp, Number(player.hp) + hpRegen * interval);
      if(nextHp !== player.hp){
        player.hp = nextHp;
        updateHudHealth();
      }
    }
    if(mpRegen > 0){
      const nextMp = Math.min(player.maxMp, Number(player.mp) + mpRegen * interval);
      player.mp = nextMp;
    }
  }

  function applyBaseDefense(base, dt){
    if(!base || !base.fountain){
      return;
    }
    const lethalRadius = Math.max(0, Number(base.lethalRadius) || 0);
    if(!(lethalRadius > 0)){
      return;
    }
    const radiusSq = lethalRadius * lethalRadius;
    const cx = Number(base.fountain.x) || 0;
    const cy = Number(base.fountain.y) || 0;
    if(player.team !== base.side && player.hp > 0){
      const playerDist = distanceSq(player.x, player.y, cx, cy);
      if(playerDist <= radiusSq){
        const damage = Math.max(0, Number(base.lethalDamagePerSecond) || 0) * dt;
        if(damage > 0){
          damagePlayer(damage);
        }
      }
    }
    for(const m of minions){
      if(!m || m.hp <= 0 || m.side === base.side){
        continue;
      }
      const dist = distanceSq(m.x, m.y, cx, cy);
      if(dist <= radiusSq){
        m.hp = 0;
        m.portalizing = 0;
      }
    }
  }

  function teleportPlayerToFountain(side, { reason = 'teleport' } = {}){
    const base = getBaseConfig(side);
    if(!base || !base.fountain){
      return;
    }
    const destX = Number(base.fountain.x) || player.x;
    const destY = Number(base.fountain.y) || player.y;
    player.x = destX;
    player.y = destY;
    player.target.x = destX;
    player.target.y = destY;
    player.nav = null;
    player.navGoal = null;
    cancelPlayerAttack();
    flash(destX, destY, { startRadius: player.r + 12, endRadius: player.r + 60, color: '#7fe3ff' });
    const invuln = Math.max(0, Number(base.invulnerabilityDuration) || 0);
    if(invuln > 0){
      player.baseInvulnTimer = Math.max(player.baseInvulnTimer, invuln);
    }
    const homeguardDuration = Math.max(0, Number(base.homeguardDuration) || 0);
    if(homeguardDuration > 0){
      player.homeguardTimer = Math.max(player.homeguardTimer, homeguardDuration);
    }
    camera.followX = player.x;
    camera.followY = player.y;
    recenterCamera({ force: true });
    setHudMessage(reason === 'recall' ? 'Recall complete.' : 'Returned to base.');
  }

  function enterPlayerCombat(reason = 'combat'){
    player.combatLockTimer = PLAYER_COMBAT_LOCK_DURATION;
    if(player.shop && Array.isArray(player.shop.undoStack) && player.shop.undoStack.length){
      player.shop.undoStack.length = 0;
    }
    if(isPlayerRecalling()){
      cancelRecall(reason);
    }
  }

  function canPlayerShop(){
    if(player.hp <= 0){
      return false;
    }
    if(!player.isInBaseZone){
      return false;
    }
    return !(player.combatLockTimer > 0);
  }

  function ensureShopUndoStack(){
    if(!player.shop.undoStack){
      player.shop.undoStack = [];
    }
    return player.shop.undoStack;
  }

  function trimShopUndoStack(){
    const stack = ensureShopUndoStack();
    if(stack.length > SHOP_UNDO_LIMIT){
      stack.splice(0, stack.length - SHOP_UNDO_LIMIT);
    }
  }

  function shopBuy(itemId){
    const item = getShopItem(itemId);
    if(!item){
      setHudMessage('Unknown item.');
      return false;
    }
    if(!canPlayerShop()){
      setHudMessage('Shop unavailable (must be in base and out of combat).');
      return false;
    }
    const inventory = player.inventory;
    if(item.uniqueTag && inventory.some(entry => entry && entry.uniqueTag === item.uniqueTag)){
      setHudMessage('Unique item already owned.');
      return false;
    }
    if(Array.isArray(item.excludesTags)){
      for(const entry of inventory){
        if(!entry || !Array.isArray(entry.tags)) continue;
        if(entry.tags.some(tag => item.excludesTags.includes(tag))){
          setHudMessage('Item conflicts with current loadout.');
          return false;
        }
      }
    }
    const components = Array.isArray(item.components) ? item.components.slice() : [];
    const consumed = [];
    const consumedIndices = [];
    let goldCost = Math.max(0, Number(item.cost) || 0);
    for(const componentId of components){
      const idx = inventory.findIndex((entry, index) => entry && entry.id === componentId && !consumedIndices.includes(index));
      if(idx >= 0){
        const entry = inventory[idx];
        consumedIndices.push(idx);
        consumed.push(entry);
        const paid = Number(entry.goldCost);
        if(Number.isFinite(paid) && paid > 0){
          goldCost = Math.max(0, goldCost - paid);
        }
      }
    }
    goldCost = Math.round(goldCost);
    if(goldCost > goldState.player){
      setHudMessage('Not enough gold.');
      return false;
    }
    consumedIndices.sort((a, b) => b - a).forEach(index => { inventory.splice(index, 1); });
    if(goldCost > 0){ addGold(-goldCost); }
    const record = {
      id: item.id,
      name: item.name || item.id,
      uniqueTag: item.uniqueTag || null,
      tags: Array.isArray(item.tags) ? [...item.tags] : [],
      goldCost,
      components: components.slice()
    };
    inventory.push(record);
    const stack = ensureShopUndoStack();
    stack.push({
      type: 'buy',
      item: record,
      consumed: consumed.slice(),
      cost: goldCost,
      transactionId: player.shop.transactionSeq++
    });
    trimShopUndoStack();
    setHudMessage(`Purchased ${record.name} for ${goldCost} gold.`);
    return true;
  }

  function shopSell(target){
    if(!canPlayerShop()){
      setHudMessage('Shop unavailable (must be in base and out of combat).');
      return false;
    }
    const inventory = player.inventory;
    if(!inventory.length){
      setHudMessage('Inventory is empty.');
      return false;
    }
    let index = -1;
    if(typeof target === 'number' && Number.isFinite(target)){
      index = Math.floor(target);
    } else if(typeof target === 'string'){
      const key = target.trim().toLowerCase();
      index = inventory.findIndex(entry => entry && entry.id === key);
    }
    if(index < 0 || index >= inventory.length){
      index = inventory.length - 1;
    }
    const [removed] = inventory.splice(index, 1);
    if(!removed){
      setHudMessage('Unable to sell item.');
      return false;
    }
    const refund = Math.max(0, Math.round((Number(removed.goldCost) || 0) * SHOP_REFUND_RATE));
    if(refund > 0){ addGold(refund); }
    const stack = ensureShopUndoStack();
    stack.push({
      type: 'sell',
      item: removed,
      refund,
      index,
      transactionId: player.shop.transactionSeq++
    });
    trimShopUndoStack();
    setHudMessage(`Sold ${removed.name || removed.id} for ${refund} gold.`);
    return true;
  }

  function shopUndo(){
    if(!canPlayerShop()){
      setHudMessage('Undo unavailable outside base/combat.');
      return false;
    }
    const stack = ensureShopUndoStack();
    const entry = stack.pop();
    if(!entry){
      setHudMessage('Nothing to undo.');
      return false;
    }
    if(entry.type === 'buy'){
      const idx = player.inventory.findIndex(item => item === entry.item);
      if(idx >= 0){
        player.inventory.splice(idx, 1);
      }
      if(entry.cost > 0){ addGold(entry.cost); }
      for(const consumed of entry.consumed || []){
        player.inventory.push(consumed);
      }
      setHudMessage('Purchase undone.');
      return true;
    }
    if(entry.type === 'sell'){
      const refund = Number(entry.refund) || 0;
      if(refund > 0){ addGold(-refund); }
      const insertAt = Math.max(0, Math.min(player.inventory.length, Number(entry.index) || 0));
      player.inventory.splice(insertAt, 0, entry.item);
      setHudMessage('Sale undone.');
      return true;
    }
    setHudMessage('Nothing to undo.');
    return false;
  }

  function updateShopState(dt){
    const stack = ensureShopUndoStack();
    if(canPlayerShop()){
      player.shop.stayTimer = (player.shop.stayTimer || 0) + dt;
    } else {
      player.shop.stayTimer = 0;
      if(stack.length){
        stack.length = 0;
      }
    }
  }

  function isPlayerRecalling(){
    return !!(player.recall && player.recall.state === 'channeling');
  }

  function cancelRecall(reason = 'cancelled'){
    if(!isPlayerRecalling()){
      return false;
    }
    player.recall.state = 'idle';
    player.recall.timer = 0;
    player.recall.interruptReason = reason;
    player.recall.anchorX = null;
    player.recall.anchorY = null;
    player.recall.lastHp = null;
    player.recallTimer = 0;
    setHudMessage(reason === 'cancelled' ? 'Recall cancelled.' : 'Recall interrupted.');
    return true;
  }

  function canPlayerRecall(){
    if(player.hp <= 0){
      return false;
    }
    if(isPlayerRecalling()){
      return false;
    }
    if(player.stunTimer > 0 || player.knockupTimer > 0 || player.polymorphTimer > 0){
      return false;
    }
    if(player.combatLockTimer > 0){
      return false;
    }
    return true;
  }

  function startRecall(){
    if(!canPlayerRecall()){
      setHudMessage('Cannot recall right now.');
      return false;
    }
    player.recall.state = 'channeling';
    player.recall.timer = 0;
    player.recall.duration = RECALL_CHANNEL_SECONDS;
    player.recall.anchorX = player.x;
    player.recall.anchorY = player.y;
    player.recall.lastHp = player.hp;
    player.recall.interruptReason = null;
    player.recall.lastStateChange = typeof performance !== 'undefined' ? performance.now() : Date.now();
    player.recallTimer = RECALL_CHANNEL_SECONDS;
    player.target.x = player.x;
    player.target.y = player.y;
    player.nav = null;
    player.navGoal = null;
    cancelPlayerAttack();
    setHudMessage('Recalling...');
    return true;
  }

  function toggleRecall(){
    if(isPlayerRecalling()){
      cancelRecall('cancelled');
    } else {
      startRecall();
    }
  }

  function completeRecall(){
    if(!isPlayerRecalling()){
      return;
    }
    player.recall.state = 'idle';
    player.recall.timer = 0;
    player.recallTimer = 0;
    player.recall.anchorX = null;
    player.recall.anchorY = null;
    teleportPlayerToFountain(player.team, { reason: 'recall' });
  }

  function updatePlayerRecall(dt){
    if(!player.recall || player.recall.state !== 'channeling'){
      player.recallTimer = 0;
      return;
    }
    const duration = Math.max(0.1, Number(player.recall.duration) || RECALL_CHANNEL_SECONDS);
    player.recall.timer += dt;
    const remaining = Math.max(0, duration - player.recall.timer);
    player.recallTimer = remaining;
    if(player.hp <= 0 || player.stunTimer > 0 || player.knockupTimer > 0 || player.polymorphTimer > 0){
      cancelRecall('crowdControl');
      return;
    }
    if(player.recall.anchorX !== null && player.recall.anchorY !== null){
      const moved = distanceSq(player.x, player.y, player.recall.anchorX, player.recall.anchorY);
      if(moved > 16){
        cancelRecall('moved');
        return;
      }
    }
    if(Number.isFinite(player.recall.lastHp) && player.hp < player.recall.lastHp - 0.5){
      cancelRecall('damage');
      return;
    }
    player.recall.lastHp = player.hp;
    if(player.recall.timer >= duration){
      completeRecall();
    }
  }

  function updatePlayerBaseState(dt){
    const allyBase = getBaseConfig(player.team);
    let inBase = false;
    let inFountain = false;
    if(allyBase){
      inBase = circleContains(player.x, player.y, allyBase.baseZone);
      inFountain = circleContains(player.x, player.y, allyBase.fountain);
      if(inBase){
        if(!player.isInBaseZone){
          onEnterBaseZone(allyBase);
        }
        const interval = Math.max(0.05, Number(allyBase.regenInterval) || 0.25);
        player.baseRegenProgress = (player.baseRegenProgress || 0) + dt;
        while(player.baseRegenProgress >= interval){
          player.baseRegenProgress -= interval;
          applyBaseRegen(allyBase, interval);
        }
        const invuln = Math.max(0, Number(allyBase.invulnerabilityDuration) || 0);
        if(invuln > 0){
          player.baseInvulnTimer = Math.max(player.baseInvulnTimer, invuln);
        }
        if(inFountain){
          const homeguardDuration = Math.max(0, Number(allyBase.homeguardDuration) || 0);
          if(homeguardDuration > 0){
            player.homeguardTimer = Math.max(player.homeguardTimer, homeguardDuration);
          }
        }
      } else {
        if(player.isInBaseZone){
          onExitBaseZone(allyBase);
        }
        player.baseRegenProgress = 0;
      }
    }
    player.isInBaseZone = inBase;
    player.isInFountain = inFountain;
    if(playerFloatHud){
      playerFloatHud.dataset.inBase = inBase ? 'true' : 'false';
      playerFloatHud.dataset.inFountain = inFountain ? 'true' : 'false';
    }
    if(!inBase){
      player.baseInvulnTimer = Math.max(0, player.baseInvulnTimer - dt);
    }
    if(player.homeguardTimer > 0){
      player.homeguardTimer = Math.max(0, player.homeguardTimer - dt);
    }
    for(const base of allBaseConfigs()){
      applyBaseDefense(base, dt);
    }
  }

  function drawBaseZones(){
    const bases = allBaseConfigs();
    if(!ctx || !bases.length){
      return;
    }
    for(const base of bases){
      if(!base){ continue; }
      const zone = base.baseZone;
      const fountain = base.fountain;
      const baseColor = base.color || teamColorForSide(base.side, '#38bdf8');
      if(zone && circleInCamera(zone.x, zone.y, Math.max(0, Number(zone.radius) || 0) + 24)){
        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = baseColor;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, Math.max(0, Number(zone.radius) || 0), 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = 2;
        ctx.strokeStyle = baseColor;
        ctx.stroke();
        ctx.restore();
      }
      if(fountain && circleInCamera(fountain.x, fountain.y, Math.max(0, Number(fountain.radius) || 0) + 24)){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = baseColor;
        ctx.beginPath();
        ctx.arc(fountain.x, fountain.y, Math.max(0, Number(fountain.radius) || 0), 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.85;
        ctx.lineWidth = 3;
        ctx.strokeStyle = baseColor;
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function triggerPlayerTaunt(duration = 1.5){
    if(player.hp <= 0){
      return;
    }
    const tauntDuration = Math.max(0, Number(duration) || 0);
    if(tauntDuration <= 0){
      return;
    }
    player.tauntTimer = tauntDuration;
    setPlayerAnimationState('taunt');
  }

  function updatePlayerAnimationFromGameplay(dt){
    if(!playerRuntime.animationController){
      return;
    }
    if(player.tauntTimer > 0){
      player.tauntTimer = Math.max(0, player.tauntTimer - dt);
    }
    if(player.hp <= 0){
      setPlayerAnimationState('death', { facingRadians: GameState.player.facingRadians });
      return;
    }
    if(player.tauntTimer > 0){
      setPlayerAnimationState('taunt', { facingRadians: GameState.player.facingRadians });
      return;
    }
    if(player.casting){
      updatePlayerFacingFromCast(player.casting);
      setPlayerAnimationState('cast', { facingRadians: GameState.player.facingRadians });
      return;
    }
    if(player.attackWindup > 0){
      if(player.attackTarget){
        updatePlayerFacingTowards(player.attackTarget);
      }
      setPlayerAnimationState('autoAttack', { facingRadians: GameState.player.facingRadians });
      return;
    }
    const speed = Math.hypot(lastPlayerVelocityX, lastPlayerVelocityY);
    if(speed > 5){
      const baseSpeed = Math.max(1, Number(player.speed) || 1);
      const speedFactor = Math.min(3, Math.max(0.2, speed / baseSpeed));
      updatePlayerFacingFromVector(lastPlayerVelocityX, lastPlayerVelocityY);
      setPlayerAnimationState('move', { speedFactor, facingRadians: GameState.player.facingRadians });
    } else {
      if(player.attackTarget){
        updatePlayerFacingTowards(player.attackTarget);
      } else if(player.selectedTarget){
        updatePlayerFacingTowards(player.selectedTarget);
      }
      setPlayerAnimationState('idle', { facingRadians: GameState.player.facingRadians });
    }
  }
  setPlayerTeam(player.team);
  if(playerSizeInput){ playerSizeInput.value = String(player.r); }
  if(playerTeamSelect){ playerTeamSelect.value = player.team; }
  if(playerHpInput){ playerHpInput.value = String(player.maxHp|0); }
  if(playerAttackRangeInput){ playerAttackRangeInput.value = String(player.attackRange|0); }
  if(playerAttackRangeOpacityInput){
    const pct = Math.max(0, Math.min(100, Math.round((Number(player.attackRangeOpacity) || 0) * 100)));
    playerAttackRangeOpacityInput.value = String(pct);
    if(playerAttackRangeOpacityDisplay){
      playerAttackRangeOpacityDisplay.textContent = `${pct}%`;
    }
  }
  if(playerAttackSpeedInput){ playerAttackSpeedInput.value = String(player.attackSpeedMs|0); }
  if(playerAttackWindupInput){ playerAttackWindupInput.value = String(player.attackWindupMs|0); }
  if(playerAttackDamageInput){ playerAttackDamageInput.value = String(player.attackDamage|0); }
  if(playerHitSplatSizeInput){ playerHitSplatSizeInput.value = String(player.hitSplatSize|0); }
  if(playerMoveCircleStartInput){ playerMoveCircleStartInput.value = String(player.moveCircleStart); }
  if(playerMoveCircleEndInput){ playerMoveCircleEndInput.value = String(player.moveCircleEnd); }
  if(playerMoveCircleColorInput){ playerMoveCircleColorInput.value = player.moveCircleColor; }
  if(playerFloatSizeInput){ playerFloatSizeInput.value = String(playerFloatState.width); }
  if(playerFloatHeightInput){
    playerFloatHeightInput.value = String(playerFloatState.height);
    if(playerFloatHeightDisplay){
      playerFloatHeightDisplay.textContent = `${Math.round(playerFloatState.height)}px`;
    }
  }
  if(playerFloatOffsetInput){
    playerFloatOffsetInput.value = String(playerFloatState.gap);
    if(playerFloatOffsetDisplay){
      playerFloatOffsetDisplay.textContent = `${Math.round(playerFloatState.gap)}px`;
    }
  }
  if(playerAttackBarWidthInput && playerFloatState.attack){
    playerAttackBarWidthInput.value = String(playerFloatState.attack.width);
    if(playerAttackBarWidthDisplay){
      playerAttackBarWidthDisplay.textContent = `${Math.round(playerFloatState.attack.width)}px`;
    }
  }
  if(playerAttackBarHeightInput && playerFloatState.attack){
    playerAttackBarHeightInput.value = String(playerFloatState.attack.height);
    if(playerAttackBarHeightDisplay){
      playerAttackBarHeightDisplay.textContent = `${Math.round(playerFloatState.attack.height)}px`;
    }
  }
  if(playerAttackBarOffsetXInput && playerFloatState.attack){
    playerAttackBarOffsetXInput.value = String(Math.round(playerFloatState.attack.offsetX));
  }
  if(playerAttackBarOffsetYInput && playerFloatState.attack){
    playerAttackBarOffsetYInput.value = String(Math.round(playerFloatState.attack.offsetY));
  }
  if(playerIconWidthInput && playerFloatState.icons){
    playerIconWidthInput.value = String(playerFloatState.icons.width);
    if(playerIconWidthDisplay){
      playerIconWidthDisplay.textContent = `${Math.round(playerFloatState.icons.width)}px`;
    }
  }
  if(playerIconHeightInput && playerFloatState.icons){
    playerIconHeightInput.value = String(playerFloatState.icons.height);
    if(playerIconHeightDisplay){
      playerIconHeightDisplay.textContent = `${Math.round(playerFloatState.icons.height)}px`;
    }
  }
  if(playerIconOffsetXInput && playerFloatState.icons){
    playerIconOffsetXInput.value = String(Math.round(playerFloatState.icons.offsetX));
  }
  if(playerIconOffsetYInput && playerFloatState.icons){
    playerIconOffsetYInput.value = String(Math.round(playerFloatState.icons.offsetY));
  }
  buildPlayerStatusConfigRows();
  buildPrayerUi();
  updatePrayerHud();
  syncMonsterInputs();
  updateMonsterHud();
  positionMonsterHud();
  if(playerHitboxShapeSelect){
    playerHitboxShapeSelect.value = player.hitboxShape || 'capsule';
  }
  if(playerHitboxLengthInput){
    const min = Number(playerHitboxLengthInput.min);
    const max = Number(playerHitboxLengthInput.max);
    const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
    const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
    let length = Number(player.hitboxLength);
    if(!Number.isFinite(length)){
      length = clampMin;
    }
    length = Math.max(clampMin, Math.min(clampMax, length));
    playerHitboxLengthInput.value = String(length);
    if(playerHitboxLengthDisplay){
      playerHitboxLengthDisplay.textContent = `${Math.round(length)}px`;
    }
  }
  if(playerHitboxWidthInput){
    const min = Number(playerHitboxWidthInput.min);
    const max = Number(playerHitboxWidthInput.max);
    const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
    const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
    let width = Number(player.hitboxWidth);
    if(!Number.isFinite(width)){
      width = clampMin;
    }
    width = Math.max(clampMin, Math.min(clampMax, width));
    playerHitboxWidthInput.value = String(width);
    if(playerHitboxWidthDisplay){
      playerHitboxWidthDisplay.textContent = `${Math.round(width)}px`;
    }
  }
  if(playerSpellOriginLengthInput){
    const raw = SPELL_ORIGIN_SLIDER_CENTER + (Number.isFinite(player.spellOriginLengthOffset) ? player.spellOriginLengthOffset : 0);
    const min = Number(playerSpellOriginLengthInput.min);
    const max = Number(playerSpellOriginLengthInput.max);
    const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
    const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
    const clamped = Math.max(clampMin, Math.min(clampMax, raw));
    playerSpellOriginLengthInput.value = String(clamped);
    if(playerSpellOriginLengthDisplay){
      const offset = clamped - SPELL_ORIGIN_SLIDER_CENTER;
      const rounded = Math.round(offset);
      const sign = rounded >= 0 ? '+' : '';
      playerSpellOriginLengthDisplay.textContent = `${sign}${rounded}px`;
    }
  }
  if(playerSpellOriginWidthInput){
    const raw = SPELL_ORIGIN_SLIDER_CENTER + (Number.isFinite(player.spellOriginWidthOffset) ? player.spellOriginWidthOffset : 0);
    const min = Number(playerSpellOriginWidthInput.min);
    const max = Number(playerSpellOriginWidthInput.max);
    const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
    const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
    const clamped = Math.max(clampMin, Math.min(clampMax, raw));
    playerSpellOriginWidthInput.value = String(clamped);
    if(playerSpellOriginWidthDisplay){
      const offset = clamped - SPELL_ORIGIN_SLIDER_CENTER;
      const rounded = Math.round(offset);
      const sign = rounded >= 0 ? '+' : '';
      playerSpellOriginWidthDisplay.textContent = `${sign}${rounded}px`;
    }
  }
  updateHudStats();
  updateHudHealth();
  applyPlayerFloatHudSizing();
  positionPlayerFloatingHud();
  positionPracticeDummyHud();
  updatePracticeDummyUiState();
  setHudMessage();
  setAbilityBar();
  initializeCameraControls();
  cameraState.viewportReady = true;
  syncMenuMeasurements();
  initializeSettingHelp();
  settingsSearch.initializeSettingsSearch();
  updatePerfPanel();
  scheduleHudFit();

  // Timer
  function fmt(ms){ const s=Math.floor(ms/1000); const m=String(Math.floor(s/60)).padStart(2,'0'); return m+':'+String(s%60).padStart(2,'0'); }
  function playGame(){
    if(scoreState.gameOver){
      resetScores();
      timerState.elapsedMs = 0;
    }
    timerState.running = true;
    timerState.start = performance.now() - timerState.elapsedMs;
    pendingSpawns.length = 0;
    timerState.nextWaveAtMs = 0;
    waveState.waveNumber = 0;
    if(btnPlay){
      btnPlay.innerHTML='â–  Stop <span class="hint">Stop &amp; reset</span>';
    }
  }
  function stopGame({ resetTimer = true, resetMinions = true, resetPlayer = true } = {}){
    if(timerState.running){
      timerState.elapsedMs = performance.now() - timerState.start;
    }
    timerState.running = false;
    if(resetTimer){
      timerState.elapsedMs = 0;
      timerState.start = performance.now();
      timerState.nextWaveAtMs = 0;
      waveState.waveNumber = 0;
      timerState.lastText = '';
    }
    if(resetMinions){
      pendingSpawns.length = 0;
      minions.length = 0;
      mourningMarchCasts.length = 0;
      attachPracticeDummy();
    }
    if(resetPlayer){
      const restoredHp = Math.max(0, Number(player.maxHp) || 0);
      player.hp = restoredHp;
      player.tauntTimer = 0;
      cancelPlayerAttack();
      updateHudHealth();
      setPlayerAnimationState('idle');
    }
    if(btnPlay){
      btnPlay.innerHTML='Ã¢â€“Â¶ Start <span class="hint">Begin waves</span>';
    }
  }

  // Waves / Minions

  // Tuning
  const MINION_SPEED = 60;
  const MINION_RANGE = 18;
  const MINION_PLAYER_AGGRO_RANGE = 160;
  const MINION_ATTACK_COOLDOWN = 0.8;
  const OFFSIDE_FRACTION = 0.5;
  const PLASMA_MARK_DURATION = 4;

  function setMinionSizePx(size){
    const numericSize = Number(size);
    const safeSize = Number.isFinite(numericSize) ? Math.max(0, numericSize) : 0;
    minionDiameter = safeSize;
    minionRadius = safeSize / 2;
    laneFanSpacing = Math.max(minionDiameter, 1) * 1.35;
    GameState.lanes.minion.diameter = minionDiameter;
    GameState.lanes.minion.radius = minionRadius;
    GameState.lanes.minion.fanSpacing = laneFanSpacing;
    clearAllNavigation();
    ensureDefaultSpawns(true);
  }

  function fanSlotOffset(index){
    if(!Number.isFinite(index) || index <= 0) return 0;
    const layer = Math.floor((index + 1) / 2);
    const sign = index % 2 === 1 ? 1 : -1;
    return layer * sign;
  }

  function defaultLaneBreaks(){
    return [{ t: 0.33, offset: 0 }, { t: 0.66, offset: 0 }];
  }
  function sanitizeLaneBreaks(cfg){
    if(!cfg || typeof cfg !== 'object'){
      return defaultLaneBreaks();
    }
    let breaks = Array.isArray(cfg.breaks) ? cfg.breaks : null;
    if(!breaks || !breaks.length){
      breaks = defaultLaneBreaks();
    }
    breaks = breaks.map((b)=>{
      const rawT = Number(b && b.t);
      const rawOff = Number(b && b.offset);
      const t = Math.max(0.05, Math.min(0.95, Number.isFinite(rawT) ? rawT : 0.5));
      const offset = Math.max(-1, Math.min(1, Number.isFinite(rawOff) ? rawOff : 0));
      return { t, offset };
    });
    breaks.sort((a, b) => a.t - b.t);
    cfg.breaks = breaks;
    return breaks;
  }

  function ensureLaneConfigCount(count){
    const target = Math.max(1, Math.round(Number(count) || 1));
    while(laneConfigs.length < target){
      laneConfigs.push({ offset: 0, breaks: defaultLaneBreaks() });
    }
    if(laneConfigs.length > target){
      laneConfigs.length = target;
    }
    for(let i=0;i<laneConfigs.length;i++){
      const cfg = laneConfigs[i] || {};
      if(!('offset' in cfg)){
        cfg.offset = 0;
      }
      sanitizeLaneBreaks(cfg);
      laneConfigs[i] = cfg;
    }
    return laneConfigs;
  }

  function formatLaneOffsetDisplay(value){
    const pct = Math.round((Number(value) || 0) * 100);
    if(pct === 0) return '0%';
    return pct > 0 ? `+${pct}%` : `${pct}%`;
  }
  function formatLaneDistanceDisplay(index){
    const layout = ensureLaneLayout();
    const lane = layout && Array.isArray(layout.lanes) ? layout.lanes[index] : null;
    const startToMid = lane && lane.distances ? lane.distances.startToMid : null;
    const endToMid = lane && lane.distances ? lane.distances.endToMid : null;
    if(Number.isFinite(startToMid) && Number.isFinite(endToMid)){
      return `${Math.round(startToMid)}px / ${Math.round(endToMid)}px to mid`;
    }
    return '--';
  }

  function setLaneCount(value, { syncInput = true, notify = true } = {}){
    let numeric = Number(value);
    if(!Number.isFinite(numeric)){
      numeric = GameState.lanes.count;
    }
    numeric = Math.max(1, Math.round(numeric));
    GameState.lanes.count = numeric;
    ensureLaneConfigCount(GameState.lanes.count);
    if(syncInput && laneCountInput && laneCountInput.value !== String(GameState.lanes.count)){
      laneCountInput.value = String(GameState.lanes.count);
    }
    updateLaneOffsetControls();
    if(notify){
      invalidateLaneLayout({ resetMinions: true });
    } else {
      GameState.lanes.layoutDirty = true;
      GameState.lanes.layout = null;
    }
    return GameState.lanes.count;
  }

  function updateLaneOffsetControls(){
    if(!laneOffsetList){
      return;
    }
    ensureLaneConfigCount(GameState.lanes.count);
    const isMultiTeam = GameState.multiTeam && GameState.multiTeam.enabled;
    laneOffsetList.innerHTML = '';
    for(let i=0; i<GameState.lanes.count; i++){
      const row = document.createElement('div');
      row.className = 'formrow rangeRow laneOffsetRow';
      const label = document.createElement('label');
      const inputId = `laneOffset${i + 1}`;
      label.setAttribute('for', inputId);
      label.textContent = `Lane ${i + 1} diagonal offset`;
      const wrap = document.createElement('div');
      wrap.className = 'rangeWrap';
      const input = document.createElement('input');
      input.type = 'number';
      input.step = '1';
      input.id = inputId;
      input.min = '-100';
      input.max = '100';
      input.value = String(Math.round((laneConfigs[i].offset || 0) * 100));
      input.dataset.laneIndex = String(i);
      const display = document.createElement('span');
      display.className = 'rangeValue';
      display.id = `laneOffsetDisplay${i + 1}`;
      display.textContent = formatLaneOffsetDisplay(laneConfigs[i].offset || 0);
      const distance = document.createElement('span');
      distance.className = 'laneDistanceNote';
      distance.id = `laneDistance${i + 1}`;
      distance.textContent = formatLaneDistanceDisplay(i);
      const normalizeBtn = document.createElement('button');
      normalizeBtn.type = 'button';
      normalizeBtn.className = 'formButton laneNormalizeBtn';
      normalizeBtn.textContent = 'Normalize';
      normalizeBtn.addEventListener('click', ()=>{
        normalizeLaneLengths(i);
      });
      const addBreakBtn = document.createElement('button');
      addBreakBtn.type = 'button';
      addBreakBtn.className = 'formButton laneAddBreakBtn';
      addBreakBtn.textContent = 'Add break';
      addBreakBtn.addEventListener('click', ()=>{
        addLaneBreak(i);
      });
      input.addEventListener('input', ()=>{
        const normalized = (Number(input.value) || 0) / 100;
        setLaneOffsetNormalized(i, normalized, { syncInput: false, notify: true });
        display.textContent = formatLaneOffsetDisplay(laneConfigs[i].offset || 0);
        updateLaneDistanceDisplays();
      });
      wrap.appendChild(input);
      wrap.appendChild(display);
      wrap.appendChild(distance);
      if(!isMultiTeam){
        wrap.appendChild(normalizeBtn);
        wrap.appendChild(addBreakBtn);
      }
      row.appendChild(label);
      row.appendChild(wrap);
      laneOffsetList.appendChild(row);
    }
  }

  function setLaneOffsetNormalized(index, value, { syncInput = true, notify = true } = {}){
    ensureLaneConfigCount(GameState.lanes.count);
    if(index < 0 || index >= laneConfigs.length){
      return;
    }
    let normalized = Number(value);
    if(!Number.isFinite(normalized)){
      normalized = 0;
    }
    normalized = Math.max(-1, Math.min(1, normalized));
    laneConfigs[index].offset = normalized;
    if(syncInput){
      const input = document.getElementById(`laneOffset${index + 1}`);
      if(input){
        const nextValue = String(Math.round(normalized * 100));
        if(input.value !== nextValue){
          input.value = nextValue;
        }
      }
      const display = document.getElementById(`laneOffsetDisplay${index + 1}`);
      if(display){
        display.textContent = formatLaneOffsetDisplay(normalized);
      }
    }
    if(notify){
      invalidateLaneLayout({ resetMinions: true });
      updateLaneDistanceDisplays();
    } else {
      GameState.lanes.layoutDirty = true;
      GameState.lanes.layout = null;
    }
  }

  function setLaneBreakpointNormalized(laneIndex, breakIndex, { t, offset }, { notify = true } = {}){
    ensureLaneConfigCount(GameState.lanes.count);
    if(laneIndex < 0 || laneIndex >= laneConfigs.length){
      return;
    }
    const cfg = laneConfigs[laneIndex];
    const breaks = sanitizeLaneBreaks(cfg);
    const idx = Math.max(0, Math.min(breaks.length - 1, Math.round(Number(breakIndex) || 0)));
    const safeT = Math.max(0.05, Math.min(0.95, Number.isFinite(t) ? t : breaks[idx].t));
    const safeOffset = Math.max(-1, Math.min(1, Number.isFinite(offset) ? offset : breaks[idx].offset));
    breaks[idx] = { t: safeT, offset: safeOffset };
    breaks.sort((a, b) => a.t - b.t);
    cfg.breaks = breaks;
    cfg.manualBreaks = true;
    if(notify){
      invalidateLaneLayout({ resetMinions: true });
      updateLaneDistanceDisplays();
    } else {
      GameState.lanes.layoutDirty = true;
      GameState.lanes.layout = null;
    }
  }

  function invalidateLaneLayout({ resetMinions = true } = {}){
    GameState.lanes.layoutDirty = true;
    GameState.lanes.layout = null;
    markTurretsDirty();
    if(resetMinions){
      pendingSpawns.length = 0;
      minions.length = 0;
      attachPracticeDummy();
    }
    if(typeof renderMinimap === 'function'){
      try {
        renderMinimap(true);
      } catch (err) {
        /* ignore */
      }
    }
  }

  function ensureLaneLayout(){
    if(!GameState.lanes.layoutDirty && GameState.lanes.layout){
      return GameState.lanes.layout;
    }
    GameState.lanes.layout = buildLaneLayout();
    GameState.lanes.layoutDirty = false;
    return GameState.lanes.layout;
  }

  function updateLaneDistanceDisplays(){
    if(!laneOffsetList){
      return;
    }
    const layout = ensureLaneLayout();
    for(let i=0;i<(GameState.lanes.count || 0);i++){
      const el = document.getElementById(`laneDistance${i + 1}`);
      if(el){
        el.textContent = formatLaneDistanceDisplay(i);
      }
    }
  }

  function buildLaneLayout(){
    if(GameState.multiTeam && GameState.multiTeam.enabled){
      return buildMultiTeamLaneLayout();
    }
    ensureLaneConfigCount(GameState.lanes.count);
    const version = GameState.lanes.version++;
    const startBlue = blueSpawns[0];
    const startRed = redSpawns[0];
    if(!startBlue || !startRed){
      return { version, lanes: [], bluePaths: [], redPaths: [] };
    }
    if(scoreState.mode === 'lastNexus'){
      ensureNexusPosition('blue', startBlue.x, startBlue.y);
      ensureNexusPosition('red', startRed.x, startRed.y);
    }
    const start = { x: startBlue.x, y: startBlue.y };
    const end = { x: startRed.x, y: startRed.y };
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const laneLen = Math.hypot(dx, dy) || 1;
    const dirX = dx / laneLen;
    const dirY = dy / laneLen;
    const diagX = dirY;
    const diagY = -dirX;
    const center = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };
    const maxOffset = Math.min(laneLen * 0.35, Math.max(mapState.width, mapState.height) * 0.4);
    const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
    const lanes = [];
    for(let i=0; i<GameState.lanes.count; i++){
      const baseNorm = GameState.lanes.count > 1 ? (-1 + (2 * i) / (GameState.lanes.count - 1)) : 0;
      const cfg = laneConfigs[i] || { offset: 0 };
      const userNorm = Math.max(-1, Math.min(1, Number(cfg.offset) || 0));
      const finalNorm = Math.max(-1, Math.min(1, baseNorm + userNorm));
      const offset = finalNorm * maxOffset;
      const middle = {
        x: clampCoord(center.x + diagX * offset, mapState.width),
        y: clampCoord(center.y + diagY * offset, mapState.height)
      };
      const rawBreaks = sanitizeLaneBreaks(cfg);
      const useAutoCurve = !cfg.manualBreaks && rawBreaks.every(b => Math.abs(b.offset) < 1e-4);
      const breaksSource = useAutoCurve
        ? [
            { t: 0.25, offset: finalNorm * 0.6 },
            { t: 0.75, offset: finalNorm * 0.6 }
          ]
        : rawBreaks;
      const breaks = breaksSource.map((b, idx) => {
        const offsetPx = Math.max(-maxOffset, Math.min(maxOffset, Number(b.offset) * maxOffset));
        const tClamped = Math.max(0.05, Math.min(0.95, Number(b.t) || 0.5));
        const baseX = start.x + dirX * laneLen * tClamped;
        const baseY = start.y + dirY * laneLen * tClamped;
        return {
          x: clampCoord(baseX + diagX * offsetPx, mapState.width),
          y: clampCoord(baseY + diagY * offsetPx, mapState.height),
          t: tClamped,
          offset: Math.max(-1, Math.min(1, Number(b.offset) || 0)),
          index: idx
        };
      });
      const anchors = [
        { x: start.x, y: start.y, t: 0 },
        ...breaks,
        { x: middle.x, y: middle.y, t: 0.5 },
        { x: end.x, y: end.y, t: 1 }
      ].sort((a, b) => a.t - b.t);
      const label = String(i + 1);
      const bluePath = buildLanePath(anchors, i, label, version, middle);
      const redPath = buildLanePath([...anchors].reverse(), i, label, version, middle);
      let totalLength = 0;
      let lengthToMid = 0;
      const midIndex = anchors.findIndex(a => Math.abs(a.t - 0.5) < 1e-6);
      for(let j=0;j<anchors.length - 1;j++){
        const a = anchors[j];
        const b = anchors[j + 1];
        const segLen = Math.hypot((b.x ?? 0) - (a.x ?? 0), (b.y ?? 0) - (a.y ?? 0));
        totalLength += segLen;
        if(j < midIndex){
          lengthToMid += segLen;
        }
      }
      const distances = {
        startToMid: lengthToMid,
        endToMid: Math.max(0, totalLength - lengthToMid),
        total: totalLength
      };
      lanes.push({ index: i, label, middle, control: bluePath.control, bluePath, redPath, breaks, distances });
    }
    return {
      version,
      lanes,
      bluePaths: lanes.map(l => l.bluePath),
      redPaths: lanes.map(l => l.redPath),
      maxOffset
    };
  }

  function buildMultiTeamLaneLayout(){
    const teams = ensureMultiTeamBases();
    const version = GameState.lanes.version++;
    if(!teams || !teams.length){
      return { version, lanes: [], bluePaths: [], redPaths: [] };
    }
    const center = { x: mapState.width / 2, y: mapState.height / 2 };
    const teamCount = teams.length;
    GameState.lanes.count = teamCount;
    ensureLaneConfigCount(teamCount);
    const lanes = [];
    for(let i=0;i<teamCount;i++){
      const cfg = laneConfigs[i] || { offset: 0, breaks: defaultLaneBreaks() };
      const start = teams[i].baseZone;
      const target = teams[(i + teamCount / 2) % teamCount].baseZone; // opposite team
      const middle = { x: center.x, y: center.y };
      const anchors = [
        { x: start.x, y: start.y, t: 0 },
        { x: middle.x, y: middle.y, t: 0.5 },
        { x: target.x, y: target.y, t: 1 }
      ];
      const label = String(i + 1);
      const bluePath = buildLanePath(anchors, i, label, version, middle);
      const redPath = buildLanePath([...anchors].reverse(), i, label, version, middle);
      bluePath.teamId = teams[i].id;
      bluePath.teamColor = teams[i].color;
      redPath.teamId = teams[(i + teamCount / 2) % teamCount].id;
      redPath.teamColor = teams[(i + teamCount / 2) % teamCount].color;
      const totalLength = bluePath.totalLength;
      const halfLength = totalLength / 2;
      lanes.push({
        index: i,
        label,
        middle,
        control: bluePath.control,
        bluePath,
        redPath,
        breaks: [],
        distances: { startToMid: halfLength, endToMid: halfLength, total: totalLength },
        teamId: teams[i].id,
        teamColor: teams[i].color,
        targetTeamId: teams[(i + teamCount / 2) % teamCount].id
      });
    }
    return {
      version,
      lanes,
      bluePaths: lanes.map(l => l.bluePath),
      redPaths: lanes.map(l => l.redPath),
      maxOffset: Math.min(mapState.width, mapState.height) * 0.4
    };
  }

  function laneHandleRadius(){
    const total = Math.max(1, GameState.lanes.count || 1);
    return Math.max(12, 20 - Math.max(0, total - 1));
  }

  function laneBreakHandleRadius(){
    return Math.max(10, laneHandleRadius() - 2);
  }

  function portalHandleRadius(){
    return Math.max(18, PORTAL_R * 2.2);
  }

  function hitTestLaneHandle(x, y){
    const layout = ensureLaneLayout();
    if(!layout || !layout.lanes || !layout.lanes.length){
      return null;
    }
    const radius = laneHandleRadius();
    const radiusSq = radius * radius;
    for(const lane of layout.lanes){
      if(!lane || !lane.middle) continue;
      const dx = x - lane.middle.x;
      const dy = y - lane.middle.y;
      if(dx * dx + dy * dy <= radiusSq){
        return { lane, layout };
      }
    }
    return null;
  }

  function hitTestLaneBreak(x, y){
    const layout = ensureLaneLayout();
    if(!layout || !layout.lanes || !layout.lanes.length){
      return null;
    }
    const radius = laneBreakHandleRadius();
    const radiusSq = radius * radius;
    for(const lane of layout.lanes){
      if(!lane || !Array.isArray(lane.breaks)) continue;
      for(const bp of lane.breaks){
        if(!bp) continue;
        const dx = x - bp.x;
        const dy = y - bp.y;
        if(dx * dx + dy * dy <= radiusSq){
          return { lane, breakIndex: bp.index, layout };
        }
      }
    }
    return null;
  }

  function applyLaneHandleDrag(lane, layout, x, y){
    if(!lane || !layout || !lane.bluePath || !lane.bluePath.from || !lane.bluePath.to){
      return;
    }
    const start = lane.bluePath.from;
    const end = lane.bluePath.to;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const len = Math.hypot(dx, dy) || 1;
    const normX = dy / len;
    const normY = -dx / len;
    const centerX = (start.x + end.x) / 2;
    const centerY = (start.y + end.y) / 2;
    const rawOffset = (x - centerX) * normX + (y - centerY) * normY;
    const maxOffset = (layout && layout.maxOffset) || Math.min(len * 0.35, Math.max(mapState.width, mapState.height) * 0.4);
    if(!(maxOffset > 0)){
      return;
    }
    const clampedOffset = Math.max(-maxOffset, Math.min(maxOffset, rawOffset));
    const baseNorm = GameState.lanes.count > 1 ? (-1 + (2 * lane.index) / (GameState.lanes.count - 1)) : 0;
    const userNorm = Math.max(-1, Math.min(1, clampedOffset / maxOffset - baseNorm));
    setLaneOffsetNormalized(lane.index, userNorm, { syncInput: true, notify: false });
    ensureLaneLayout();
    renderMinimap(true);
    updateLaneDistanceDisplays();
  }

  function applyLaneBreakDrag(lane, layout, breakIndex, x, y){
    if(!lane || !layout || !lane.bluePath || !lane.bluePath.from || !lane.bluePath.to){
      return;
    }
    const start = lane.bluePath.from;
    const end = lane.bluePath.to;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const len = Math.hypot(dx, dy) || 1;
    const dirX = dx / len;
    const dirY = dy / len;
    const normX = dirY;
    const normY = -dirX;
    const relX = x - start.x;
    const relY = y - start.y;
    const proj = relX * dirX + relY * dirY;
    const t = Math.max(0.05, Math.min(0.95, proj / len));
    const rawOffset = relX * normX + relY * normY;
    const maxOffset = (layout && layout.maxOffset) || Math.min(len * 0.35, Math.max(mapState.width, mapState.height) * 0.4);
    const offsetNorm = maxOffset > 0 ? Math.max(-1, Math.min(1, rawOffset / maxOffset)) : 0;
    setLaneBreakpointNormalized(lane.index, breakIndex, { t, offset: offsetNorm }, { notify: false });
    ensureLaneLayout();
    renderMinimap(true);
    updateLaneDistanceDisplays();
  }

  function hitTestPortal(x, y){
    const radius = portalHandleRadius();
    const radiusSq = radius * radius;
    if(blueSpawns[0]){
      const dx = x - blueSpawns[0].x;
      const dy = y - blueSpawns[0].y;
      if(dx * dx + dy * dy <= radiusSq){
        return { side: 'blue', spawn: blueSpawns[0] };
      }
    }
    if(redSpawns[0]){
      const dx = x - redSpawns[0].x;
      const dy = y - redSpawns[0].y;
      if(dx * dx + dy * dy <= radiusSq){
        return { side: 'red', spawn: redSpawns[0] };
      }
    }
    return null;
  }

  function applyPortalDrag(side, x, y, { finalize = false } = {}){
    const list = side === 'red' ? redSpawns : blueSpawns;
    if(!list || !list[0]) return;
    const spawn = list[0];
    const clampCoord = (value, max) => Math.max(0, Math.min(max, Number.isFinite(value) ? value : 0));
    spawn.x = clampCoord(x, mapState.width);
    spawn.y = clampCoord(y, mapState.height);
    spawn.userPlaced = true;
    GameState.lanes.layoutDirty = true;
    markTurretsDirty();
    ensureLaneLayout();
    renderMinimap(true);
    if(finalize){
      invalidateLaneLayout({ resetMinions: false });
    }
  }

  function findTurretById(id){
    const list = ensureTurrets();
    return list.find(t => t && t.id === id) || null;
  }

  function hitTestTurret(x, y){
    const list = ensureTurrets();
    if(!list.length) return null;
    const bodyRadius = Math.max(12, minionRadius + 6);
    const radiusSq = (bodyRadius + 6) * (bodyRadius + 6);
    for(const turret of list){
      if(!turret) continue;
      const dx = x - turret.x;
      const dy = y - turret.y;
      if(dx * dx + dy * dy <= radiusSq){
        return turret;
      }
    }
    return null;
  }

  function applyTurretDrag(turret, x, y, { finalize = false } = {}){
    if(!turret) return;
    const perLane = clampTurretCount(turretState.perLane);
    ensureTurretOffsetsCount(perLane);
    const fractions = turretProgressFractions(perLane);
    const baseT = fractions[turret.slot] ?? 0.25;
    const layout = ensureLaneLayout();
    const lane = layout && Array.isArray(layout.lanes) ? layout.lanes.find(l => l && l.index === turret.laneIndex) : null;
    const path = lanePathForSide(lane, turret.side);
    const pathLen = path ? path.totalLength || 0 : 0;
    if(!path || !(pathLen > 0)){
      return;
    }
    const sample = lanePointAtDistance(path, pathLen * baseT);
    if(!sample || !sample.point){
      return;
    }
    const offsetX = clampTurretOffset(x - sample.point.x);
    const offsetY = clampTurretOffset(y - sample.point.y);
    turretState.offsets[turret.slot] = { x: offsetX, y: offsetY };
    turretState.hasCustomOffsets = true;
    markTurretsDirty();
    ensureTurrets();
    renderMinimap(true);
    if(finalize){
      updateTurretOffsetControls();
    }
  }

  function buildLanePath(anchors, laneIndex, label, version, middlePoint){
    const points = Array.isArray(anchors) ? anchors.map(p => ({ x: p.x, y: p.y })) : [];
    if(!points.length && middlePoint){
      points.push({ x: middlePoint.x, y: middlePoint.y });
    }
    if(!points.length){
      points.push({ x: 0, y: 0 });
    }
    const segments = [];
    let totalLength = 0;
    for(let i=0; i<points.length - 1; i++){
      const a = points[i];
      const b = points[i + 1];
      const segDx = b.x - a.x;
      const segDy = b.y - a.y;
      const length = Math.hypot(segDx, segDy);
      if(!(length > 0)){
        continue;
      }
      const dirX = segDx / length;
      const dirY = segDy / length;
      segments.push({
        from: a,
        to: b,
        length,
        dirX,
        dirY,
        normalX: -dirY,
        normalY: dirX,
        startDistance: totalLength,
        endDistance: totalLength + length
      });
      totalLength += length;
    }
    const startPoint = points[0];
    const endPoint = points[points.length - 1];
    const middleResolved = middlePoint || points[Math.floor(points.length / 2)] || startPoint;
    const control = middleResolved;
    return {
      from: startPoint,
      to: endPoint,
      middle: middleResolved,
      control,
      points,
      segments,
      totalLength,
      label,
      laneIndex,
      version
    };
  }

  function lanePointAtDistance(path, distance){
    if(!path){
      return null;
    }
    const segments = path.segments || [];
    if(!segments.length){
      return {
        point: { x: path.from ? path.from.x : 0, y: path.from ? path.from.y : 0 },
        dirX: 1,
        dirY: 0,
        normalX: 0,
        normalY: 1,
        distance: 0
      };
    }
    const target = Math.max(0, Math.min(path.totalLength, Number(distance) || 0));
    for(const segment of segments){
      if(target <= segment.endDistance){
        const span = segment.endDistance - segment.startDistance;
        const ratio = span > 0 ? (target - segment.startDistance) / span : 0;
        const x = segment.from.x + (segment.to.x - segment.from.x) * ratio;
        const y = segment.from.y + (segment.to.y - segment.from.y) * ratio;
        return {
          point: { x, y },
          dirX: segment.dirX,
          dirY: segment.dirY,
          normalX: segment.normalX,
          normalY: segment.normalY,
          distance: target
        };
      }
    }
    const last = segments[segments.length - 1];
    return {
      point: { x: last.to.x, y: last.to.y },
      dirX: last.dirX,
      dirY: last.dirY,
      normalX: last.normalX,
      normalY: last.normalY,
      distance: path.totalLength
    };
  }

  function projectPointOntoLane(path, x, y){
    if(!path || !path.segments || !path.segments.length){
      return null;
    }
    if(!Number.isFinite(x) || !Number.isFinite(y)){
      return null;
    }
    let best = null;
    for(const segment of path.segments){
      const segDx = segment.to.x - segment.from.x;
      const segDy = segment.to.y - segment.from.y;
      const segLenSq = segDx * segDx + segDy * segDy;
      let t = 0;
      if(segLenSq > 0){
        t = ((x - segment.from.x) * segDx + (y - segment.from.y) * segDy) / segLenSq;
      }
      t = Math.max(0, Math.min(1, t));
      const projX = segment.from.x + segDx * t;
      const projY = segment.from.y + segDy * t;
      const dx = x - projX;
      const dy = y - projY;
      const distSq = dx * dx + dy * dy;
      if(!best || distSq < best.distSq){
        best = {
          distSq,
          distance: segment.startDistance + segment.length * t,
          pointX: projX,
          pointY: projY,
          dirX: segment.dirX,
          dirY: segment.dirY,
          normalX: segment.normalX,
          normalY: segment.normalY
        };
      }
    }
    if(!best){
      return null;
    }
    return {
      distance: best.distance,
      point: { x: best.pointX, y: best.pointY },
      dirX: best.dirX,
      dirY: best.dirY,
      normalX: best.normalX,
      normalY: best.normalY,
      dist: Math.sqrt(best.distSq)
    };
  }

  function markTurretsDirty(){
    turretsDirty = true;
    turretLayoutVersion = null;
    turretConfigRevision += 1;
  }

  function ensureTurretOffsetsCount(count){
    const target = Math.max(0, Math.round(Number(count) || 0));
    if(!Array.isArray(turretState.offsets)){
      turretState.offsets = [];
    }
    while(turretState.offsets.length < target){
      turretState.offsets.push({ x: 0, y: 0 });
    }
    if(turretState.offsets.length > target){
      turretState.offsets.length = target;
    }
  }

  function setTurretPerLane(value, { syncInput = true, notify = true } = {}){
    const next = clampTurretCount(value);
    turretState.perLane = next;
    ensureTurretOffsetsCount(next);
    if(!turretState.hasCustomOffsets){
      for(let i = 0; i < turretState.offsets.length; i++){
        const off = turretState.offsets[i];
        if(!off || typeof off !== 'object'){
          turretState.offsets[i] = { x: 0, y: 0 };
        } else {
          off.x = 0;
          off.y = 0;
        }
      }
    }
    if(syncInput && turretCountInput){
      turretCountInput.value = String(next);
    }
    updateTurretOffsetControls();
    if(notify){
      markTurretsDirty();
      renderMinimap(true);
    }
    return next;
  }

  function setTurretRange(value, { syncInput = true } = {}){
    const next = clampTurretRange(value);
    turretState.range = next;
    if(syncInput && turretRangeInput){
      turretRangeInput.value = String(next);
    }
    markTurretsDirty();
    renderMinimap(true);
    return next;
  }

  function setTurretDamage(value, { syncInput = true } = {}){
    const next = clampTurretDamage(value);
    turretState.damage = next;
    if(syncInput && turretDamageInput){
      turretDamageInput.value = String(next);
    }
    markTurretsDirty();
    return next;
  }

  function setTurretInterval(value, { syncInput = true } = {}){
    const next = clampTurretInterval(value);
    turretState.attackInterval = next;
    if(syncInput && turretIntervalInput){
      turretIntervalInput.value = String(next);
    }
    markTurretsDirty();
    return next;
  }

  function setTurretFocus(value, { syncInput = true } = {}){
    const next = clampTurretFocus(value);
    turretState.playerFocusSeconds = next;
    if(syncInput && turretFocusInput){
      turretFocusInput.value = String(next);
    }
    markTurretsDirty();
    return next;
  }

  function setTurretOffset(index, axis, value, { syncInput = true, notify = true } = {}){
    ensureTurretOffsetsCount(turretState.perLane);
    if(index < 0 || index >= turretState.offsets.length){
      return;
    }
    const offset = turretState.offsets[index];
    if(!offset || typeof offset !== 'object'){
      turretState.offsets[index] = { x: 0, y: 0 };
    }
    const clamped = clampTurretOffset(value);
    if(axis === 'x'){
      turretState.offsets[index].x = clamped;
      if(syncInput){
        const input = document.getElementById(`turretOffsetX${index + 1}`);
        if(input){
          input.value = String(clamped);
        }
      }
    } else if(axis === 'y'){
      turretState.offsets[index].y = clamped;
      if(syncInput){
        const input = document.getElementById(`turretOffsetY${index + 1}`);
        if(input){
          input.value = String(clamped);
        }
      }
    }
    turretState.hasCustomOffsets = true;
    if(notify){
      markTurretsDirty();
      renderMinimap(true);
    }
  }

  function resetTurretOffsets(){
    ensureTurretOffsetsCount(turretState.perLane);
    turretState.hasCustomOffsets = false;
    for(let i = 0; i < turretState.offsets.length; i++){
      turretState.offsets[i] = { x: 0, y: 0 };
    }
    updateTurretOffsetControls();
    markTurretsDirty();
    renderMinimap(true);
  }

  function updateTurretOffsetControls(){
    if(!turretOffsetList){
      return;
    }
    ensureTurretOffsetsCount(turretState.perLane);
    turretOffsetList.innerHTML = '';
    for(let i = 0; i < turretState.perLane; i++){
      const offset = turretState.offsets[i] || { x: 0, y: 0 };
      const row = document.createElement('div');
      row.className = 'formrow';
      const label = document.createElement('label');
      label.textContent = `Turret ${i + 1} offset`;
      const group = document.createElement('div');
      group.className = 'offsetGroup';

      const inputX = document.createElement('input');
      inputX.type = 'number';
      inputX.id = `turretOffsetX${i + 1}`;
      inputX.min = String(TURRET_MIN_OFFSET);
      inputX.max = String(TURRET_MAX_OFFSET);
      inputX.step = '1';
      inputX.value = String(Math.round(offset.x || 0));
      inputX.addEventListener('input', ()=> setTurretOffset(i, 'x', inputX.value, { syncInput: false, notify: true }));

      const inputY = document.createElement('input');
      inputY.type = 'number';
      inputY.id = `turretOffsetY${i + 1}`;
      inputY.min = String(TURRET_MIN_OFFSET);
      inputY.max = String(TURRET_MAX_OFFSET);
      inputY.step = '1';
      inputY.value = String(Math.round(offset.y || 0));
      inputY.addEventListener('input', ()=> setTurretOffset(i, 'y', inputY.value, { syncInput: false, notify: true }));

      const labelX = document.createElement('label');
      const spanX = document.createElement('span');
      spanX.textContent = 'X';
      labelX.appendChild(spanX);
      labelX.appendChild(inputX);

      const labelY = document.createElement('label');
      const spanY = document.createElement('span');
      spanY.textContent = 'Y';
      labelY.appendChild(spanY);
      labelY.appendChild(inputY);

      group.appendChild(labelX);
      group.appendChild(labelY);
      row.appendChild(label);
      row.appendChild(group);
      turretOffsetList.appendChild(row);
    }
  }

  function turretProgressFractions(count){
    const total = Math.max(0, Math.floor(count) || 0);
    if(total <= 0){
      return [];
    }
    // Evenly space turrets between portal (0) and midpoint (0.5) on the lane.
    const span = 0.5;
    const fractions = [];
    for(let i = 0; i < total; i++){
      const step = span / (total + 1);
      const t = step * (i + 1);
      fractions.push(Math.max(0, Math.min(0.5, t)));
    }
    return fractions;
  }

  function resolvePathTeam(path, fallbackSide){
    const side = (path && path.teamId) ? path.teamId : fallbackSide;
    const teamColor = (path && path.teamColor) ? path.teamColor : teamColorForSide(side);
    return { side, teamColor };
  }

  function lanePathForSide(lane, side){
    if(!lane){
      return null;
    }
    const matches = (path)=> path && (path.teamId === side);
    if(matches(lane.bluePath)) return lane.bluePath;
    if(matches(lane.redPath)) return lane.redPath;
    if(side === 'red') return lane.redPath || lane.bluePath;
    if(side === 'blue') return lane.bluePath || lane.redPath;
    return lane.bluePath || lane.redPath || null;
  }

  function createTurret({ id, side, laneIndex, slot, x, y, range, damage, attackInterval, focusSeconds, teamColor }){
    return {
      id,
      side,
      laneIndex,
      slot,
      x,
      y,
      range,
      damage,
      attackInterval,
      focusSeconds,
      teamColor,
      target: null,
      cooldown: 0,
      focusPlayerTimer: 0,
      stunTimer: 0
    };
  }

  function ensureTurrets(){
    const layout = ensureLaneLayout();
    const layoutVersion = layout ? layout.version : null;
    if(!turretsDirty && turretLayoutVersion === layoutVersion && lastAppliedTurretConfigRevision === turretConfigRevision){
      return turrets;
    }
    turretsDirty = false;
    turretLayoutVersion = layoutVersion;
    lastAppliedTurretConfigRevision = turretConfigRevision;
    turrets.length = 0;
    const perLane = clampTurretCount(turretState.perLane);
    ensureTurretOffsetsCount(perLane);
    if(!layout || !layout.lanes.length || perLane <= 0){
      return turrets;
    }
    const useOffsets = turretState.hasCustomOffsets === true;
    const slotFractions = turretProgressFractions(perLane);
    const range = clampTurretRange(turretState.range);
    const damage = clampTurretDamage(turretState.damage);
    const attackInterval = clampTurretInterval(turretState.attackInterval);
    const focusSeconds = clampTurretFocus(turretState.playerFocusSeconds);
    let nextId = 1;
    const clampCoord = (value, max) => {
      if(!(max > 0)){
        return Math.max(0, Number(value) || 0);
      }
      const numeric = Number(value);
      if(!Number.isFinite(numeric)){
        return 0;
      }
      return Math.max(0, Math.min(max, numeric));
    };
    for(const lane of layout.lanes){
      const bluePath = lane && lane.bluePath;
      const redPath = lane && lane.redPath;
      const blueLength = bluePath ? bluePath.totalLength || 0 : 0;
      const redLength = redPath ? redPath.totalLength || 0 : 0;
      const blueTeam = resolvePathTeam(bluePath, 'blue');
      const redTeam = resolvePathTeam(redPath, 'red');
      for(let slot = 0; slot < perLane; slot++){
        const baseT = slotFractions[slot] ?? 0.25;
        const tBlue = baseT;           // 0 -> own portal, 0.5 -> midpoint
        const tRed = baseT;            // same fraction along red->blue path (starts at red portal)
        const offset = turretState.offsets[slot] || { x: 0, y: 0 };
        if(bluePath && blueLength > 0){
          const sample = lanePointAtDistance(bluePath, blueLength * tBlue) || { point: { x: 0, y: 0 } };
          const x = clampCoord(sample.point.x + (useOffsets ? (Number(offset.x) || 0) : 0), mapState.width);
          const y = clampCoord(sample.point.y + (useOffsets ? (Number(offset.y) || 0) : 0), mapState.height);
          turrets.push(createTurret({
            id: nextId++,
            side: blueTeam.side,
            teamColor: blueTeam.teamColor,
            laneIndex: lane.index,
            slot,
            x,
            y,
            range,
            damage,
            attackInterval,
            focusSeconds
          }));
        }
        if(redPath && redLength > 0){
          const sample = lanePointAtDistance(redPath, redLength * tRed) || { point: { x: 0, y: 0 } };
          const x = clampCoord(sample.point.x + (useOffsets ? (Number(offset.x) || 0) : 0), mapState.width);
          const y = clampCoord(sample.point.y + (useOffsets ? (Number(offset.y) || 0) : 0), mapState.height);
          turrets.push(createTurret({
            id: nextId++,
            side: redTeam.side,
            teamColor: redTeam.teamColor,
            laneIndex: lane.index,
            slot,
            x,
            y,
            range,
            damage,
            attackInterval,
            focusSeconds
          }));
        }
      }
    }
    return turrets;
  }

  function getLanePathsForSide(side){
    const layout = ensureLaneLayout();
    if(!layout){
      return [];
    }
    return side === 'red' ? layout.redPaths : layout.bluePaths;
  }

  function updateMinionLaneFrame(minion){
    if(!minion || !minion.lanePath){
      minion.laneProjection = null;
      if(minion){
        minion.offLaneDistance = 0;
        if(!Number.isFinite(minion.laneProgress)){
          minion.laneProgress = 0;
        }
      }
      return null;
    }
    const projection = projectPointOntoLane(minion.lanePath, minion.x, minion.y);
    if(!projection){
      minion.laneProjection = null;
      minion.offLaneDistance = 0;
      return null;
    }
    minion.laneProjection = projection;
    minion.laneDir = { x: projection.dirX, y: projection.dirY };
    minion.laneNormal = { x: projection.normalX, y: projection.normalY };
    minion.laneFacing = Math.atan2(projection.dirY, projection.dirX);
    minion.pathDistance = projection.distance;
    const laneLength = Number.isFinite(minion.laneLength) ? minion.laneLength
      : (minion.lanePath && Number.isFinite(minion.lanePath.totalLength) ? minion.lanePath.totalLength : undefined);
    if(!Number.isFinite(minion.laneProgress)){
      minion.laneProgress = projection.distance;
    } else {
      const capped = Number.isFinite(laneLength) ? Math.min(laneLength, projection.distance) : projection.distance;
      minion.laneProgress = Math.max(minion.laneProgress, capped);
    }
    minion.offLaneDistance = Number.isFinite(projection.dist) ? projection.dist : 0;
    return projection;
  }

  // Portal behavior
  const PORTAL_R = 14;
  const PORTAL_INTAKE_R = PORTAL_R * 1.6;
  const PORTAL_SUCTION = 1.6;

  ensureDefaultSpawns();

  // Customizable base stats + per-wave scaling
  // Scoring

  function updateGoldUI(){
    if(!goldDisplay) return;
    const safeGold = Math.max(0, goldState.player);
    let displayText;
    if(safeGold < 100){
      const formatted = safeGold.toFixed(1);
      displayText = formatted.endsWith('.0') ? formatted.slice(0, -2) : formatted;
    } else {
      displayText = String(Math.round(safeGold));
    }
    if(displayText === goldState.lastDisplayText){
      return;
    }
    goldState.lastDisplayText = displayText;
    goldDisplay.textContent = displayText;
    scheduleHudFit();
  }
  function addGold(amount){
    if(!Number.isFinite(amount) || amount <= 0) return;
    goldState.player = Math.max(0, goldState.player + amount);
    updateGoldUI();
  }
  function resetGold(){
    goldState.player = 0;
    updateGoldUI();
  }
  updateGoldUI();

  function updateScoreUI(){
    let changed = false;
    if(scoreBlueEl){
      const blueText = String(scoreState.blue);
      if(blueText !== scoreState.lastBlueText){
        scoreBlueEl.textContent = blueText;
        scoreState.lastBlueText = blueText;
        changed = true;
      }
    }
    if(scoreRedEl){
      const redText = String(scoreState.red);
      if(redText !== scoreState.lastRedText){
        scoreRedEl.textContent = redText;
        scoreState.lastRedText = redText;
        changed = true;
      }
    }
    if(changed){
      scheduleHudFit();
    }
  }
  function setWinner(side){
    scoreState.gameOver = true;
    stopGame({ resetTimer: false, resetMinions: false, resetPlayer: false });
    const msg = side === 'blue' ? 'Blue wins!' : 'Red wins!';
    winBanner.textContent = msg;
    winBanner.classList.add('show');
  }
  function addScore(side, amount){
    if(scoreState.gameOver) return;
    if(side==='blue'){ scoreState.blue += amount; }
    else { scoreState.red += amount; }
    updateScoreUI();
    if(scoreState.blue>=scoreState.winTarget) setWinner('blue');
    else if(scoreState.red>=scoreState.winTarget) setWinner('red');
  }
  function resetScores(){
    scoreState.blue=0; scoreState.red=0; scoreState.gameOver=false;
    updateScoreUI();
    winBanner.classList.remove('show');
    resetGold();
  }
  resetScoreBtn.addEventListener('click', resetScores);

  // Image loading
  function syncCameraDimensions(){
    const safeScale = Math.max(0.001, Number(camera.scale) || 1);
    camera.width = camera.baseWidth / safeScale;
    camera.height = camera.baseHeight / safeScale;
  }
  syncCameraDimensions();

  function applyMinimapPointerState(){
    if(!minimapCanvas){
      return;
    }
    const visible = minimapState.layoutVisible && minimapState.effectiveScale > 0;
    const pointerEnabled = visible && !minimapState.clickThroughEnabled;
    minimapCanvas.dataset.clickthrough = minimapState.clickThroughEnabled ? 'true' : 'false';
    minimapCanvas.dataset.clickToMove = minimapState.clickToMoveEnabled ? 'true' : 'false';
    minimapCanvas.style.pointerEvents = pointerEnabled ? 'auto' : 'none';
    minimapCanvas.style.cursor = pointerEnabled && minimapState.clickToMoveEnabled ? 'pointer' : 'default';
  }

  function setMinimapClickToMove(value, { syncInput = true } = {}){
    const normalized = typeof value === 'string' ? value.trim().toLowerCase() : value;
    const enabled = normalized === true || normalized === 'enabled' || normalized === 'true' || normalized === 'on';
    minimapState.clickToMoveEnabled = !!enabled;
    if(minimapClickToMoveSelect && syncInput){
      minimapClickToMoveSelect.value = minimapState.clickToMoveEnabled ? 'enabled' : 'disabled';
    }
    applyMinimapPointerState();
  }

  function setMinimapClickThrough(value, { syncInput = true } = {}){
    const normalized = typeof value === 'string' ? value.trim().toLowerCase() : value;
    const enabled = normalized === true || normalized === 'allow' || normalized === 'enabled' || normalized === 'true' || normalized === 'on';
    minimapState.clickThroughEnabled = !!enabled;
    if(minimapClickThroughSelect && syncInput){
      minimapClickThroughSelect.value = minimapState.clickThroughEnabled ? 'allow' : 'blocked';
    }
    applyMinimapPointerState();
  }

  function setMinimapUserScale(value, { syncInput = true } = {}){
    let numeric = Number(value);
    if(!Number.isFinite(numeric)){
      numeric = minimapState.userScale;
    }
    numeric = Math.max(0, Math.min(5, numeric));
    minimapState.userScale = numeric;
    if(minimapScaleInput && syncInput){
      minimapScaleInput.value = String(numeric);
    }
    applyMinimapScale();
  }

  function applyMinimapScale(){
    const combined = Math.max(0, Math.min(5, minimapState.autoScale * minimapState.userScale));
    minimapState.effectiveScale = combined;
    if(rootStyle){
      rootStyle.setProperty('--minimap-scale', combined.toFixed(3));
    }
    if(minimapCanvas){
      const px = Math.max(0, MINIMAP_BASE_SIZE * combined);
      minimapCanvas.style.width = `${px}px`;
      minimapCanvas.style.height = `${px}px`;
      const visible = combined > 0 && minimapState.layoutVisible;
      minimapCanvas.style.visibility = visible ? 'visible' : 'hidden';
      minimapCanvas.setAttribute('aria-hidden', visible ? 'false' : 'true');
      const targetSize = Math.max(1, Math.round(Math.max(px, 1)));
      if(minimapCanvas.width !== targetSize){ minimapCanvas.width = targetSize; }
      if(minimapCanvas.height !== targetSize){ minimapCanvas.height = targetSize; }
    }
    applyMinimapPointerState();
    if(minimapCtx){
      renderMinimap(true);
    }
  }

  function updateMinimapScale(baseWidth, baseHeight){
    if(!rootStyle){
      return;
    }
    const safeWidth = Math.max(0, Number(baseWidth) || 0);
    const safeHeight = Math.max(0, Number(baseHeight) || 0);
    const widthRatio = (safeWidth - MINIMAP_MARGIN) > 0 ? (safeWidth - MINIMAP_MARGIN) / MINIMAP_BASE_SIZE : 0;
    const heightRatio = (safeHeight - MINIMAP_MARGIN) > 0 ? (safeHeight - MINIMAP_MARGIN) / MINIMAP_BASE_SIZE : 0;
    const candidates = [1, Math.max(0, widthRatio), Math.max(0, heightRatio)].filter((value) => Number.isFinite(value));
    let scale = candidates.length ? Math.min(...candidates) : 1;
    if(!(scale > 0)){
      const fallbackWidth = safeWidth > 0 ? safeWidth / MINIMAP_BASE_SIZE : 0;
      const fallbackHeight = safeHeight > 0 ? safeHeight / MINIMAP_BASE_SIZE : 0;
      const fallback = Math.max(fallbackWidth, fallbackHeight);
      scale = fallback > 0 ? Math.min(1, fallback) : 0;
    }
    const readabilityMin = 0.2;
    if(scale < readabilityMin && widthRatio >= readabilityMin && heightRatio >= readabilityMin){
      scale = readabilityMin;
    }
    scale = Math.max(0, Math.min(1, scale));
    minimapState.autoScale = scale;
    applyMinimapScale();
  }

  function fitCameraStageToViewport(viewport){
    if(!cameraState.viewportReady){
      return;
    }
    const metrics = viewport || measureViewport();
    const width = Math.max(0, Number(metrics && metrics.width) || 0);
    const height = Math.max(0, Number(metrics && metrics.height) || 0);
    if(!(width > 0) || !(height > 0)){
      return;
    }
    const widthLimit = Math.min(3000, width);
    const heightLimit = Math.min(3000, height);
    let scale = Math.min(widthLimit / BASE_CAMERA_WIDTH, heightLimit / BASE_CAMERA_HEIGHT);
    if(!Number.isFinite(scale) || scale <= 0){
      scale = 1;
    }
    const maxScale = Math.min(3000 / BASE_CAMERA_WIDTH, 3000 / BASE_CAMERA_HEIGHT);
    scale = Math.min(scale, maxScale);
    const nextBaseWidth = Math.max(1, Math.round(BASE_CAMERA_WIDTH * scale));
    const nextBaseHeight = Math.max(1, Math.round(BASE_CAMERA_HEIGHT * scale));
    updateMinimapScale(nextBaseWidth, nextBaseHeight);
    if(nextBaseWidth === camera.baseWidth && nextBaseHeight === camera.baseHeight){
      return;
    }
    camera.baseWidth = nextBaseWidth;
    camera.baseHeight = nextBaseHeight;
    syncCameraDimensions();
    rootStyle.setProperty('--camera-w', String(nextBaseWidth));
    rootStyle.setProperty('--camera-h', String(nextBaseHeight));
    if(canvas){
      if(canvas.width !== nextBaseWidth){ canvas.width = nextBaseWidth; }
      if(canvas.height !== nextBaseHeight){ canvas.height = nextBaseHeight; }
    }
    clampCameraToBounds();
    updateCamera(true, 0, { force: true });
    renderMinimap(true);
    updateStagePointerState();
  }

  function setVars(){
    syncCameraDimensions();
    document.documentElement.style.setProperty('--map-w', String(mapState.width));
    document.documentElement.style.setProperty('--map-h', String(mapState.height));
    document.documentElement.style.setProperty('--camera-w', camera.baseWidth);
    document.documentElement.style.setProperty('--camera-h', camera.baseHeight);
    updateMinimapScale(camera.baseWidth, camera.baseHeight);
    if(view){
      view.style.width = `${mapState.width}px`;
      view.style.height = `${mapState.height}px`;
    }
    if(canvas){
      if(canvas.width !== camera.baseWidth){ canvas.width = camera.baseWidth; }
      if(canvas.height !== camera.baseHeight){ canvas.height = camera.baseHeight; }
    }
    let playerRef = null;
    try {
      playerRef = player;
    } catch (err) {
      playerRef = null;
    }
    if(playerRef){
      const minX = playerRef.r;
      const minY = playerRef.r;
      const maxX = Math.max(minX, mapState.width - playerRef.r);
      const maxY = Math.max(minY, mapState.height - playerRef.r);
      playerRef.x = Math.max(minX, Math.min(maxX, playerRef.x));
      playerRef.y = Math.max(minY, Math.min(maxY, playerRef.y));
      playerRef.target.x = Math.max(minX, Math.min(maxX, playerRef.target.x));
      playerRef.target.y = Math.max(minY, Math.min(maxY, playerRef.target.y));
    }
    const clampVisionCoord = (value, max) => Math.max(0, Math.min(max, Number.isFinite(value) ? value : 0));
    for(const source of customVisionSources){
      if(!source) continue;
      source.x = clampVisionCoord(source.x, mapState.width);
      source.y = clampVisionCoord(source.y, mapState.height);
    }
    if(visionDummy){
      visionDummy.x = clampVisionCoord(visionDummy.x, mapState.width);
      visionDummy.y = clampVisionCoord(visionDummy.y, mapState.height);
    }
    positionPlayerFloatingHud();
    positionPracticeDummyHud();
    camera.manualOffsetX = 0;
    camera.manualOffsetY = 0;
    lastCameraTransformX = null;
    lastCameraTransformY = null;
    lastCameraTransformScale = null;
    camera.lastTransform.x = null;
    camera.lastTransform.y = null;
    camera.lastTransform.scale = null;
    updateCamera(true, 0, { force: true });
    renderMinimap(true);
  }
  let pendingMapArtSize = null;
  function markFileLoaded(el, loaded){ if(el) el.classList.toggle('loaded', !!loaded); }
  function invalidateHitbox(message){
    GameState.map.hitbox.loaded = false;
    GameState.map.hitbox.width = 0;
    GameState.map.hitbox.height = 0;
    GameState.map.hitbox.data = null;
    GameState.map.hitbox.displayName = '';
    if(hitboxImg) hitboxImg.removeAttribute('src');
    if(hitboxName) hitboxName.textContent = message || 'No hitbox map loaded';
    markFileLoaded(hitboxNameWrap, false);
    clearAllNavigation(true);
  }
  function rebuildHitboxData(){
    if(!hitboxImg) return;
    const width = hitboxImg.naturalWidth || 0;
    const height = hitboxImg.naturalHeight || 0;
    if(!width || !height){
      invalidateHitbox('Hitbox map failed to load');
      return;
    }
    if(mapState.loaded && (width !== mapState.width || height !== mapState.height)){
      invalidateHitbox('Hitbox size must match art map. Please upload again.');
      return;
    }
    if(!hitboxCtx){
      GameState.map.hitbox.data = null;
      GameState.map.hitbox.loaded = false;
      return;
    }
    GameState.map.hitbox.width = width;
    GameState.map.hitbox.height = height;
    hitboxCanvas.width = width;
    hitboxCanvas.height = height;
    hitboxCtx.clearRect(0,0,width,height);
    hitboxCtx.drawImage(hitboxImg, 0, 0, width, height);
    const raw = hitboxCtx.getImageData(0,0,width,height).data;
    const total = width * height;
    const arr = new Uint8Array(total);
    for(let i=0;i<total;i++){
      const idx = i*4;
      const r = raw[idx];
      const g = raw[idx+1];
      const b = raw[idx+2];
      const a = raw[idx+3];
      arr[i] = (a>0 && r===0 && g===0 && b===0) ? 1 : 0;
    }
    const coarse = buildCoarseBlocks(arr, width, height, NAV_COARSE_CELL);
    GameState.map.hitbox.data = arr;
    GameState.map.hitbox.coarse = coarse;
    GameState.map.hitbox.grid = buildNavGrid(coarse, width, height, NAV_COARSE_CELL);
    GameState.map.hitbox.loaded = true;
    clearAllNavigation();
    if(hitboxName){ hitboxName.textContent = GameState.map.hitbox.displayName || hitboxName.textContent || 'Hitbox map loaded'; }
    markFileLoaded(hitboxNameWrap, true);
  }
  function ensureHitboxMatchesArt(){
    if(mapState.hitbox.loaded && (mapState.hitbox.width !== mapState.width || mapState.hitbox.height !== mapState.height)){
      invalidateHitbox('Hitbox cleared - size mismatch. Please upload matching hitbox map.');
    }
  }
  function clampMapDimensions(width, height){
    const rawWidth = Math.max(0, Number(width) || 0);
    const rawHeight = Math.max(0, Number(height) || 0);
    const basePixels = rawWidth * rawHeight;
    let scale = 1;
    if(rawWidth > MAX_MAP_DIMENSION){
      scale = Math.min(scale, MAX_MAP_DIMENSION / rawWidth);
    }
    if(rawHeight > MAX_MAP_DIMENSION){
      scale = Math.min(scale, MAX_MAP_DIMENSION / rawHeight);
    }
    if(basePixels > MAX_MAP_PIXELS && basePixels > 0){
      scale = Math.min(scale, Math.sqrt(MAX_MAP_PIXELS / basePixels));
    }
    if(!(scale < 1)){
      return { width: rawWidth, height: rawHeight, clamped: false, scale: 1 };
    }
    const w = Math.max(1, Math.floor(rawWidth * scale));
    const h = Math.max(1, Math.floor(rawHeight * scale));
    return { width: w, height: h, clamped: true, scale };
  }
  function resetMapArtProcessing(){
    pendingMapArtSize = null;
    mapState.artScale = 1;
    if(img){
      delete img.dataset.safeScaled;
      img.removeAttribute('width');
      img.removeAttribute('height');
    }
  }
  function buildSafeMapImage(image, rawWidth, rawHeight){
    const { width: safeWidth, height: safeHeight, clamped, scale } = clampMapDimensions(rawWidth, rawHeight);
    if(!clamped || !(safeWidth > 0) || !(safeHeight > 0) || !image) return null;
    try{
      const c = document.createElement('canvas');
      c.width = safeWidth;
      c.height = safeHeight;
      const cctx = c.getContext('2d');
      if(!cctx) return null;
      cctx.drawImage(image, 0, 0, safeWidth, safeHeight);
      const dataUrl = c.toDataURL('image/png');
      return { dataUrl, safeWidth, safeHeight, scale };
    } catch(err){
      console.error('Map downscale failed', err);
      return null;
    }
  }
  function useArtImage(src, name){
    resetMapArtProcessing();
    if (name) fileName.textContent = name;
    img.src = src;
  }
  img.addEventListener('load', ()=>{
    const logicalWidth = (pendingMapArtSize && pendingMapArtSize.width) || img.naturalWidth || mapState.width || 0;
    const logicalHeight = (pendingMapArtSize && pendingMapArtSize.height) || img.naturalHeight || mapState.height || 0;
    const alreadyScaled = img.dataset.safeScaled === 'true';

    if(!alreadyScaled){
      const resized = buildSafeMapImage(img, logicalWidth, logicalHeight);
      if(resized && resized.dataUrl){
        pendingMapArtSize = { width: logicalWidth, height: logicalHeight, scale: resized.scale };
        img.dataset.safeScaled = 'true';
        img.src = resized.dataUrl;
        img.width = logicalWidth;
        img.height = logicalHeight;
        mapState.artScale = resized.scale;
        if(typeof setHudMessage === 'function'){
          setHudMessage(`Map downscaled for performance: ${logicalWidth}x${logicalHeight} -> ${resized.safeWidth}x${resized.safeHeight}. World size unchanged.`);
        }
        return;
      }
      mapState.artScale = 1;
    }

    mapState.width = logicalWidth;
    mapState.height = logicalHeight;
    if(!Number.isFinite(mapState.artScale)){
      mapState.artScale = (pendingMapArtSize && pendingMapArtSize.scale) || 1;
    }
    img.width = logicalWidth;
    img.height = logicalHeight;
    setVars();
    mapState.loaded = !!img.src;
    markFileLoaded(fileNameWrap, mapState.loaded);
    clearAllNavigation(true);
    ensureHitboxMatchesArt();
    ensureDefaultSpawns(true);
    pendingMapArtSize = null;
  });
  img.addEventListener('error', ()=>{
    mapState.loaded = false;
    markFileLoaded(fileNameWrap, false);
    if(fileName) fileName.textContent = 'Map failed to load';
  });
  btnMap.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', (e)=>{
    const f=e.target.files && e.target.files[0]; if(!f) return;
    const r=new FileReader();
    r.onload=()=>useArtImage(r.result,f.name);
    r.readAsDataURL(f);
    e.target.value = '';
  });
  btnHitbox.addEventListener('click', ()=> hitboxInput.click());
  hitboxInput.addEventListener('change', (e)=>{
    const f=e.target.files && e.target.files[0]; if(!f) return;
    const r=new FileReader();
    GameState.map.hitbox.loaded = false;
    markFileLoaded(hitboxNameWrap, false);
    GameState.map.hitbox.displayName = f.name || '';
    if(hitboxName) hitboxName.textContent = GameState.map.hitbox.displayName || 'Loading hitbox map...';
    r.onload=()=>{ hitboxImg.src = r.result; };
    r.readAsDataURL(f);
    e.target.value = '';
  });
  hitboxImg.addEventListener('load', rebuildHitboxData);
  hitboxImg.addEventListener('error', ()=>{
    invalidateHitbox('Hitbox map failed to load');
  });
  stage.addEventListener('dragover', e=>{ e.preventDefault(); });
  stage.addEventListener('drop', e=>{
    e.preventDefault();
    const f=e.dataTransfer.files&&e.dataTransfer.files[0]; if(!f) return;
    const r=new FileReader(); r.onload=()=>useArtImage(r.result,f.name); r.readAsDataURL(f);
  });

  const collisionHelpers = createCollisionHelpers({
    GameState,
    mapState,
    customColliders,
    clampSettingValue,
    SETTINGS_RANGE_MIN,
    perfCounters
  });
  const {
    hitboxPixelsReady,
    hitboxActive,
    circleCollides,
    collidersBlockCircle,
    colliderBlocksCircle,
    ensureCapsuleMetrics,
    ensureCrescentMetrics,
    distancePointToSegment,
    circleIntersectsCapsule,
    moveCircleWithCollision,
    navGoalKey,
    pointToCell,
    cellCenter,
    isCellWalkable,
    findNearestWalkableCell,
    lineOfSight,
    simplifyPath,
    findPath,
    navCellSize,
    navLineStep
  } = collisionHelpers;

  function clearEntityNav(entity){ if(entity && entity.nav){ entity.nav = null; } }

  function clearAllNavigation(resetPlayerGoal = false){
    player.nav = null;
    if(resetPlayerGoal){ player.navGoal = null; }
    for(const m of minions){ if(m.nav) m.nav = null; }
  }

  function ensureNavForEntity(entity, goal, radius){
    if(!hitboxActive() || !goal) return null;
    const distanceToGoal = Math.hypot(goal.x - entity.x, goal.y - entity.y);
    const cellSize = navCellSize();
    if(distanceToGoal <= Math.max(radius * 0.8, cellSize * 0.5)){
      clearEntityNav(entity);
      return null;
    }
    const key = navGoalKey(goal, radius);
    if(!entity.nav || entity.nav.key !== key){
      if(pathfindBudget <= 0){
        return null;
      }
      const path = findPath({x: entity.x, y: entity.y}, goal, radius);
      if(!path || !path.length){
        entity.nav = null;
        return null;
      }
      pathfindBudget -= 1;
      entity.nav = { key, points: path, index: 0 };
    }
    const tol = Math.max(radius * 0.6, cellSize * 0.4);
    while(entity.nav && entity.nav.index < entity.nav.points.length){
      const waypoint = entity.nav.points[entity.nav.index];
      const d = Math.hypot(waypoint.x - entity.x, waypoint.y - entity.y);
      if(d <= tol){
        entity.nav.index++;
        continue;
      }
      return waypoint;
    }
    entity.nav = null;
    return null;
  }

  function setPlayerDestination(x, y){
    player.target.x = x;
    player.target.y = y;
    player.navGoal = {x, y};
    player.nav = null;
    if(hitboxActive()){
      ensureNavForEntity(player, player.navGoal, player.r);
    }
  }

  // Spawn placement
  function prepareSpawnPlacement(side){
    const mapReady = GameState.map.loaded;
    if(!mapReady){
      if(fileName){
        fileName.textContent = 'No map loaded â€” using default arena bounds for spawn placement.';
      }
      flash(mapState.width / 2, mapState.height / 2);
    }
    const list = side === 'blue' ? blueSpawns : redSpawns;
    const defaults = defaultSpawnPosition(side);
    list.length = 0;
    list.push({ ...defaults, userPlaced: false });
    clearAllNavigation();
    GameState.spawns.placing = side;
    const label = side === 'blue' ? 'BLUE' : 'RED';
    if(mapReady){
      setHudMessage(`${label} spawn reset. Click to place a new location on the map.`);
    } else {
      setHudMessage(`${label} spawn reset. Click anywhere on the stage to choose a position.`);
    }
  }
  btnSpawnBlue.addEventListener('click', ()=> prepareSpawnPlacement('blue'));
  btnSpawnRed.addEventListener('click', ()=> prepareSpawnPlacement('red'));
  // Collision editor
  function getColliderByIdValue(id){
    if(!Number.isFinite(id)) return null;
    for(const collider of customColliders){
      if(collider && collider.id === id){
        return collider;
      }
    }
    return null;
  }
  function getSelectedCollider(){
    return getColliderByIdValue(GameState.map.colliders.selectedId);
  }
  function refreshColliderList(){
    if(!colliderListEl) return;
    colliderListEl.innerHTML = '';
    if(!customColliders.length){
      const empty = document.createElement('div');
      empty.className = 'colliderListEmpty';
      empty.textContent = 'No collision shapes.';
      colliderListEl.appendChild(empty);
      return;
    }
    let index = 0;
    for(const collider of customColliders){
      if(!collider) continue;
      index += 1;
      const button = document.createElement('button');
      button.type = 'button';
      button.dataset.id = String(collider.id);
      button.className = 'colliderEntry' + (collider.id === GameState.map.colliders.selectedId ? ' is-active' : '');
      const label = collider.type === 'capsule' ? 'Pill'
        : (collider.type === 'crescent' ? 'Crescent' : 'Circle');
      button.textContent = `${label} #${index}`;
      colliderListEl.appendChild(button);
    }
  }
  function ensureColliderConsistency(collider){
    if(!collider) return;
    const type = collider.type === 'capsule' ? 'capsule'
      : (collider.type === 'crescent' ? 'crescent' : 'circle');
    collider.type = type;
    const sanitizedRadius = clampSettingValue(Number(collider.radius), SETTINGS_RANGE_MIN);
    collider.radius = sanitizedRadius;
    if(type === 'capsule'){
      const rawLength = Number(collider.length);
      const fallbackLength = sanitizedRadius * 2;
      collider.length = Number.isFinite(rawLength)
        ? clampSettingValue(rawLength, fallbackLength)
        : clampSettingValue(fallbackLength);
      if(!Number.isFinite(collider.angle)) collider.angle = 0;
    } else if(type === 'crescent'){
      const metrics = ensureCrescentMetrics(collider);
      collider.innerRadius = metrics.innerRadius;
      collider.offset = metrics.offset;
      const rawLength = Number(collider.length);
      const fallbackLength = sanitizedRadius * 2;
      collider.length = Number.isFinite(rawLength)
        ? clampSettingValue(rawLength, fallbackLength)
        : clampSettingValue(fallbackLength);
    } else {
      const rawLength = Number(collider.length);
      const fallbackLength = sanitizedRadius * 2;
      collider.length = Number.isFinite(rawLength)
        ? clampSettingValue(rawLength, fallbackLength)
        : clampSettingValue(fallbackLength);
      collider.angle = 0;
    }
  }
  function updateColliderUiState(){
    if(!colliderShapeSelect) return;
    const selected = getSelectedCollider();
    if(selected){
      ensureColliderConsistency(selected);
    } else {
      ensureColliderConsistency(colliderDefaults);
    }
    const resolveType = (type)=> type === 'capsule' ? 'capsule'
      : (type === 'crescent' ? 'crescent' : 'circle');
    const activeType = resolveType(selected ? selected.type : colliderDefaults.type);
    colliderShapeSelect.value = activeType;
    const radiusValue = clampSettingValue(selected ? selected.radius : colliderDefaults.radius, SETTINGS_RANGE_MIN);
    if(selected){
      selected.radius = radiusValue;
    } else {
      colliderDefaults.radius = radiusValue;
    }
    if(colliderRadiusRange){
      colliderRadiusRange.min = String(SETTINGS_RANGE_MIN);
      colliderRadiusRange.max = String(SETTINGS_RANGE_MAX);
      const radiusRounded = Math.round(radiusValue);
      colliderRadiusRange.value = String(radiusRounded);
      if(colliderRadiusDisplay){
        colliderRadiusDisplay.textContent = `${radiusRounded}px`;
      }
    }
    const typeIsCapsule = activeType === 'capsule';
    const typeIsCrescent = activeType === 'crescent';
    if(colliderLengthRow){ colliderLengthRow.hidden = !typeIsCapsule; }
    if(colliderInnerRadiusRow){ colliderInnerRadiusRow.hidden = !typeIsCrescent; }
    if(colliderOffsetRow){ colliderOffsetRow.hidden = !typeIsCrescent; }
    if(colliderRotationRow){ colliderRotationRow.hidden = !(typeIsCapsule || typeIsCrescent); }

    if(typeIsCapsule && colliderLengthRange){
      const lengthValue = clampSettingValue(selected ? selected.length : colliderDefaults.length, SETTINGS_RANGE_MIN);
      if(selected){
        selected.length = lengthValue;
      } else {
        colliderDefaults.length = lengthValue;
      }
      colliderLengthRange.min = String(SETTINGS_RANGE_MIN);
      colliderLengthRange.max = String(SETTINGS_RANGE_MAX);
      const lengthRounded = Math.round(lengthValue);
      colliderLengthRange.value = String(lengthRounded);
      if(colliderLengthDisplay){
        colliderLengthDisplay.textContent = `${lengthRounded}px`;
      }
      const angleDeg = selected ? radToDeg(selected.angle) : colliderDefaults.angleDeg;
      const normalized = ((Math.round(angleDeg) % 360) + 360) % 360;
      if(colliderRotationRange){
        colliderRotationRange.value = String(normalized);
      }
      if(colliderRotationDisplay){
        colliderRotationDisplay.textContent = `${normalized}Â°`;
      }
    } else if(typeIsCrescent){
      const metrics = selected ? ensureCrescentMetrics(selected)
        : ensureCrescentMetrics({
            x: 0,
            y: 0,
            radius: colliderDefaults.radius,
            innerRadius: colliderDefaults.innerRadius,
            offset: colliderDefaults.offset,
            angle: degToRad(colliderDefaults.angleDeg)
          });
      if(!selected){
        colliderDefaults.innerRadius = metrics.innerRadius;
        colliderDefaults.offset = metrics.offset;
      }
      if(colliderInnerRadiusRange){
        const innerValue = clampSettingValue(metrics.innerRadius, SETTINGS_RANGE_MIN);
        colliderInnerRadiusRange.min = String(SETTINGS_RANGE_MIN);
        colliderInnerRadiusRange.max = String(SETTINGS_RANGE_MAX);
        colliderInnerRadiusRange.value = String(Math.round(innerValue));
        if(colliderInnerRadiusDisplay){
          colliderInnerRadiusDisplay.textContent = `${Math.round(innerValue)}px`;
        }
      }
      if(colliderOffsetRange){
        const offsetValue = clampSettingValue(metrics.offset, SETTINGS_RANGE_MIN);
        colliderOffsetRange.min = String(SETTINGS_RANGE_MIN);
        colliderOffsetRange.max = String(SETTINGS_RANGE_MAX);
        colliderOffsetRange.value = String(Math.round(offsetValue));
        if(colliderOffsetDisplay){
          colliderOffsetDisplay.textContent = `${Math.round(offsetValue)}px`;
        }
      }
      const angleDeg = selected ? radToDeg(selected.angle) : colliderDefaults.angleDeg;
      const normalized = ((Math.round(angleDeg) % 360) + 360) % 360;
      if(colliderRotationRange){
        colliderRotationRange.value = String(normalized);
      }
      if(colliderRotationDisplay){
        colliderRotationDisplay.textContent = `${normalized}Â°`;
      }
    } else if(colliderRotationDisplay && colliderRotationRange){
      colliderRotationRange.value = '0';
      colliderRotationDisplay.textContent = '0Â°';
    }
    if(colliderDeleteButton){
      colliderDeleteButton.disabled = !selected;
    }
    if(colliderEditToggle){
      colliderEditToggle.textContent = GameState.map.colliders.editMode ? 'Exit collision edit mode' : 'Enter collision edit mode';
    }
    if(colliderPlaceButton){
      colliderPlaceButton.textContent = GameState.map.colliders.placing ? 'Cancel placement' : 'Place new shape';
    }
    if(colliderToggleVisibilityButton){
      colliderToggleVisibilityButton.textContent = GameState.map.colliders.hidden ? 'Show shapes' : 'Hide shapes';
    }
    if(colliderSaveButton){
      colliderSaveButton.disabled = customColliders.length === 0;
    }
    refreshColliderList();
  }
  function selectCollider(id){
    if(Number.isFinite(id)){
      const found = getColliderByIdValue(id);
      GameState.map.colliders.selectedId = found ? found.id : null;
    } else {
      GameState.map.colliders.selectedId = null;
    }
    updateColliderUiState();
  }
  function setColliderEditMode(enabled){
    const next = !!enabled;
    if(GameState.map.colliders.editMode === next) return;
    if(next && GameState.player.vision.editMode){
      setVisionEditMode(false);
    }
    GameState.map.colliders.editMode = next;
    if(!next){
      GameState.map.colliders.placing = false;
      stopColliderDrag();
    }
    updateColliderUiState();
  }
  function stopColliderDrag(){
    if(stage && GameState.map.colliders.pointerId !== null){
      try {
        stage.releasePointerCapture(GameState.map.colliders.pointerId);
      } catch (err) {
        /* ignore */
      }
    }
    GameState.map.colliders.draggingId = null;
    GameState.map.colliders.pointerId = null;
    GameState.map.colliders.dragMoved = false;
  }
  function toggleColliderPlacement(){
    if(!GameState.map.colliders.editMode){
      setColliderEditMode(true);
    }
    GameState.map.colliders.placing = !GameState.map.colliders.placing;
    if(GameState.map.colliders.placing){
      stopColliderDrag();
    }
    updateColliderUiState();
  }
  function onCollidersChanged({ navigation = true } = {}){
    if(navigation){
      clearAllNavigation();
    }
    renderMinimap(true);
  }
  function buildCollisionMapSnapshot(){
    const snapshot = {
      version: 1,
      generatedAt: new Date().toISOString(),
      colliders: []
    };
    for(const collider of customColliders){
      if(!collider) continue;
      ensureColliderConsistency(collider);
      const type = collider.type === 'capsule' ? 'capsule'
        : (collider.type === 'crescent' ? 'crescent' : 'circle');
      const entry = {
        type,
        x: Number.isFinite(collider.x) ? collider.x : 0,
        y: Number.isFinite(collider.y) ? collider.y : 0,
        radius: Number.isFinite(collider.radius) ? collider.radius : 0,
        length: Number.isFinite(collider.length) ? collider.length : Math.max(0, Number(collider.radius) || 0) * 2,
        angle: Number.isFinite(collider.angle) ? collider.angle : 0
      };
      if(type === 'crescent'){
        entry.innerRadius = Number.isFinite(collider.innerRadius) ? collider.innerRadius : Math.max(0, entry.radius * 0.6);
        entry.offset = Number.isFinite(collider.offset) ? collider.offset : Math.max(0, entry.radius * 0.6);
      }
      snapshot.colliders.push(entry);
    }
    return snapshot;
  }
  function formatCollisionMapFilename(){
    const now = new Date();
    const pad = (value)=> String(value).padStart(2, '0');
    const base = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    return `collision-map-${base}.json`;
  }
  function saveCollisionMap(){
    const snapshot = buildCollisionMapSnapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = formatCollisionMapFilename();
    const parent = document.body || document.documentElement;
    if(parent){
      parent.appendChild(link);
      link.click();
      parent.removeChild(link);
    } else {
      link.click();
    }
    setTimeout(()=> URL.revokeObjectURL(url), 0);
  }
  function parseCollisionMapText(text){
    if(typeof text !== 'string' || !text.trim()){
      throw new Error('No collision map data');
    }
    let data;
    try {
      data = JSON.parse(text);
    } catch (err) {
      throw new Error('Invalid JSON');
    }
    const list = Array.isArray(data && data.colliders) ? data.colliders
      : (Array.isArray(data) ? data : null);
    if(!list){
      throw new Error('Missing collider list');
    }
    const result = [];
    let nextId = 1;
    for(const item of list){
      if(!item) continue;
      const typeRaw = typeof item.type === 'string' ? item.type.toLowerCase() : 'circle';
      const type = typeRaw === 'capsule' ? 'capsule'
        : (typeRaw === 'crescent' ? 'crescent' : 'circle');
      const xValue = Number(item.x);
      const yValue = Number(item.y);
      const radiusValue = Number(item.radius);
      const collider = {
        id: nextId++,
        type,
        x: Number.isFinite(xValue) ? xValue : 0,
        y: Number.isFinite(yValue) ? yValue : 0,
        radius: clampSettingValue(Number.isFinite(radiusValue) ? radiusValue : SETTINGS_RANGE_MIN, SETTINGS_RANGE_MIN)
      };
      if(type === 'capsule'){
        const lengthValue = Number(item.length);
        const angleValue = Number(item.angle);
        collider.length = Number.isFinite(lengthValue) ? clampSettingValue(lengthValue, collider.radius * 2) : clampSettingValue(collider.radius * 2);
        if(Number.isFinite(angleValue)){
          collider.angle = angleValue;
        } else if(Number.isFinite(Number(item.angleDeg))){
          collider.angle = degToRad(Number(item.angleDeg));
        } else {
          collider.angle = 0;
        }
      } else if(type === 'crescent'){
        const innerValue = Number(item.innerRadius);
        const offsetValue = Number(item.offset);
        const lengthValue = Number(item.length);
        const angleValue = Number(item.angle);
        collider.innerRadius = Number.isFinite(innerValue) ? clampSettingValue(innerValue, collider.radius * 0.6) : clampSettingValue(collider.radius * 0.6);
        collider.offset = Number.isFinite(offsetValue) ? clampSettingValue(offsetValue, collider.radius * 0.6) : clampSettingValue(collider.radius * 0.6);
        collider.length = Number.isFinite(lengthValue) ? clampSettingValue(lengthValue, collider.radius * 2) : clampSettingValue(collider.radius * 2);
        if(Number.isFinite(angleValue)){
          collider.angle = angleValue;
        } else if(Number.isFinite(Number(item.angleDeg))){
          collider.angle = degToRad(Number(item.angleDeg));
        } else {
          collider.angle = 0;
        }
      } else {
        const lengthValue = Number(item.length);
        collider.length = Number.isFinite(lengthValue) ? clampSettingValue(lengthValue, collider.radius * 2) : clampSettingValue(collider.radius * 2);
        collider.angle = 0;
      }
      ensureColliderConsistency(collider);
      result.push(collider);
    }
    return { colliders: result, nextId };
  }
  function applyCollisionMapSnapshot(snapshot){
    if(!snapshot){
      return;
    }
    const { colliders: parsedColliders, nextId } = snapshot;
    customColliders.length = 0;
    if(Array.isArray(parsedColliders) && parsedColliders.length){
      customColliders.push(...parsedColliders);
    }
    GameState.map.colliders.nextId = Math.max(1, Number(nextId) || (customColliders.length + 1));
    GameState.map.colliders.selectedId = null;
    GameState.map.colliders.placing = false;
    updateColliderUiState();
    onCollidersChanged();
    const count = customColliders.length;
    const plural = count === 1 ? '' : 's';
    setHudMessage(count ? `Loaded ${count} collision shape${plural}.` : 'Cleared collision map.');
  }
  function loadCollisionMapFromText(text){
    try {
      const snapshot = parseCollisionMapText(text);
      applyCollisionMapSnapshot(snapshot);
    } catch (err) {
      console.error('Failed to load collision map', err);
      setHudMessage('Unable to load collision map.');
    }
  }
  function colliderBoundingRadius(collider){
    if(!collider) return 0;
    if(collider.type === 'capsule'){
      const metrics = ensureCapsuleMetrics(collider);
      return Math.hypot(metrics.reach, metrics.radius);
    }
    if(collider.type === 'crescent'){
      const metrics = ensureCrescentMetrics(collider);
      return metrics.radius;
    }
    return Math.max(0, Number(collider.radius) || 0);
  }
  function colliderContainsPoint(collider, x, y, tolerance = 0){
    if(!collider) return false;
    const extra = Math.max(0, tolerance);
    if(collider.type === 'capsule'){
      const metrics = ensureCapsuleMetrics(collider);
      if(metrics.span <= 0){
        return Math.hypot(x - collider.x, y - collider.y) <= metrics.radius + extra;
      }
      return distancePointToSegment(x, y, metrics.ax, metrics.ay, metrics.bx, metrics.by) <= metrics.radius + extra;
    }
    if(collider.type === 'crescent'){
      const metrics = ensureCrescentMetrics(collider);
      const distOuter = Math.hypot(x - metrics.cx, y - metrics.cy);
      if(distOuter > metrics.radius + extra) return false;
      if(metrics.innerRadius <= 0){
        return true;
      }
      const innerThreshold = Math.max(0, metrics.innerRadius - extra);
      const distInner = Math.hypot(x - metrics.innerCx, y - metrics.innerCy);
      return distInner >= innerThreshold;
    }
    const dx = x - collider.x;
    const dy = y - collider.y;
    const rad = Math.max(0, Number(collider.radius) || 0);
    return Math.hypot(dx, dy) <= rad + extra;
  }
  function findColliderAt(x, y, tolerance = 0){
    for(let i = customColliders.length - 1; i >= 0; i--){
      const collider = customColliders[i];
      if(!collider) continue;
      if(colliderContainsPoint(collider, x, y, tolerance)){
        return collider;
      }
    }
    return null;
  }
  function visionContainsPoint(source, x, y, tolerance = 0){
    return colliderContainsPoint(source, x, y, tolerance);
  }
  function pointInVision(x, y, tolerance = 0){
    if(GameState.player.vision.fullReveal){
      return true;
    }
    const buffer = Math.max(0, tolerance);
    for(const source of customVisionSources){
      if(!source) continue;
      ensureVisionConsistency(source);
      if(source.mode === 2 && visionContainsPoint(source, x, y, buffer)){
        return false;
      }
    }
    let revealed = false;
    for(const source of customVisionSources){
      if(!source) continue;
      ensureVisionConsistency(source);
      if(source.mode === 2) continue;
      if(visionContainsPoint(source, x, y, buffer)){
        revealed = true;
        break;
      }
    }
    if(revealed){
      return true;
    }
    const playerRadiusValue = clampSettingValue(GameState.player.vision.radius, SETTINGS_RANGE_MIN);
    if(playerRadiusValue > 0){
      const playerDx = x - player.x;
      const playerDy = y - player.y;
      if(Math.hypot(playerDx, playerDy) <= playerRadiusValue + buffer){
        return true;
      }
    }
    if(visionDummy && visionDummy.active !== false){
      const dummySize = clampPracticeDummySize(visionDummy.size, practiceDummyDefaults.size);
      const bodyRadius = Math.max(10, dummySize * 0.5);
      const span = Math.max(bodyRadius * 2, dummySize * 2.2);
      const coverageRadius = Math.max(bodyRadius, span / 2);
      if(coverageRadius > 0){
        const clampCoord = (value, max) => Math.max(0, Math.min(max, Number.isFinite(value) ? value : 0));
        const dummyX = clampCoord(visionDummy.x, mapState.width);
        const dummyY = clampCoord(visionDummy.y, mapState.height);
        const dummyDx = x - dummyX;
        const dummyDy = y - dummyY;
        if(Math.hypot(dummyDx, dummyDy) <= coverageRadius + buffer){
          return true;
        }
      }
    }
    return false;
  }
  function findVisionAt(x, y, tolerance = 0){
    for(let i = customVisionSources.length - 1; i >= 0; i--){
      const source = customVisionSources[i];
      if(!source) continue;
      if(visionContainsPoint(source, x, y, tolerance)){
        return source;
      }
    }
    return null;
  }
  function addColliderAt(x, y){
    const type = colliderDefaults.type === 'capsule' ? 'capsule'
      : (colliderDefaults.type === 'crescent' ? 'crescent' : 'circle');
    const radius = clampSettingValue(colliderDefaults.radius, SETTINGS_RANGE_MIN);
    const angle = degToRad(colliderDefaults.angleDeg);
    let collider;
    if(type === 'capsule'){
      const baseLength = Number(colliderDefaults.length);
      const fallbackLength = radius * 2;
      const length = Number.isFinite(baseLength)
        ? clampSettingValue(baseLength, fallbackLength)
        : clampSettingValue(fallbackLength);
      collider = { id: GameState.map.colliders.nextId++, type, x, y, radius, length, angle };
    } else if(type === 'crescent'){
      const innerRadius = Number.isFinite(Number(colliderDefaults.innerRadius))
        ? clampSettingValue(colliderDefaults.innerRadius, radius * 0.6)
        : clampSettingValue(radius * 0.6);
      const offset = Number.isFinite(Number(colliderDefaults.offset))
        ? clampSettingValue(colliderDefaults.offset, radius * 0.6)
        : clampSettingValue(radius * 0.6);
      const fallbackLength = radius * 2;
      collider = {
        id: GameState.map.colliders.nextId++,
        type,
        x,
        y,
        radius,
        innerRadius,
        offset,
        angle,
        length: clampSettingValue(fallbackLength)
      };
    } else {
      collider = {
        id: GameState.map.colliders.nextId++,
        type: 'circle',
        x,
        y,
        radius,
        length: clampSettingValue(radius * 2),
        angle: 0
      };
    }
    ensureColliderConsistency(collider);
    customColliders.push(collider);
    GameState.map.colliders.selectedId = collider.id;
    updateColliderUiState();
    onCollidersChanged();
    return collider;
  }
  function removeSelectedCollider(){
    if(!Number.isFinite(GameState.map.colliders.selectedId)) return;
    for(let i = customColliders.length - 1; i >= 0; i--){
      const collider = customColliders[i];
      if(collider && collider.id === GameState.map.colliders.selectedId){
        customColliders.splice(i, 1);
        break;
      }
    }
    GameState.map.colliders.selectedId = null;
    updateColliderUiState();
    onCollidersChanged();
  }
  if(colliderEditToggle){
    colliderEditToggle.addEventListener('click', ()=>{
      setColliderEditMode(!GameState.map.colliders.editMode);
    });
  }
  if(colliderPlaceButton){
    colliderPlaceButton.addEventListener('click', ()=>{
      toggleColliderPlacement();
    });
  }
  if(colliderToggleVisibilityButton){
    colliderToggleVisibilityButton.addEventListener('click', ()=>{
      GameState.map.colliders.hidden = !GameState.map.colliders.hidden;
      updateColliderUiState();
      renderMinimap(true);
    });
  }
  if(colliderDeleteButton){
    colliderDeleteButton.addEventListener('click', ()=>{
      removeSelectedCollider();
    });
  }
  if(colliderSaveButton){
    colliderSaveButton.addEventListener('click', ()=>{
      saveCollisionMap();
    });
  }
  if(colliderLoadButton && colliderImportInput){
    colliderLoadButton.addEventListener('click', ()=>{
      colliderImportInput.click();
    });
    colliderImportInput.addEventListener('change', ()=>{
      const file = colliderImportInput.files && colliderImportInput.files[0];
      if(!file){
        return;
      }
      const reader = new FileReader();
      reader.addEventListener('load', ()=>{
        const text = typeof reader.result === 'string' ? reader.result : '';
        loadCollisionMapFromText(text);
      });
      reader.addEventListener('error', ()=>{
        setHudMessage('Unable to read collision map file.');
      });
      reader.readAsText(file);
      colliderImportInput.value = '';
    });
  }
  if(colliderShapeSelect){
    colliderShapeSelect.addEventListener('change', ()=>{
      const rawValue = colliderShapeSelect.value;
      const value = rawValue === 'capsule' ? 'capsule'
        : (rawValue === 'crescent' ? 'crescent' : 'circle');
      const selected = getSelectedCollider();
      if(selected){
        selected.type = value;
        ensureColliderConsistency(selected);
        onCollidersChanged();
      }
      colliderDefaults.type = value;
      if(value === 'circle'){
        colliderDefaults.angleDeg = 0;
      } else if(value === 'capsule'){
        const baseRadius = clampSettingValue(selected ? selected.radius : colliderDefaults.radius, SETTINGS_RANGE_MIN);
        const fallbackLength = baseRadius * 2;
        if(!Number.isFinite(colliderDefaults.length)){
          colliderDefaults.length = clampSettingValue(fallbackLength);
        } else {
          colliderDefaults.length = clampSettingValue(colliderDefaults.length, fallbackLength);
        }
      } else if(value === 'crescent'){
        if(!Number.isFinite(colliderDefaults.innerRadius)){
          colliderDefaults.innerRadius = clampSettingValue(colliderDefaults.radius * 0.6, SETTINGS_RANGE_MIN);
        }
        if(!Number.isFinite(colliderDefaults.offset)){
          colliderDefaults.offset = clampSettingValue(colliderDefaults.radius * 0.6, SETTINGS_RANGE_MIN);
        }
      }
      updateColliderUiState();
      renderMinimap(true);
    });
  }
  if(colliderRadiusRange){
    colliderRadiusRange.addEventListener('input', ()=>{
      const value = clampSettingValue(colliderRadiusRange.value, SETTINGS_RANGE_MIN);
      colliderRadiusRange.value = String(value);
      const selected = getSelectedCollider();
      if(selected){
        selected.radius = value;
        ensureColliderConsistency(selected);
      } else {
        colliderDefaults.radius = value;
        ensureColliderConsistency(colliderDefaults);
      }
      updateColliderUiState();
    });
    colliderRadiusRange.addEventListener('change', ()=>{
      if(getSelectedCollider()){
        onCollidersChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(colliderInnerRadiusRange){
    colliderInnerRadiusRange.addEventListener('input', ()=>{
      const value = clampSettingValue(colliderInnerRadiusRange.value, SETTINGS_RANGE_MIN);
      colliderInnerRadiusRange.value = String(value);
      const selected = getSelectedCollider();
      if(selected){
        selected.innerRadius = value;
        ensureColliderConsistency(selected);
      } else {
        colliderDefaults.innerRadius = value;
        ensureColliderConsistency(colliderDefaults);
      }
      updateColliderUiState();
    });
    colliderInnerRadiusRange.addEventListener('change', ()=>{
      if(getSelectedCollider()){
        onCollidersChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(colliderOffsetRange){
    colliderOffsetRange.addEventListener('input', ()=>{
      const value = clampSettingValue(colliderOffsetRange.value, SETTINGS_RANGE_MIN);
      colliderOffsetRange.value = String(value);
      const selected = getSelectedCollider();
      if(selected){
        selected.offset = value;
        ensureColliderConsistency(selected);
      } else {
        colliderDefaults.offset = value;
        ensureColliderConsistency(colliderDefaults);
      }
      updateColliderUiState();
    });
    colliderOffsetRange.addEventListener('change', ()=>{
      if(getSelectedCollider()){
        onCollidersChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(colliderLengthRange){
    colliderLengthRange.addEventListener('input', ()=>{
      const value = clampSettingValue(colliderLengthRange.value, SETTINGS_RANGE_MIN);
      colliderLengthRange.value = String(value);
      const selected = getSelectedCollider();
      if(selected){
        selected.length = value;
        ensureColliderConsistency(selected);
      } else {
        colliderDefaults.length = value;
      }
      updateColliderUiState();
    });
    colliderLengthRange.addEventListener('change', ()=>{
      if(getSelectedCollider()){
        onCollidersChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(colliderRotationRange){
    colliderRotationRange.addEventListener('input', ()=>{
      const value = Number(colliderRotationRange.value) || 0;
      const selected = getSelectedCollider();
      if(selected){
        selected.angle = degToRad(value);
      } else {
        colliderDefaults.angleDeg = value;
      }
      updateColliderUiState();
    });
    colliderRotationRange.addEventListener('change', ()=>{
      if(getSelectedCollider()){
        onCollidersChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(colliderListEl){
    colliderListEl.addEventListener('click', (event)=>{
      const target = event.target instanceof Element ? event.target.closest('.colliderEntry') : null;
      if(!target) return;
      const id = Number(target.dataset.id);
      if(Number.isFinite(id)){
        selectCollider(id);
      }
    });
  }
  updateColliderUiState();

  // Vision editor
  function isAutoVisionSource(source){
    return source && source.autoVision === true;
  }
  function getVisionByIdValue(id){
    if(!Number.isFinite(id)) return null;
    for(const source of customVisionSources){
      if(source && source.id === id && !isAutoVisionSource(source)){
        return source;
      }
    }
    return null;
  }
  function getSelectedVision(){
    return getVisionByIdValue(GameState.player.vision.selectedId);
  }
  function refreshVisionList(){
    if(!visionListEl) return;
    visionListEl.innerHTML = '';
    const visibleSources = customVisionSources.filter(source => !isAutoVisionSource(source));
    if(!visibleSources.length){
      const empty = document.createElement('div');
      empty.className = 'colliderListEmpty';
      empty.textContent = 'No vision shapes.';
      visionListEl.appendChild(empty);
      return;
    }
    let index = 0;
    for(const source of visibleSources){
      if(!source) continue;
      index += 1;
      const button = document.createElement('button');
      button.type = 'button';
      button.dataset.id = String(source.id);
      button.className = 'colliderEntry' + (source.id === GameState.player.vision.selectedId ? ' is-active' : '');
      const label = source.type === 'capsule' ? 'Pill'
        : (source.type === 'crescent' ? 'Crescent' : 'Circle');
      const modeLabel = source.mode === 2 ? 'Hiding' : 'Vision';
      button.textContent = `${modeLabel} ${label} #${index}`;
      visionListEl.appendChild(button);
    }
  }
  function ensureVisionConsistency(source){
    if(!source) return;
    const type = source.type === 'capsule' ? 'capsule'
      : (source.type === 'crescent' ? 'crescent' : 'circle');
    source.type = type;
    source.mode = normalizeVisionMode(source.mode);
    const sanitizedRadius = clampSettingValue(Number(source.radius), SETTINGS_RANGE_MIN);
    source.radius = sanitizedRadius;
    if(type === 'capsule'){
      const rawLength = Number(source.length);
      const fallbackLength = sanitizedRadius * 2;
      source.length = Number.isFinite(rawLength)
        ? clampSettingValue(rawLength, fallbackLength)
        : clampSettingValue(fallbackLength);
      if(!Number.isFinite(source.angle)) source.angle = 0;
    } else if(type === 'crescent'){
      const metrics = ensureCrescentMetrics(source);
      source.innerRadius = metrics.innerRadius;
      source.offset = metrics.offset;
      const rawLength = Number(source.length);
      const fallbackLength = sanitizedRadius * 2;
      source.length = Number.isFinite(rawLength)
        ? clampSettingValue(rawLength, fallbackLength)
        : clampSettingValue(fallbackLength);
    } else {
      const rawLength = Number(source.length);
      const fallbackLength = sanitizedRadius * 2;
      source.length = Number.isFinite(rawLength)
        ? clampSettingValue(rawLength, fallbackLength)
        : clampSettingValue(fallbackLength);
      source.angle = 0;
    }
  }
  function updateVisionUiState(){
    const selected = getSelectedVision();
    if(selected){
      ensureVisionConsistency(selected);
    } else {
      ensureVisionConsistency(visionDefaults);
    }
    setVisionFullReveal(GameState.player.vision.fullReveal !== false, { syncInput: true });
    const resolveType = (type)=> type === 'capsule' ? 'capsule'
      : (type === 'crescent' ? 'crescent' : 'circle');
    const activeType = resolveType(selected ? selected.type : visionDefaults.type);
    const activeMode = normalizeVisionMode(selected ? selected.mode : visionDefaults.mode);
    if(visionShapeSelect){
      visionShapeSelect.value = activeType;
    }
    if(visionModeInput){
      visionModeInput.value = visionModeToOption(activeMode);
    }
    const radiusValue = clampSettingValue(selected ? selected.radius : visionDefaults.radius, SETTINGS_RANGE_MIN);
    if(selected){
      selected.radius = radiusValue;
    } else {
      visionDefaults.radius = radiusValue;
    }
    if(visionRadiusRange){
      visionRadiusRange.min = String(SETTINGS_RANGE_MIN);
      visionRadiusRange.max = String(SETTINGS_RANGE_MAX);
      const radiusRounded = Math.round(radiusValue);
      visionRadiusRange.value = String(radiusRounded);
      if(visionRadiusDisplay){
        visionRadiusDisplay.textContent = `${radiusRounded}px`;
      }
    }
    const typeIsCapsule = activeType === 'capsule';
    const typeIsCrescent = activeType === 'crescent';
    if(visionLengthRow){ visionLengthRow.hidden = !typeIsCapsule; }
    if(visionInnerRadiusRow){ visionInnerRadiusRow.hidden = !typeIsCrescent; }
    if(visionOffsetRow){ visionOffsetRow.hidden = !typeIsCrescent; }
    if(visionRotationRow){ visionRotationRow.hidden = !(typeIsCapsule || typeIsCrescent); }

    if(typeIsCapsule && visionLengthRange){
      const lengthValue = clampSettingValue(selected ? selected.length : visionDefaults.length, SETTINGS_RANGE_MIN);
      if(selected){
        selected.length = lengthValue;
      } else {
        visionDefaults.length = lengthValue;
      }
      visionLengthRange.min = String(SETTINGS_RANGE_MIN);
      visionLengthRange.max = String(SETTINGS_RANGE_MAX);
      const lengthRounded = Math.round(lengthValue);
      visionLengthRange.value = String(lengthRounded);
      if(visionLengthDisplay){
        visionLengthDisplay.textContent = `${lengthRounded}px`;
      }
      const angleDeg = selected ? radToDeg(selected.angle) : visionDefaults.angleDeg;
      const normalized = ((Math.round(angleDeg) % 360) + 360) % 360;
      if(visionRotationRange){
        visionRotationRange.value = String(normalized);
      }
      if(visionRotationDisplay){
        visionRotationDisplay.textContent = `${normalized}Â°`;
      }
    } else if(typeIsCrescent){
      const metrics = selected ? ensureCrescentMetrics(selected)
        : ensureCrescentMetrics({
            x: 0,
            y: 0,
            radius: visionDefaults.radius,
            innerRadius: visionDefaults.innerRadius,
            offset: visionDefaults.offset,
            angle: degToRad(visionDefaults.angleDeg)
          });
      if(!selected){
        visionDefaults.innerRadius = metrics.innerRadius;
        visionDefaults.offset = metrics.offset;
      }
      if(visionInnerRadiusRange){
        const innerValue = clampSettingValue(metrics.innerRadius, SETTINGS_RANGE_MIN);
        visionInnerRadiusRange.min = String(SETTINGS_RANGE_MIN);
        visionInnerRadiusRange.max = String(SETTINGS_RANGE_MAX);
        visionInnerRadiusRange.value = String(Math.round(innerValue));
        if(visionInnerRadiusDisplay){
          visionInnerRadiusDisplay.textContent = `${Math.round(innerValue)}px`;
        }
      }
      if(visionOffsetRange){
        const offsetValue = clampSettingValue(metrics.offset, SETTINGS_RANGE_MIN);
        visionOffsetRange.min = String(SETTINGS_RANGE_MIN);
        visionOffsetRange.max = String(SETTINGS_RANGE_MAX);
        visionOffsetRange.value = String(Math.round(offsetValue));
        if(visionOffsetDisplay){
          visionOffsetDisplay.textContent = `${Math.round(offsetValue)}px`;
        }
      }
      const angleDeg = selected ? radToDeg(selected.angle) : visionDefaults.angleDeg;
      const normalized = ((Math.round(angleDeg) % 360) + 360) % 360;
      if(visionRotationRange){
        visionRotationRange.value = String(normalized);
      }
      if(visionRotationDisplay){
        visionRotationDisplay.textContent = `${normalized}Â°`;
      }
    } else {
      if(visionRotationDisplay){
        visionRotationDisplay.textContent = '0Â°';
      }
      if(visionRotationRange){
        visionRotationRange.value = '0';
      }
    }

    if(playerVisionRadiusDisplay){
      const rounded = Math.round(clampSettingValue(GameState.player.vision.radius, SETTINGS_RANGE_MIN));
      playerVisionRadiusDisplay.textContent = `${rounded}px`;
      if(playerVisionRadiusInput){
        playerVisionRadiusInput.value = String(rounded);
      }
    }
    if(visionEditToggle){
      visionEditToggle.textContent = GameState.player.vision.editMode ? 'Exit vision edit mode' : 'Enter vision edit mode';
    }
    if(visionPlaceButton){
      visionPlaceButton.textContent = GameState.player.vision.placing ? 'Cancel placement' : 'Place new vision';
    }
    if(visionToggleVisibilityButton){
      visionToggleVisibilityButton.textContent = GameState.player.vision.hidden ? 'Show vision' : 'Hide vision';
    }
    if(visionDeleteButton){
      visionDeleteButton.disabled = !selected;
    }
    refreshVisionList();
  }
  function selectVision(id){
    if(Number.isFinite(id)){
      const found = getVisionByIdValue(id);
      GameState.player.vision.selectedId = found ? found.id : null;
    } else {
      GameState.player.vision.selectedId = null;
    }
    updateVisionUiState();
  }
  function setVisionEditMode(enabled){
    const next = !!enabled;
    if(GameState.player.vision.editMode === next) return;
    if(next){
      setColliderEditMode(false);
    }
    GameState.player.vision.editMode = next;
    if(!next){
      GameState.player.vision.placing = false;
      GameState.player.vision.dummyState.placing = false;
      stopVisionDrag();
      stopVisionDummyDrag();
    }
    updateVisionUiState();
  }
  function stopVisionDrag(){
    if(stage && GameState.player.vision.pointerId !== null){
      try {
        stage.releasePointerCapture(GameState.player.vision.pointerId);
      } catch (err) {
        /* ignore */
      }
    }
    GameState.player.vision.draggingId = null;
    GameState.player.vision.pointerId = null;
    GameState.player.vision.dragMoved = false;
  }
  function stopVisionDummyDrag(){
    if(stage && GameState.player.vision.dummyState.pointerId !== null){
      try {
        stage.releasePointerCapture(GameState.player.vision.dummyState.pointerId);
      } catch (err) {
        /* ignore */
      }
    }
    GameState.player.vision.dummyState.dragging = false;
    GameState.player.vision.dummyState.pointerId = null;
    GameState.player.vision.dummyState.dragOffset.x = 0;
    GameState.player.vision.dummyState.dragOffset.y = 0;
  }
  function toggleVisionPlacement(){
    if(!GameState.player.vision.editMode){
      setVisionEditMode(true);
    }
    GameState.player.vision.placing = !GameState.player.vision.placing;
    if(GameState.player.vision.placing){
      stopVisionDrag();
      GameState.player.vision.dummyState.placing = false;
    }
    updateVisionUiState();
  }
  function addVisionAt(x, y){
    const type = visionDefaults.type === 'capsule' ? 'capsule'
      : (visionDefaults.type === 'crescent' ? 'crescent' : 'circle');
    const radius = clampSettingValue(visionDefaults.radius, SETTINGS_RANGE_MIN);
    const angle = degToRad(visionDefaults.angleDeg);
    let entry;
    const mode = normalizeVisionMode(visionDefaults.mode);
    if(type === 'capsule'){
      const baseLength = Number(visionDefaults.length);
      const fallbackLength = radius * 2;
      const length = Number.isFinite(baseLength)
        ? clampSettingValue(baseLength, fallbackLength)
        : clampSettingValue(fallbackLength);
      entry = { id: GameState.player.vision.nextId++, type, mode, x, y, radius, length, angle };
    } else if(type === 'crescent'){
      const innerRadius = Number.isFinite(Number(visionDefaults.innerRadius))
        ? clampSettingValue(visionDefaults.innerRadius, radius * 0.6)
        : clampSettingValue(radius * 0.6);
      const offset = Number.isFinite(Number(visionDefaults.offset))
        ? clampSettingValue(visionDefaults.offset, radius * 0.6)
        : clampSettingValue(radius * 0.6);
      entry = {
        id: GameState.player.vision.nextId++,
        type,
        mode,
        x,
        y,
        radius,
        innerRadius,
        offset,
        angle,
        length: clampSettingValue(radius * 2)
      };
    } else {
      entry = {
        id: GameState.player.vision.nextId++,
        type: 'circle',
        mode,
        x,
        y,
        radius,
        length: clampSettingValue(radius * 2),
        angle: 0
      };
    }
    ensureVisionConsistency(entry);
    customVisionSources.push(entry);
    GameState.player.vision.selectedId = entry.id;
    updateVisionUiState();
    onVisionsChanged();
    return entry;
  }
  function onVisionsChanged(){
    renderMinimap(true);
  }
  function removeSelectedVision(){
    if(!Number.isFinite(GameState.player.vision.selectedId)) return;
    for(let i = customVisionSources.length - 1; i >= 0; i--){
      const source = customVisionSources[i];
      if(source && source.id === GameState.player.vision.selectedId){
        customVisionSources.splice(i, 1);
        break;
      }
    }
    GameState.player.vision.selectedId = null;
    updateVisionUiState();
    onVisionsChanged();
  }
  if(visionEditToggle){
    visionEditToggle.addEventListener('click', ()=>{
      setVisionEditMode(!GameState.player.vision.editMode);
    });
  }
  if(visionPlaceButton){
    visionPlaceButton.addEventListener('click', ()=>{
      toggleVisionPlacement();
    });
  }
  if(visionToggleVisibilityButton){
    visionToggleVisibilityButton.addEventListener('click', ()=>{
      GameState.player.vision.hidden = !GameState.player.vision.hidden;
      updateVisionUiState();
      renderMinimap(true);
    });
  }
  if(visionFullRevealInput){
    visionFullRevealInput.addEventListener('change', ()=>{
      setVisionFullReveal(visionFullRevealInput.checked, { syncInput: false });
    });
  }
  if(visionDeleteButton){
    visionDeleteButton.addEventListener('click', ()=>{
      removeSelectedVision();
    });
  }
  if(visionShapeSelect){
    visionShapeSelect.addEventListener('change', ()=>{
      const rawValue = visionShapeSelect.value;
      const value = rawValue === 'capsule' ? 'capsule'
        : (rawValue === 'crescent' ? 'crescent' : 'circle');
      const selected = getSelectedVision();
      if(selected){
        selected.type = value;
        ensureVisionConsistency(selected);
        onVisionsChanged();
      }
      visionDefaults.type = value;
      if(value === 'circle'){
        visionDefaults.angleDeg = 0;
      } else if(value === 'capsule'){
        const baseRadius = clampSettingValue(selected ? selected.radius : visionDefaults.radius, SETTINGS_RANGE_MIN);
        const fallbackLength = baseRadius * 2;
        if(!Number.isFinite(visionDefaults.length)){
          visionDefaults.length = clampSettingValue(fallbackLength);
        } else {
          visionDefaults.length = clampSettingValue(visionDefaults.length, fallbackLength);
        }
      } else if(value === 'crescent'){
        if(!Number.isFinite(visionDefaults.innerRadius)){
          visionDefaults.innerRadius = clampSettingValue(visionDefaults.radius * 0.6, SETTINGS_RANGE_MIN);
        }
        if(!Number.isFinite(visionDefaults.offset)){
          visionDefaults.offset = clampSettingValue(visionDefaults.radius * 0.6, SETTINGS_RANGE_MIN);
        }
      }
      updateVisionUiState();
      renderMinimap(true);
    });
  }
  if(visionModeInput){
    const handleVisionModeChange = ()=>{
      const mode = normalizeVisionMode(visionModeInput.value);
      const selected = getSelectedVision();
      if(selected){
        if(selected.mode !== mode){
          selected.mode = mode;
          ensureVisionConsistency(selected);
          onVisionsChanged();
        }
      } else if(visionDefaults.mode !== mode){
        visionDefaults.mode = mode;
        ensureVisionConsistency(visionDefaults);
        renderMinimap(true);
      }
      visionModeInput.value = visionModeToOption(mode);
      updateVisionUiState();
    };
    visionModeInput.addEventListener('change', handleVisionModeChange);
    visionModeInput.addEventListener('input', handleVisionModeChange);
  }
  if(visionRadiusRange){
    visionRadiusRange.addEventListener('input', ()=>{
      const value = clampSettingValue(visionRadiusRange.value, SETTINGS_RANGE_MIN);
      visionRadiusRange.value = String(value);
      const selected = getSelectedVision();
      if(selected){
        selected.radius = value;
        ensureVisionConsistency(selected);
      } else {
        visionDefaults.radius = value;
        ensureVisionConsistency(visionDefaults);
      }
      updateVisionUiState();
    });
    visionRadiusRange.addEventListener('change', ()=>{
      if(getSelectedVision()){
        onVisionsChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(visionInnerRadiusRange){
    visionInnerRadiusRange.addEventListener('input', ()=>{
      const value = clampSettingValue(visionInnerRadiusRange.value, SETTINGS_RANGE_MIN);
      visionInnerRadiusRange.value = String(value);
      const selected = getSelectedVision();
      if(selected){
        selected.innerRadius = value;
        ensureVisionConsistency(selected);
      } else {
        visionDefaults.innerRadius = value;
        ensureVisionConsistency(visionDefaults);
      }
      updateVisionUiState();
    });
    visionInnerRadiusRange.addEventListener('change', ()=>{
      if(getSelectedVision()){
        onVisionsChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(visionOffsetRange){
    visionOffsetRange.addEventListener('input', ()=>{
      const value = clampSettingValue(visionOffsetRange.value, SETTINGS_RANGE_MIN);
      visionOffsetRange.value = String(value);
      const selected = getSelectedVision();
      if(selected){
        selected.offset = value;
        ensureVisionConsistency(selected);
      } else {
        visionDefaults.offset = value;
        ensureVisionConsistency(visionDefaults);
      }
      updateVisionUiState();
    });
    visionOffsetRange.addEventListener('change', ()=>{
      if(getSelectedVision()){
        onVisionsChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(visionLengthRange){
    visionLengthRange.addEventListener('input', ()=>{
      const value = clampSettingValue(visionLengthRange.value, SETTINGS_RANGE_MIN);
      visionLengthRange.value = String(value);
      const selected = getSelectedVision();
      if(selected){
        selected.length = value;
        ensureVisionConsistency(selected);
      } else {
        visionDefaults.length = value;
        ensureVisionConsistency(visionDefaults);
      }
      updateVisionUiState();
    });
    visionLengthRange.addEventListener('change', ()=>{
      if(getSelectedVision()){
        onVisionsChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(visionRotationRange){
    visionRotationRange.addEventListener('input', ()=>{
      const value = Number(visionRotationRange.value) || 0;
      const selected = getSelectedVision();
      if(selected){
        selected.angle = degToRad(value);
      } else {
        visionDefaults.angleDeg = value;
      }
      updateVisionUiState();
    });
    visionRotationRange.addEventListener('change', ()=>{
      if(getSelectedVision()){
        onVisionsChanged();
      } else {
        renderMinimap(true);
      }
    });
  }
  if(visionListEl){
    visionListEl.addEventListener('click', (event)=>{
      const target = event.target instanceof Element ? event.target.closest('.colliderEntry') : null;
      if(!target) return;
      const id = Number(target.dataset.id);
      if(Number.isFinite(id)){
        selectVision(id);
      }
    });
  }
  if(playerVisionRadiusInput){
    playerVisionRadiusInput.addEventListener('input', ()=>{
      const value = clampSettingValue(playerVisionRadiusInput.value, SETTINGS_RANGE_MIN);
      playerVisionRadiusInput.value = String(value);
      GameState.player.vision.radius = value;
      updateVisionUiState();
    });
    playerVisionRadiusInput.addEventListener('change', ()=>{
      renderMinimap(true);
    });
  }
  if(visionDummyRadiusInput){
    visionDummyRadiusInput.addEventListener('input', ()=>{
      const value = clampSettingValue(visionDummyRadiusInput.value, SETTINGS_RANGE_MIN);
      visionDummyRadiusInput.value = String(value);
      visionDummy.radius = value;
      updateVisionUiState();
    });
    visionDummyRadiusInput.addEventListener('change', ()=>{
      renderMinimap(true);
    });
  }
  if(visionDummyPlaceButton){
    visionDummyPlaceButton.addEventListener('click', ()=>{
      if(!GameState.player.vision.editMode){
        setVisionEditMode(true);
      }
      GameState.player.vision.dummyState.placing = !GameState.player.vision.dummyState.placing;
      if(GameState.player.vision.dummyState.placing){
        GameState.player.vision.placing = false;
        stopVisionDrag();
      }
      updateVisionUiState();
    });
  }
  updateVisionUiState();

  function buildPracticeDummySnapshot(){
    const base = defaultBuildSectionSnapshot(practiceDummyPane);
    if(!base){
      return null;
    }
    const dummySnapshot = {
      active: practiceDummy && practiceDummy.active !== false && !(practiceDummy && practiceDummy.respawnTimer > 0),
      x: Number(practiceDummy && practiceDummy.x) || 0,
      y: Number(practiceDummy && practiceDummy.y) || 0,
      size: clampPracticeDummySize(practiceDummy && practiceDummy.size, practiceDummyDefaults.size),
      hp: Math.max(0, Number(practiceDummy && practiceDummy.hp) || 0),
      maxHp: Math.max(1, Number(practiceDummy && practiceDummy.maxHp) || practiceDummyDefaults.maxHp),
      deathResponse: practiceDummy && practiceDummy.deathResponse === 'despawn' ? 'despawn' : 'respawn'
    };
    if(practiceDummy && practiceDummy.statuses && typeof practiceDummy.statuses === 'object'){
      dummySnapshot.statuses = deepClone(practiceDummy.statuses);
    }
    base.dummy = dummySnapshot;
    return base;
  }

  function applyPracticeDummySnapshot(snapshot){
    if(!snapshot || typeof snapshot !== 'object'){
      return false;
    }
    const baseApplied = defaultApplySectionSnapshot(practiceDummyPane, snapshot);
    let dummyApplied = false;
    if(practiceDummy && snapshot.dummy && typeof snapshot.dummy === 'object'){
      const dummy = snapshot.dummy;
      const clampCoord = (value, max) => {
        const numeric = Number(value);
        if(!Number.isFinite(numeric)){
          return null;
        }
        if(!(max > 0)){
          return Math.max(0, numeric);
        }
        return Math.max(0, Math.min(max, numeric));
      };
      const clampedX = clampCoord(dummy.x, mapState.width);
      if(clampedX !== null){
        practiceDummy.x = clampedX;
        dummyApplied = true;
      }
      const clampedY = clampCoord(dummy.y, mapState.height);
      if(clampedY !== null){
        practiceDummy.y = clampedY;
        dummyApplied = true;
      }
      if(Number.isFinite(Number(dummy.size))){
        practiceDummy.size = clampPracticeDummySize(dummy.size, practiceDummyDefaults.size);
        dummyApplied = true;
      }
      if(Number.isFinite(Number(dummy.maxHp))){
        practiceDummy.maxHp = Math.max(1, Number(dummy.maxHp));
        dummyApplied = true;
      }
      if(Number.isFinite(Number(dummy.hp))){
        practiceDummy.hp = Math.max(0, Math.min(practiceDummy.maxHp, Number(dummy.hp)));
        dummyApplied = true;
      } else if(practiceDummy.hp > practiceDummy.maxHp){
        practiceDummy.hp = practiceDummy.maxHp;
      }
      if(dummy.statuses && typeof dummy.statuses === 'object'){
        practiceDummy.statuses = deepClone(dummy.statuses);
        dummyApplied = true;
      }
      if(typeof dummy.deathResponse === 'string'){
        practiceDummy.deathResponse = dummy.deathResponse === 'despawn' ? 'despawn' : 'respawn';
        dummyApplied = true;
      }
      const active = dummy.active === false ? false : true;
      practiceDummy.active = active;
      practiceDummy.respawnTimer = 0;
      if(!active){
        practiceDummy.hp = 0;
        resetPracticeDummyStatuses();
      } else if(!practiceDummy.statuses || typeof practiceDummy.statuses !== 'object'){
        practiceDummy.statuses = buildDefaultPlayerStatusConfig();
      }
      practiceDummyState.placing = false;
      practiceDummyState.selected = false;
      practiceDummyState.dragging = false;
      practiceDummyState.pointerId = null;
      if(practiceDummyState.dragOffset){
        practiceDummyState.dragOffset.x = 0;
        practiceDummyState.dragOffset.y = 0;
      } else {
        practiceDummyState.dragOffset = { x: 0, y: 0 };
      }
      normalizePracticeDummyState();
      refreshPracticeDummyAnchors();
      updatePracticeDummyUiState();
      updatePracticeDummyHud();
      updatePracticeDummyStatusIcons();
      positionPracticeDummyHud();
      renderMinimap(true);
      dummyApplied = true;
    }
    return baseApplied || dummyApplied;
  }

  setupSectionPersistence({
    paneId: 'visionPane',
    saveButtonId: 'visionConfigSave',
    loadButtonId: 'visionConfigLoad',
    fileInputId: 'visionConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'vision',
    label: 'Vision',
    filePrefix: 'vision',
    buildSnapshot: ()=> buildVisionSnapshot(),
    applySnapshot: (snapshot)=> applyVisionSnapshot(snapshot)
  });

  function buildTurretSnapshot(){
    const base = defaultBuildSectionSnapshot(turretPane);
    if(!base){
      return null;
    }
    base.turrets = {
      perLane: clampTurretCount(turretState.perLane),
      range: clampTurretRange(turretState.range),
      damage: clampTurretDamage(turretState.damage),
      attackInterval: clampTurretInterval(turretState.attackInterval),
      playerFocusSeconds: clampTurretFocus(turretState.playerFocusSeconds),
      hasCustomOffsets: turretState.hasCustomOffsets === true,
      offsets: turretState.offsets.map(entry => ({
        x: Number(entry && entry.x) || 0,
        y: Number(entry && entry.y) || 0
      }))
    };
    return base;
  }

  function applyTurretSnapshot(snapshot){
    if(!snapshot || typeof snapshot !== 'object'){
      return false;
    }
    if(snapshot.turrets && typeof snapshot.turrets === 'object'){
      const cfg = snapshot.turrets;
      let appliedOffsets = false;
      if(cfg.perLane !== undefined){
        setTurretPerLane(cfg.perLane, { syncInput: true, notify: false });
      }
      if(cfg.range !== undefined){
        setTurretRange(cfg.range, { syncInput: true });
      }
      if(cfg.damage !== undefined){
        setTurretDamage(cfg.damage, { syncInput: true });
      }
      if(cfg.attackInterval !== undefined){
        setTurretInterval(cfg.attackInterval, { syncInput: true });
      }
      if(cfg.playerFocusSeconds !== undefined){
        setTurretFocus(cfg.playerFocusSeconds, { syncInput: true });
      }
      if(Array.isArray(cfg.offsets)){
        ensureTurretOffsetsCount(cfg.offsets.length);
        cfg.offsets.forEach((entry, index) => {
          if(entry && typeof entry === 'object'){
            setTurretOffset(index, 'x', entry.x, { syncInput: true, notify: false });
            setTurretOffset(index, 'y', entry.y, { syncInput: true, notify: false });
            appliedOffsets = appliedOffsets || !!(Number(entry.x) || Number(entry.y));
          }
        });
      }
      const explicitCustom = cfg.hasCustomOffsets === true;
      const hasNonZero = turretState.offsets.some(entry => {
        if(!entry || typeof entry !== 'object') return false;
        return (Number(entry.x) || 0) !== 0 || (Number(entry.y) || 0) !== 0;
      });
      turretState.hasCustomOffsets = (explicitCustom && hasNonZero) || hasNonZero || appliedOffsets;
      updateTurretOffsetControls();
    }
    const baseApplied = defaultApplySectionSnapshot(turretPane, snapshot);
    markTurretsDirty();
    renderMinimap(true);
    return baseApplied || !!snapshot.turrets;
  }

  function buildMinionSnapshot(){
    const base = defaultBuildSectionSnapshot(minionsPane);
    if(!base){
      return null;
    }
    base.lane = {
      count: GameState.lanes.count,
      offsets: laneConfigs.map(cfg => cfg && Number.isFinite(cfg.offset) ? cfg.offset : 0)
    };
    return base;
  }

  function applyMinionSnapshot(snapshot){
    if(!snapshot || typeof snapshot !== 'object'){
      return false;
    }
    let applied = false;
    if(snapshot.lane && Number.isFinite(snapshot.lane.count)){
      setLaneCount(snapshot.lane.count, { syncInput: true, notify: false });
      applied = true;
    }
    updateLaneOffsetControls();
    if(snapshot.lane && Array.isArray(snapshot.lane.offsets)){
      snapshot.lane.offsets.forEach((value, index) => {
        if(Number.isFinite(value)){
          setLaneOffsetNormalized(index, value, { syncInput: true, notify: false });
        }
      });
      applied = true;
    }
    const baseApplied = defaultApplySectionSnapshot(minionsPane, snapshot);
    invalidateLaneLayout({ resetMinions: true });
    return applied || baseApplied;
  }

  setupSectionPersistence({
    paneId: 'minionsPane',
    saveButtonId: 'minionConfigSave',
    loadButtonId: 'minionConfigLoad',
    fileInputId: 'minionConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'minions',
    label: 'Minion waves',
    filePrefix: 'minions',
    buildSnapshot: ()=> buildMinionSnapshot(),
    applySnapshot: (snapshot)=> applyMinionSnapshot(snapshot)
  });

  setupSectionPersistence({
    paneId: 'turretPane',
    saveButtonId: 'turretConfigSave',
    loadButtonId: 'turretConfigLoad',
    fileInputId: 'turretConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'turrets',
    label: 'Turrets',
    filePrefix: 'turrets',
    buildSnapshot: ()=> buildTurretSnapshot(),
    applySnapshot: (snapshot)=> applyTurretSnapshot(snapshot)
  });

  setupSectionPersistence({
    paneId: 'playerPane',
    saveButtonId: 'playerConfigSave',
    loadButtonId: 'playerConfigLoad',
    fileInputId: 'playerConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'player',
    label: 'Player',
    filePrefix: 'player'
  });

  setupSectionPersistence({
    paneId: 'healthPane',
    saveButtonId: 'healthConfigSave',
    loadButtonId: 'healthConfigLoad',
    fileInputId: 'healthConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'health',
    label: 'Health bar',
    filePrefix: 'health'
  });

  setupSectionPersistence({
    paneId: 'practiceDummyPane',
    storageKey: SECTION_STORAGE_PREFIX + 'practice-dummy',
    label: 'Practice dummy',
    filePrefix: 'practice-dummy',
    buildSnapshot: ()=> buildPracticeDummySnapshot(),
    applySnapshot: (snapshot)=> applyPracticeDummySnapshot(snapshot)
  });

  setupSectionPersistence({
    paneId: 'cameraPane',
    saveButtonId: 'cameraConfigSave',
    loadButtonId: 'cameraConfigLoad',
    fileInputId: 'cameraConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'camera',
    label: 'Camera',
    filePrefix: 'camera'
  });

  setupSectionPersistence({
    paneId: 'abilityPane',
    saveButtonId: 'abilityConfigSave',
    loadButtonId: 'abilityConfigLoad',
    fileInputId: 'abilityConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'ability',
    label: 'Ability bar',
    filePrefix: 'ability'
  });

  setupSectionPersistence({
    paneId: 'minimapPane',
    saveButtonId: 'minimapConfigSave',
    loadButtonId: 'minimapConfigLoad',
    fileInputId: 'minimapConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'minimap',
    label: 'Minimap',
    filePrefix: 'minimap'
  });

  applyScoreModeUi();

  setupSectionPersistence({
    paneId: 'goldPane',
    saveButtonId: 'goldConfigSave',
    loadButtonId: 'goldConfigLoad',
    fileInputId: 'goldConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'gold',
    label: 'Gold',
    filePrefix: 'gold'
  });

  setupSectionPersistence({
    paneId: 'scorePane',
    saveButtonId: 'scoreConfigSave',
    loadButtonId: 'scoreConfigLoad',
    fileInputId: 'scoreConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'score',
    label: 'Score rules',
    filePrefix: 'score'
  });

  setupSectionPersistence({
    paneId: 'uiLayoutPane',
    saveButtonId: 'uiLayoutConfigSave',
    loadButtonId: 'uiLayoutConfigLoad',
    fileInputId: 'uiLayoutConfigFile',
    storageKey: SECTION_STORAGE_PREFIX + 'ui-layout',
    label: 'UI layout',
    filePrefix: 'ui-layout'
  });

  if(gameStateExportButton){
    gameStateExportButton.addEventListener('click', ()=>{
      const json = exportGameState();
      if(!json){
        alert('Unable to export game setup.');
        return;
      }
      const exported = downloadJson(json, formatSectionConfigFilename('game-state'));
      if(exported){
        if(typeof setHudMessage === 'function'){
          setHudMessage('Full game setup exported.');
        }
      } else {
        alert('Unable to download game setup.');
      }
    });
  }

  if(gameStateImportButton){
    gameStateImportButton.addEventListener('click', ()=>{
      if(!gameStateImportInput){
        return;
      }
      gameStateImportInput.value = '';
      if(!triggerFileInputPicker(gameStateImportInput)){
        alert('Unable to open file picker.');
      }
    });
  }

  if(gameStateImportInput){
    gameStateImportInput.addEventListener('change', ()=>{
      const file = gameStateImportInput.files && gameStateImportInput.files[0];
      if(!file){
        return;
      }
      const reader = new FileReader();
      reader.addEventListener('load', ()=>{
        const text = typeof reader.result === 'string' ? reader.result : '';
        let result;
        try {
          result = importGameState(text);
        } catch (err){
          console.error('importGameState invocation failed', err);
          alert('Import failed: Unexpected error while applying game setup.');
          return;
        }
        if(result && result.ok){
          if(typeof setHudMessage === 'function'){
            setHudMessage('Full game setup imported.');
          }
          if(result.errors && result.errors.length){
            alert(`Imported with warnings:\n\n${result.errors.join('\n')}`);
          }
        } else if(result && Array.isArray(result.errors) && result.errors.length){
          alert(`Import failed:\n\n${result.errors.join('\n')}`);
        } else {
          alert('Import failed: Unable to apply game setup.');
        }
      });
      reader.addEventListener('error', ()=>{
        alert('Unable to read game setup file.');
      });
      reader.readAsText(file);
      gameStateImportInput.value = '';
    });
  }
  setCursorEmoji(cursorState.emoji, { syncInput: true });
  setCursorHoverColor(cursorState.hoverColor, { syncInput: true });
  setCursorEnabled(cursorState.enabled, { syncInput: false });
  setCursorOutlineEnabled(cursorState.outlineEnabled, { syncInput: false });
  refreshCursorToggleButtons();
  refreshStageCursor();

  if(cursorToggleBtn){
    cursorToggleBtn.addEventListener('click', () => {
      const next = !cursorState.enabled;
      setCursorEnabled(next, { syncInput: true });
      setHudMessage(`Custom cursor ${next ? 'enabled' : 'disabled'}.`);
    });
  }
  if(cursorOutlineToggle){
    cursorOutlineToggle.addEventListener('click', () => {
      const next = !cursorState.outlineEnabled;
      setCursorOutlineEnabled(next, { syncInput: true });
      setHudMessage(`Hover outline ${next ? 'enabled' : 'disabled'}.`);
    });
  }
  if(cursorEmojiInput){
    const handleCursorEmoji = () => setCursorEmoji(cursorEmojiInput.value, { syncInput: true });
    cursorEmojiInput.addEventListener('input', handleCursorEmoji);
    cursorEmojiInput.addEventListener('change', handleCursorEmoji);
  }
  if(cursorHoverColorInput){
    const handleCursorColor = () => setCursorHoverColor(cursorHoverColorInput.value, { syncInput: false });
    cursorHoverColorInput.addEventListener('input', handleCursorColor);
    cursorHoverColorInput.addEventListener('change', handleCursorColor);
  }

  for(const [type, input] of Object.entries(pingInputs)){
    if(!input) continue;
    input.value = pingState.types[type] || input.value;
    const handlePingEmoji = () => setPingEmoji(type, input.value, { syncInput: true });
    input.addEventListener('input', handlePingEmoji);
    input.addEventListener('change', handlePingEmoji);
  }
  for(const [type, button] of Object.entries(pingButtons)){
    if(!button) continue;
    button.addEventListener('click', () => triggerPing(type));
  }

  updateAttackMoveBindingDisplay();
  updatePingWheelBindingDisplay();
  if(attackMoveBindBtn){
    attackMoveBindBtn.addEventListener('click', () => {
      attackMoveCapture = !attackMoveCapture;
      updateAttackMoveBindingDisplay();
      if(attackMoveCapture){
        setHudMessage('Press a key for attack move.');
      }
    });
  }

  if(pingWheelBindBtn){
    pingWheelBindBtn.addEventListener('click', () => {
      pingWheelCapture = !pingWheelCapture;
      updatePingWheelBindingDisplay();
      if(pingWheelCapture){
        setHudMessage('Press a key for the ping wheel.');
      }
    });
  }

  if(spellCastDefaultSelect){
    spellCastDefaultSelect.addEventListener('change', ()=>{
      setDefaultSpellCastType(spellCastDefaultSelect.value, { syncInput: true });
    });
  }
  if(spellCastNormalBindBtn){
    spellCastNormalBindBtn.addEventListener('click', ()=> toggleSpellCastBindingCapture('normal'));
  }
  if(spellCastQuickBindBtn){
    spellCastQuickBindBtn.addEventListener('click', ()=> toggleSpellCastBindingCapture('quick'));
  }
  if(spellCastIndicatorBindBtn){
    spellCastIndicatorBindBtn.addEventListener('click', ()=> toggleSpellCastBindingCapture('quickIndicator'));
  }
  if(abilityCountInput){
    abilityCountInput.addEventListener('input', ()=>{
      const count = sanitizeAbilityCount(abilityCountInput.value);
      abilityCountInput.value = String(count);
      setAbilityBar(count, abilityBarState.scale);
    });
  }
  if(abilityScaleInput){
    abilityScaleInput.addEventListener('input', ()=>{
      const raw = abilityScaleInput.value;
      if(raw === ''){
        setAbilityBar(abilityBarState.count, 0, false);
        return;
      }
      const scale = sanitizeAbilityScale(raw);
      setAbilityBar(abilityBarState.count, scale, false);
    });
    abilityScaleInput.addEventListener('change', ()=>{
      const raw = abilityScaleInput.value;
      if(raw === ''){
        setAbilityBar(abilityBarState.count, 0, true);
        return;
      }
      const scale = sanitizeAbilityScale(raw);
      setAbilityBar(abilityBarState.count, scale, true);
    });
  }
  if(abilityOrientationSelect){
    abilityOrientationSelect.addEventListener('change', ()=>{
      setAbilityOrientation(abilityOrientationSelect.value, { syncInput: false });
    });
    setAbilityOrientation(abilityOrientationSelect.value, { syncInput: true });
  } else {
    setAbilityOrientation(abilityBarState.orientation, { syncInput: false });
  }
  if(abilityHealthHorizontalSelect){
    abilityHealthHorizontalSelect.addEventListener('change', ()=>{
      setAbilityHealthPlacementHorizontal(abilityHealthHorizontalSelect.value, { syncInput: false });
    });
    setAbilityHealthPlacementHorizontal(abilityHealthHorizontalSelect.value, { syncInput: true });
  } else {
    setAbilityHealthPlacementHorizontal(abilityBarState.healthPlacement.horizontal, { syncInput: false });
  }
  if(abilityHealthVerticalSelect){
    abilityHealthVerticalSelect.addEventListener('change', ()=>{
      setAbilityHealthPlacementVertical(abilityHealthVerticalSelect.value, { syncInput: false });
    });
    setAbilityHealthPlacementVertical(abilityHealthVerticalSelect.value, { syncInput: true });
  } else {
    setAbilityHealthPlacementVertical(abilityBarState.healthPlacement.vertical, { syncInput: false });
  }
  if(abilityHealthVerticalTextSelect){
    abilityHealthVerticalTextSelect.addEventListener('change', ()=>{
      setAbilityHealthTextPlacementVertical(abilityHealthVerticalTextSelect.value, { syncInput: false });
    });
    setAbilityHealthTextPlacementVertical(abilityHealthVerticalTextSelect.value, { syncInput: true });
  } else {
    setAbilityHealthTextPlacementVertical(abilityBarState.healthPlacement.textVertical, { syncInput: false });
  }
  if(abilityStatsVerticalSelect){
    abilityStatsVerticalSelect.addEventListener('change', ()=>{
      setAbilityStatsPlacementVertical(abilityStatsVerticalSelect.value, { syncInput: false });
    });
    setAbilityStatsPlacementVertical(abilityStatsVerticalSelect.value, { syncInput: true });
  } else {
    setAbilityStatsPlacementVertical(abilityBarState.statsPlacementVertical, { syncInput: false });
  }
  if(minimapScaleInput){
    const handleMinimapScale = ()=> setMinimapUserScale(minimapScaleInput.value, { syncInput: false });
    minimapScaleInput.addEventListener('input', handleMinimapScale);
    minimapScaleInput.addEventListener('change', handleMinimapScale);
    setMinimapUserScale(minimapScaleInput.value, { syncInput: true });
  } else {
    setMinimapUserScale(minimapState.userScale, { syncInput: false });
  }
  if(minimapClickToMoveSelect){
    const handleMinimapOrders = ()=> setMinimapClickToMove(minimapClickToMoveSelect.value, { syncInput: false });
    minimapClickToMoveSelect.addEventListener('change', handleMinimapOrders);
    setMinimapClickToMove(minimapClickToMoveSelect.value, { syncInput: true });
  } else {
    setMinimapClickToMove(minimapState.clickToMoveEnabled, { syncInput: false });
  }
  if(minimapClickThroughSelect){
    const handleMinimapThrough = ()=> setMinimapClickThrough(minimapClickThroughSelect.value, { syncInput: false });
    minimapClickThroughSelect.addEventListener('change', handleMinimapThrough);
    setMinimapClickThrough(minimapClickThroughSelect.value, { syncInput: true });
  } else {
    setMinimapClickThrough(minimapState.clickThroughEnabled, { syncInput: false });
  }
  if(spellSpeedScaleInput){
    spellSpeedScaleInput.addEventListener('input', ()=>{
      setSpellSpeedScale(spellSpeedScaleInput.value, { syncInput: true });
    });
    setSpellSpeedScale(abilityTunables.spellSpeedScale, { syncInput: true });
  }
  if(spellSizeScaleInput){
    spellSizeScaleInput.addEventListener('input', ()=>{
      setSpellSizeScale(spellSizeScaleInput.value, { syncInput: true });
    });
    setSpellSizeScale(abilityTunables.spellSizeScale, { syncInput: true });
  }
  initUiLayoutControls();
  if(goldPerSecondInput){
    goldPerSecondInput.addEventListener('input', ()=>{
      const value = clampFloat(goldPerSecondInput.value, 0, 100);
      goldState.perSecond = value;
      goldPerSecondInput.value = String(value);
    });
    goldPerSecondInput.dispatchEvent(new Event('input'));
  }
  if(goldPerKillInput){
    goldPerKillInput.addEventListener('input', ()=>{
      const value = clampFloat(goldPerKillInput.value, 0, 100);
      goldState.perKill = value;
      goldPerKillInput.value = String(value);
    });
    goldPerKillInput.dispatchEvent(new Event('input'));
  }
  waveCountInput.addEventListener('input', ()=>{
    waveState.waveCount = clamp(waveCountInput.value,0,1000);
    waveCountInput.value = String(waveState.waveCount);
  });
  waveIntervalInput.addEventListener('input', ()=>{
    const sec = clamp(waveIntervalInput.value,5,60);
    waveIntervalInput.value = String(sec);
    waveState.waveIntervalMs = sec*1000;
    if(timerState.running){
      const cur=performance.now()-timerState.start;
      timerState.nextWaveAtMs = cur + waveState.waveIntervalMs;
    }
  });
  spawnSpacingInput.addEventListener('input', ()=>{
    const sec = clampFloat(spawnSpacingInput.value,0,1);
    spawnSpacingInput.value = sec.toFixed(2);
    waveState.spawnSpacingMs = sec * 1000;
  });
  spawnSpacingInput.dispatchEvent(new Event('input'));
  if(laneCountInput){
    laneCountInput.addEventListener('input', ()=>{
      setLaneCount(laneCountInput.value, { syncInput: false, notify: true });
    });
    setLaneCount(laneCountInput.value, { syncInput: false, notify: false });
  } else {
    setLaneCount(GameState.lanes.count, { syncInput: false, notify: false });
  }
  minionSizeInput.addEventListener('input', ()=>{
    const size = clamp(minionSizeInput.value,0,1000);
    minionSizeInput.value = String(size);
    setMinionSizePx(size);
  });
  minionSizeInput.dispatchEvent(new Event('input'));
  minionHPInput.addEventListener('input', ()=>{
    portalState.baseMinionHP = clamp(minionHPInput.value,1,1000);
    minionHPInput.value = String(portalState.baseMinionHP);
  });
  minionDMGInput.addEventListener('input', ()=>{
    portalState.baseMinionDMG = clamp(minionDMGInput.value,1,100);
    minionDMGInput.value = String(portalState.baseMinionDMG);
  });
  scalePctInput.addEventListener('input', ()=>{
    const next = Math.max(0, Math.min(50, Number(scalePctInput.value) || 0));
    portalState.scalePct = next;
    scalePctInput.value = String(next);
  });
  if(turretCountInput){
    turretCountInput.value = String(turretState.perLane);
    turretCountInput.addEventListener('input', ()=>{
      setTurretPerLane(turretCountInput.value, { syncInput: false, notify: true });
    });
  } else {
    setTurretPerLane(turretState.perLane, { syncInput: false, notify: false });
  }
    if(turretRangeInput){
      turretRangeInput.value = String(turretState.range);
      turretRangeInput.addEventListener('input', ()=>{
        setTurretRange(turretRangeInput.value, { syncInput: false });
      });
    }
  if(turretDamageInput){
    turretDamageInput.value = String(turretState.damage);
    turretDamageInput.addEventListener('input', ()=>{
      setTurretDamage(turretDamageInput.value, { syncInput: false });
    });
  }
  if(turretIntervalInput){
    turretIntervalInput.value = String(turretState.attackInterval);
    turretIntervalInput.addEventListener('input', ()=>{
      setTurretInterval(turretIntervalInput.value, { syncInput: false });
    });
  }
  if(turretFocusInput){
    turretFocusInput.value = String(turretState.playerFocusSeconds);
    turretFocusInput.addEventListener('input', ()=>{
      setTurretFocus(turretFocusInput.value, { syncInput: false });
    });
  }
  if(turretResetOffsetsBtn){
    turretResetOffsetsBtn.addEventListener('click', resetTurretOffsets);
  }
  updateTurretOffsetControls();
  playerSpeedInput.addEventListener('input', ()=>{
    const speed = clamp(playerSpeedInput.value,1,1000);
    playerSpeedInput.value = String(speed);
    player.speed = speed;
    updateHudStats();
  });
  playerSizeInput.addEventListener('input', ()=>{
    const prevSize = Number(player.r) || 0;
    const size = clamp(playerSizeInput.value,0,1000);
    playerSizeInput.value = String(size);
    player.r = size;
    player.x = Math.max(player.r, Math.min(mapState.width - player.r, player.x));
    player.y = Math.max(player.r, Math.min(mapState.height - player.r, player.y));
    positionPlayerFloatingHud();
    positionPracticeDummyHud();
    clearEntityNav(player);
    if(playerRuntime.model){
      playerRuntime.model.setPlayerRadius(size);
    }
    const approxHurtLen = player.hurtboxLength || (prevSize * 2);
    const approxHurtWid = player.hurtboxWidth || (prevSize * 2);
    if(Math.abs(approxHurtLen - prevSize * 2) < 1e-3){
      setPlayerHurtboxLength(size * 2);
    }
    if(Math.abs(approxHurtWid - prevSize * 2) < 1e-3){
      setPlayerHurtboxWidth(size * 2);
    }
  });
  if(playerHurtboxToggleButton){
    const updateHurtToggle = ()=>{
      const visible = player.hurtboxVisible !== false;
      playerHurtboxToggleButton.textContent = visible ? 'Hide hurtbox' : 'Show hurtbox';
    };
    playerHurtboxToggleButton.addEventListener('click', ()=>{
      player.hurtboxVisible = !player.hurtboxVisible;
      updateHurtToggle();
    });
    updateHurtToggle();
  }
  if(playerHurtboxShapeSelect){
    playerHurtboxShapeSelect.value = setPlayerHurtboxShape(player.hurtboxShape);
    playerHurtboxShapeSelect.addEventListener('change', ()=> setPlayerHurtboxShape(playerHurtboxShapeSelect.value));
  }
  if(playerHurtboxLengthInput){
    const syncHurtLength = ()=> setPlayerHurtboxLength(playerHurtboxLengthInput.value);
    syncHurtLength();
    playerHurtboxLengthInput.addEventListener('input', syncHurtLength);
  }
  if(playerHurtboxWidthInput){
    const syncHurtWidth = ()=> setPlayerHurtboxWidth(playerHurtboxWidthInput.value);
    syncHurtWidth();
    playerHurtboxWidthInput.addEventListener('input', syncHurtWidth);
  }
  if(playerTeamSelect){
    playerTeamSelect.addEventListener('change', ()=>{
      setPlayerTeam(playerTeamSelect.value);
    });
  }
  if(playerHpInput){
    playerHpInput.addEventListener('input', ()=>{
      const maxHp = clamp(playerHpInput.value,0,10000);
      playerHpInput.value = String(maxHp);
      const prevMax = Math.max(0, Number(player.maxHp) || 0);
      const prevHp = Math.max(0, Number(player.hp) || 0);
      player.maxHp = maxHp;
      if(maxHp <= 0){
        player.hp = 0;
      } else if(prevMax <= 0){
        player.hp = maxHp;
      } else {
        const ratio = prevMax > 0 ? prevHp / prevMax : 1;
        const nextHp = Number.isFinite(ratio) ? ratio * maxHp : maxHp;
        player.hp = Math.max(0, Math.min(maxHp, Math.round(nextHp)));
      }
      updateHudHealth();
    });
  }
  if(playerFloatSizeInput){
    const handleFloatSizeChange = ()=>{
      const width = clampSettingValue(playerFloatSizeInput.value, SETTINGS_RANGE_MIN);
      playerFloatState.width = width;
      playerFloatSizeInput.value = String(width);
      applyPlayerFloatHudSizing();
      positionPlayerFloatingHud();
      positionPracticeDummyHud();
    };
    playerFloatSizeInput.addEventListener('input', handleFloatSizeChange);
    handleFloatSizeChange();
  }
  if(playerFloatOffsetInput){
    const handleFloatOffsetChange = ()=>{
      const offset = clampSettingValue(playerFloatOffsetInput.value, SETTINGS_RANGE_MIN);
      playerFloatState.gap = offset;
      playerFloatOffsetInput.value = String(offset);
      if(playerFloatOffsetDisplay){
        playerFloatOffsetDisplay.textContent = `${Math.round(playerFloatState.gap)}px`;
      }
      applyPlayerFloatHudSizing();
      positionPlayerFloatingHud();
      positionPracticeDummyHud();
    };
    playerFloatOffsetInput.addEventListener('input', handleFloatOffsetChange);
    handleFloatOffsetChange();
  }
  if(playerFloatHeightInput){
    const handleFloatHeightChange = ()=>{
      const height = clampFloat(playerFloatHeightInput.value, 0, 500);
      playerFloatState.height = height;
      playerFloatHeightInput.value = String(height);
      if(playerFloatHeightDisplay){
        playerFloatHeightDisplay.textContent = `${Math.round(height)}px`;
      }
      applyPlayerFloatHudSizing();
    };
    playerFloatHeightInput.addEventListener('input', handleFloatHeightChange);
    handleFloatHeightChange();
  }
  if(playerHealthColorInput){
    const applyColor = ()=>{
      const color = sanitizeHexColor(playerHealthColorInput.value, playerFloatState.color || '#5bc357');
      playerFloatState.color = color;
      if(playerFloatHud){
        playerFloatHud.style.setProperty('--player-float-color', color);
        playerFloatHud.style.setProperty('--player-float-color-dark', darkenHex(color, 0.25));
      }
    };
    playerHealthColorInput.value = sanitizeHexColor(playerFloatState.color || '#5bc357', '#5bc357');
    playerHealthColorInput.addEventListener('input', applyColor);
    applyColor();
  } else if(playerFloatHud){
    const color = sanitizeHexColor(playerFloatState.color || '#5bc357', '#5bc357');
    playerFloatHud.style.setProperty('--player-float-color', color);
    playerFloatHud.style.setProperty('--player-float-color-dark', darkenHex(color, 0.25));
  }
  if(practiceDummySizeInput){
    const handlePracticeSizeChange = ()=>{
      const size = clampPracticeDummySize(practiceDummySizeInput.value, practiceDummy.size);
      practiceDummy.size = size;
      practiceDummySizeInput.value = String(Math.round(size));
      if(practiceDummySizeDisplay){
        practiceDummySizeDisplay.textContent = `${Math.round(size)}px`;
      }
      updatePracticeDummyHud();
      positionPracticeDummyHud();
      renderMinimap(true);
    };
    practiceDummySizeInput.addEventListener('input', handlePracticeSizeChange);
    handlePracticeSizeChange();
  }
  if(practiceDummyMoveButton){
    practiceDummyMoveButton.addEventListener('click', ()=>{
      if(practiceDummy && practiceDummy.respawnTimer > 0){
        return;
      }
      const nextPlacing = !practiceDummyState.placing;
      practiceDummyState.placing = nextPlacing;
      practiceDummyState.selected = false;
      if(!nextPlacing){
        stopVisionDummyDrag();
      }
      updatePracticeDummyUiState();
    });
  }
  if(practiceDummyResetButton){
    practiceDummyResetButton.addEventListener('click', ()=>{
      respawnPracticeDummy({ resetPosition: true, resetSize: true, resetStats: true });
      practiceDummyState.selected = false;
      updatePracticeDummyUiState();
    });
  }
  if(practiceDummyRemoveButton){
    practiceDummyRemoveButton.addEventListener('click', ()=>{
      const active = practiceDummy && practiceDummy.active !== false && !(practiceDummy && practiceDummy.respawnTimer > 0);
      if(!active || !(practiceDummyState && practiceDummyState.selected)){
        return;
      }
      removePracticeDummy();
    });
  }
  if(monsterMoveButton){
    monsterMoveButton.addEventListener('click', ()=>{
      if(monsterDragState.dragging){
        cancelMonsterDrag();
        return;
      }
      if(monsterDragState.active){
        cancelMonsterDrag();
      } else {
        monsterDragState.active = true;
        monsterDragState.messageActive = true;
        setHudMessage('Click and drag on the map to move the monster.');
        updateMonsterUiState();
      }
    });
  }
  if(monsterAggroRadiusInput){
    const handleMonsterAggroChange = ()=>{
      const radius = Math.max(0, Number(monsterAggroRadiusInput.value) || 0);
      monsterState.aggroRadius = radius;
      monsterAggroRadiusInput.value = String(Math.round(radius));
    };
    monsterAggroRadiusInput.addEventListener('input', handleMonsterAggroChange);
    monsterAggroRadiusInput.addEventListener('change', handleMonsterAggroChange);
  }
  if(monsterSizeInput){
    const handleMonsterSizeChange = ()=>{
      const size = Math.max(40, Math.min(400, Number(monsterSizeInput.value) || monsterState.size));
      monsterState.size = size;
      monsterSizeInput.value = String(Math.round(size));
      updateMonsterHud();
      positionMonsterHud();
    };
    monsterSizeInput.addEventListener('input', handleMonsterSizeChange);
    monsterSizeInput.addEventListener('change', handleMonsterSizeChange);
  }
  if(monsterMaxHpInput){
    const handleMonsterMaxHpChange = ()=>{
      const maxHp = Math.max(1, Number(monsterMaxHpInput.value) || monsterState.maxHp || 1);
      monsterState.maxHp = maxHp;
      monsterState.hp = Math.max(0, Math.min(maxHp, Number(monsterState.hp) || maxHp));
      monsterMaxHpInput.value = String(Math.round(maxHp));
      updateMonsterHud();
    };
    monsterMaxHpInput.addEventListener('input', handleMonsterMaxHpChange);
    monsterMaxHpInput.addEventListener('change', handleMonsterMaxHpChange);
  }
  if(monsterProjectileDamageInput){
    const handleMonsterDamageChange = ()=>{
      const damage = Math.max(0, Number(monsterProjectileDamageInput.value) || 0);
      monsterState.projectileDamage = damage;
      monsterProjectileDamageInput.value = String(Math.round(damage));
    };
    monsterProjectileDamageInput.addEventListener('input', handleMonsterDamageChange);
    monsterProjectileDamageInput.addEventListener('change', handleMonsterDamageChange);
  }
  if(monsterCastIntervalInput){
    const handleMonsterIntervalChange = ()=>{
      const interval = Math.max(0.5, Number(monsterCastIntervalInput.value) || monsterState.castInterval || 1);
      monsterState.castInterval = interval;
      monsterState.castTimer = Math.min(Math.max(0, Number(monsterState.castTimer) || interval), interval);
      monsterCastIntervalInput.value = interval.toFixed(2);
      updateMonsterAbilityQueueDisplay();
    };
    monsterCastIntervalInput.addEventListener('input', handleMonsterIntervalChange);
    monsterCastIntervalInput.addEventListener('change', handleMonsterIntervalChange);
  }
  if(monsterQueueSizeInput){
    const handleMonsterQueueChange = ()=>{
      const queueSize = Math.max(1, Math.min(6, Number(monsterQueueSizeInput.value) || monsterState.queueSize || 1));
      monsterState.queueSize = queueSize;
      monsterQueueSizeInput.value = String(Math.round(queueSize));
      ensureMonsterQueue(monsterState);
      updateMonsterAbilityQueueDisplay();
    };
    monsterQueueSizeInput.addEventListener('input', handleMonsterQueueChange);
    monsterQueueSizeInput.addEventListener('change', handleMonsterQueueChange);
  }
  if(monsterSlotSpinInput){
    const handleMonsterSlotSpinChange = ()=>{
      const duration = Math.max(0, Number(monsterSlotSpinInput.value) || 0);
      monsterState.slotMachineSpinDuration = duration;
      monsterSlotSpinInput.value = duration.toFixed(2);
    };
    monsterSlotSpinInput.addEventListener('input', handleMonsterSlotSpinChange);
    monsterSlotSpinInput.addEventListener('change', handleMonsterSlotSpinChange);
  }
  if(monsterSlotRevealInput){
    const handleMonsterSlotRevealChange = ()=>{
      const duration = Math.max(0, Number(monsterSlotRevealInput.value) || 0);
      monsterState.slotMachineRevealDuration = duration;
      monsterSlotRevealInput.value = duration.toFixed(2);
    };
    monsterSlotRevealInput.addEventListener('input', handleMonsterSlotRevealChange);
    monsterSlotRevealInput.addEventListener('change', handleMonsterSlotRevealChange);
  }
  if(monsterFreezeDurationInput){
    const handleMonsterFreezeChange = ()=>{
      const freezeDuration = Math.max(0, Number(monsterFreezeDurationInput.value) || 0);
      monsterState.freezeDuration = freezeDuration;
      monsterFreezeDurationInput.value = freezeDuration.toFixed(2);
    };
    monsterFreezeDurationInput.addEventListener('input', handleMonsterFreezeChange);
    monsterFreezeDurationInput.addEventListener('change', handleMonsterFreezeChange);
  }
  if(monsterSpeedBoostPctInput){
    const handleMonsterSpeedChange = ()=>{
      const boost = Math.max(0, Number(monsterSpeedBoostPctInput.value) || 0);
      monsterState.speedBoostPct = boost;
      monsterSpeedBoostPctInput.value = String(Math.round(boost));
    };
    monsterSpeedBoostPctInput.addEventListener('input', handleMonsterSpeedChange);
    monsterSpeedBoostPctInput.addEventListener('change', handleMonsterSpeedChange);
  }
  if(monsterHealAmountInput){
    const handleMonsterHealChange = ()=>{
      const heal = Math.max(0, Number(monsterHealAmountInput.value) || 0);
      monsterState.healAmount = heal;
      monsterHealAmountInput.value = String(Math.round(heal));
    };
    monsterHealAmountInput.addEventListener('input', handleMonsterHealChange);
    monsterHealAmountInput.addEventListener('change', handleMonsterHealChange);
  }
  const handleMonsterIconChange = (abilityId, input)=>{
    if(!input){
      return;
    }
    const handler = ()=>{
      setMonsterProjectileIcon(abilityId, input.value);
      syncMonsterInputs();
      updatePrayerButtons();
      updatePrayerHud();
      updateMonsterAbilityQueueDisplay();
    };
    input.addEventListener('input', handler);
    input.addEventListener('change', handler);
  };
  handleMonsterIconChange('green', monsterIconGreenInput);
  handleMonsterIconChange('blue', monsterIconBlueInput);
  handleMonsterIconChange('red', monsterIconRedInput);
  if(practiceDummyDeathResponseSelect){
    practiceDummyDeathResponseSelect.addEventListener('change', ()=>{
      if(!practiceDummy){
        return;
      }
      const value = practiceDummyDeathResponseSelect.value === 'despawn' ? 'despawn' : 'respawn';
      practiceDummy.deathResponse = value;
      if(value === 'despawn' && practiceDummy.respawnTimer > 0){
        removePracticeDummy();
      }
      updatePracticeDummyUiState();
    });
    updatePracticeDummyUiState();
  }
  if(playerAttackBarWidthInput && playerFloatState.attack){
    const handleAttackWidthChange = ()=>{
      const width = clampSettingValue(playerAttackBarWidthInput.value, SETTINGS_RANGE_MIN);
      playerFloatState.attack.width = width;
      playerAttackBarWidthInput.value = String(width);
      if(playerAttackBarWidthDisplay){
        playerAttackBarWidthDisplay.textContent = `${Math.round(width)}px`;
      }
      applyPlayerFloatHudSizing();
    };
    playerAttackBarWidthInput.addEventListener('input', handleAttackWidthChange);
    handleAttackWidthChange();
  }
  if(playerAttackBarHeightInput && playerFloatState.attack){
    const handleAttackHeightChange = ()=>{
      const height = clampFloat(playerAttackBarHeightInput.value, 0, 500);
      playerFloatState.attack.height = height;
      playerAttackBarHeightInput.value = String(height);
      if(playerAttackBarHeightDisplay){
        playerAttackBarHeightDisplay.textContent = `${Math.round(height)}px`;
      }
      applyPlayerFloatHudSizing();
    };
    playerAttackBarHeightInput.addEventListener('input', handleAttackHeightChange);
    handleAttackHeightChange();
  }
  if(playerAttackBarOffsetXInput && playerFloatState.attack){
    const handleAttackOffsetXChange = ()=>{
      const offset = clampUiOffsetValue(playerAttackBarOffsetXInput.value);
      playerFloatState.attack.offsetX = offset;
      playerAttackBarOffsetXInput.value = String(Math.round(offset));
      applyPlayerFloatHudSizing();
    };
    playerAttackBarOffsetXInput.addEventListener('input', handleAttackOffsetXChange);
    handleAttackOffsetXChange();
  }
  if(playerAttackBarOffsetYInput && playerFloatState.attack){
    const handleAttackOffsetYChange = ()=>{
      const offset = clampUiOffsetValue(playerAttackBarOffsetYInput.value);
      playerFloatState.attack.offsetY = offset;
      playerAttackBarOffsetYInput.value = String(Math.round(offset));
      applyPlayerFloatHudSizing();
    };
    playerAttackBarOffsetYInput.addEventListener('input', handleAttackOffsetYChange);
    handleAttackOffsetYChange();
  }
  if(playerIconWidthInput && playerFloatState.icons){
    const handleIconWidthChange = ()=>{
      const width = clampFloat(playerIconWidthInput.value, 0, 400);
      playerFloatState.icons.width = width;
      playerIconWidthInput.value = String(width);
      if(playerIconWidthDisplay){
        playerIconWidthDisplay.textContent = `${Math.round(width)}px`;
      }
      applyPlayerFloatHudSizing();
    };
    playerIconWidthInput.addEventListener('input', handleIconWidthChange);
    handleIconWidthChange();
  }
  if(playerIconHeightInput && playerFloatState.icons){
    const handleIconHeightChange = ()=>{
      const height = clampFloat(playerIconHeightInput.value, 0, 400);
      playerFloatState.icons.height = height;
      playerIconHeightInput.value = String(height);
      if(playerIconHeightDisplay){
        playerIconHeightDisplay.textContent = `${Math.round(height)}px`;
      }
      applyPlayerFloatHudSizing();
    };
    playerIconHeightInput.addEventListener('input', handleIconHeightChange);
    handleIconHeightChange();
  }
  if(playerIconOffsetXInput && playerFloatState.icons){
    const handleIconOffsetXChange = ()=>{
      const offset = clampUiOffsetValue(playerIconOffsetXInput.value);
      playerFloatState.icons.offsetX = offset;
      playerIconOffsetXInput.value = String(Math.round(offset));
      applyPlayerFloatHudSizing();
    };
    playerIconOffsetXInput.addEventListener('input', handleIconOffsetXChange);
    handleIconOffsetXChange();
  }
  if(playerIconOffsetYInput && playerFloatState.icons){
    const handleIconOffsetYChange = ()=>{
      const offset = clampUiOffsetValue(playerIconOffsetYInput.value);
      playerFloatState.icons.offsetY = offset;
      playerIconOffsetYInput.value = String(Math.round(offset));
      applyPlayerFloatHudSizing();
    };
    playerIconOffsetYInput.addEventListener('input', handleIconOffsetYChange);
    handleIconOffsetYChange();
  }
  if(playerAttackRangeOpacityInput){
    const initialOpacityPct = clampSettingValue(Math.round((Number(player.attackRangeOpacity) || 0) * 100), SETTINGS_RANGE_MIN);
    playerAttackRangeOpacityInput.value = String(initialOpacityPct);
    const handleRangeOpacityChange = ()=>{
      const pct = clampSettingValue(playerAttackRangeOpacityInput.value, SETTINGS_RANGE_MIN);
      playerAttackRangeOpacityInput.value = String(pct);
      player.attackRangeOpacity = Math.min(1, pct / 100);
      if(playerAttackRangeOpacityDisplay){
        playerAttackRangeOpacityDisplay.textContent = `${Math.round(pct)}%`;
      }
    };
    playerAttackRangeOpacityInput.addEventListener('input', handleRangeOpacityChange);
    handleRangeOpacityChange();
  }
  if(playerHitboxToggleButton){
    const syncHitboxToggleLabel = ()=>{
      const visible = player.hitboxVisible !== false;
      playerHitboxToggleButton.textContent = visible ? 'Hide hitbox' : 'Show hitbox';
      playerHitboxToggleButton.setAttribute('aria-pressed', visible ? 'true' : 'false');
    };
    playerHitboxToggleButton.addEventListener('click', ()=>{
      const visible = player.hitboxVisible !== false;
      player.hitboxVisible = !visible;
      syncHitboxToggleLabel();
    });
    syncHitboxToggleLabel();
  }
  if(playerHitboxShapeSelect){
    const syncHitboxShape = ()=>{
      const value = (playerHitboxShapeSelect.value || '').toLowerCase();
      if(value === 'circle' || value === 'rectangle' || value === 'capsule'){
        player.hitboxShape = value;
      } else {
        player.hitboxShape = 'capsule';
        playerHitboxShapeSelect.value = 'capsule';
      }
    };
    playerHitboxShapeSelect.addEventListener('change', syncHitboxShape);
    if(player.hitboxShape){
      playerHitboxShapeSelect.value = player.hitboxShape;
    }
    syncHitboxShape();
  }
  if(playerHitboxLengthInput){
    const syncHitboxLength = ()=>{
      const min = Number(playerHitboxLengthInput.min);
      const max = Number(playerHitboxLengthInput.max);
      const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
      const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
      let length = clampSettingValue(playerHitboxLengthInput.value, clampMin);
      length = Math.min(clampMax, Math.max(clampMin, length));
      if(!Number.isFinite(length)){
        length = Number.isFinite(player.hitboxLength) ? player.hitboxLength : clampMin;
      }
      player.hitboxLength = length;
      playerHitboxLengthInput.value = String(length);
      if(playerHitboxLengthDisplay){
        playerHitboxLengthDisplay.textContent = `${Math.round(length)}px`;
      }
    };
    playerHitboxLengthInput.addEventListener('input', syncHitboxLength);
    syncHitboxLength();
  }
  if(playerHitboxWidthInput){
    const syncHitboxWidth = ()=>{
      const min = Number(playerHitboxWidthInput.min);
      const max = Number(playerHitboxWidthInput.max);
      const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
      const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
      let width = clampSettingValue(playerHitboxWidthInput.value, clampMin);
      width = Math.min(clampMax, Math.max(clampMin, width));
      if(!Number.isFinite(width)){
        width = Number.isFinite(player.hitboxWidth) ? player.hitboxWidth : clampMin;
      }
      player.hitboxWidth = width;
      playerHitboxWidthInput.value = String(width);
      if(playerHitboxWidthDisplay){
        playerHitboxWidthDisplay.textContent = `${Math.round(width)}px`;
      }
    };
    playerHitboxWidthInput.addEventListener('input', syncHitboxWidth);
    syncHitboxWidth();
  }
  if(playerSpellOriginLengthInput){
    const syncOriginLength = ()=>{
      const min = Number(playerSpellOriginLengthInput.min);
      const max = Number(playerSpellOriginLengthInput.max);
      const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
      const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
      let raw = clampSettingValue(playerSpellOriginLengthInput.value, clampMin);
      if(!Number.isFinite(raw)){
        raw = SPELL_ORIGIN_SLIDER_CENTER + (Number.isFinite(player.spellOriginLengthOffset) ? player.spellOriginLengthOffset : 0);
      }
      raw = Math.max(clampMin, Math.min(clampMax, raw));
      playerSpellOriginLengthInput.value = String(raw);
      const offset = raw - SPELL_ORIGIN_SLIDER_CENTER;
      player.spellOriginLengthOffset = offset;
      if(playerSpellOriginLengthDisplay){
        const rounded = Math.round(offset);
        const sign = rounded >= 0 ? '+' : '';
        playerSpellOriginLengthDisplay.textContent = `${sign}${rounded}px`;
      }
    };
    playerSpellOriginLengthInput.addEventListener('input', syncOriginLength);
    syncOriginLength();
  }
  if(playerSpellOriginWidthInput){
    const syncOriginWidth = ()=>{
      const min = Number(playerSpellOriginWidthInput.min);
      const max = Number(playerSpellOriginWidthInput.max);
      const clampMin = Number.isFinite(min) ? min : SETTINGS_RANGE_MIN;
      const clampMax = Number.isFinite(max) ? max : SETTINGS_RANGE_MAX;
      let raw = clampSettingValue(playerSpellOriginWidthInput.value, clampMin);
      if(!Number.isFinite(raw)){
        raw = SPELL_ORIGIN_SLIDER_CENTER + (Number.isFinite(player.spellOriginWidthOffset) ? player.spellOriginWidthOffset : 0);
      }
      raw = Math.max(clampMin, Math.min(clampMax, raw));
      playerSpellOriginWidthInput.value = String(raw);
      const offset = raw - SPELL_ORIGIN_SLIDER_CENTER;
      player.spellOriginWidthOffset = offset;
      if(playerSpellOriginWidthDisplay){
        const rounded = Math.round(offset);
        const sign = rounded >= 0 ? '+' : '';
        playerSpellOriginWidthDisplay.textContent = `${sign}${rounded}px`;
      }
    };
    playerSpellOriginWidthInput.addEventListener('input', syncOriginWidth);
    syncOriginWidth();
  }
  if(playerAttackRangeInput){
    playerAttackRangeInput.addEventListener('input', ()=>{
      const range = clamp(playerAttackRangeInput.value,0,1000);
      playerAttackRangeInput.value = String(range);
      player.attackRange = range;
      updateHudStats();
      if(player.attackTarget){
        const dx = player.attackTarget.x - player.x;
        const dy = player.attackTarget.y - player.y;
        if(dx*dx + dy*dy > range*range){
          cancelPlayerAttack();
        }
      }
    });
  }
  if(playerAttackSpeedInput){
    playerAttackSpeedInput.addEventListener('input', ()=>{
      const speed = clamp(playerAttackSpeedInput.value,0,5000);
      playerAttackSpeedInput.value = String(speed);
      player.attackSpeedMs = speed;
      updateHudStats();
      const speedSeconds = speed / 1000;
      if(speed === 0){
        player.attackCooldown = 0;
      } else if(player.attackCooldown > speedSeconds){
        player.attackCooldown = speedSeconds;
      }
    });
  }
  if(playerAttackWindupInput){
    playerAttackWindupInput.addEventListener('input', ()=>{
      const windup = clamp(playerAttackWindupInput.value,0,5000);
      playerAttackWindupInput.value = String(windup);
      player.attackWindupMs = windup;
      updateHudStats();
      const windupSeconds = windup / 1000;
      if(player.attackWindup > windupSeconds){
        player.attackWindup = windupSeconds;
      }
    });
  }
  if(playerAttackDamageInput){
    playerAttackDamageInput.addEventListener('input', ()=>{
      const dmg = clamp(playerAttackDamageInput.value,0,1000);
      playerAttackDamageInput.value = String(dmg);
      player.attackDamage = dmg;
      updateHudStats();
      if(player.attackDamage <= 0){
        cancelPlayerAttack();
      }
    });
  }
  if(playerHitSplatSizeInput){
    playerHitSplatSizeInput.addEventListener('input', ()=>{
      const size = clamp(playerHitSplatSizeInput.value,0,100);
      playerHitSplatSizeInput.value = String(size);
      player.hitSplatSize = size;
    });
  }
  if(playerMoveCircleStartInput){
    const handleMoveCircleStartChange = ()=>{
      const start = clampFloat(playerMoveCircleStartInput.value,0,1000);
      player.moveCircleStart = start;
      playerMoveCircleStartInput.value = String(start);
      if(player.moveCircleEnd < start){
        player.moveCircleEnd = start;
        if(playerMoveCircleEndInput){
          playerMoveCircleEndInput.value = String(start);
        }
      }
    };
    playerMoveCircleStartInput.addEventListener('input', handleMoveCircleStartChange);
    handleMoveCircleStartChange();
  }
  if(playerMoveCircleEndInput){
    const handleMoveCircleEndChange = ()=>{
      const endRaw = clampFloat(playerMoveCircleEndInput.value,0,1000);
      const start = Math.max(0, Number(player.moveCircleStart) || 0);
      const end = Math.max(start, endRaw);
      player.moveCircleEnd = end;
      playerMoveCircleEndInput.value = String(end);
    };
    playerMoveCircleEndInput.addEventListener('input', handleMoveCircleEndChange);
    handleMoveCircleEndChange();
  }
  if(playerMoveCircleColorInput){
    const handleMoveCircleColorChange = ()=>{
      const color = sanitizeHexColor(playerMoveCircleColorInput.value, player.moveCircleColor);
      player.moveCircleColor = color;
      playerMoveCircleColorInput.value = color;
    };
    playerMoveCircleColorInput.addEventListener('input', handleMoveCircleColorChange);
    handleMoveCircleColorChange();
  }
  pointsPerInput.addEventListener('input', ()=>{
    scoreState.pointsPer = clamp(pointsPerInput.value,1,10);
    pointsPerInput.value = String(scoreState.pointsPer);
  });
  winTargetInput.addEventListener('input', ()=>{
    scoreState.winTarget = clamp(winTargetInput.value,1,1000);
    winTargetInput.value = String(scoreState.winTarget);
  });

  // Start/stop
  btnPlay.addEventListener('click', ()=>{
    if(timerState.running){
      stopGame();
    } else {
      playGame();
    }
  });

  const spawnSystem = createSpawnSystem({
    blueSpawns,
    redSpawns,
    pendingSpawns,
    waveState,
    portalState,
    fanSlotOffset,
    laneFanSpacing,
    lanePointAtDistance,
    updateMinionLaneFrame,
    minions,
    minionDiameter,
    minionRadius,
    mapState,
    defaultSpawnPosition,
    clampSettingValue
  });
  const {
    getPath,
    statsForWave,
    enqueueMinionSpawn,
    spawnFromQueue,
    distributeMinions,
    spawnWave,
    blendAngles
  } = spawnSystem;

  const physicsSystem = createPhysicsSystem({
    minions,
    minionDiameter,
    minionRadius,
    mapState,
    player,
    circleCollides,
    moveCircleWithCollision
  });
  const { resolveOverlaps, resolvePlayerMinionSeparation } = physicsSystem;

  function isEnemyMinionForSide(minion, side){
    if(!minion || minion.isPracticeDummy){
      return false;
    }
    if(GameState.multiTeam && GameState.multiTeam.enabled){
      const targetSide = side ?? player.team;
      if(minion.teamId === targetSide){
        return false;
      }
      return !!(minion.hp > 0 && minion.portalizing <= 0);
    }
    if(minion.side !== 'blue' && minion.side !== 'red'){
      return false;
    }
    return !!(minion.hp > 0 && minion.portalizing <= 0 && minion.side !== side);
  }

  function isEnemyMinionForPlayer(minion){
    return isEnemyMinionForSide(minion, player.team);
  }

  function monsterAttackRadius(monster = monsterState){
    if(!monster){
      return 0;
    }
    const size = Math.max(0, Number(monster.size) || 0);
    return size > 0 ? size / 2 : 0;
  }

  function isMonsterAttackable(target){
    if(!target || target !== monsterState){
      return false;
    }
    if(target.active === false){
      return false;
    }
    return Number(target.hp) > 0;
  }

  function isAutoAttackTarget(target){
    return isEnemyMinionForPlayer(target) || isMonsterAttackable(target);
  }

  function playerTargetInRange(target, rangeSq){
    if(!isAutoAttackTarget(target)) return false;
    const dx = target.x - player.x;
    const dy = target.y - player.y;
    return dx*dx + dy*dy <= rangeSq;
  }

  function findEnemyMinionAt(x, y){
    let best = null;
    let bestDistSq = Infinity;
    const hitRadius = Math.max(minionRadius, 16);
    const hitRadiusSq = hitRadius * hitRadius;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= hitRadiusSq && distSq < bestDistSq){
        bestDistSq = distSq;
        best = m;
      }
    }
    return best;
  }

  function findAutoAttackTargetAt(x, y){
    const enemy = findEnemyMinionAt(x, y);
    if(enemy){
      return enemy;
    }
    if(isMonsterAttackable(monsterState)){
      const radius = Math.max(12, monsterAttackRadius());
      const dx = monsterState.x - x;
      const dy = monsterState.y - y;
      if(dx * dx + dy * dy <= radius * radius){
        return monsterState;
      }
    }
    return null;
  }

  function findNearestEnemyMinion(x, y){
    let best = null;
    let bestDistSq = Infinity;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      const distSq = dx * dx + dy * dy;
      if(distSq < bestDistSq){
        best = m;
        bestDistSq = distSq;
      }
    }
    return best;
  }

  function findNearestEnemyMinionWithinRange(x, y, maxRange){
    const maxRangeValue = Number(maxRange);
    if(!(maxRangeValue > 0)) return null;
    const maxRangeSq = maxRangeValue * maxRangeValue;
    let best = null;
    let bestDistSq = Infinity;
    for(const m of minions){
      if(!isEnemyMinionForPlayer(m)) continue;
      const dx = m.x - x;
      const dy = m.y - y;
      const distSq = dx * dx + dy * dy;
      if(distSq <= maxRangeSq && distSq < bestDistSq){
        best = m;
        bestDistSq = distSq;
      }
    }
    return best;
  }

  function commandPlayerAttack(target){
    if(isPlayerRecalling()){
      cancelRecall('attack');
    }
    if(!isAutoAttackTarget(target)) return false;
    cancelShadowPursuitForCaster(player, 'attack');
    player.selectedTarget = target;
    player.attackTarget = null;
    player.attackWindup = 0;
    const range = Math.max(0, player.attackRange);
    const rangeSq = range * range;
    const inRange = range > 0 && playerTargetInRange(target, rangeSq);
    if(inRange){
      player.chaseTarget = null;
      player.target.x = player.x;
      player.target.y = player.y;
      player.navGoal = null;
      player.nav = null;
    } else {
      player.chaseTarget = target;
      player.target.x = target.x;
      player.target.y = target.y;
      player.navGoal = {x: target.x, y: target.y};
      if(hitboxActive()){
        ensureNavForEntity(player, player.navGoal, player.r);
      } else {
        player.nav = null;
      }
    }
    return true;
  }

  function spawnPlayerProjectile(fromX, fromY, target){
    const startX = Number.isFinite(fromX) ? fromX : player.x;
    const startY = Number.isFinite(fromY) ? fromY : player.y;
    if(!target){
      projectiles.push({
        startX,
        startY,
        targetRef: null,
        targetX: startX,
        targetY: startY,
        progress: 0,
        duration: 0.15
      });
      return;
    }
    const destX = target.x;
    const destY = target.y;
    const dx = destX - startX;
    const dy = destY - startY;
    const distance = Math.hypot(dx, dy) || 1;
    const speed = Math.max(120, PLAYER_PROJECTILE_SPEED * Math.max(0, Number(phantomOverdriveProjectileSpeedMultiplier) || 1));
    const duration = Math.max(0.1, distance / speed);
    projectiles.push({
      startX,
      startY,
      targetRef: target,
      targetX: destX,
      targetY: destY,
      progress: 0,
      duration
    });
  }

  function spawnHitSplat(x, y, amount){
    const dmg = Number(amount);
    const size = Math.max(0, Number(player.hitSplatSize) || 0);
    if(!Number.isFinite(dmg) || dmg <= 0 || size <= 0) return;
    hitsplats.push({
      x,
      y,
      amount: Math.round(dmg),
      size,
      age: 0,
      lifetime: 0.9,
      rise: Math.max(16, size * 0.9)
    });
  }

  function separateMinionsAfterAttack(attacker, target, distance){
    if(!attacker || !target || target.portalizing > 0 || target.hp <= 0){
      return;
    }
    const currentDistance = Number.isFinite(distance) ? distance : Math.hypot(target.x - attacker.x, target.y - attacker.y);
    const desiredGap = Math.max(minionDiameter * 0.85, MINION_RANGE);
    const overlap = desiredGap - currentDistance;
    if(!(overlap > 0)){
      return;
    }
    const dx = target.x - attacker.x;
    const dy = target.y - attacker.y;
    const len = Math.hypot(dx, dy) || 1;
    const push = Math.min(overlap * 0.5, minionRadius * 0.75);
    if(!(push > 0)){
      return;
    }
    const ax = -dx / len * push;
    const ay = -dy / len * push;
    const bx = dx / len * push;
    const by = dy / len * push;
    const movedA = moveCircleWithCollision(attacker.x, attacker.y, ax, ay, minionRadius);
    const movedB = moveCircleWithCollision(target.x, target.y, bx, by, minionRadius);
    attacker.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, movedA.x));
    attacker.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, movedA.y));
    target.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, movedB.x));
    target.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, movedB.y));
  }

  function separateMinionFromPlayer(minion, distanceToPlayer, playerRadius){
    if(!minion){
      return;
    }
    const dist = Number.isFinite(distanceToPlayer) ? distanceToPlayer : Math.hypot(player.x - minion.x, player.y - minion.y);
    const desired = Math.max(playerRadius + minionRadius * 0.8, MINION_RANGE);
    const overlap = desired - dist;
    if(!(overlap > 0)){
      return;
    }
    const dx = player.x - minion.x;
    const dy = player.y - minion.y;
    const len = Math.hypot(dx, dy) || 1;
    const push = Math.min(overlap, minionRadius * 0.75);
    if(!(push > 0)){
      return;
    }
    const moved = moveCircleWithCollision(minion.x, minion.y, -dx / len * push, -dy / len * push, minionRadius);
    minion.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, moved.x));
    minion.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, moved.y));
  }

  function applyDamageMitigation(target, amount){
    const dmg = Math.max(0, Number(amount) || 0);
    if(!(dmg > 0) || !target){
      return dmg;
    }
    const timerActive = Number(target.damageReductionTimer) > 0;
    const reduction = Math.max(0, Math.min(0.95, Number(target.damageReductionFraction) || 0));
    if(timerActive && reduction > 0){
      return dmg * (1 - reduction);
    }
    return dmg;
  }

  function absorbDamageWithShields(amount, { attacker = null } = {}){
    let remaining = Math.max(0, Number(amount) || 0);
    let absorbed = 0;
    for(let i = playerShields.length - 1; i >= 0 && remaining > 0; i--){
      const shield = playerShields[i];
      if(!shield){
        playerShields.splice(i, 1);
        continue;
      }
      const duration = Math.max(0, Number(shield.duration) || 0);
      const shieldRemaining = Math.max(0, Number(shield.remaining) || 0);
      if(!(shieldRemaining > 0) || duration <= 0){
        playerShields.splice(i, 1);
        handlePlayerShieldBreak(shield, { cause: duration <= 0 ? 'expired' : 'depleted', source: shield.source || 'ability' });
        continue;
      }
      const taken = Math.min(remaining, shieldRemaining);
      if(taken > 0){
        shield.remaining = Math.max(0, shieldRemaining - taken);
        shield.absorbed = true;
        if(shield.castRef){
          shield.castRef.shieldAbsorbed = true;
        }
        const retaliationDamage = Math.max(0, Number(shield.retaliationDamage) || 0);
        if(retaliationDamage > 0 && attacker){
          const hits = shield.retaliationHits || [];
          if(!hits.includes(attacker)){
            hits.push(attacker);
            shield.retaliationHits = hits;
            applyRetaliationDamage(attacker, retaliationDamage);
          }
        }
        absorbed += taken;
        remaining -= taken;
      }
      if(!(shield.remaining > 0)){
        playerShields.splice(i, 1);
        handlePlayerShieldBreak(shield, { cause: 'depleted', absorbedDamage: taken, source: shield.source || 'ability' });
      }
    }
    return { remainingDamage: remaining, absorbedDamage: absorbed };
  }

  function applyRetaliationDamage(attacker, amount){
    const damage = Math.max(0, Number(amount) || 0);
    if(!(damage > 0) || !attacker){
      return 0;
    }
    const spawnEffect = (target, offset = 0) => {
      if(!target || !Number.isFinite(target.x) || !Number.isFinite(target.y)){
        return;
      }
      spawnHitSplat(target.x, target.y - offset, damage);
    };
    const isMonsterTarget = attacker === monsterState && isMonsterAttackable(attacker);
    if(isMonsterTarget){
      const prevHp = Math.max(0, Number(attacker.hp) || 0);
      attacker.hp = Math.max(0, prevHp - damage);
      spawnEffect(attacker, Math.max(minionRadius, monsterAttackRadius(attacker)));
      updateMonsterHud();
      return damage;
    }
    if(attacker.isPracticeDummy === true){
      const prevHp = Math.max(0, Number(attacker.hp) || 0);
      attacker.hp = Math.max(0, prevHp - damage);
      const offset = clampPracticeDummySize(attacker.size, 120) * 0.5;
      spawnEffect(attacker, offset);
      handlePracticeDummyDamage(attacker, prevHp);
      return damage;
    }
    if(typeof attacker.hp === 'number'){
      const prevHp = Number(attacker.hp) || 0;
      attacker.hp = Math.max(0, prevHp - damage);
      spawnEffect(attacker, minionRadius);
      return damage;
    }
    if(Number.isFinite(attacker.x) && Number.isFinite(attacker.y)){
      spawnHitSplat(attacker.x, attacker.y, damage);
      return damage;
    }
    return 0;
  }

  function damagePlayer(amount, { attacker = null } = {}){
    const rawDamage = Number(amount);
    if(!Number.isFinite(rawDamage) || rawDamage <= 0){
      return;
    }
    if(player.baseInvulnTimer > 0 || Number(player.ghostTimer) > 0){
      return;
    }
    const prevHp = Math.max(0, Number(player.hp) || 0);
    if(prevHp <= 0){
      return;
    }
    const mitigated = applyDamageMitigation(player, rawDamage);
    if(!(mitigated > 0)){
      return;
    }
    const shieldResult = absorbDamageWithShields(mitigated, { attacker });
    const postShield = shieldResult.remainingDamage;
    if(!(postShield > 0)){
      if(shieldResult.absorbedDamage > 0){
        enterPlayerCombat('damage');
      }
      return;
    }
    const nextHp = Math.max(0, prevHp - postShield);
    if(nextHp === prevHp){
      return;
    }
    player.hp = nextHp;
    const offset = Math.max(player.r + 8, 24);
    spawnHitSplat(player.x, player.y - offset, postShield);
    updateHudHealth();
    enterPlayerCombat('damage');
    if(player.attackTarget && typeof player.attackTarget.hp === 'number' && player.attackTarget.hp <= 0){
      cancelPlayerAttack(false);
    }
    if(player.hp <= 0){
      player.tauntTimer = 0;
      player.damageReductionTimer = 0;
      player.damageReductionFraction = 0;
      setPlayerAnimationState('death');
    }
  }

  function updatePlayerShields(dt){
    for(let i = playerShields.length - 1; i >= 0; i--){
      const shield = playerShields[i];
      if(!shield){
        playerShields.splice(i, 1);
        continue;
      }
      const duration = Math.max(0, Number(shield.duration) || 0);
      const nextDuration = Math.max(0, duration - dt);
      shield.duration = nextDuration;
      if(nextDuration <= 0 || !(Number(shield.remaining) > 0)){
        playerShields.splice(i, 1);
        handlePlayerShieldBreak(shield, { cause: nextDuration <= 0 ? 'expired' : 'depleted', source: shield.source || 'ability' });
      }
    }
  }

  function applyPlayerAttackDamageToTarget(target, damage){
    if(!target || !(damage > 0)){
      return 0;
    }
    const bonus = consumeShadowTalonMarkDamage(target);
    const totalDamage = damage + bonus;
    if(!(totalDamage > 0)){
      return 0;
    }
    const monsterTarget = target === monsterState;
    const prevHp = Math.max(0, Number(target.hp) || 0);
    if(prevHp <= 0){
      return 0;
    }
    const nextHp = Math.max(0, prevHp - totalDamage);
    target.hp = nextHp;
    const offset = monsterTarget ? Math.max(24, monsterAttackRadius()) : minionRadius;
    spawnHitSplat(target.x, target.y - offset, totalDamage);
    handlePracticeDummyDamage(target, prevHp);
    if(prevHp > 0 && nextHp <= 0 && !monsterTarget && !target.isPracticeDummy){
      addGold(goldState.perKill);
    }
    if(monsterTarget){
      updateMonsterHud();
    }
    if(!isEnemyMinionForPlayer(target) && target !== monsterState){
      playerDrewTurretAggro(target);
    }
    return prevHp - nextHp;
  }

  function applyPlayerAttackDamage(target){
    if(!target) return;
    enterPlayerCombat('attack');
    const damage = Math.max(0, Number(player.attackDamage) || 0);
    flash(target.x, target.y);
    spawnPlayerProjectile(player.x, player.y, target);
    applyPlayerAttackDamageToTarget(target, damage);
    const currentHp = Math.max(0, Number(target.hp) || 0);
    tryDetonateEdgeFluxMark(target, { prevHp: currentHp, cause: 'attack' });
    handlePhantomOverdriveAttackHit();
    handleRoyalOnslaughtAttackHit(target);
    handleSpinningAxeAttackHit(target);
  }

  function handlePhantomOverdriveAttackHit(){
    const buff = activePhantomOverdriveAttackBuffForCaster(player);
    if(!buff) return;
    const reduction = Math.max(0, Number(buff.cooldownReductionSeconds) || 0);
    if(!(reduction > 0)) return;
    const slotIndex = Number.isFinite(buff.slotIndex) ? buff.slotIndex : null;
    if(slotIndex === null) return;
    const state = getAbilitySlotState(slotIndex);
    if(!state) return;
    const remaining = Math.max(0, Number(state.cooldown) || 0);
    if(!(remaining > 0)) return;
    setAbilitySlotCooldown(slotIndex, Math.max(0, remaining - reduction));
  }

  function handleRoyalOnslaughtAttackHit(target){
    if(!target) return;
    const buff = activeRoyalOnslaughtBuffForCaster(player);
    if(!buff) return;
    const attackDamage = Math.max(0, Number(player.attackDamage) || 0);
    const primaryPct = Math.max(0, Number(buff.bonusDamagePct) || 0) / 100;
    const splashPct = Math.max(0, Number(buff.splashDamagePct) || 0) / 100;
    const splashRadius = Math.max(0, Number(buff.splashRadius) || 0);
    const duration = Math.max(0, Number(buff.duration) || 0);
    const primaryDamage = Math.round(attackDamage * primaryPct);
    if(primaryDamage > 0){
      applyPlayerAttackDamageToTarget(target, primaryDamage);
    }
    const splashDamage = Math.round(attackDamage * splashPct);
    if(splashDamage > 0 && splashRadius > 0){
      const splashSq = splashRadius * splashRadius;
      for(const m of minions){
        if(!m || m === target) continue;
        if(!isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const dx = m.x - target.x;
        const dy = m.y - target.y;
        if(dx * dx + dy * dy > splashSq) continue;
        applyPlayerAttackDamageToTarget(m, splashDamage);
      }
      if(isMonsterAttackable(monsterState) && monsterState !== target){
        const dx = monsterState.x - target.x;
        const dy = monsterState.y - target.y;
        if(dx * dx + dy * dy <= splashSq){
          applyPlayerAttackDamageToTarget(monsterState, splashDamage);
        }
      }
    }
    const remainingCharges = Math.max(0, (Number(buff.chargesRemaining) || 0) - 1);
    buff.chargesRemaining = remainingCharges;
    if(remainingCharges <= 0){
      buff.remaining = 0;
    } else {
      buff.remaining = duration;
    }
    player.attackCooldown = 0;
    player.attackWindup = 0;
    const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
    setPlayerAttackCooldownFromPeriod(attackPeriod);
  }

  function consumeSpinningAxeInHand(){
    if(!spinningAxesInHand.length) return null;
    return spinningAxesInHand.shift();
  }

  function addSpinningAxeInHand(config, { silent = false } = {}){
    if(!config) return false;
    const maxHeld = Math.max(1, Number(config.maxInHand) || 1);
    if(spinningAxesInHand.length >= maxHeld){
      return false;
    }
    const axe = {
      abilityId: config.abilityId,
      abilityName: config.abilityName || 'Spinning Axe',
      bonusDamage: Math.max(0, Number(config.bonusDamage) || 0),
      maxInHand: maxHeld,
      flightTime: Math.max(0, Number(config.flightTime) || 0),
      catchWindow: Math.max(0, Number(config.catchWindow) || 0),
      catchRadius: Math.max(0, Number(config.catchRadius) || 0),
      moveSpeedThreshold: Math.max(0, Number(config.moveSpeedThreshold) || 0),
      forwardMin: Math.max(0, Number(config.forwardMin) || 0),
      forwardMax: Math.max(0, Number(config.forwardMax) || 0),
      stillMin: Math.max(0, Number(config.stillMin) || 0),
      stillMax: Math.max(0, Number(config.stillMax) || 0),
      sideJitterMax: Math.max(0, Number(config.sideJitterMax) || 0),
      edgeMargin: Math.max(0, Number(config.edgeMargin) || 0),
      slotIndex: Number.isFinite(config.slotIndex) ? config.slotIndex : null,
      state: 'IN_HAND'
    };
    spinningAxesInHand.push(axe);
    if(!silent){
      setHudMessage(`${axe.abilityName || 'Spinning Axe'} caught! (${spinningAxesInHand.length}/${axe.maxInHand})`);
    }
    return true;
  }

  function handleSpinningAxeAttackHit(target){
    const axe = consumeSpinningAxeInHand();
    if(!axe) return;
    if(target && axe.bonusDamage > 0){
      applyPlayerAttackDamageToTarget(target, axe.bonusDamage);
    }
    const flight = {
      ...axe,
      state: 'IN_AIR',
      originX: player.x,
      originY: player.y,
      velocityX: lastPlayerVelocityX,
      velocityY: lastPlayerVelocityY,
      remaining: axe.flightTime
    };
    spinningAxeFlights.push(flight);
  }

  function playerDrewTurretAggro(target){
    if(!target || target === player){
      return;
    }
    const defenderSide = target.side === 'blue' || target.side === 'red' ? target.side : null;
    if(!defenderSide || defenderSide === player.team){
      return;
    }
    const focusSeconds = clampTurretFocus(turretState.playerFocusSeconds);
    if(!(focusSeconds > 0)){
      return;
    }
    const turretList = ensureTurrets();
    if(!turretList.length){
      return;
    }
    const playerRadius = Math.max(6, getPlayerHurtRadius());
    for(const turret of turretList){
      if(!turret || turret.side !== defenderSide){
        continue;
      }
      const range = Math.max(0, Number(turret.range) || 0);
      const effective = range + playerRadius;
      const dx = player.x - turret.x;
      const dy = player.y - turret.y;
      if(dx * dx + dy * dy <= effective * effective){
        turret.focusPlayerTimer = Math.max(turret.focusPlayerTimer || 0, focusSeconds);
        turret.target = player;
      }
    }
  }

  function isEnemyPlayerForTurret(turret){
    return !!(turret && player && player.team !== turret.side && Number(player.hp) > 0);
  }

  function turretTargetInRange(turret, target){
    if(!turret || !target){
      return false;
    }
    const range = Math.max(0, Number(turret.range) || 0);
    const padding = target === player ? Math.max(6, getPlayerHurtRadius()) : minionRadius;
    const dx = target.x - turret.x;
    const dy = target.y - turret.y;
    const effective = range + padding;
    return dx * dx + dy * dy <= effective * effective;
  }

  function fireTurret(turret, target){
    if(!turret || !target){
      return;
    }
    const damage = Math.max(0, Number(turret.damage) || 0);
    const offset = target === player ? Math.max(6, Number(player.r) || 0) : minionRadius;
    turretShots.push({
      fromX: turret.x,
      fromY: turret.y,
      toX: target.x,
      toY: target.y,
      side: turret.side,
      teamColor: turret.teamColor,
      age: 0,
      duration: 0.2
    });
    if(damage <= 0){
      return;
    }
    if(target === player){
      damagePlayer(damage, { attacker: turret });
      return;
    }
    const prevHp = Number(target.hp) || 0;
    const applied = applyDamageMitigation(target, damage);
    if(applied > 0){
      target.hp = Math.max(0, prevHp - applied);
      spawnHitSplat(target.x, target.y - offset, applied);
      handlePracticeDummyDamage(target, prevHp);
    }
  }

  function updateTurretShots(dt){
    for(let i = turretShots.length - 1; i >= 0; i--){
      const shot = turretShots[i];
      shot.age = (Number(shot.age) || 0) + dt;
      const duration = Math.max(0.05, Number(shot.duration) || 0.2);
      if(shot.age >= duration){
        turretShots.splice(i, 1);
      }
    }
  }

  function updateTurrets(dt){
    const turretList = ensureTurrets();
    if(!turretList.length){
      updateTurretShots(dt);
      return;
    }
    const focusDefault = clampTurretFocus(turretState.playerFocusSeconds);
    const playerRadius = Math.max(6, getPlayerHurtRadius());
    for(const turret of turretList){
      if(!turret){
        continue;
      }
      turret.cooldown = Math.max(0, (Number(turret.cooldown) || 0) - dt);
      turret.focusPlayerTimer = Math.max(0, (Number(turret.focusPlayerTimer) || 0) - dt);
      const range = Math.max(0, Number(turret.range) || 0);
      const effectiveMinionRange = range + minionRadius;
      const effectiveMinionSq = effectiveMinionRange * effectiveMinionRange;
      let bestMinion = null;
      let bestMinionDistSq = Infinity;
      for(const m of minions){
        if(!isEnemyMinionForSide(m, turret.side)) continue;
        const dx = m.x - turret.x;
        const dy = m.y - turret.y;
        const distSq = dx * dx + dy * dy;
        if(distSq <= effectiveMinionSq && distSq < bestMinionDistSq){
          bestMinion = m;
          bestMinionDistSq = distSq;
        }
      }
      const playerInRange = isEnemyPlayerForTurret(turret) && turretTargetInRange(turret, player);
      let currentTarget = turret.target;
      if(currentTarget){
        const alive = currentTarget === player ? Number(player.hp) > 0
          : (!!currentTarget.hp && !currentTarget.isPracticeDummy && currentTarget.portalizing <= 0);
        if(!alive || !turretTargetInRange(turret, currentTarget)){
          currentTarget = null;
        }
      }
      if(!currentTarget){
        if(turret.focusPlayerTimer > 0 && playerInRange){
          currentTarget = player;
        } else if(bestMinion){
          currentTarget = bestMinion;
        } else if(playerInRange){
          currentTarget = player;
        }
      } else if(currentTarget === player && bestMinion && turret.focusPlayerTimer <= 0){
        currentTarget = bestMinion;
      } else if(currentTarget !== player && playerInRange && turret.focusPlayerTimer > 0){
        currentTarget = player;
      }
      if(currentTarget === player){
        turret.focusPlayerTimer = Math.max(turret.focusPlayerTimer, focusDefault);
      }
      turret.target = currentTarget;
      if(currentTarget && turret.cooldown <= 0){
        fireTurret(turret, currentTarget);
        const interval = clampTurretInterval(turret.attackInterval);
        turret.cooldown = interval;
      }
    }
    updateTurretShots(dt);
  }

  function activeQuiverstormBuffForCaster(caster){
    if(!caster){
      return null;
    }
    for(const buff of quiverstormBuffs){
      if(!buff || Number(buff.remaining) <= 0){
        continue;
      }
      if(buff.casterRef === caster){
        return buff;
      }
    }
    return null;
  }

  function activeFrenziedSurgeAttackBuffForCaster(caster){
    if(!caster){
      return null;
    }
    for(const buff of frenziedSurgeAttackBuffs){
      if(!buff || Number(buff.remaining) <= 0){
        continue;
      }
      if(buff.casterRef === caster){
        return buff;
      }
    }
    return null;
  }

  function activeRoyalOnslaughtBuffForCaster(caster){
    if(!caster){
      return null;
    }
    for(const buff of royalOnslaughtBuffs){
      if(!buff || Number(buff.remaining) <= 0){
        continue;
      }
      if(Number(buff.chargesRemaining) <= 0){
        continue;
      }
      if(buff.casterRef === caster){
        return buff;
      }
    }
    return null;
  }

  function activePhantomOverdriveAttackBuffForCaster(caster){
    if(!caster){
      return null;
    }
    for(const buff of phantomOverdriveAttackBuffs){
      if(!buff || Number(buff.remaining) <= 0){
        continue;
      }
      if(buff.casterRef === caster){
        return buff;
      }
    }
    return null;
  }

  function activeStrideSurgeAttackBuffForCaster(caster){
    if(!caster){
      return null;
    }
    for(const buff of strideSurgeAttackBuffs){
      if(!buff || Number(buff.remaining) <= 0){
        continue;
      }
      if(buff.casterRef === caster){
        return buff;
      }
    }
    return null;
  }

  function bestPhantomOverdriveWindupReductionForCaster(caster){
    const buff = activePhantomOverdriveAttackBuffForCaster(caster);
    if(!buff){
      return 0;
    }
    return Math.max(0, Number(buff.windupReductionPct) || 0);
  }

  function bestActiveAttackSpeedBonusForCaster(caster){
    if(!caster){
      return 0;
    }
    let best = 0;
    const quiver = activeQuiverstormBuffForCaster(caster);
    if(quiver){
      best = Math.max(best, Math.max(0, Number(quiver.attackSpeedPct) || 0));
    }
    const surge = activeFrenziedSurgeAttackBuffForCaster(caster);
    if(surge){
      best = Math.max(best, Math.max(0, Number(surge.attackSpeedPct) || 0));
    }
    const royal = activeRoyalOnslaughtBuffForCaster(caster);
    if(royal){
      best = Math.max(best, Math.max(0, Number(royal.attackSpeedPct) || 0));
    }
    const stride = activeStrideSurgeAttackBuffForCaster(caster);
    if(stride){
      best = Math.max(best, Math.max(0, Number(stride.attackSpeedPct) || 0));
    }
    const phantom = activePhantomOverdriveAttackBuffForCaster(caster);
    if(phantom){
      best = Math.max(best, Math.max(0, Number(phantom.attackSpeedPct) || 0));
    }
    return best;
  }

  function setPlayerAttackCooldownFromPeriod(period){
    const basePeriod = Math.max(0, Number(period) || 0);
    if(basePeriod <= 0){
      player.attackCooldown = 0;
      return;
    }
    let totalMultiplier = 1;
    const bonusPct = bestActiveAttackSpeedBonusForCaster(player);
    if(bonusPct > 0){
      totalMultiplier *= 1 + bonusPct / 100;
    }
    if(totalMultiplier > 0){
      player.attackCooldown = basePeriod / totalMultiplier;
    } else {
      player.attackCooldown = basePeriod;
    }
  }

  function applyQuiverstormFlurryDamage(target){
    const buff = activeQuiverstormBuffForCaster(player);
    if(!buff || !target){
      return;
    }
    const arrowCount = Math.max(0, Math.floor(Number(buff.arrowCount) || 0));
    const arrowDamage = Math.max(0, Number(buff.arrowDamage) || 0);
    const lifeStealPct = Math.max(0, Number(buff.lifeStealPct) || 0) / 100;
    if(arrowCount <= 0 || arrowDamage <= 0){
      return;
    }
    enterPlayerCombat('attack');
    const monsterTarget = target === monsterState;
    let totalDamage = 0;
    for(let i = 0; i < arrowCount; i++){
      if(!target || target.hp <= 0){
        break;
      }
      const prevHp = Math.max(0, Number(target.hp) || 0);
      if(prevHp <= 0){
        break;
      }
      const nextHp = Math.max(0, prevHp - arrowDamage);
      const actualDamage = prevHp - nextHp;
      if(actualDamage <= 0){
        break;
      }
      target.hp = nextHp;
      totalDamage += actualDamage;
      const offset = monsterTarget ? Math.max(24, monsterAttackRadius()) : minionRadius;
      spawnHitSplat(target.x, target.y - offset, actualDamage);
      handlePracticeDummyDamage(target, prevHp);
      if(prevHp > 0 && nextHp <= 0 && !monsterTarget && !target.isPracticeDummy){
        addGold(goldState.perKill);
      }
      if(monsterTarget){
        updateMonsterHud();
      }
      if(!isEnemyMinionForPlayer(target) && target !== monsterState){
        playerDrewTurretAggro(target);
      }
    }
    if(totalDamage > 0 && lifeStealPct > 0){
      const healAmount = totalDamage * lifeStealPct;
      if(healAmount > 0){
        const currentHp = Math.max(0, Number(player.hp) || 0);
        player.hp = Math.min(Math.max(0, Number(player.maxHp) || 0), currentHp + healAmount);
      }
    }
  }

  function updatePlayerAutoAttack(dt){
    const attackPeriod = Math.max(0, Number(player.attackSpeedMs) || 0) / 1000;
    const updateAttackReady = () => {
      const cooldown = Math.max(0, Number(player.attackCooldown) || 0);
      const enabled = player.attackDamage > 0;
      let progress = 0;
      if(enabled){
        if(attackPeriod > 0){
          const pct = attackPeriod > 0 ? 1 - Math.min(1, cooldown / attackPeriod) : 1;
          progress = Math.max(0, Math.min(1, pct));
        } else {
          progress = player.attackWindup > 0 ? 0 : 1;
        }
      }
      const ready = enabled && player.attackWindup <= 0 && cooldown <= 0;
      setPlayerAttackReadyState(progress, ready, enabled);
    };

    if(player.casting){
      updateAttackReady();
      return;
    }
    if(player.attackDamage <= 0){
      cancelPlayerAttack();
      player.attackCooldown = 0;
      updateAttackReady();
      return;
    }

    const range = Math.max(0, player.attackRange);
    const baseWindupSeconds = Math.max(0, Number(player.attackWindupMs) || 0) / 1000;
    const windupReductionPct = bestPhantomOverdriveWindupReductionForCaster(player);
    const windupMultiplier = Math.max(0, 1 - windupReductionPct / 100);
    const windupSeconds = baseWindupSeconds * windupMultiplier;
    const lashTether = activeLinkLashFollowup();
    const bonusRange = lashTether ? Math.max(0, Number(lashTether.followupRangeBonus) || 0) : 0;
    const effectiveRange = Math.max(0, range + bonusRange);
    const rangeSq = effectiveRange * effectiveRange;
    const lashFollowupBase = lashTether ? Math.max(0, Number(lashTether.followupWindup) || baseWindupSeconds) : baseWindupSeconds;
    const followupWindup = lashTether ? lashFollowupBase * windupMultiplier : windupSeconds;

    if(player.attackCooldown > 0){
      player.attackCooldown = Math.max(0, player.attackCooldown - dt);
    }
    updateAttackReady();

    const selection = player.selectedTarget;
    if(!selection){
      if(player.attackWindup > 0 || player.attackTarget){
        cancelPlayerAttack();
        updateAttackReady();
      }
      return;
    }

    if(!isAutoAttackTarget(selection)){
      cancelPlayerAttack();
      updateAttackReady();
      return;
    }

    if(effectiveRange <= 0){
      cancelPlayerAttack();
      updateAttackReady();
      return;
    }

    const selectionInRange = playerTargetInRange(selection, rangeSq);
    if(selectionInRange){
      if(player.chaseTarget){
        player.chaseTarget = null;
        player.target.x = player.x;
        player.target.y = player.y;
        player.navGoal = null;
        player.nav = null;
      }
    } else {
      player.chaseTarget = selection;
      player.target.x = selection.x;
      player.target.y = selection.y;
      player.navGoal = {x: selection.x, y: selection.y};
      if(hitboxActive()){
        ensureNavForEntity(player, player.navGoal, player.r);
      } else {
        player.nav = null;
      }
    }

    if(player.attackWindup > 0){
      if(!player.attackTarget || !isAutoAttackTarget(player.attackTarget)){
        cancelPlayerAttack();
        updateAttackReady();
        return;
      }
      const override = player.attackOverride;
      let targetRangeSq = rangeSq;
      if(override && override.type === 'linkLash'){
        const tetherBonus = Math.max(0, Number(override.tetherRef && override.tetherRef.followupRangeBonus) || bonusRange);
        const overrideRange = Math.max(0, range + tetherBonus);
        targetRangeSq = overrideRange * overrideRange;
      }
      if(!playerTargetInRange(player.attackTarget, targetRangeSq)){
        cancelPlayerAttack(false);
        updateAttackReady();
        return;
      }
      updatePlayerFacingTowards(player.attackTarget);
      player.attackWindup = Math.max(0, player.attackWindup - dt);
      updateAttackReady();
      if(player.attackWindup <= 0){
        const pendingOverride = player.attackOverride;
        player.attackOverride = null;
        let handled = false;
        if(pendingOverride && pendingOverride.type === 'linkLash'){
          const tether = pendingOverride.tetherRef;
          if(resolveLinkLashFollowup(tether, player.attackTarget)){
            player.attackCooldown = 0;
            handled = true;
          }
        }
        if(!handled && player.attackTarget){
          applyPlayerAttackDamage(player.attackTarget);
          applyQuiverstormFlurryDamage(player.attackTarget);
          setPlayerAttackCooldownFromPeriod(attackPeriod);
        }
        player.attackTarget = null;
        updateAttackReady();
      }
      return;
    }

    if(player.attackCooldown > 0){
      updateAttackReady();
      return;
    }

    if(!selectionInRange){
      return;
    }

    if(followupWindup > 0){
      player.attackTarget = selection;
      player.attackWindup = followupWindup;
      player.attackOverride = lashTether ? { type: 'linkLash', tetherRef: lashTether } : null;
      updateAttackReady();
      updatePlayerFacingTowards(selection);
      setPlayerAnimationState('autoAttack', { facingRadians: GameState.player.facingRadians });
    } else {
      let usedOverride = false;
      if(lashTether && resolveLinkLashFollowup(lashTether, selection)){
        player.attackCooldown = 0;
        usedOverride = true;
      }
      if(!usedOverride){
        applyPlayerAttackDamage(selection);
        applyQuiverstormFlurryDamage(selection);
        setPlayerAttackCooldownFromPeriod(attackPeriod);
      }
      player.attackOverride = null;
      updateAttackReady();
      updatePlayerFacingTowards(selection);
      setPlayerAnimationState('autoAttack', { facingRadians: GameState.player.facingRadians });
    }
  }

  function updateGaleThrustStacks(dt){
    const timer = Math.max(0, Number(abilityRuntime.galeThrustStackTimer) || 0);
    if(timer <= 0){
      return;
    }
    const next = Math.max(0, timer - dt);
    abilityRuntime.galeThrustStackTimer = next;
    if(next <= 0){
      abilityRuntime.galeThrustStacks = 0;
    }
  }

  function updateGaleThrustCasts(dt){
    for(let i = galeThrustCasts.length - 1; i >= 0; i--){
      const cast = galeThrustCasts[i];
      if(!cast){
        galeThrustCasts.splice(i, 1);
        continue;
      }
      cast.elapsed = (Number(cast.elapsed) || 0) + dt;
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      if(cast.elapsed < duration){
        continue;
      }
      galeThrustCasts.splice(i, 1);
      launchGaleThrustCast(cast);
    }
  }

  function updateLaserProjectiles(dt){
    for(let i = laserProjectiles.length - 1; i >= 0; i--){
      const laser = laserProjectiles[i];
      const prevTraveled = Number(laser.traveled) || 0;
      const speed = Math.max(0, Number(laser.speed) || 0);
      const maxDistance = Math.max(0, Number(laser.maxDistance) || 0);
      let nextTraveled = prevTraveled + speed * dt;
      if(speed <= 0){
        nextTraveled = maxDistance;
      }
      const clampedNext = maxDistance > 0 ? Math.min(nextTraveled, maxDistance) : nextTraveled;
      const pathVisionSpacing = Math.max(0, Number(laser.pathVisionSpacing) || 0);
      const pathVisionRadius = Math.max(0, Number(laser.pathVisionRadius) || 0);
      const pathVisionDuration = Math.max(0, Number(laser.pathVisionDuration) || 0);
      if(pathVisionSpacing > 0 && pathVisionRadius > 0 && pathVisionDuration > 0){
        let nextVisionDistance = Number.isFinite(laser.nextVisionDistance) ? Number(laser.nextVisionDistance) : 0;
        while(nextVisionDistance <= clampedNext){
          const vx = laser.startX + laser.dirX * nextVisionDistance;
          const vy = laser.startY + laser.dirY * nextVisionDistance;
          spawnScoutflareVisionSource(vx, vy, pathVisionRadius, pathVisionDuration);
          nextVisionDistance += pathVisionSpacing;
        }
        laser.nextVisionDistance = nextVisionDistance;
      }
      const effectiveHalfWidth = Math.max(0, (Number(laser.width) || 0) / 2);
      const effectiveRadius = effectiveHalfWidth + minionRadius;
      const effectiveRadiusSq = effectiveRadius * effectiveRadius;
      let hitTarget = null;
      let hitAlong = Infinity;
      for(const m of minions){
        if(!isEnemyMinionForPlayer(m)) continue;
        const relX = m.x - laser.startX;
        const relY = m.y - laser.startY;
        const along = relX * laser.dirX + relY * laser.dirY;
        if(along < prevTraveled || along > clampedNext) continue;
        const closestX = laser.startX + laser.dirX * along;
        const closestY = laser.startY + laser.dirY * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        const distSq = offX * offX + offY * offY;
        if(distSq <= effectiveRadiusSq && along < hitAlong){
          hitAlong = along;
          hitTarget = m;
        }
      }
      if(laser.hitMonsters && isMonsterAttackable(monsterState)){
        const relX = monsterState.x - laser.startX;
        const relY = monsterState.y - laser.startY;
        const along = relX * laser.dirX + relY * laser.dirY;
        if(along >= prevTraveled && along <= clampedNext){
          const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
          if(!(maxDistance > 0 && (along < -monsterRadius || along > maxDistance + monsterRadius))){
            const closestX = laser.startX + laser.dirX * along;
            const closestY = laser.startY + laser.dirY * along;
            const offX = monsterState.x - closestX;
            const offY = monsterState.y - closestY;
            const monsterEffectiveRadius = effectiveHalfWidth + monsterRadius;
            if(offX * offX + offY * offY <= monsterEffectiveRadius * monsterEffectiveRadius && along < hitAlong){
              hitAlong = along;
              hitTarget = monsterState;
            }
          }
        }
      }
      if(hitTarget){
        const hitPointX = laser.startX + laser.dirX * hitAlong;
        const hitPointY = laser.startY + laser.dirY * hitAlong;
        const impactOffX = hitTarget.x - hitPointX;
        const impactOffY = hitTarget.y - hitPointY;
        const prevHp = Number(hitTarget.hp) || 0;
        const baseDamage = Number(laser.damage) || 0;
        const chillDuration = Math.max(0, Number(laser.chillDuration) || 0);
        const chillDamageMultiplier = Math.max(1, Number(laser.chillDamageMultiplier) || 1);
        const targetChilled = Number(hitTarget.chillTimer) > 0;
        const hitDamage = targetChilled && chillDamageMultiplier > 1
          ? baseDamage * chillDamageMultiplier
          : baseDamage;
        const refundSeconds = Math.max(0, Number(laser.cooldownRefundSeconds) || 0);
        const targetRadius = hitTarget === monsterState ? Math.max(24, monsterAttackRadius()) : minionRadius;
        if(hitDamage > 0){
          hitTarget.hp = Math.max(0, prevHp - hitDamage);
          spawnHitSplat(hitTarget.x, hitTarget.y - targetRadius, hitDamage);
          if(hitTarget === monsterState){
            updateMonsterHud();
          }
        }
        const killed = prevHp > 0 && hitTarget.hp <= 0;
        const goldAmount = Math.max(0, Math.round(Number(laser.goldOnKill) || 0));
        if(killed && goldAmount > 0){
          addGold(goldAmount);
          setHudMessage(`${laser.abilityName || 'Plunder Shot'} plundered ${goldAmount} gold!`);
        }
        const slowFraction = Number(laser.slowFraction) || 0;
        const slowMin = Number(laser.slowMinDistance);
        const slowApplies = slowFraction > 0 && (!Number.isFinite(slowMin) || slowMin <= 0 || hitAlong >= slowMin);
        if(slowApplies){
          const existing = typeof hitTarget.slowPct === 'number' ? hitTarget.slowPct : 0;
          hitTarget.slowPct = Math.max(existing, slowFraction);
          const slowDuration = Number(laser.slowDuration) || 0;
          if(slowDuration > 0){
            hitTarget.slowTimer = Math.max(hitTarget.slowTimer || 0, slowDuration);
          }
        }
        const stunDuration = Math.max(0, Number(laser.stunDuration) || 0);
        if(stunDuration > 0){
          hitTarget.stunTimer = Math.max(hitTarget.stunTimer || 0, stunDuration);
        }
        const knockupDuration = Math.max(0, Number(laser.knockupDuration) || 0);
        if(knockupDuration > 0){
          hitTarget.knockupTimer = Math.max(hitTarget.knockupTimer || 0, knockupDuration);
        }
        if(chillDuration > 0){
          hitTarget.chillTimer = Math.max(Number(hitTarget.chillTimer) || 0, chillDuration);
        }
        if(hitTarget.isPracticeDummy){
          handlePracticeDummyDamage(hitTarget, prevHp);
        }
        const knockbackDistance = Math.max(0, Number(laser.knockbackDistance) || 0);
        if(knockbackDistance > 0){
          const perpX = -laser.dirY;
          const perpY = laser.dirX;
          const dot = impactOffX * perpX + impactOffY * perpY;
          let pushX = perpX;
          let pushY = perpY;
          if(dot < 0){
            pushX = -perpX;
            pushY = -perpY;
          }
          const moved = moveCircleWithCollision(hitTarget.x, hitTarget.y, pushX * knockbackDistance, pushY * knockbackDistance, minionRadius);
          hitTarget.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, moved.x));
          hitTarget.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, moved.y));
        }
        if(hitDamage > 0 && refundSeconds > 0){
          reduceAllAbilityCooldowns(refundSeconds);
        }
        flash(hitPointX, hitPointY, { startRadius: 10, endRadius: 34, color: '#b9f0ff' });
        let statusText = typeof laser.hitStatusText === 'string' && laser.hitStatusText.trim() ? laser.hitStatusText.trim() : '';
        if(targetChilled && chillDamageMultiplier > 1){
          const multText = chillDamageMultiplier % 1 === 0 ? chillDamageMultiplier : Number(chillDamageMultiplier.toFixed(1));
          statusText = `${statusText ? `${statusText} ` : ''}(chilled bonus x${multText})`;
        } else if(chillDuration > 0 && !statusText){
          statusText = '(chilled)';
        }
        const appliedPlasma = applyPlasmaStacks(hitTarget, Number(laser.plasmaStacks) || 0, Number(laser.plasmaDuration) || 0);
        let revealApplied = false;
        const revealRadius = Math.max(0, Number(laser.revealRadius) || 0);
        const revealDuration = Math.max(0, Number(laser.revealDuration) || 0);
        if(revealRadius > 0 && revealDuration > 0){
          const record = registerScoutflareChampionReveal(hitTarget, revealRadius, revealDuration);
          revealApplied = !!record;
        }
        const extraStatusParts = [];
        if(appliedPlasma > 0){
          extraStatusParts.push(`${appliedPlasma} Plasma`);
        }
        if(revealApplied){
          extraStatusParts.push('true sight');
        }
        if(extraStatusParts.length){
          const extraText = `(${extraStatusParts.join(', ')})`;
          statusText = statusText ? `${statusText} ${extraText}` : extraText;
        }
        if(hitDamage > 0){
          setHudMessage(`${laser.abilityName || 'Laser'} hit for ${Math.round(hitDamage)} damage!${statusText ? ` ${statusText}` : ''}`);
        } else {
          setHudMessage(`${laser.abilityName || 'Laser'} hit!${statusText ? ` ${statusText}` : ''}`);
        }
        const stackDuration = Math.max(0, Number(laser.galeThrustStackDuration) || 0);
        if(stackDuration > 0 && laser.casterRef === player){
          grantGaleThrustStack(stackDuration);
        }
        if(laser.abilityId === 'shadow_talon' && !laser.shadowRecastPending){
          applyShadowTalonMark(hitTarget, laser);
          scheduleShadowTalonRecasts(laser, laser.casterRef || player, hitTarget);
          laser.shadowRecastPending = true;
        }
        laserProjectiles.splice(i, 1);
        continue;
      }
      laser.traveled = clampedNext;
      laser.currentX = laser.startX + laser.dirX * clampedNext;
      laser.currentY = laser.startY + laser.dirY * clampedNext;
      if(maxDistance > 0 && clampedNext >= maxDistance - 0.001){
        laserProjectiles.splice(i, 1);
      }
    }
  }

  function updateDuskwaveVolleys(dt){
    for(let i = duskwaveVolleys.length - 1; i >= 0; i--){
      const volley = duskwaveVolleys[i];
      if(!volley){
        duskwaveVolleys.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(volley.speed) || 0);
      if(!(speed > 0)){
        duskwaveVolleys.splice(i, 1);
        continue;
      }

      volley.prevX = Number.isFinite(volley.prevX) ? volley.prevX : volley.x;
      volley.prevY = Number.isFinite(volley.prevY) ? volley.prevY : volley.y;
      let travel = speed * dt;

      if(volley.targetRef && volley.targetRef.hp > 0 && !volley.primaryHitDone){
        const dx = volley.targetRef.x - volley.x;
        const dy = volley.targetRef.y - volley.y;
        const dist = Math.hypot(dx, dy);
        if(dist > 0.0001){
          volley.dirX = dx / dist;
          volley.dirY = dy / dist;
        }
        const move = Math.min(dist, travel);
        volley.x += volley.dirX * move;
        volley.y += volley.dirY * move;
        travel -= move;
        if(dist <= Math.max(minionRadius, volley.width * 0.5) || move >= dist - 0.0001){
          applyDuskwaveVolleyDamage(volley, volley.targetRef, volley.primaryDamage, true);
          volley.primaryHitDone = true;
          volley.targetRef = null;
        }
      }

      if(travel > 0){
        volley.x += volley.dirX * travel;
        volley.y += volley.dirY * travel;
      }

      volley.traveled = Math.max(volley.traveled || 0, (volley.traveled || 0) + speed * dt);
      const outerRange = Math.max(volley.range || 0, Math.hypot(mapState.width, mapState.height));
      if(volley.traveled >= outerRange || volley.x < -128 || volley.y < -128 || volley.x > mapState.width + 128 || volley.y > mapState.height + 128){
        duskwaveVolleys.splice(i, 1);
        continue;
      }

      const segX = volley.x - volley.prevX;
      const segY = volley.y - volley.prevY;
      const segLenSq = segX * segX + segY * segY;
      if(segLenSq <= 0) continue;
      const effectiveRadius = Math.max(minionRadius, (volley.width || 0) * 0.5);
      const effectiveSq = effectiveRadius * effectiveRadius;

      for(const m of minions){
        if(!m || !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        if(volley.hitTargets.has(m)) continue;
        const toMinX = m.x - volley.prevX;
        const toMinY = m.y - volley.prevY;
        const proj = Math.max(0, Math.min(1, (toMinX * segX + toMinY * segY) / segLenSq));
        const closestX = volley.prevX + segX * proj;
        const closestY = volley.prevY + segY * proj;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        if(offX * offX + offY * offY <= effectiveSq){
          applyDuskwaveVolleyDamage(volley, m, volley.secondaryDamage, false);
        }
      }
    }
  }

  function updateRicochetBombCasts(dt){
    for(let i = ricochetBombCasts.length - 1; i >= 0; i--){
      const cast = ricochetBombCasts[i];
      if(!cast){
        ricochetBombCasts.splice(i, 1);
        continue;
      }
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      const caster = cast.casterRef || player;
      const interrupted = caster && (caster.stunTimer > 0 || caster.knockupTimer > 0 || caster.silenceTimer > 0);
      if(interrupted){
        if(caster === player && player.casting === cast){
          player.casting = null;
          setHudMessage(`${cast.abilityName || 'Spell'} interrupted.`);
        }
        ricochetBombCasts.splice(i, 1);
        continue;
      }
      if(duration <= 0 || cast.elapsed >= duration){
        launchRicochetBomb(cast);
        ricochetBombCasts.splice(i, 1);
      }
    }
  }

  function updateRicochetBombProjectiles(dt){
    for(let i = ricochetBombProjectiles.length - 1; i >= 0; i--){
      const bomb = ricochetBombProjectiles[i];
      if(!bomb){
        ricochetBombProjectiles.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(bomb.speed) || 0);
      const segmentDistance = Math.max(0, Number(bomb.segmentDistance) || 0);
      if(!(segmentDistance > 0)){
        ricochetBombProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(bomb.traveled) || 0);
      const nextTraveled = speed > 0 ? prevTraveled + speed * dt : segmentDistance;
      const clamped = Math.min(nextTraveled, segmentDistance);
      bomb.traveled = clamped;
      bomb.currentX = bomb.startX + bomb.dirX * clamped;
      bomb.currentY = bomb.startY + bomb.dirY * clamped;

      if(clamped >= segmentDistance - 0.001){
        const landingX = bomb.targetX;
        const landingY = bomb.targetY;
        const triggerRadius = Math.max(0, Number(bomb.triggerRadius) || 0);
        const triggerCheck = triggerRadius + minionRadius;
        const triggerSq = triggerCheck * triggerCheck;
        let nearEnemy = false;
        for(const m of minions){
          if(!m || !isEnemyMinionForPlayer(m)) continue;
          if(m.hp <= 0 || m.portalizing > 0) continue;
          const dx = m.x - landingX;
          const dy = m.y - landingY;
          if(dx * dx + dy * dy <= triggerSq){
            nearEnemy = true;
            break;
          }
        }
        const terrainHit = triggerRadius > 0 ? circleCollides(landingX, landingY, triggerRadius) : false;
        const forceExplode = Number(bomb.bouncesUsed) >= Number(bomb.maxBounces);
        const nextScale = ricochetBounceScale(bomb, Number(bomb.bouncesUsed) || 0);
        if(nearEnemy || terrainHit || forceExplode || !(nextScale > 0)){
          detonateRicochetBomb(bomb, landingX, landingY, nearEnemy ? 'enemy' : (terrainHit ? 'terrain' : 'final'));
          ricochetBombProjectiles.splice(i, 1);
          continue;
        }

        const nextDistance = Math.max(0, Number(bomb.baseDistance) || segmentDistance) * nextScale;
        const baseDirX = Number(bomb.baseDirX) || bomb.dirX || 1;
        const baseDirY = Number(bomb.baseDirY) || bomb.dirY || 0;
        let targetX = landingX + baseDirX * nextDistance;
        let targetY = landingY + baseDirY * nextDistance;
        const safeRadius = Math.max(triggerRadius, Number(bomb.explosionRadius) || 0, minionRadius);
        targetX = Math.max(safeRadius, Math.min(mapState.width - safeRadius, targetX));
        targetY = Math.max(safeRadius, Math.min(mapState.height - safeRadius, targetY));
        const segDx = targetX - landingX;
        const segDy = targetY - landingY;
        const segDist = Math.hypot(segDx, segDy);
        if(!(segDist > 1)){
          detonateRicochetBomb(bomb, landingX, landingY, 'final');
          ricochetBombProjectiles.splice(i, 1);
          continue;
        }
        bomb.startX = landingX;
        bomb.startY = landingY;
        bomb.targetX = targetX;
        bomb.targetY = targetY;
        bomb.dirX = segDx / segDist;
        bomb.dirY = segDy / segDist;
        bomb.segmentDistance = segDist;
        bomb.traveled = 0;
        bomb.bouncesUsed = (Number(bomb.bouncesUsed) || 0) + 1;
      }
    }
  }

  function updateSlingshotCrashLeaps(dt){
    for(let i = slingshotCrashLeaps.length - 1; i >= 0; i--){
      const leap = slingshotCrashLeaps[i];
      if(!leap){
        slingshotCrashLeaps.splice(i, 1);
        continue;
      }
      const totalDistance = Math.max(0, Number(leap.distance) || 0);
      if(!(totalDistance > 0)){
        if(leap.casterRef === player && player.casting === leap){
          player.casting = null;
        }
        leap.currentX = Number.isFinite(leap.currentX) ? leap.currentX : (Number.isFinite(leap.startX) ? leap.startX : player.x);
        leap.currentY = Number.isFinite(leap.currentY) ? leap.currentY : (Number.isFinite(leap.startY) ? leap.startY : player.y);
        applySlingshotCrashLanding(leap);
        slingshotCrashLeaps.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(leap.speed) || 0);
      const remaining = Math.max(0, totalDistance - (Number(leap.traveled) || 0));
      const step = speed > 0 ? speed * dt : remaining;
      const move = Math.min(remaining, step);
      const prevX = Number.isFinite(leap.currentX) ? leap.currentX : leap.startX;
      const prevY = Number.isFinite(leap.currentY) ? leap.currentY : leap.startY;
      const moveX = (Number(leap.dirX) || 0) * move;
      const moveY = (Number(leap.dirY) || 0) * move;
      const moved = moveCircleWithCollision(prevX, prevY, moveX, moveY, player.r);
      const deltaX = moved.x - prevX;
      const deltaY = moved.y - prevY;
      const traveled = Math.hypot(deltaX, deltaY);
      leap.traveled = Math.max(0, (Number(leap.traveled) || 0) + traveled);
      leap.currentX = moved.x;
      leap.currentY = moved.y;
      leap.elapsed = Math.max(0, (Number(leap.elapsed) || 0) + dt);
      if(leap.casterRef === player){
        player.x = moved.x;
        player.y = moved.y;
        player.target.x = moved.x;
        player.target.y = moved.y;
        player.navGoal = null;
        player.nav = null;
      }
      const remainingAfterMove = Math.max(0, totalDistance - leap.traveled);
      const duration = Math.max(0, Number(leap.duration) || 0);
      const timeComplete = duration > 0 && leap.elapsed >= duration - 0.0001;
      const stuck = traveled <= 0.001 && move > 0.01;
      if(remainingAfterMove <= 0.5 || timeComplete || stuck){
        if(leap.casterRef === player && player.casting === leap){
          player.casting = null;
        }
        applySlingshotCrashLanding(leap);
        slingshotCrashLeaps.splice(i, 1);
      }
    }
  }

  function collectReboundOrbSegmentHits(orb, prevX, prevY, nextX, nextY, hitSet){
    const dx = nextX - prevX;
    const dy = nextY - prevY;
    const segLenSq = dx * dx + dy * dy;
    if(!(segLenSq > 0.0001)) return [];
    const segLen = Math.sqrt(segLenSq);
    const halfWidth = Math.max(0, Number(orb && orb.width) || 0) * 0.5;
    const hits = [];
    for(const m of minions){
      if(!m) continue;
      const practiceTarget = m.isPracticeDummy === true;
      if(!practiceTarget && !isEnemyMinionForPlayer(m)) continue;
      if(m.hp <= 0 || m.portalizing > 0) continue;
      if(practiceTarget && (m.active === false || m.respawnTimer > 0)) continue;
      if(hitSet && hitSet.has(m)) continue;
      const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
      const effectiveRadius = halfWidth + targetRadius;
      const effectiveSq = effectiveRadius * effectiveRadius;
      const relX = m.x - prevX;
      const relY = m.y - prevY;
      const t = (relX * dx + relY * dy) / segLenSq;
      if(t < -0.05 || t > 1.05) continue;
      const clamped = Math.max(0, Math.min(1, t));
      const closestX = prevX + dx * clamped;
      const closestY = prevY + dy * clamped;
      const offX = m.x - closestX;
      const offY = m.y - closestY;
      if(offX * offX + offY * offY <= effectiveSq){
        hits.push({ target: m, along: segLen * clamped, hitX: closestX, hitY: closestY, targetRadius });
      }
    }
    hits.sort((a, b) => a.along - b.along);
    return hits;
  }

  function findCycloneCast(castId){
    return cycloneCasts.find(cast => cast && cast.id === castId && !cast.completed) || null;
  }

  function updateCycloneAxes(dt){
    for(let i = cycloneAxes.length - 1; i >= 0; i--){
      const axis = cycloneAxes[i];
      if(!axis){
        cycloneAxes.splice(i, 1);
        continue;
      }
      if(axis.state === 'done'){
        cycloneAxes.splice(i, 1);
        continue;
      }
      const cast = findCycloneCast(axis.castId);
      if(!cast || cast.completed){
        cycloneAxes.splice(i, 1);
        continue;
      }
      axis.prevX = axis.currentX;
      axis.prevY = axis.currentY;
      if(axis.state === 'outbound'){
        const speed = Math.max(0, Number(axis.speedOut) || 0);
        if(!(speed > 0)){
          beginCycloneAxesReturn(cast, { reason: 'range', announce: axis.casterRef === player });
          continue;
        }
        const move = speed * dt;
        const nextX = axis.currentX + (Number(axis.dirX) || 0) * move;
        const nextY = axis.currentY + (Number(axis.dirY) || 0) * move;
        const hits = collectReboundOrbSegmentHits(axis, axis.prevX, axis.prevY, nextX, nextY, axis.hitOutbound);
        if(hits.length > 0){
          for(const hit of hits){
            if(hit.target) axis.hitOutbound.add(hit.target);
            applyCycloneAxisHit(axis, hit, 'outbound');
          }
          beginCycloneAxesReturn(cast, { reason: 'hit', announce: axis.casterRef === player });
        }
        axis.traveled = Math.min(axis.range || move, (axis.traveled || 0) + move);
        axis.currentX = nextX;
        axis.currentY = nextY;
        let clampedX = nextX;
        let clampedY = nextY;
        let hitEdge = false;
        const safeRadius = Math.max(minionRadius, axis.width * 0.5, 6);
        if(mapState){
          if(Number.isFinite(mapState.width)){
            const minX = safeRadius;
            const maxX = mapState.width - safeRadius;
            if(clampedX < minX){
              clampedX = minX;
              hitEdge = true;
            } else if(clampedX > maxX){
              clampedX = maxX;
              hitEdge = true;
            }
          }
          if(Number.isFinite(mapState.height)){
            const minY = safeRadius;
            const maxY = mapState.height - safeRadius;
            if(clampedY < minY){
              clampedY = minY;
              hitEdge = true;
            } else if(clampedY > maxY){
              clampedY = maxY;
              hitEdge = true;
            }
          }
        }
        if(clampedX !== nextX || clampedY !== nextY){
          axis.currentX = clampedX;
          axis.currentY = clampedY;
          hitEdge = true;
        }
        if(hitEdge || axis.traveled >= (axis.range || 0) - 0.1){
          beginCycloneAxesReturn(cast, { reason: 'range', announce: axis.casterRef === player });
        }
        continue;
      }
      if(axis.state === 'return'){
        const caster = cast.casterRef || player;
        const origin = getSpellOrigin(caster);
        const toCasterX = origin.x - axis.currentX;
        const toCasterY = origin.y - axis.currentY;
        const distance = Math.hypot(toCasterX, toCasterY);
        const speed = Math.max(0, Number(axis.speedReturn) || 0);
        if(!(distance > 0.0001) || !(speed > 0)){
          axis.state = 'done';
          continue;
        }
        const dirX = toCasterX / distance;
        const dirY = toCasterY / distance;
        axis.dirX = dirX;
        axis.dirY = dirY;
        const travel = Math.min(distance, speed * dt);
        const nextX = axis.currentX + dirX * travel;
        const nextY = axis.currentY + dirY * travel;
        const hits = collectReboundOrbSegmentHits(axis, axis.prevX, axis.prevY, nextX, nextY, axis.hitReturn);
        for(const hit of hits){
          if(hit.target) axis.hitReturn.add(hit.target);
          applyCycloneAxisHit(axis, hit, 'return');
        }
        axis.currentX = nextX;
        axis.currentY = nextY;
        if(travel >= distance - 0.001){
          axis.state = 'done';
        }
        continue;
      }
    }
    for(const cast of cycloneCasts.slice()){
      if(!cast || cast.completed) continue;
      const hasAxes = cycloneAxes.some(axis => axis && axis.castId === cast.id);
      if(!hasAxes){
        finishCycloneAxesCast(cast);
      }
    }
  }

  function applyReboundOrbHit(orb, hit, phase){
    if(!orb || !hit || !hit.target) return;
    const target = hit.target;
    const targetRadius = Math.max(minionRadius, Number(hit.targetRadius) || minionRadius);
    const prevHp = Number(target.hp) || 0;
    if(orb.damage > 0){
      target.hp = Math.max(0, prevHp - orb.damage);
      spawnHitSplat(target.x, target.y - targetRadius, orb.damage);
    }
    handlePracticeDummyDamage(target, prevHp);
    const flashColor = phase === 'return' ? '#ffd6b0' : '#bde7ff';
    const startRadius = Math.max(8, (Number(orb.width) || 0) * 0.2);
    const endRadius = Math.max(targetRadius + 14, (Number(orb.width) || 0) * 0.6 + 18);
    flash(hit.hitX, hit.hitY, { startRadius, endRadius, color: flashColor });
    const owner = orb.casterRef || (orb.castRef ? orb.castRef.casterRef : null);
    if(owner === player){
      const dmgText = orb.damage > 0 ? ` for ${Math.round(orb.damage)}${phase === 'return' ? ' true' : ''} damage` : '';
      const phaseText = phase === 'return' ? ' return' : '';
      setHudMessage(`${orb.abilityName || 'Rebound Orb'}${phaseText} hit${dmgText}!`);
    }
  }

  function updateReboundOrbProjectiles(dt){
    for(let i = reboundOrbProjectiles.length - 1; i >= 0; i--){
      const orb = reboundOrbProjectiles[i];
      if(!orb){
        reboundOrbProjectiles.splice(i, 1);
        continue;
      }
      const outbound = orb.state !== 'return';
      const speed = outbound ? Math.max(0, Number(orb.speedOut) || 0) : Math.max(0, Number(orb.speedReturn) || 0);
      if(!(speed > 0)){
        reboundOrbProjectiles.splice(i, 1);
        continue;
      }
      const prevX = Number.isFinite(orb.currentX) ? orb.currentX : orb.startX;
      const prevY = Number.isFinite(orb.currentY) ? orb.currentY : orb.startY;
      let nextX = prevX;
      let nextY = prevY;
      const hitSet = outbound ? (orb.hitOutbound || (orb.hitOutbound = new Set())) : (orb.hitReturn || (orb.hitReturn = new Set()));

      if(outbound){
        const range = Math.max(0, Number(orb.range) || 0);
        const traveled = Math.max(0, Number(orb.traveled) || 0);
        const remaining = Math.max(0, range - traveled);
        const travel = Math.min(remaining, speed * dt);
        nextX = prevX + (Number(orb.dirX) || 0) * travel;
        nextY = prevY + (Number(orb.dirY) || 0) * travel;

        const hits = collectReboundOrbSegmentHits(orb, prevX, prevY, nextX, nextY, hitSet);
        for(const hit of hits){
          hitSet.add(hit.target);
          applyReboundOrbHit(orb, hit, 'outbound');
        }

        orb.traveled = traveled + travel;
        orb.currentX = nextX;
        orb.currentY = nextY;

        if(orb.traveled >= range - 0.0001 || remaining <= 0.0001){
          orb.state = 'return';
          orb.traveled = 0;
          flash(orb.currentX, orb.currentY, { startRadius: Math.max(10, (Number(orb.width) || 0) * 0.25), endRadius: Math.max(32, (Number(orb.width) || 0) * 0.5 + 26), color: '#ffd6b0' });
        }
      } else {
        const caster = orb.casterRef || player;
        const origin = getSpellOrigin(caster);
        const toCasterX = origin.x - prevX;
        const toCasterY = origin.y - prevY;
        const distance = Math.hypot(toCasterX, toCasterY);
        if(!(distance > 0.0001)){
          reboundOrbProjectiles.splice(i, 1);
          continue;
        }
        const dirX = toCasterX / distance;
        const dirY = toCasterY / distance;
        orb.dirX = dirX;
        orb.dirY = dirY;
        const travel = Math.min(distance, speed * dt);
        nextX = prevX + dirX * travel;
        nextY = prevY + dirY * travel;

        const hits = collectReboundOrbSegmentHits(orb, prevX, prevY, nextX, nextY, hitSet);
        for(const hit of hits){
          hitSet.add(hit.target);
          applyReboundOrbHit(orb, hit, 'return');
        }

        orb.traveled = Math.max(0, (Number(orb.traveled) || 0) + travel);
        orb.currentX = nextX;
        orb.currentY = nextY;

        if(travel >= distance - 0.0001){
          flash(origin.x, origin.y, { startRadius: Math.max(10, (Number(orb.width) || 0) * 0.25), endRadius: Math.max(32, (Number(orb.width) || 0) * 0.5 + 26), color: '#ffd6b0' });
          reboundOrbProjectiles.splice(i, 1);
        }
      }
    }
  }

  function updateShatterburstOrbProjectiles(dt){
    for(let i = shatterburstOrbProjectiles.length - 1; i >= 0; i--){
      const proj = shatterburstOrbProjectiles[i];
      if(!proj){
        shatterburstOrbProjectiles.splice(i, 1);
        continue;
      }
      if(proj.removed){
        shatterburstOrbProjectiles.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(speed > 0)){
        shatterburstOrbProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const traveled = Math.max(0, Number(proj.traveled) || 0);
      const remaining = Math.max(0, range - traveled);
      const move = Math.min(remaining, speed * dt);
      const prevX = Number.isFinite(proj.currentX) ? proj.currentX : proj.startX;
      const prevY = Number.isFinite(proj.currentY) ? proj.currentY : proj.startY;
      const nextX = prevX + (Number(proj.dirX) || 0) * move;
      const nextY = prevY + (Number(proj.dirY) || 0) * move;
      const hitSet = proj.hitPass || (proj.hitPass = new Set());
      const hits = collectReboundOrbSegmentHits(proj, prevX, prevY, nextX, nextY, hitSet);
      for(const hit of hits){
        hitSet.add(hit.target);
        if(hit.target && (hit.target.isPracticeDummy === true || isEnemyMinionForPlayer(hit.target))){
          applyShatterburstPassHit(proj, hit);
        }
      }
      proj.traveled = traveled + move;
      proj.currentX = nextX;
      proj.currentY = nextY;

      if(proj.traveled >= range - 0.0001 || remaining <= 0.0001){
        detonateShatterburstOrb(proj, { cause: 'maxRange', announce: true });
      }
    }
  }

  function updateFocusedLockshotCasts(dt){
    for(let i = focusedLockshotCasts.length - 1; i >= 0; i--){
      const cast = focusedLockshotCasts[i];
      if(!cast){
        focusedLockshotCasts.splice(i, 1);
        continue;
      }
      cast.channelElapsed = Math.max(0, (Number(cast.channelElapsed) || 0) + dt);
      const target = cast.targetRef;
      const targetAlive = target && isAutoAttackTarget(target)
        && target.hp > 0
        && (Number(target.portalizing) || 0) <= 0;
      if(!targetAlive){
        cancelFocusedLockshotCast(cast, { message: `${cast.abilityName || 'Lockshot'} lost its lock.` });
        continue;
      }
      const duration = Math.max(0, Number(cast.channelDuration) || 0);
      if(duration > 0 && cast.channelElapsed < duration){
        continue;
      }
      releaseFocusedLockshot(cast);
    }
  }

  function updateFocusedLockshotProjectiles(dt){
    for(let i = focusedLockshotProjectiles.length - 1; i >= 0; i--){
      const proj = focusedLockshotProjectiles[i];
      if(!proj){
        focusedLockshotProjectiles.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(speed > 0)){
        focusedLockshotProjectiles.splice(i, 1);
        continue;
      }
      let dirX = Number(proj.dirX) || 1;
      let dirY = Number(proj.dirY) || 0;
      const target = proj.targetRef;
      if(target && isAutoAttackTarget(target) && target.hp > 0 && (Number(target.portalizing) || 0) <= 0){
        const dx = target.x - proj.x;
        const dy = target.y - proj.y;
        const len = Math.hypot(dx, dy);
        if(len > 0.0001){
          dirX = dx / len;
          dirY = dy / len;
        }
      }
      proj.prevX = Number(proj.x) || Number(proj.startX) || 0;
      proj.prevY = Number(proj.y) || Number(proj.startY) || 0;
      const move = speed * dt;
      proj.x += dirX * move;
      proj.y += dirY * move;
      proj.dirX = dirX;
      proj.dirY = dirY;
      proj.traveled = Math.max(0, (Number(proj.traveled) || 0) + move);
      const maxRange = Math.max(0, Number(proj.range) || 0);
      if(maxRange > 0 && proj.traveled >= maxRange - 0.0001){
        focusedLockshotProjectiles.splice(i, 1);
        continue;
      }
      const radius = Math.max(0, Number(proj.width) || 0) / 2;
      let hitTarget = null;
      for(const m of minions){
        if(!m) continue;
        const practiceTarget = m.isPracticeDummy === true;
        if(practiceTarget){
          if(m.active === false || m.hp <= 0 || (Number(m.portalizing) || 0) > 0) continue;
        } else if(!isEnemyMinionForPlayer(m)){
          continue;
        }
        const targetRadius = practiceTarget ? Math.max(minionRadius, Number(m.radius) || minionRadius) : minionRadius;
        const dx = m.x - proj.x;
        const dy = m.y - proj.y;
        const totalRadius = radius + targetRadius;
        if(dx * dx + dy * dy <= totalRadius * totalRadius){
          hitTarget = m;
          break;
        }
      }
      if(hitTarget){
        applyFocusedLockshotHit(proj, hitTarget);
        focusedLockshotProjectiles.splice(i, 1);
        continue;
      }
      if(isMonsterAttackable(monsterState)){
        const monsterRadius = Math.max(minionRadius, monsterAttackRadius());
        const dx = monsterState.x - proj.x;
        const dy = monsterState.y - proj.y;
        const totalRadius = radius + monsterRadius;
        if(dx * dx + dy * dy <= totalRadius * totalRadius){
          applyFocusedLockshotHit(proj, monsterState);
          focusedLockshotProjectiles.splice(i, 1);
          continue;
        }
      }
    }
  }

  function updateFlipbladeCasts(dt){
    for(let i = flipbladeCasts.length - 1; i >= 0; i--){
      const cast = flipbladeCasts[i];
      if(!cast){
        flipbladeCasts.splice(i, 1);
        continue;
      }
      const duration = Math.max(0, Number(cast.castDuration) || 0);
      cast.elapsed = Math.max(0, (cast.elapsed || 0) + dt);
      if(cast.elapsed >= duration){
        if(cast.casterRef === player && player.casting === cast){
          player.casting = null;
        }
        launchFlipbladeCast(cast);
        flipbladeCasts.splice(i, 1);
      }
    }
  }

  function applyFlipbladeProjectileHit(proj, target, hitX, hitY){
    if(!proj || !target) return;
    const prevHp = Number(target.hp) || 0;
    const damage = Math.max(0, Number(proj.damage) || 0);
    if(damage > 0){
      target.hp = Math.max(0, prevHp - damage);
      spawnHitSplat(target.x, target.y - minionRadius, damage);
    }
    handlePracticeDummyDamage(target, prevHp);
    flash(hitX, hitY, { startRadius: 10, endRadius: 30, color: '#bdf7e4' });
    const owner = proj.casterRef || player;
    const duration = Math.max(0, Number(proj.markDuration) || 0);
    const targetAlive = target.hp > 0 && target.portalizing <= 0;
    if(owner === player){
      const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
      const recastText = duration > 0 && targetAlive ? ' Recast to dash.' : '';
      setHudMessage(`${proj.abilityName || 'Flipblade'} hit${dmgText}!${recastText}`);
    }
    if(duration > 0 && targetAlive){
      for(let i = flipbladeMarks.length - 1; i >= 0; i--){
        const existing = flipbladeMarks[i];
        if(existing && existing.casterRef === owner && existing.abilityId === proj.abilityId){
          flipbladeMarks.splice(i, 1);
        }
      }
      const mark = {
        id: `flip-${abilityRuntime.flipbladeSequence++}`,
        abilityId: proj.abilityId,
        abilityName: proj.abilityName,
        slotIndex: proj.slotIndex,
        casterRef: owner,
        targetRef: target,
        targetId: target.id || null,
        lastKnownX: target.x,
        lastKnownY: target.y,
        remaining: duration,
        duration,
        recastDamage: Math.max(0, Number(proj.markDamage) || 0),
        recastSpeed: Math.max(0, Number(proj.recastSpeed) || 0),
        cooldownSeconds: Math.max(0, Number(proj.cooldownSeconds) || 0)
      };
      flipbladeMarks.push(mark);
    } else {
      applyFlipbladeCooldown(proj.slotIndex, proj.cooldownSeconds);
    }
  }

  function updateFlipbladeProjectiles(dt){
    for(let i = flipbladeProjectiles.length - 1; i >= 0; i--){
      const proj = flipbladeProjectiles[i];
      if(!proj){
        flipbladeProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(range > 0) || !(speed > 0)){
        flipbladeProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      const nextTraveled = Math.min(range, prevTraveled + speed * dt);
      const effectiveRadius = Math.max(0, (Number(proj.width) || 0) * 0.5 + minionRadius);
      let bestHit = null;
      for(const m of minions){
        if(!m || !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const relX = m.x - proj.startX;
        const relY = m.y - proj.startY;
        const along = relX * proj.dirX + relY * proj.dirY;
        if(along < prevTraveled - minionRadius) continue;
        if(along > nextTraveled + minionRadius) continue;
        if(along < -minionRadius || along > range + minionRadius) continue;
        const closestX = proj.startX + proj.dirX * along;
        const closestY = proj.startY + proj.dirY * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        if(offX * offX + offY * offY <= effectiveRadius * effectiveRadius){
          if(!bestHit || along < bestHit.along){
            bestHit = { target: m, along, hitX: closestX, hitY: closestY };
          }
        }
      }
      if(bestHit){
        applyFlipbladeProjectileHit(proj, bestHit.target, bestHit.hitX, bestHit.hitY);
        flipbladeProjectiles.splice(i, 1);
        continue;
      }
      proj.traveled = nextTraveled;
      proj.currentX = proj.startX + proj.dirX * nextTraveled;
      proj.currentY = proj.startY + proj.dirY * nextTraveled;
      if(nextTraveled >= range - 0.0001){
        applyFlipbladeCooldown(proj.slotIndex, proj.cooldownSeconds);
        flipbladeProjectiles.splice(i, 1);
        continue;
      }
      if(proj.currentX < -64 || proj.currentY < -64 || proj.currentX > mapState.width + 64 || proj.currentY > mapState.height + 64){
        applyFlipbladeCooldown(proj.slotIndex, proj.cooldownSeconds);
        flipbladeProjectiles.splice(i, 1);
      }
    }
  }

  function updateFlipbladeMarks(dt){
    for(let i = flipbladeMarks.length - 1; i >= 0; i--){
      const mark = flipbladeMarks[i];
      if(!mark){
        flipbladeMarks.splice(i, 1);
        continue;
      }
      const targetAlive = mark.targetRef && mark.targetRef.hp > 0 && mark.targetRef.portalizing <= 0;
      if(targetAlive){
        mark.lastKnownX = mark.targetRef.x;
        mark.lastKnownY = mark.targetRef.y;
      }
      mark.remaining = Math.max(0, (mark.remaining || 0) - dt);
      if(mark.remaining <= 0){
        if(mark.casterRef === player){
          setHudMessage(`${mark.abilityName || 'Flipblade'} mark faded.`);
        }
        applyFlipbladeCooldown(mark.slotIndex, mark.cooldownSeconds);
        flipbladeMarks.splice(i, 1);
      }
    }
  }

  function completeFlipbladeDash(dash){
    if(!dash) return;
    const caster = dash.casterRef || player;
    if(caster === player && player.casting === dash){
      player.casting = null;
    }
    const targetAlive = dash.targetRef && dash.targetRef.hp > 0 && dash.targetRef.portalizing <= 0;
    const hitX = targetAlive ? dash.targetRef.x : dash.targetX;
    const hitY = targetAlive ? dash.targetRef.y : dash.targetY;
    if(targetAlive){
      const prevHp = Number(dash.targetRef.hp) || 0;
      const damage = Math.max(0, Number(dash.damage) || 0);
      if(damage > 0){
        dash.targetRef.hp = Math.max(0, prevHp - damage);
        spawnHitSplat(dash.targetRef.x, dash.targetRef.y - minionRadius, damage);
      }
      handlePracticeDummyDamage(dash.targetRef, prevHp);
      flash(hitX, hitY, { startRadius: 12, endRadius: 36, color: '#bdf7e4' });
      if(caster === player){
        const dmgText = damage > 0 ? ` for ${Math.round(damage)} damage` : '';
        setHudMessage(`${dash.abilityName || 'Flipblade'} struck${dmgText}!`);
      }
    } else {
      flash(hitX, hitY, { startRadius: 10, endRadius: 28, color: '#bdf7e4' });
      if(caster === player){
        setHudMessage(`${dash.abilityName || 'Flipblade'} recast ended.`);
      }
    }
  }

  function updateFlipbladeDashes(dt){
    for(let i = flipbladeDashes.length - 1; i >= 0; i--){
      const dash = flipbladeDashes[i];
      if(!dash){
        flipbladeDashes.splice(i, 1);
        continue;
      }
      const caster = dash.casterRef || player;
      const targetAlive = dash.targetRef && dash.targetRef.hp > 0 && dash.targetRef.portalizing <= 0;
      const destX = targetAlive ? dash.targetRef.x : dash.targetX;
      const destY = targetAlive ? dash.targetRef.y : dash.targetY;
      dash.targetX = destX;
      dash.targetY = destY;
      const dx = destX - caster.x;
      const dy = destY - caster.y;
      const distance = Math.hypot(dx, dy);
      const speed = Math.max(0, Number(dash.speed) || 0);
      if(!(distance > 0.0001) || !(speed > 0)){
        completeFlipbladeDash(dash);
        flipbladeDashes.splice(i, 1);
        continue;
      }
      const travel = Math.min(distance, speed * dt);
      const moveX = dx / distance * travel;
      const moveY = dy / distance * travel;
      const moved = moveCircleWithCollision(caster.x, caster.y, moveX, moveY, caster.r || minionRadius);
      caster.x = Math.max(caster.r, Math.min(mapState.width - caster.r, moved.x));
      caster.y = Math.max(caster.r, Math.min(mapState.height - caster.r, moved.y));
      caster.target.x = caster.x;
      caster.target.y = caster.y;
      caster.navGoal = null;
      caster.nav = null;
      caster.chaseTarget = null;
      if(travel >= distance - 0.0001 || Math.hypot(destX - caster.x, destY - caster.y) <= Math.max(6, caster.r || minionRadius)){
        completeFlipbladeDash(dash);
        flipbladeDashes.splice(i, 1);
      }
    }
  }

  function updateBlinkingBoltProjectiles(dt){
    for(let i = blinkingBoltProjectiles.length - 1; i >= 0; i--){
      const bolt = blinkingBoltProjectiles[i];
      const maxLifetime = Number(bolt.maxLifetime) || 0;
      bolt.age = Math.max(0, (bolt.age || 0) + dt);
      if(maxLifetime > 0 && bolt.age >= maxLifetime){
        blinkingBoltProjectiles.splice(i, 1);
        continue;
      }

      const speed = Math.max(0, Number(bolt.speed) || 0);
      let target = bolt.targetRef;
      if(target && target.hp <= 0){
        target = null;
        bolt.targetRef = null;
      }
      if(!target){
        const reacquired = findNearestEnemyMinion(bolt.x, bolt.y);
        if(reacquired){
          bolt.targetRef = reacquired;
          target = reacquired;
        }
      }

      const hitRadius = minionRadius + 6;
      bolt.prevX = bolt.x;
      bolt.prevY = bolt.y;

      if(target){
        const dx = target.x - bolt.x;
        const dy = target.y - bolt.y;
        const dist = Math.hypot(dx, dy);
        if(dist > 0.0001){
          bolt.dirX = dx / dist;
          bolt.dirY = dy / dist;
        }
        const travel = Math.min(dist, speed * dt);
        bolt.x += bolt.dirX * travel;
        bolt.y += bolt.dirY * travel;
        const remaining = Math.hypot(target.x - bolt.x, target.y - bolt.y);
        if(dist <= hitRadius || remaining <= hitRadius){
          const prevHp = Number(target.hp) || 0;
          if(Number(bolt.damage) > 0){
            target.hp = Math.max(0, prevHp - bolt.damage);
            spawnHitSplat(target.x, target.y - minionRadius, bolt.damage);
          }
          handlePracticeDummyDamage(target, prevHp);
          flash(target.x, target.y, { startRadius: 10, endRadius: 36, color: '#7fe3ff' });
          const dmgValue = Number(bolt.damage) || 0;
          if(dmgValue > 0){
            setHudMessage(`${bolt.abilityName || 'Blink Bolt'} hit for ${Math.round(dmgValue)} damage!`);
          } else {
            setHudMessage(`${bolt.abilityName || 'Blink Bolt'} hit!`);
          }
          blinkingBoltProjectiles.splice(i, 1);
          continue;
        }
      } else {
        bolt.x += bolt.dirX * speed * dt;
        bolt.y += bolt.dirY * speed * dt;
      }

      if(bolt.x < -64 || bolt.y < -64 || bolt.x > mapState.width + 64 || bolt.y > mapState.height + 64){
        blinkingBoltProjectiles.splice(i, 1);
      }
    }
  }

  function updateVerdictSalvoCasts(dt){
    for(let i = verdictSalvoCasts.length - 1; i >= 0; i--){
      const cast = verdictSalvoCasts[i];
      if(!cast || cast.ended){
        verdictSalvoCasts.splice(i, 1);
        continue;
      }
      const caster = cast.casterRef || player;
      const controlTimers = [caster && caster.stunTimer, caster && caster.knockupTimer, caster && caster.silenceTimer, caster && caster.disarmTimer, caster && caster.polymorphTimer];
      const interrupted = controlTimers.some(value => Number(value) > 0);
      if(interrupted){
        const cancelled = cast.state === 'channel' && cast.shotsFired <= 0;
        endVerdictSalvoCast(cast, { reason: 'control', cancelled });
        continue;
      }

      cast.elapsed = Math.max(0, Number(cast.elapsed) || 0) + dt;
      if(cast.state === 'channel'){
        const interval = Math.max(0, Number(cast.storageInterval) || 0);
        while(cast.storedBullets < cast.maxStoredBullets && cast.elapsed + 1e-6 >= cast.nextStoreTime){
          cast.storedBullets += 1;
          cast.nextStoreTime += interval > 0 ? interval : 0.0001;
        }
        if(cast.elapsed >= cast.duration - 1e-6){
          beginVerdictSalvoVolley(cast, { cause: 'auto' });
        }
      } else if(cast.state === 'firing'){
        cast.volleyElapsed = Math.max(0, Number(cast.volleyElapsed) || 0) + dt;
        const interval = Math.max(0, Number(cast.fireInterval) || 0);
        while(cast.shotsFired < cast.shotsToFire && cast.volleyElapsed + 1e-6 >= cast.nextShotTime){
          fireVerdictSalvoShot(cast);
          cast.shotsFired += 1;
          cast.nextShotTime += interval > 0 ? interval : 0.0001;
        }
        if(cast.shotsFired >= cast.shotsToFire){
          endVerdictSalvoCast(cast, { reason: 'complete' });
        }
      }
    }
  }

  function updateVerdictSalvoProjectiles(dt){
    for(let i = verdictSalvoProjectiles.length - 1; i >= 0; i--){
      const proj = verdictSalvoProjectiles[i];
      if(!proj){
        verdictSalvoProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(range > 0) || !(speed > 0)){
        verdictSalvoProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      const nextTraveled = Math.min(range, prevTraveled + speed * dt);
      const halfWidth = Math.max(0, (Number(proj.width) || 0) / 2);
      const effectiveRadius = halfWidth + minionRadius;
      const effectiveSq = effectiveRadius * effectiveRadius;
      let hitTarget = null;
      let hitAlong = Infinity;
      for(const m of minions){
        if(!m) continue;
        const isDummy = m.isPracticeDummy === true;
        if(!isEnemyMinionForPlayer(m) && !isDummy) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        const relX = m.x - proj.startX;
        const relY = m.y - proj.startY;
        const along = relX * proj.dirX + relY * proj.dirY;
        if(along < prevTraveled - minionRadius) continue;
        if(along > nextTraveled + minionRadius) continue;
        if(along < -minionRadius || along > range + minionRadius) continue;
        const closestX = proj.startX + proj.dirX * along;
        const closestY = proj.startY + proj.dirY * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        if(offX * offX + offY * offY <= effectiveSq && along < hitAlong){
          hitAlong = along;
          hitTarget = m;
        }
      }
      if(hitTarget){
        applyVerdictSalvoHit(proj, hitTarget);
        verdictSalvoProjectiles.splice(i, 1);
        continue;
      }
      proj.traveled = nextTraveled;
      proj.x = proj.startX + proj.dirX * nextTraveled;
      proj.y = proj.startY + proj.dirY * nextTraveled;
      proj.age = (Number(proj.age) || 0) + dt;
      if(nextTraveled >= range - 0.001){
        verdictSalvoProjectiles.splice(i, 1);
      }
    }
  }

  function updatePiercingArrowProjectiles(dt){
    for(let i = piercingArrowProjectiles.length - 1; i >= 0; i--){
      const proj = piercingArrowProjectiles[i];
      if(!proj){
        piercingArrowProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(range > 0) || !(speed > 0)){
        piercingArrowProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      const nextTraveled = Math.min(range, prevTraveled + speed * dt);
      const halfWidth = Math.max(0, (Number(proj.width) || 0) / 2);
      const effectiveRadius = halfWidth + minionRadius;
      const effectiveSq = effectiveRadius * effectiveRadius;
      const hits = [];
      for(const m of minions){
        if(!m || !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        if(proj.hitTargets && proj.hitTargets.has(m)) continue;
        const relX = m.x - proj.startX;
        const relY = m.y - proj.startY;
        const along = relX * proj.dirX + relY * proj.dirY;
        if(along < prevTraveled - minionRadius) continue;
        if(along > nextTraveled + minionRadius) continue;
        if(along < -minionRadius || along > range + minionRadius) continue;
        const closestX = proj.startX + proj.dirX * along;
        const closestY = proj.startY + proj.dirY * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        if(offX * offX + offY * offY <= effectiveSq){
          hits.push({ target: m, along });
        }
      }
      if(hits.length){
        hits.sort((a, b) => a.along - b.along);
        for(const hit of hits){
          if(proj.hitTargets && proj.hitTargets.has(hit.target)) continue;
          applyPiercingArrowHit(proj, hit.target);
          if(proj.hitTargets) proj.hitTargets.add(hit.target);
        }
      }
      proj.traveled = nextTraveled;
      proj.currentX = proj.startX + proj.dirX * nextTraveled;
      proj.currentY = proj.startY + proj.dirY * nextTraveled;
      if(nextTraveled >= range - 0.0001){
        if(proj.casterRef === player && !proj.announcedHit){
          setHudMessage(`${proj.abilityName || 'Piercing Arrow'} dissipated.`);
        }
        piercingArrowProjectiles.splice(i, 1);
        continue;
      }
      if(proj.currentX < -64 || proj.currentY < -64 || proj.currentX > mapState.width + 64 || proj.currentY > mapState.height + 64){
        piercingArrowProjectiles.splice(i, 1);
      }
    }
  }

  function updateExpandingShotProjectiles(dt){
    for(let i = expandingShotProjectiles.length - 1; i >= 0; i--){
      const proj = expandingShotProjectiles[i];
      if(!proj){
        expandingShotProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(range > 0) || !(speed > 0)){
        expandingShotProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      const nextTraveled = Math.min(range, prevTraveled + speed * dt);
      const candidates = [];
      for(const m of minions){
        if(!m || !isEnemyMinionForPlayer(m)) continue;
        if(m.hp <= 0 || m.portalizing > 0) continue;
        if(proj.hitTargets && proj.hitTargets.has(m)) continue;
        const relX = m.x - proj.startX;
        const relY = m.y - proj.startY;
        const along = relX * proj.dirX + relY * proj.dirY;
        if(along < prevTraveled - minionRadius) continue;
        if(along > nextTraveled + minionRadius) continue;
        if(along < -minionRadius || along > range + minionRadius) continue;
        const closestX = proj.startX + proj.dirX * along;
        const closestY = proj.startY + proj.dirY * along;
        const offX = m.x - closestX;
        const offY = m.y - closestY;
        candidates.push({ target: m, along, offX, offY });
      }
      if(candidates.length){
        candidates.sort((a, b) => a.along - b.along);
        for(const hit of candidates){
          const widthCheck = proj.primaryHit
            ? Math.max(proj.expandedWidth, proj.width)
            : proj.width;
          const halfWidth = Math.max(0, widthCheck / 2);
          const effectiveRadius = halfWidth + minionRadius;
          const effectiveSq = effectiveRadius * effectiveRadius;
          if(hit.offX * hit.offX + hit.offY * hit.offY > effectiveSq){
            continue;
          }
          const isPrimary = !proj.primaryHit;
          const damageValue = isPrimary ? proj.primaryDamage : proj.secondaryDamage;
          applyPiercingBloomHit(proj, hit.target, damageValue);
          if(proj.hitTargets) proj.hitTargets.add(hit.target);
          if(isPrimary){
            proj.primaryHit = true;
            if(proj.expandedWidth > proj.width){
              proj.width = proj.expandedWidth;
            }
          }
        }
      }
      proj.traveled = nextTraveled;
      proj.currentX = proj.startX + proj.dirX * nextTraveled;
      proj.currentY = proj.startY + proj.dirY * nextTraveled;
      if(nextTraveled >= range - 0.0001){
        expandingShotProjectiles.splice(i, 1);
        continue;
      }
      if(proj.currentX < -64 || proj.currentY < -64 || proj.currentX > mapState.width + 64 || proj.currentY > mapState.height + 64){
        expandingShotProjectiles.splice(i, 1);
        continue;
      }
    }
  }

  function updateChargingGaleProjectiles(dt){
    for(let i = chargingGaleProjectiles.length - 1; i >= 0; i--){
      const proj = chargingGaleProjectiles[i];
      if(!proj){
        chargingGaleProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(!(range > 0)){
        chargingGaleProjectiles.splice(i, 1);
        continue;
      }
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      let nextTraveled = prevTraveled + speed * dt;
      if(speed <= 0){
        nextTraveled = range;
      }
      const clampedNext = Math.min(nextTraveled, range);
      const halfWidth = Math.max(0, (Number(proj.width) || 0) / 2);
      const effectiveRadius = halfWidth + minionRadius;
      const effectiveSq = effectiveRadius * effectiveRadius;
      let removed = false;

      if(proj.pierce){
        const hits = [];
        for(const m of minions){
          if(!m || !isEnemyMinionForPlayer(m)) continue;
          if(m.hp <= 0 || m.portalizing > 0) continue;
          if(proj.hitTargets && proj.hitTargets.has(m)) continue;
          const relX = m.x - proj.startX;
          const relY = m.y - proj.startY;
          const along = relX * proj.dirX + relY * proj.dirY;
          if(along < prevTraveled - minionRadius) continue;
          if(along > clampedNext + minionRadius) continue;
          if(along < -minionRadius || along > range + minionRadius) continue;
          const closestX = proj.startX + proj.dirX * along;
          const closestY = proj.startY + proj.dirY * along;
          const offX = m.x - closestX;
          const offY = m.y - closestY;
          if(offX * offX + offY * offY <= effectiveSq){
            hits.push({ target: m, along });
          }
        }
        if(hits.length){
          hits.sort((a, b) => a.along - b.along);
          for(const hit of hits){
            if(proj.hitTargets && proj.hitTargets.has(hit.target)) continue;
            applyChargingGaleHit(proj, hit.target, hit.along);
            if(proj.hitTargets) proj.hitTargets.add(hit.target);
          }
        }
      } else {
        let hitTarget = null;
        let hitAlong = Infinity;
        for(const m of minions){
          if(!m || !isEnemyMinionForPlayer(m)) continue;
          if(m.hp <= 0 || m.portalizing > 0) continue;
          const relX = m.x - proj.startX;
          const relY = m.y - proj.startY;
          const along = relX * proj.dirX + relY * proj.dirY;
          if(along < prevTraveled - minionRadius) continue;
          if(along > clampedNext + minionRadius) continue;
          if(along < -minionRadius || along > range + minionRadius) continue;
          const closestX = proj.startX + proj.dirX * along;
          const closestY = proj.startY + proj.dirY * along;
          const offX = m.x - closestX;
          const offY = m.y - closestY;
          if(offX * offX + offY * offY <= effectiveSq && along < hitAlong){
            hitAlong = along;
            hitTarget = m;
          }
        }
        if(hitTarget){
          applyChargingGaleHit(proj, hitTarget, hitAlong);
          chargingGaleProjectiles.splice(i, 1);
          removed = true;
        }
      }

      if(removed) continue;

      proj.traveled = clampedNext;
      proj.currentX = proj.startX + proj.dirX * clampedNext;
      proj.currentY = proj.startY + proj.dirY * clampedNext;

      if(clampedNext >= range - 0.001){
        if(!proj.announcedHit){
          setHudMessage(`${proj.abilityName || 'Charging Gale'} dissipated.`);
        }
        chargingGaleProjectiles.splice(i, 1);
      }
    }
  }

  const combatSystem = createCombatSystem({
    cullingBarrageChannels,
    cullingBarrageProjectiles,
    projectiles,
    hitsplats,
    player,
    minions,
    minionRadius,
    getSpellOrigin,
    fireCullingBarrageShot,
    endCullingBarrageChannel,
    applyCullingBarrageHit,
    isEnemyMinionForPlayer
  });
  const {
    updateCullingBarrageChannels,
    updateCullingBarrageProjectiles,
    updateProjectiles,
    updateHitSplats
  } = combatSystem;

  function stagePointerPosition(e){
    if(!stage){
      return { x: 0, y: 0 };
    }
    const rect = stage.getBoundingClientRect();
    const width = rect && Number.isFinite(rect.width) ? rect.width : 0;
    const height = rect && Number.isFinite(rect.height) ? rect.height : 0;
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    if(width > 0){
      x = Math.max(0, Math.min(width, x));
    }
    if(height > 0){
      y = Math.max(0, Math.min(height, y));
    }
    const scaleX = width > 0 ? camera.width / width : 1;
    const scaleY = height > 0 ? camera.height / height : 1;
    const worldX = camera.x + x * scaleX;
    const worldY = camera.y + y * scaleY;
    const clampedX = Math.max(0, Math.min(mapState.width, worldX));
    const clampedY = Math.max(0, Math.min(mapState.height, worldY));
    return { x: clampedX, y: clampedY };
  }

  function renderMinimap(force = false){
    if(!minimapCtx || !minimapCanvas){
      return;
    }
    if(perfCounters && typeof perfCounters.minimapRenders === 'number'){
      perfCounters.minimapRenders += 1;
    }
    const now = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
    if(!force && now - minimapState.lastRender < 120){
      return;
    }
    const width = minimapCanvas.width;
    const height = minimapCanvas.height;
    if(!(width > 0) || !(height > 0) || !(mapState.width > 0) || !(mapState.height > 0) || !minimapState.layoutVisible || !(minimapState.effectiveScale > 0)){
      minimapCtx.clearRect(0, 0, width, height);
      minimapState.lastRender = now;
      return;
    }
    minimapState.lastRender = now;
    minimapCtx.clearRect(0, 0, width, height);
    minimapCtx.fillStyle = 'rgba(4, 12, 24, 0.85)';
    minimapCtx.fillRect(0, 0, width, height);
    if(mapState.loaded && img && img.naturalWidth && img.naturalHeight){
      minimapCtx.save();
      minimapCtx.globalAlpha = 0.9;
      const sourceWidth = img.naturalWidth || mapState.width;
      const sourceHeight = img.naturalHeight || mapState.height;
      minimapCtx.drawImage(img, 0, 0, sourceWidth, sourceHeight, 0, 0, width, height);
      minimapCtx.restore();
    }
    const scaleX = width / mapState.width;
    const scaleY = height / mapState.height;
    const scale = Math.min(scaleX, scaleY);
    const drawPoint = (x, y, color, radius = 2.5) => {
      if(!Number.isFinite(x) || !Number.isFinite(y)) return;
      const px = x * scaleX;
      const py = y * scaleY;
      const r = Math.max(radius, radius * scale);
      minimapCtx.beginPath();
      minimapCtx.arc(px, py, Math.max(1.5, r), 0, Math.PI * 2);
      minimapCtx.fillStyle = color;
      minimapCtx.fill();
    };
    const drawDiamond = (x, y, color) => {
      if(!Number.isFinite(x) || !Number.isFinite(y)) return;
      const px = x * scaleX;
      const py = y * scaleY;
      const size = Math.max(4, 9 * scale);
      minimapCtx.beginPath();
      minimapCtx.moveTo(px, py - size);
      minimapCtx.lineTo(px + size, py);
      minimapCtx.lineTo(px, py + size);
      minimapCtx.lineTo(px - size, py);
      minimapCtx.closePath();
      minimapCtx.fillStyle = color;
      minimapCtx.fill();
      minimapCtx.lineWidth = 1;
      minimapCtx.strokeStyle = '#041019';
      minimapCtx.stroke();
    };

    if(customColliders.length){
      minimapCtx.save();
      minimapCtx.globalAlpha = GameState.map.colliders.hidden ? 0 : 0.6;
      for(const collider of customColliders){
        if(!collider) continue;
        const highlight = collider.id === GameState.map.colliders.selectedId;
        const fill = highlight ? '#ff7b7b55' : '#f4a34144';
        const stroke = highlight ? '#ff7b7bcc' : '#f4a341bb';
        const px = collider.x * scaleX;
        const py = collider.y * scaleY;
        if(collider.type === 'capsule'){
          const metrics = ensureCapsuleMetrics(collider);
          const radius = Math.max(1.5, metrics.radius * scale);
          const halfSpan = Math.max(0, metrics.span * scale / 2);
          minimapCtx.save();
          minimapCtx.translate(px, py);
          minimapCtx.rotate(metrics.angle);
          minimapCtx.beginPath();
          if(halfSpan <= 0.5){
            minimapCtx.arc(0, 0, radius, 0, Math.PI * 2);
          } else {
            minimapCtx.moveTo(-halfSpan, -radius);
            minimapCtx.lineTo(halfSpan, -radius);
            minimapCtx.arc(halfSpan, 0, radius, -Math.PI / 2, Math.PI / 2);
            minimapCtx.lineTo(-halfSpan, radius);
            minimapCtx.arc(-halfSpan, 0, radius, Math.PI / 2, -Math.PI / 2);
          }
          minimapCtx.closePath();
          minimapCtx.fillStyle = fill;
          minimapCtx.strokeStyle = stroke;
          minimapCtx.lineWidth = highlight ? 2 : 1.4;
          minimapCtx.fill();
          minimapCtx.stroke();
          minimapCtx.restore();
        } else if(collider.type === 'crescent'){
          const metrics = ensureCrescentMetrics(collider);
          const outerRadius = Math.max(2, metrics.radius * scale);
          const innerRadius = Math.max(0, metrics.innerRadius * scale);
          const innerX = metrics.innerCx * scaleX;
          const innerY = metrics.innerCy * scaleY;
          minimapCtx.beginPath();
          minimapCtx.arc(px, py, outerRadius, 0, Math.PI * 2);
          if(innerRadius > 0.5){
            minimapCtx.moveTo(innerX + innerRadius, innerY);
            minimapCtx.arc(innerX, innerY, innerRadius, 0, Math.PI * 2, true);
          }
          minimapCtx.fillStyle = fill;
          minimapCtx.strokeStyle = stroke;
          minimapCtx.lineWidth = highlight ? 2 : 1.4;
          minimapCtx.fill('evenodd');
          minimapCtx.stroke();
        } else {
          const radius = Math.max(2, (Number(collider.radius) || 0) * scale);
          minimapCtx.beginPath();
          minimapCtx.arc(px, py, radius, 0, Math.PI * 2);
          minimapCtx.fillStyle = fill;
          minimapCtx.strokeStyle = stroke;
          minimapCtx.lineWidth = highlight ? 2 : 1.4;
          minimapCtx.fill();
          minimapCtx.stroke();
        }
      }
      minimapCtx.restore();
    }

    const visionDummyActive = visionDummy && visionDummy.active !== false;
    const practiceDummySize = visionDummyActive ? clampPracticeDummySize(visionDummy.size, practiceDummyDefaults.size) : 0;
    if(customVisionSources.length || (GameState.player.vision.radius > 0) || (visionDummyActive && practiceDummySize > 0)){
      minimapCtx.save();
      minimapCtx.globalAlpha = GameState.player.vision.hidden ? 0 : 0.55;
      for(const source of customVisionSources){
        if(!source) continue;
        ensureVisionConsistency(source);
        const highlight = source.id === GameState.player.vision.selectedId;
        const isHiding = source.mode === 2;
        const fill = highlight
          ? (isHiding ? '#39ff1444' : '#63d7ff44')
          : (isHiding ? '#39ff142e' : '#2f8cff30');
        const stroke = highlight
          ? (isHiding ? '#39ff14cc' : '#63d7ffcc')
          : (isHiding ? '#39ff1499' : '#2f8cffbb');
        const px = source.x * scaleX;
        const py = source.y * scaleY;
        if(source.type === 'capsule'){
          const metrics = ensureCapsuleMetrics(source);
          const radius = Math.max(1.5, metrics.radius * scale);
          const halfSpan = Math.max(0, metrics.span * scale / 2);
          minimapCtx.save();
          minimapCtx.translate(px, py);
          minimapCtx.rotate(metrics.angle);
          minimapCtx.beginPath();
          if(halfSpan <= 0.5){
            minimapCtx.arc(0, 0, radius, 0, Math.PI * 2);
          } else {
            minimapCtx.moveTo(-halfSpan, -radius);
            minimapCtx.lineTo(halfSpan, -radius);
            minimapCtx.arc(halfSpan, 0, radius, -Math.PI / 2, Math.PI / 2);
            minimapCtx.lineTo(-halfSpan, radius);
            minimapCtx.arc(-halfSpan, 0, radius, Math.PI / 2, -Math.PI / 2);
          }
          minimapCtx.closePath();
          minimapCtx.fillStyle = fill;
          minimapCtx.strokeStyle = stroke;
          minimapCtx.lineWidth = highlight ? 2 : 1.4;
          minimapCtx.fill();
          minimapCtx.stroke();
          minimapCtx.restore();
        } else if(source.type === 'crescent'){
          const metrics = ensureCrescentMetrics(source);
          const outerRadius = Math.max(2, metrics.radius * scale);
          const innerRadius = Math.max(0, metrics.innerRadius * scale);
          const innerX = metrics.innerCx * scaleX;
          const innerY = metrics.innerCy * scaleY;
          minimapCtx.beginPath();
          minimapCtx.arc(px, py, outerRadius, 0, Math.PI * 2);
          if(innerRadius > 0.5){
            minimapCtx.moveTo(innerX + innerRadius, innerY);
            minimapCtx.arc(innerX, innerY, innerRadius, 0, Math.PI * 2, true);
          }
          minimapCtx.fillStyle = fill;
          minimapCtx.strokeStyle = stroke;
          minimapCtx.lineWidth = highlight ? 2 : 1.4;
          minimapCtx.fill('evenodd');
          minimapCtx.stroke();
        } else {
          const radius = Math.max(2, (Number(source.radius) || 0) * scale);
          minimapCtx.beginPath();
          minimapCtx.arc(px, py, radius, 0, Math.PI * 2);
          minimapCtx.fillStyle = fill;
          minimapCtx.strokeStyle = stroke;
          minimapCtx.lineWidth = highlight ? 2 : 1.4;
          minimapCtx.fill();
          minimapCtx.stroke();
        }
      }
      if(GameState.player.vision.radius > 0){
        const radius = Math.max(2, GameState.player.vision.radius * scale);
        minimapCtx.beginPath();
        minimapCtx.arc(player.x * scaleX, player.y * scaleY, radius, 0, Math.PI * 2);
        minimapCtx.lineWidth = 1.6;
        minimapCtx.strokeStyle = '#63d7ffb0';
        minimapCtx.setLineDash([6, 5]);
        minimapCtx.stroke();
        minimapCtx.setLineDash([]);
      }
      if(visionDummy && visionDummy.active !== false){
        const dummySize = clampPracticeDummySize(visionDummy.size, practiceDummyDefaults.size);
        const bodyRadius = Math.max(10, dummySize * 0.5);
        const span = Math.max(bodyRadius * 2, dummySize * 2.2);
        const radiusPx = Math.max(2, bodyRadius * scale);
        const halfSpanPx = Math.max(radiusPx, (span * scale) / 2);
        minimapCtx.save();
        minimapCtx.translate(visionDummy.x * scaleX, visionDummy.y * scaleY);
        minimapCtx.beginPath();
        if(halfSpanPx <= radiusPx + 0.5){
          minimapCtx.arc(0, 0, radiusPx, 0, Math.PI * 2);
        } else {
          minimapCtx.moveTo(-halfSpanPx, -radiusPx);
          minimapCtx.lineTo(halfSpanPx, -radiusPx);
          minimapCtx.arc(halfSpanPx, 0, radiusPx, -Math.PI / 2, Math.PI / 2);
          minimapCtx.lineTo(-halfSpanPx, radiusPx);
          minimapCtx.arc(-halfSpanPx, 0, radiusPx, Math.PI / 2, -Math.PI / 2);
        }
        minimapCtx.closePath();
        minimapCtx.lineWidth = 1.4;
        minimapCtx.strokeStyle = '#ff5577b0';
        minimapCtx.setLineDash([6, 5]);
        minimapCtx.stroke();
        minimapCtx.setLineDash([]);
        minimapCtx.restore();
      }
      minimapCtx.restore();
    }

    if(visionDummyActive){
      drawPoint(visionDummy.x, visionDummy.y, '#ff5577', Math.max(2.5, 6 * scale));
    }

    const lanePlanMinimap = ensureLaneLayout();
    if(lanePlanMinimap && lanePlanMinimap.lanes.length){
      minimapCtx.save();
      minimapCtx.lineCap = 'round';
      const drawLanePath = (path, color)=>{
        const points = (path && Array.isArray(path.points) && path.points.length > 1)
          ? path.points
          : (path ? [path.from, path.to] : null);
        if(points && points.length > 1){
          minimapCtx.beginPath();
          minimapCtx.moveTo(points[0].x * scaleX, points[0].y * scaleY);
          for(let i=1;i<points.length;i++){
            minimapCtx.lineTo(points[i].x * scaleX, points[i].y * scaleY);
          }
          minimapCtx.lineWidth = Math.max(2, 5 * scale);
          minimapCtx.strokeStyle = color;
          minimapCtx.stroke();
        }
      };

      for(const lane of lanePlanMinimap.lanes){
        const blueColor = (lane.bluePath && lane.bluePath.teamColor) || teamColorForSide('blue');
        const redColor = (lane.redPath && lane.redPath.teamColor) || teamColorForSide('red');
        const laneColor = lane.teamColor
          ? lane.teamColor
          : ((lane.bluePath && lane.bluePath.teamColor) || (lane.redPath && lane.redPath.teamColor) || blueColor || redColor || '#32d97c');

        if(lane.bluePath){
          drawLanePath(lane.bluePath, blueColor);
        }
        if(lane.redPath && lane.redPath !== lane.bluePath){
          drawLanePath(lane.redPath, redColor);
        }

        const midX = lane.middle.x * scaleX;
        const midY = lane.middle.y * scaleY;
        const radius = Math.max(6, 14 * scale);
        minimapCtx.beginPath();
        minimapCtx.arc(midX, midY, radius, 0, Math.PI * 2);
        minimapCtx.globalAlpha = 0.22;
        minimapCtx.fillStyle = laneColor;
        minimapCtx.fill();
        minimapCtx.globalAlpha = 1;
        minimapCtx.lineWidth = Math.max(1.6, 3 * scale);
        minimapCtx.strokeStyle = laneColor;
        minimapCtx.stroke();
        minimapCtx.fillStyle = '#d7ffde';
        minimapCtx.font = `bold ${Math.max(8, Math.round((radius + 2) * 0.9))}px system-ui`;
        minimapCtx.textAlign = 'center';
        minimapCtx.textBaseline = 'middle';
        minimapCtx.fillText(lane.label, midX, midY + Math.max(0.5, scale * 0.8));

        if(Array.isArray(lane.breaks) && lane.breaks.length){
          const breakRadius = Math.max(4, 10 * scale);
          for(const bp of lane.breaks){
            minimapCtx.beginPath();
            minimapCtx.arc(bp.x * scaleX, bp.y * scaleY, breakRadius, 0, Math.PI * 2);
            minimapCtx.fillStyle = '#041019';
            minimapCtx.fill();
            minimapCtx.lineWidth = Math.max(1.4, 2.5 * scale);
            minimapCtx.strokeStyle = laneColor;
            minimapCtx.stroke();
          }
        }
      }
      minimapCtx.restore();
    }

    const turretList = ensureTurrets();
    if(turretList.length){
      minimapCtx.save();
      minimapCtx.lineWidth = 1.6;
      for(const turret of turretList){
        if(!turret) continue;
        const px = turret.x * scaleX;
        const py = turret.y * scaleY;
        const size = Math.max(4, 8 * scale);
        const markerColor = turret.teamColor || teamColorForSide(turret.side);
        minimapCtx.beginPath();
        minimapCtx.rect(px - size / 2, py - size / 2, size, size);
        minimapCtx.fillStyle = markerColor;
        minimapCtx.fill();
        minimapCtx.strokeStyle = '#041019';
        minimapCtx.stroke();
      }
      minimapCtx.restore();
    }

    if(blueSpawns[0]){
      drawDiamond(blueSpawns[0].x, blueSpawns[0].y, '#2aa9ff');
    }
    if(redSpawns[0]){
      drawDiamond(redSpawns[0].x, redSpawns[0].y, '#ff5577');
    }

    for(const m of minions){
      if(!m) continue;
      if(m.isPracticeDummy && (m.active === false || (m.respawnTimer > 0) || !(Number(m.hp) > 0))){
        continue;
      }
      if(!pointInVision(m.x, m.y, minionRadius)) continue;
      const color = m.side === 'red' ? '#ff5577' : '#2aa9ff';
      drawPoint(m.x, m.y, color, Math.max(2, minionRadius * scale));
    }

    let playerRef = null;
    try {
      playerRef = player;
    } catch (err) {
      playerRef = null;
    }
    if(playerRef){
      drawPoint(playerRef.x, playerRef.y, '#f7ff7a', Math.max(3, playerRef.r * scale));
    }

    const viewX = camera.x * scaleX;
    const viewY = camera.y * scaleY;
    const viewW = camera.width * scaleX;
    const viewH = camera.height * scaleY;
    const clampedViewX = Math.max(0, Math.min(width, viewX));
    const clampedViewY = Math.max(0, Math.min(height, viewY));
    const clampedViewW = Math.max(0, Math.min(width - clampedViewX, viewW));
    const clampedViewH = Math.max(0, Math.min(height - clampedViewY, viewH));
    minimapCtx.fillStyle = 'rgba(255, 255, 255, 0.08)';
    minimapCtx.fillRect(clampedViewX, clampedViewY, clampedViewW, clampedViewH);
    minimapCtx.lineWidth = 1.5;
    minimapCtx.strokeStyle = '#ffffffcc';
    minimapCtx.strokeRect(clampedViewX, clampedViewY, clampedViewW, clampedViewH);

    minimapCtx.lineWidth = 2;
    minimapCtx.strokeStyle = 'rgba(58, 84, 122, 0.9)';
    minimapCtx.strokeRect(1, 1, width - 2, height - 2);
  }

  function minimapEventToWorld(event){
    if(!minimapCanvas || !minimapState.layoutVisible || !(minimapState.effectiveScale > 0)){
      return null;
    }
    const rect = minimapCanvas.getBoundingClientRect();
    const width = rect && Number.isFinite(rect.width) ? rect.width : 0;
    const height = rect && Number.isFinite(rect.height) ? rect.height : 0;
    if(!(width > 0) || !(height > 0) || !(mapState.width > 0) || !(mapState.height > 0)){
      return null;
    }
    const relX = (event.clientX - rect.left) / width;
    const relY = (event.clientY - rect.top) / height;
    const worldX = Math.max(0, Math.min(mapState.width, relX * mapState.width));
    const worldY = Math.max(0, Math.min(mapState.height, relY * mapState.height));
    return { x: worldX, y: worldY };
  }

  function handleMinimapPointer(event, { flash = false } = {}){
    if(!minimapState.clickToMoveEnabled){
      return;
    }
    const coords = minimapEventToWorld(event);
    if(!coords){
      return;
    }
    issuePlayerMoveOrder(coords.x, coords.y, { flashPulse: flash, updateHud: true });
  }

  if(minimapCanvas){
    const endMinimapPointer = (event) => {
      if(event && minimapState.pointerId !== null && Number.isFinite(event.pointerId) && event.pointerId !== minimapState.pointerId){
        return;
      }
      minimapState.pointerActive = false;
      minimapState.pointerId = null;
    };
    minimapCanvas.addEventListener('pointerdown', (event) => {
      if(event.button !== 0){
        return;
      }
      if(!minimapState.layoutVisible || !(minimapState.effectiveScale > 0)){
        return;
      }
      if(minimapState.clickThroughEnabled){
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if(!minimapState.clickToMoveEnabled){
        return;
      }
      minimapState.pointerActive = true;
      minimapState.pointerId = Number.isFinite(event.pointerId) ? event.pointerId : null;
      try {
        minimapCanvas.setPointerCapture(event.pointerId);
      } catch (err) {
        /* ignore */
      }
      handleMinimapPointer(event, { flash: true });
    });
    minimapCanvas.addEventListener('pointermove', (event) => {
      if(!minimapState.pointerActive){
        return;
      }
      if(minimapState.pointerId !== null && event.pointerId !== minimapState.pointerId){
        return;
      }
      if(!minimapState.layoutVisible || !(minimapState.effectiveScale > 0)){
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if(!minimapState.clickToMoveEnabled){
        return;
      }
      handleMinimapPointer(event);
    });
    minimapCanvas.addEventListener('pointerup', (event) => {
      if(minimapState.pointerId !== null && event.pointerId !== minimapState.pointerId){
        return;
      }
      if(minimapState.pointerActive || minimapState.pointerId !== null){
        event.preventDefault();
        event.stopPropagation();
      }
      try {
        minimapCanvas.releasePointerCapture(event.pointerId);
      } catch (err) {
        /* ignore */
      }
      endMinimapPointer(event);
    });
    minimapCanvas.addEventListener('pointercancel', (event) => {
      if(minimapState.pointerId !== null && event.pointerId !== minimapState.pointerId){
        return;
      }
      try {
        minimapCanvas.releasePointerCapture(event.pointerId);
      } catch (err) {
        /* ignore */
      }
      endMinimapPointer(event);
    });
    minimapCanvas.addEventListener('lostpointercapture', () => {
      minimapState.pointerActive = false;
      minimapState.pointerId = null;
    });
  }

  function issuePlayerMoveOrder(x, y, { flashPulse = false, updateHud = false } = {}){
    if(isPlayerRecalling()){
      cancelRecall('move');
    }
    if(!flashPulse){
      const currentGoal = player.navGoal;
      if(currentGoal && Math.abs(currentGoal.x - x) < 0.5 && Math.abs(currentGoal.y - y) < 0.5){
        return;
      }
    }
    cancelPlayerAttack();
    setPlayerDestination(x, y);
    if(flashPulse){
      flash(x, y, {
        startRadius: player.moveCircleStart,
        endRadius: player.moveCircleEnd,
        color: player.moveCircleColor
      });
    }
    if(updateHud){
      setHudMessage();
    }
  }

  function stopStagePointerOrdering(){
    if(abilityRuntime.stagePointerOrdering && stage && abilityRuntime.activePointerId !== null){
      try {
        stage.releasePointerCapture(abilityRuntime.activePointerId);
      } catch (err) {
        /* ignore */
      }
    }
    abilityRuntime.stagePointerOrdering = false;
    abilityRuntime.activePointerId = null;
  }

  function stopLaneDrag({ finalize = true } = {}){
    if(!laneDragState.dragging){
      return;
    }
    const pointerId = laneDragState.pointerId;
    laneDragState.dragging = false;
    laneDragState.pointerId = null;
    const laneIndex = laneDragState.laneIndex;
    laneDragState.breakIndex = null;
    laneDragState.mode = null;
    laneDragState.laneIndex = null;
    if(stage && Number.isFinite(pointerId)){
      try { stage.releasePointerCapture(pointerId); } catch (err) { /* ignore */ }
    }
    if(finalize && Number.isInteger(laneIndex) && laneIndex >= 0){
      invalidateLaneLayout({ resetMinions: true });
    }
  }

  function stopPortalDrag({ finalize = true } = {}){
    if(!portalDragState.dragging){
      return;
    }
    const pointerId = portalDragState.pointerId;
    const side = portalDragState.side;
    portalDragState.dragging = false;
    portalDragState.pointerId = null;
    portalDragState.side = null;
    portalDragState.offsetX = 0;
    portalDragState.offsetY = 0;
    if(stage && Number.isFinite(pointerId)){
      try { stage.releasePointerCapture(pointerId); } catch (err) { /* ignore */ }
    }
    if(finalize && side){
      invalidateLaneLayout({ resetMinions: false });
    }
  }

  function stopTurretDrag({ finalize = true } = {}){
    if(!turretDragState.dragging){
      return;
    }
    const pointerId = turretDragState.pointerId;
    const turretId = turretDragState.turretId;
    turretDragState.dragging = false;
    turretDragState.pointerId = null;
    turretDragState.turretId = null;
    if(stage && Number.isFinite(pointerId)){
      try { stage.releasePointerCapture(pointerId); } catch (err) { /* ignore */ }
    }
    if(finalize && Number.isInteger(turretId)){
      const turret = findTurretById(turretId);
      if(turret){
        applyTurretDrag(turret, turret.x, turret.y, { finalize: true });
      }
    }
  }

  // Clicks
  stage.addEventListener('pointerdown', (e)=>{
    updateStagePointerState(e);
    if(e.button === 1){
      e.preventDefault();
      startCameraDrag(e);
      stopStagePointerOrdering();
      return;
    }
    if(e.button === 2){
      if(cancelSkillshotIndicator({ reason: 'pointerCancel' })){
        e.preventDefault();
      }
      stopStagePointerOrdering();
      return;
    }
    if(e.button !== 0){
      return;
    }
    const targetEl = e.target instanceof Element ? e.target : null;
    if(targetEl && targetEl.closest('[data-stage-ignore-click="true"], button, input, select, textarea, [role="button"], [contenteditable="true"]')){
      return;
    }
    const { x, y } = stagePointerPosition(e);
    abilityRuntime.lastPointerWorld = { x, y };
    const pointerId = Number.isFinite(e.pointerId) ? e.pointerId : null;
    if(monsterDragState.dragging && (monsterDragState.pointerId === null || monsterDragState.pointerId === pointerId)){
      e.preventDefault();
      return;
    }
    if(monsterDragState.active){
      e.preventDefault();
      stopStagePointerOrdering();
      beginMonsterDrag(pointerId, x, y);
      if(stage && monsterDragState.pointerId !== null){
        try { stage.setPointerCapture(monsterDragState.pointerId); } catch (err) { /* ignore */ }
      }
      return;
    }

    if(!GameState.spawns.placing){
      const portalHit = hitTestPortal(x, y);
      if(portalHit){
        e.preventDefault();
        stopStagePointerOrdering();
        portalDragState.dragging = true;
        portalDragState.pointerId = pointerId;
        portalDragState.side = portalHit.side;
        portalDragState.offsetX = portalHit.spawn.x - x;
        portalDragState.offsetY = portalHit.spawn.y - y;
        applyPortalDrag(portalHit.side, x + portalDragState.offsetX, y + portalDragState.offsetY, { finalize: false });
        if(stage && portalDragState.pointerId !== null){
          try { stage.setPointerCapture(portalDragState.pointerId); } catch (err) { /* ignore */ }
        }
        return;
      }
    }

    const turretHit = hitTestTurret(x, y);
    if(turretHit){
      e.preventDefault();
      stopStagePointerOrdering();
      turretDragState.dragging = true;
      turretDragState.pointerId = pointerId;
      turretDragState.turretId = turretHit.id;
      applyTurretDrag(turretHit, x, y, { finalize: false });
      if(stage && turretDragState.pointerId !== null){
        try { stage.setPointerCapture(turretDragState.pointerId); } catch (err) { /* ignore */ }
      }
      return;
    }

    const laneBreakHit = hitTestLaneBreak(x, y);
    if(laneBreakHit && laneBreakHit.lane){
      e.preventDefault();
      stopStagePointerOrdering();
      laneDragState.dragging = true;
      laneDragState.pointerId = pointerId;
      laneDragState.laneIndex = laneBreakHit.lane.index;
      laneDragState.breakIndex = laneBreakHit.breakIndex;
      laneDragState.mode = 'break';
      applyLaneBreakDrag(laneBreakHit.lane, laneBreakHit.layout, laneBreakHit.breakIndex, x, y);
      if(stage && laneDragState.pointerId !== null){
        try { stage.setPointerCapture(laneDragState.pointerId); } catch (err) { /* ignore */ }
      }
      return;
    }

    const laneHit = hitTestLaneHandle(x, y);
    if(laneHit && laneHit.lane){
      e.preventDefault();
      stopStagePointerOrdering();
      laneDragState.dragging = true;
      laneDragState.pointerId = pointerId;
      laneDragState.laneIndex = laneHit.lane.index;
      laneDragState.breakIndex = null;
      laneDragState.mode = 'middle';
      applyLaneHandleDrag(laneHit.lane, laneHit.layout, x, y);
      if(stage && laneDragState.pointerId !== null){
        try { stage.setPointerCapture(laneDragState.pointerId); } catch (err) { /* ignore */ }
      }
      return;
    }

    if(practiceDummyState.placing){
      e.preventDefault();
      placePracticeDummyAt(x, y);
      practiceDummyState.placing = false;
      updatePracticeDummyUiState();
      return;
    }
    const dummyRespawning = practiceDummy && practiceDummy.respawnTimer > 0;
    const dummyActive = practiceDummy && practiceDummy.active !== false && !dummyRespawning;
    const insideDummy = dummyActive && isPointerInsidePracticeDummy(x, y);
    if(insideDummy){
      e.preventDefault();
      if(practiceDummyState.selected !== true){
        practiceDummyState.selected = true;
        updatePracticeDummyUiState();
      }
      practiceDummyState.dragging = true;
      practiceDummyState.pointerId = pointerId;
      practiceDummyState.dragOffset.x = practiceDummy.x - x;
      practiceDummyState.dragOffset.y = practiceDummy.y - y;
      if(stage && practiceDummyState.pointerId !== null){
        try { stage.setPointerCapture(practiceDummyState.pointerId); } catch (err) { /* ignore */ }
      }
      return;
    }
    if(practiceDummyState.selected){
      practiceDummyState.selected = false;
      updatePracticeDummyUiState();
    }

    if(GameState.player.vision.editMode){
      e.preventDefault();
      stopStagePointerOrdering();
      const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
      if(GameState.player.vision.dummyState.placing){
        visionDummy.active = true;
        visionDummy.x = clampCoord(x, mapState.width);
        visionDummy.y = clampCoord(y, mapState.height);
        GameState.player.vision.dummyState.placing = false;
        updateVisionUiState();
        renderMinimap(true);
        return;
      }
      if(GameState.player.vision.placing){
        const created = addVisionAt(clampCoord(x, mapState.width), clampCoord(y, mapState.height));
        GameState.player.vision.placing = false;
        updateVisionUiState();
        GameState.player.vision.draggingId = created ? created.id : null;
        GameState.player.vision.dragOffset.x = 0;
        GameState.player.vision.dragOffset.y = 0;
        GameState.player.vision.dragMoved = false;
        GameState.player.vision.pointerId = pointerId;
        if(stage && GameState.player.vision.pointerId !== null){
          try { stage.setPointerCapture(GameState.player.vision.pointerId); } catch (err) { /* ignore */ }
        }
        return;
      }
      const dummyActive = visionDummy && visionDummy.active !== false;
      if(dummyActive){
        const threshold = practiceDummyDragThreshold();
        const dist = Math.hypot(x - visionDummy.x, y - visionDummy.y);
        if(dist <= threshold){
          selectVision(null);
          GameState.player.vision.dummyState.dragging = true;
          GameState.player.vision.dummyState.pointerId = pointerId;
          GameState.player.vision.dummyState.dragOffset.x = visionDummy.x - x;
          GameState.player.vision.dummyState.dragOffset.y = visionDummy.y - y;
          if(stage && GameState.player.vision.dummyState.pointerId !== null){
            try { stage.setPointerCapture(GameState.player.vision.dummyState.pointerId); } catch (err) { /* ignore */ }
          }
          return;
        }
      }
      const hitVision = findVisionAt(x, y, 6);
      if(hitVision){
        selectVision(hitVision.id);
        GameState.player.vision.draggingId = hitVision.id;
        GameState.player.vision.dragOffset.x = hitVision.x - x;
        GameState.player.vision.dragOffset.y = hitVision.y - y;
        GameState.player.vision.dragMoved = false;
        GameState.player.vision.pointerId = pointerId;
        if(stage && GameState.player.vision.pointerId !== null){
          try { stage.setPointerCapture(GameState.player.vision.pointerId); } catch (err) { /* ignore */ }
        }
      } else {
        selectVision(null);
        GameState.player.vision.draggingId = null;
        GameState.player.vision.pointerId = pointerId;
      }
      return;
    }

    if(GameState.map.colliders.editMode){
      e.preventDefault();
      stopStagePointerOrdering();
      const pointerId = Number.isFinite(e.pointerId) ? e.pointerId : null;
      if(GameState.map.colliders.placing){
        const created = addColliderAt(x, y);
        GameState.map.colliders.placing = false;
        updateColliderUiState();
        GameState.map.colliders.draggingId = created ? created.id : null;
        GameState.map.colliders.dragOffset.x = 0;
        GameState.map.colliders.dragOffset.y = 0;
        GameState.map.colliders.dragMoved = false;
        GameState.map.colliders.pointerId = pointerId;
        if(stage && GameState.map.colliders.pointerId !== null){
          try { stage.setPointerCapture(GameState.map.colliders.pointerId); } catch (err) { /* ignore */ }
        }
        return;
      }
      const hit = findColliderAt(x, y, 6);
      if(hit){
        selectCollider(hit.id);
        GameState.map.colliders.draggingId = hit.id;
        GameState.map.colliders.dragOffset.x = hit.x - x;
        GameState.map.colliders.dragOffset.y = hit.y - y;
        GameState.map.colliders.dragMoved = false;
        GameState.map.colliders.pointerId = pointerId;
        if(stage && GameState.map.colliders.pointerId !== null){
          try { stage.setPointerCapture(GameState.map.colliders.pointerId); } catch (err) { /* ignore */ }
        }
      } else {
        selectCollider(null);
        GameState.map.colliders.draggingId = null;
        GameState.map.colliders.pointerId = pointerId;
      }
      return;
    }

    if (GameState.spawns.placing){
      const list = GameState.spawns.placing==='blue'?blueSpawns:redSpawns;
      list.length = 0; // keep single
      list.push({x, y, userPlaced: true});
      setHudMessage((GameState.spawns.placing.toUpperCase())+` spawn set at (${x|0}, ${y|0})`);
      invalidateLaneLayout({ resetMinions: true });
      clearAllNavigation();
      GameState.spawns.placing = null;
      stopStagePointerOrdering();
      return;
    }
    const artilleryMode = activeArcaneRiteModeForCaster(player);
    if(artilleryMode){
      e.preventDefault();
      stopStagePointerOrdering();
      scheduleArcaneRiteExplosion(artilleryMode, x, y);
      return;
    }
    const target = findAutoAttackTargetAt(x, y);
    if(target){
      cancelPlayerAttack();
      if(commandPlayerAttack(target)){
        flash(target.x, target.y);
      }
      setHudMessage();
      stopStagePointerOrdering();
      return;
    }
    abilityRuntime.stagePointerOrdering = true;
    abilityRuntime.activePointerId = Number.isFinite(e.pointerId) ? e.pointerId : null;
    if(stage && abilityRuntime.activePointerId !== null){
      try {
        stage.setPointerCapture(abilityRuntime.activePointerId);
      } catch (err) {
        /* ignore */
      }
    }
    issuePlayerMoveOrder(x, y, { flashPulse: true, updateHud: true });
  });

  stage.addEventListener('pointermove', (e)=>{
    updateStagePointerState(e);
    if(cameraDragActive && (cameraDragPointerId === null || cameraDragPointerId === e.pointerId)){
      clearHoverTarget();
      e.preventDefault();
      if(cameraDragLast){
        const rect = stage.getBoundingClientRect();
        const dx = e.clientX - cameraDragLast.clientX;
        const dy = e.clientY - cameraDragLast.clientY;
        cameraDragLast = { clientX: e.clientX, clientY: e.clientY };
        camera.drag.last = cameraDragLast ? { ...cameraDragLast } : null;
        const width = rect && Number.isFinite(rect.width) ? rect.width : 0;
        const height = rect && Number.isFinite(rect.height) ? rect.height : 0;
        if(width > 0 && height > 0){
          const worldPerPixelX = camera.width / width;
          const worldPerPixelY = camera.height / height;
          applyManualCameraOffset(dx * worldPerPixelX, dy * worldPerPixelY);
        }
      } else {
        cameraDragLast = { clientX: e.clientX, clientY: e.clientY };
        camera.drag.last = cameraDragLast ? { ...cameraDragLast } : null;
      }
      return;
    }
    const { x, y } = stagePointerPosition(e);
    abilityRuntime.lastPointerWorld = { x, y };
    if(monsterDragState.dragging && (monsterDragState.pointerId === null || monsterDragState.pointerId === e.pointerId)){
      clearHoverTarget();
      e.preventDefault();
      updateMonsterDragPosition(x, y);
      return;
    }
    if(portalDragState.dragging && (portalDragState.pointerId === null || portalDragState.pointerId === e.pointerId)){
      clearHoverTarget();
      e.preventDefault();
      const side = portalDragState.side;
      if(side){
        applyPortalDrag(side, x + portalDragState.offsetX, y + portalDragState.offsetY, { finalize: false });
      }
      return;
    }
    if(turretDragState.dragging && (turretDragState.pointerId === null || turretDragState.pointerId === e.pointerId)){
      clearHoverTarget();
      e.preventDefault();
      const turret = findTurretById(turretDragState.turretId);
      if(turret){
        applyTurretDrag(turret, x, y, { finalize: false });
      }
      return;
    }
    if(laneDragState.dragging && (laneDragState.pointerId === null || laneDragState.pointerId === e.pointerId)){
      clearHoverTarget();
      e.preventDefault();
      const layout = ensureLaneLayout();
      const lane = layout && Array.isArray(layout.lanes) ? layout.lanes.find(l => l && l.index === laneDragState.laneIndex) : null;
      if(lane){
        if(laneDragState.mode === 'break' && Number.isInteger(laneDragState.breakIndex)){
          applyLaneBreakDrag(lane, layout, laneDragState.breakIndex, x, y);
        } else {
          applyLaneHandleDrag(lane, layout, x, y);
        }
      }
      return;
    }
    if(practiceDummyState.dragging && (practiceDummyState.pointerId === null || practiceDummyState.pointerId === e.pointerId)){
      clearHoverTarget();
      e.preventDefault();
      placePracticeDummyAt(x + practiceDummyState.dragOffset.x, y + practiceDummyState.dragOffset.y);
      return;
    }
    if(GameState.player.vision.editMode){
      if(GameState.player.vision.dummyState.dragging && (GameState.player.vision.dummyState.pointerId === null || GameState.player.vision.dummyState.pointerId === e.pointerId)){
        clearHoverTarget();
        e.preventDefault();
        const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
        visionDummy.x = clampCoord(x + GameState.player.vision.dummyState.dragOffset.x, mapState.width);
        visionDummy.y = clampCoord(y + GameState.player.vision.dummyState.dragOffset.y, mapState.height);
        renderMinimap(true);
      } else if(GameState.player.vision.draggingId !== null && (GameState.player.vision.pointerId === null || GameState.player.vision.pointerId === e.pointerId)){
        clearHoverTarget();
        e.preventDefault();
        const source = getVisionByIdValue(GameState.player.vision.draggingId);
        if(source){
          const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
          source.x = clampCoord(x + GameState.player.vision.dragOffset.x, mapState.width);
          source.y = clampCoord(y + GameState.player.vision.dragOffset.y, mapState.height);
          GameState.player.vision.dragMoved = true;
          renderMinimap(true);
        }
      }
      return;
    }
    if(GameState.map.colliders.editMode){
      if(GameState.map.colliders.draggingId !== null && (GameState.map.colliders.pointerId === null || GameState.map.colliders.pointerId === e.pointerId)){
        clearHoverTarget();
        e.preventDefault();
        const collider = getColliderByIdValue(GameState.map.colliders.draggingId);
        if(collider){
          collider.x = Math.max(0, Math.min(mapState.width, x + GameState.map.colliders.dragOffset.x));
          collider.y = Math.max(0, Math.min(mapState.height, y + GameState.map.colliders.dragOffset.y));
          GameState.map.colliders.dragMoved = true;
          renderMinimap(true);
        }
      }
      return;
    }
    if(activeArcaneRiteModeForCaster(player)){
      if(abilityRuntime.stagePointerOrdering){
        stopStagePointerOrdering();
      }
      clearHoverTarget();
      return;
    }
    if(abilityRuntime.stagePointerOrdering){
      issuePlayerMoveOrder(x, y);
      updateHoverTargetFromPosition(x, y);
      return;
    }
    updateHoverTargetFromPosition(x, y);
  });
  stage.addEventListener('pointerup', (e) => {
    updateStagePointerState(e);
    if(portalDragState.dragging && (portalDragState.pointerId === null || portalDragState.pointerId === e.pointerId)){
      stopPortalDrag({ finalize: true });
      return;
    }
    if(turretDragState.dragging && (turretDragState.pointerId === null || turretDragState.pointerId === e.pointerId)){
      stopTurretDrag({ finalize: true });
      return;
    }
    if(laneDragState.dragging && (laneDragState.pointerId === null || laneDragState.pointerId === e.pointerId)){
      stopLaneDrag({ finalize: true });
      return;
    }
    if(monsterDragState.dragging && (monsterDragState.pointerId === null || monsterDragState.pointerId === e.pointerId)){
      endMonsterDrag({ commit: true });
      return;
    }
    if(monsterDragState.active){
      cancelMonsterDrag();
    }
    if(practiceDummyState.dragging && (practiceDummyState.pointerId === null || practiceDummyState.pointerId === e.pointerId)){
      stopVisionDummyDrag();
      updatePracticeDummyUiState();
      return;
    }
    if(practiceDummyState.placing){
      practiceDummyState.placing = false;
      updatePracticeDummyUiState();
    }
    if(GameState.player.vision.editMode){
      if(GameState.player.vision.dummyState.dragging && (GameState.player.vision.dummyState.pointerId === null || GameState.player.vision.dummyState.pointerId === e.pointerId)){
        stopVisionDummyDrag();
        updateVisionUiState();
        return;
      }
      if(GameState.player.vision.pointerId === null || GameState.player.vision.pointerId === e.pointerId){
        if(GameState.player.vision.dragMoved){
          onVisionsChanged();
        }
        stopVisionDrag();
        GameState.player.vision.placing = false;
        updateVisionUiState();
        if(stage && Number.isFinite(e.pointerId)){
          try { stage.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
        }
      }
      return;
    }
    if(GameState.map.colliders.editMode){
      if(GameState.map.colliders.pointerId === null || GameState.map.colliders.pointerId === e.pointerId){
        if(GameState.map.colliders.dragMoved){
          onCollidersChanged();
        }
        stopColliderDrag();
        GameState.map.colliders.placing = false;
        updateColliderUiState();
        if(stage && Number.isFinite(e.pointerId)){
          try { stage.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
        }
      }
      return;
    }
    stopCameraDrag();
    stopStagePointerOrdering();
  });
  stage.addEventListener('pointercancel', (e) => {
    updateStagePointerState(e);
    if(portalDragState.dragging && (portalDragState.pointerId === null || portalDragState.pointerId === e.pointerId)){
      stopPortalDrag({ finalize: true });
      return;
    }
    if(turretDragState.dragging && (turretDragState.pointerId === null || turretDragState.pointerId === e.pointerId)){
      stopTurretDrag({ finalize: true });
      return;
    }
    if(monsterDragState.dragging && (monsterDragState.pointerId === null || monsterDragState.pointerId === e.pointerId)){
      cancelMonsterDrag();
      return;
    }
    if(monsterDragState.active){
      cancelMonsterDrag();
    }
    if(practiceDummyState.dragging && (practiceDummyState.pointerId === null || practiceDummyState.pointerId === e.pointerId)){
      stopVisionDummyDrag();
      updatePracticeDummyUiState();
      return;
    }
    if(practiceDummyState.placing){
      practiceDummyState.placing = false;
      updatePracticeDummyUiState();
    }
    if(GameState.player.vision.editMode){
      if(GameState.player.vision.dummyState.dragging && (GameState.player.vision.dummyState.pointerId === null || GameState.player.vision.dummyState.pointerId === e.pointerId)){
        stopVisionDummyDrag();
      }
      if(GameState.player.vision.pointerId === null || GameState.player.vision.pointerId === e.pointerId){
        stopVisionDrag();
        GameState.player.vision.placing = false;
      }
      updateVisionUiState();
      return;
    }
    if(GameState.map.colliders.editMode){
      stopColliderDrag();
      GameState.map.colliders.placing = false;
      updateColliderUiState();
      return;
    }
    stopCameraDrag();
    stopStagePointerOrdering();
  });
  stage.addEventListener('contextmenu', (e) => {
    if(cancelSkillshotIndicator({ reason: 'pointerCancel' })){
      e.preventDefault();
    }
  });
  stage.addEventListener('lostpointercapture', (e) => {
    updateStagePointerState(e);
    if(portalDragState.dragging && (portalDragState.pointerId === null || portalDragState.pointerId === e.pointerId)){
      stopPortalDrag({ finalize: true });
      return;
    }
    if(turretDragState.dragging && (turretDragState.pointerId === null || turretDragState.pointerId === e.pointerId)){
      stopTurretDrag({ finalize: true });
      return;
    }
    if(laneDragState.dragging && (laneDragState.pointerId === null || laneDragState.pointerId === e.pointerId)){
      stopLaneDrag({ finalize: true });
      return;
    }
    if(monsterDragState.dragging && (monsterDragState.pointerId === null || monsterDragState.pointerId === e.pointerId)){
      cancelMonsterDrag();
      return;
    }
    if(monsterDragState.active){
      cancelMonsterDrag();
    }
    if(practiceDummyState.dragging && (practiceDummyState.pointerId === null || practiceDummyState.pointerId === e.pointerId)){
      stopVisionDummyDrag();
      updatePracticeDummyUiState();
      return;
    }
    if(GameState.player.vision.editMode){
      if(GameState.player.vision.dummyState.dragging && (GameState.player.vision.dummyState.pointerId === null || GameState.player.vision.dummyState.pointerId === e.pointerId)){
        stopVisionDummyDrag();
        updateVisionUiState();
        return;
      }
      if(GameState.player.vision.pointerId === null || GameState.player.vision.pointerId === e.pointerId){
        stopVisionDrag();
        GameState.player.vision.placing = false;
        updateVisionUiState();
      }
      return;
    }
    if(GameState.map.colliders.editMode){
      if(GameState.map.colliders.pointerId === null || GameState.map.colliders.pointerId === e.pointerId){
        stopColliderDrag();
        GameState.map.colliders.placing = false;
        updateColliderUiState();
      }
      return;
    }
    stopCameraDrag();
    stopStagePointerOrdering();
  });
  stage.addEventListener('wheel', (e) => {
    if(e.ctrlKey){
      return;
    }
    if(!(cameraWheelSensitivity > 0)){
      return;
    }
    updateStagePointerState(e);
    const deltaY = e.deltaY;
    if(!Number.isFinite(deltaY) || deltaY === 0){
      return;
    }
    e.preventDefault();
    const rect = stage.getBoundingClientRect();
    const width = rect && Number.isFinite(rect.width) ? rect.width : 0;
    const height = rect && Number.isFinite(rect.height) ? rect.height : 0;
    const pointerNx = width > 0 ? Math.max(0, Math.min(1, (e.clientX - rect.left) / width)) : 0.5;
    const pointerNy = height > 0 ? Math.max(0, Math.min(1, (e.clientY - rect.top) / height)) : 0.5;
    const anchor = stagePointerPosition(e);
    const basePercent = camera.scale * 100;
    const baseStep = Math.max(0, Number(cameraWheelSensitivity) || 0);
    if(!(baseStep > 0)){
      return;
    }
    const magnitude = Math.min(3, Math.abs(deltaY) / 100) || 1;
    const change = baseStep * magnitude;
    const direction = deltaY > 0 ? 1 : -1;
    const nextPercent = basePercent - change * direction;
    const zoomChanged = setCameraZoom(nextPercent, { syncInput: true, instant: false });
    if(!zoomChanged){
      return;
    }
    if(camera.mode !== 'locked'){
      const desiredX = anchor.x - pointerNx * camera.width;
      const desiredY = anchor.y - pointerNy * camera.height;
      const deltaX = desiredX - camera.x;
      const deltaYCam = desiredY - camera.y;
      if(Math.abs(deltaX) > 0.01 || Math.abs(deltaYCam) > 0.01){
        applyManualCameraOffset(deltaX, deltaYCam, { immediate: true });
      }
    } else {
      recenterCamera({ force: true });
    }
  }, { passive: false });
  stage.addEventListener('pointerenter', (e) => updateStagePointerState(e));
  stage.addEventListener('pointerleave', (e) => {
    stagePointerState.inside = false;
    clearHoverTarget();
    refreshStageCursor();
    if(portalDragState.dragging && (portalDragState.pointerId === null || portalDragState.pointerId === (e && e.pointerId))){
      stopPortalDrag({ finalize: true });
    }
    if(turretDragState.dragging && (turretDragState.pointerId === null || turretDragState.pointerId === (e && e.pointerId))){
      stopTurretDrag({ finalize: true });
    }
    if(laneDragState.dragging && (laneDragState.pointerId === null || laneDragState.pointerId === (e && e.pointerId))){
      stopLaneDrag();
    }
    if(GameState.map.colliders.editMode){
      stopColliderDrag();
      GameState.map.colliders.placing = false;
      updateColliderUiState();
      return;
    }
    stopCameraDrag();
  });
  window.addEventListener('pointerup', (e) => {
    stagePointerState.inside = false;
    clearHoverTarget();
    refreshStageCursor();
    if(portalDragState.dragging && (portalDragState.pointerId === null || portalDragState.pointerId === e.pointerId)){
      stopPortalDrag({ finalize: true });
    }
    if(turretDragState.dragging && (turretDragState.pointerId === null || turretDragState.pointerId === e.pointerId)){
      stopTurretDrag({ finalize: true });
    }
    if(laneDragState.dragging && (laneDragState.pointerId === null || laneDragState.pointerId === e.pointerId)){
      stopLaneDrag();
    }
    if(GameState.map.colliders.editMode){
      if(GameState.map.colliders.pointerId === null || GameState.map.colliders.pointerId === e.pointerId){
        if(GameState.map.colliders.dragMoved){
          onCollidersChanged();
        }
        stopColliderDrag();
        GameState.map.colliders.placing = false;
        updateColliderUiState();
      }
      return;
    }
    stopCameraDrag();
    stopStagePointerOrdering();
  }, { passive: true });
  window.addEventListener('pointercancel', (e) => {
    stagePointerState.inside = false;
    clearHoverTarget();
    refreshStageCursor();
    if(portalDragState.dragging && (portalDragState.pointerId === null || portalDragState.pointerId === e.pointerId)){
      stopPortalDrag({ finalize: true });
    }
    if(turretDragState.dragging && (turretDragState.pointerId === null || turretDragState.pointerId === e.pointerId)){
      stopTurretDrag({ finalize: true });
    }
    if(laneDragState.dragging && (laneDragState.pointerId === null || laneDragState.pointerId === e.pointerId)){
      stopLaneDrag();
    }
    if(GameState.map.colliders.editMode){
      stopColliderDrag();
      GameState.map.colliders.placing = false;
      updateColliderUiState();
      return;
    }
    stopCameraDrag();
    stopStagePointerOrdering();
  }, { passive: true });

  // === Drawing helpers ===
  function drawHoverHighlight(){
    if(!cursorState.outlineEnabled){
      return;
    }
    const targetInfo = cursorRuntime.hoverTarget;
    if(!targetInfo || !targetInfo.ref){
      return;
    }
    const target = targetInfo.ref;
    let radius = 0;
    let centerX = target.x;
    let centerY = target.y;
    if(targetInfo.type === 'minion'){
      if(!minions.includes(target) || !(target.hp > 0)){
        return;
      }
      radius = minionRadius + 14;
    } else if(targetInfo.type === 'monster'){
      if(!isMonsterAttackable(target)){
        return;
      }
      const monsterRadius = Math.max(20, monsterAttackRadius(target));
      radius = monsterRadius + 20;
    } else if(targetInfo.type === 'dummy'){
      if(target.active === false || target.hp <= 0){
        return;
      }
      const size = Math.max(40, Number(target.size) || 120);
      radius = size / 2 + 12;
    } else {
      return;
    }
    if(!circleInCamera(centerX, centerY, radius + 12)){
      return;
    }
    const color = cursorState.hoverColor || '#7fe3ff';
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawVisionShapes(){
    if(GameState.player.vision.hidden){
      return;
    }
    ctx.save();
    for(const source of customVisionSources){
      if(!source) continue;
      ensureVisionConsistency(source);
      const highlight = source.id === GameState.player.vision.selectedId;
      const alpha = highlight ? 0.6 : 0.4;
      const isHiding = source.mode === 2;
      const fillColor = highlight
        ? (isHiding ? '#39ff1444' : '#63d7ff2a')
        : (isHiding ? '#39ff1424' : '#2f8cff24');
      const strokeColor = highlight
        ? (isHiding ? '#39ff14' : '#63d7ff')
        : (isHiding ? '#39ff14cc' : '#2f8cffcc');
      if(source.type === 'capsule'){
        const metrics = ensureCapsuleMetrics(source);
        const bounds = colliderBoundingRadius(source) + 8;
        if(!circleInCamera(source.x, source.y, bounds)){
          continue;
        }
        ctx.save();
        ctx.translate(source.x, source.y);
        ctx.rotate(metrics.angle);
        ctx.globalAlpha = alpha;
        const radius = metrics.radius;
        const halfSpan = metrics.span / 2;
        ctx.beginPath();
        if(metrics.span <= 0){
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
        } else {
          ctx.moveTo(-halfSpan, -radius);
          ctx.lineTo(halfSpan, -radius);
          ctx.arc(halfSpan, 0, radius, -Math.PI / 2, Math.PI / 2);
          ctx.lineTo(-halfSpan, radius);
          ctx.arc(-halfSpan, 0, radius, Math.PI / 2, -Math.PI / 2);
        }
        ctx.closePath();
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = highlight ? 4 : 3;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else if(source.type === 'crescent'){
        const metrics = ensureCrescentMetrics(source);
        const radius = Math.max(0, metrics.radius);
        if(!circleInCamera(source.x, source.y, radius + 8)){
          continue;
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(source.x, source.y, radius, 0, Math.PI * 2);
        if(metrics.innerRadius > 0){
          ctx.moveTo(metrics.innerCx + metrics.innerRadius, metrics.innerCy);
          ctx.arc(metrics.innerCx, metrics.innerCy, metrics.innerRadius, 0, Math.PI * 2, true);
        }
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = highlight ? 4 : 3;
        ctx.fill('evenodd');
        ctx.stroke();
        ctx.restore();
      } else {
        const radius = Math.max(0, Number(source.radius) || 0);
        if(!circleInCamera(source.x, source.y, radius + 8)){
          continue;
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(source.x, source.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = highlight ? 4 : 3;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }
    const playerRadiusValue = Math.max(0, Number(GameState.player.vision.radius) || 0);
    if(playerRadiusValue > 0 && circleInCamera(player.x, player.y, playerRadiusValue + 4)){
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.setLineDash([12, 8]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#63d7ffb0';
      ctx.beginPath();
      ctx.arc(player.x, player.y, playerRadiusValue, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    if(visionDummy && visionDummy.active !== false){
      const dummySize = clampPracticeDummySize(visionDummy.size, practiceDummyDefaults.size);
      const bodyRadius = Math.max(10, dummySize * 0.5);
      const span = Math.max(bodyRadius * 2, dummySize * 2.2);
      const boundRadius = Math.max(bodyRadius, span / 2);
      if(boundRadius > 0 && circleInCamera(visionDummy.x, visionDummy.y, boundRadius + 4)){
        ctx.save();
        ctx.translate(visionDummy.x, visionDummy.y);
        ctx.globalAlpha = 0.9;
        ctx.setLineDash([10, 6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ff5577b0';
        ctx.beginPath();
        const radius = bodyRadius;
        const halfSpan = span / 2;
        if(halfSpan <= radius){
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
        } else {
          ctx.moveTo(-halfSpan, -radius);
          ctx.lineTo(halfSpan, -radius);
          ctx.arc(halfSpan, 0, radius, -Math.PI / 2, Math.PI / 2);
          ctx.lineTo(-halfSpan, radius);
          ctx.arc(-halfSpan, 0, radius, Math.PI / 2, -Math.PI / 2);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
    }
    ctx.restore();
  }
  function drawColliders(){
    if(!customColliders.length) return;
    for(const collider of customColliders){
      if(!collider) continue;
      const highlight = collider.id === GameState.map.colliders.selectedId;
      const alpha = GameState.map.colliders.hidden ? 0 : (highlight ? 0.55 : 0.38);
      if(collider.type === 'capsule'){
        const metrics = ensureCapsuleMetrics(collider);
        const bounds = colliderBoundingRadius(collider) + 8;
        if(!circleInCamera(collider.x, collider.y, bounds)){
          continue;
        }
        ctx.save();
        ctx.translate(collider.x, collider.y);
        ctx.rotate(metrics.angle);
        ctx.globalAlpha = alpha;
        const radius = metrics.radius;
        const halfSpan = metrics.span / 2;
        ctx.beginPath();
        if(metrics.span <= 0){
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
        } else {
          ctx.moveTo(-halfSpan, -radius);
          ctx.lineTo(halfSpan, -radius);
          ctx.arc(halfSpan, 0, radius, -Math.PI / 2, Math.PI / 2);
          ctx.lineTo(-halfSpan, radius);
          ctx.arc(-halfSpan, 0, radius, Math.PI / 2, -Math.PI / 2);
        }
        ctx.closePath();
        ctx.fillStyle = highlight ? '#ff7b7b33' : '#f89b3330';
        ctx.strokeStyle = highlight ? '#ff7b7b' : '#f89b33cc';
        ctx.lineWidth = highlight ? 4 : 3;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      } else if(collider.type === 'crescent'){
        const metrics = ensureCrescentMetrics(collider);
        const radius = Math.max(0, metrics.radius);
        if(!circleInCamera(collider.x, collider.y, radius + 8)){
          continue;
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(collider.x, collider.y, radius, 0, Math.PI * 2);
        if(metrics.innerRadius > 0){
          ctx.moveTo(metrics.innerCx + metrics.innerRadius, metrics.innerCy);
          ctx.arc(metrics.innerCx, metrics.innerCy, metrics.innerRadius, 0, Math.PI * 2, true);
        }
        ctx.fillStyle = highlight ? '#ff7b7b33' : '#f89b3330';
        ctx.strokeStyle = highlight ? '#ff7b7b' : '#f89b33cc';
        ctx.lineWidth = highlight ? 4 : 3;
        ctx.fill('evenodd');
        ctx.stroke();
        ctx.restore();
      } else {
        const radius = Math.max(0, Number(collider.radius) || 0);
        if(!circleInCamera(collider.x, collider.y, radius + 8)){
          continue;
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(collider.x, collider.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = highlight ? '#ff7b7b33' : '#f89b3330';
        ctx.strokeStyle = highlight ? '#ff7b7b' : '#f89b33cc';
        ctx.lineWidth = highlight ? 4 : 3;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }
    ctx.globalAlpha = 1;
  }
  function drawVisionDummy(){
    if(!visionDummy || visionDummy.active === false) return;
    const markerRadius = 16;
    if(!circleInCamera(visionDummy.x, visionDummy.y, markerRadius + 6)){
      return;
    }
    ctx.save();
    ctx.beginPath();
    ctx.arc(visionDummy.x, visionDummy.y, markerRadius, 0, Math.PI * 2);
    ctx.fillStyle = '#ff5577';
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#32050c';
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('E', visionDummy.x, visionDummy.y + 1);
    ctx.restore();
  }
  function drawFogOfWar(){
    const overlayColor = 'rgba(6, 12, 20, 0.82)';
    const viewWidth = Math.max(1, Math.round(camera.baseWidth));
    const viewHeight = Math.max(1, Math.round(camera.baseHeight));
    if(fogCanvas.width !== viewWidth || fogCanvas.height !== viewHeight){
      fogCanvas.width = viewWidth;
      fogCanvas.height = viewHeight;
    }

    fogCtx.setTransform(1, 0, 0, 1, 0, 0);
    fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
    if(GameState.player.vision.fullReveal){
      return;
    }

    const areas = [];
    for(const source of customVisionSources){
      if(!source) continue;
      ensureVisionConsistency(source);
      const type = source.type === 'capsule' ? 'capsule'
        : (source.type === 'crescent' ? 'crescent' : 'circle');
      if(type === 'capsule'){
        const metrics = ensureCapsuleMetrics(source);
        const bounds = colliderBoundingRadius(source) + 12;
        if(!circleInCamera(source.x, source.y, bounds)){
          continue;
        }
        areas.push({ type: 'capsule', x: source.x, y: source.y, metrics });
      } else if(type === 'crescent'){
        const metrics = ensureCrescentMetrics(source);
        const radius = Math.max(0, metrics.radius);
        if(radius <= 0 || !circleInCamera(source.x, source.y, radius + 12)){
          continue;
        }
        areas.push({ type: 'crescent', metrics });
      } else {
        const radius = Math.max(0, Number(source.radius) || 0);
        if(radius <= 0 || !circleInCamera(source.x, source.y, radius + 8)){
          continue;
        }
        areas.push({ type: 'circle', x: source.x, y: source.y, radius });
      }
    }
    const playerRadiusValue = Math.max(0, Number(GameState.player.vision.radius) || 0);
    if(playerRadiusValue > 0 && circleInCamera(player.x, player.y, playerRadiusValue + 8)){
      areas.push({ type: 'circle', x: player.x, y: player.y, radius: playerRadiusValue });
    }
    if(visionDummy && visionDummy.active !== false){
      const dummyRadius = Math.max(0, Number(visionDummy.radius) || 0);
      if(dummyRadius > 0){
        const clampCoord = (value, max) => Math.max(0, Math.min(max, Number.isFinite(value) ? value : 0));
        const dummyX = clampCoord(visionDummy.x, mapState.width);
        const dummyY = clampCoord(visionDummy.y, mapState.height);
        if(circleInCamera(dummyX, dummyY, dummyRadius + 8)){
          areas.push({ type: 'circle', x: dummyX, y: dummyY, radius: dummyRadius });
        }
      }
    }

    const cameraScale = Math.max(0.001, Number(camera.scale) || 1);
    fogCtx.setTransform(cameraScale, 0, 0, cameraScale, -camera.x * cameraScale, -camera.y * cameraScale);
    fogCtx.globalCompositeOperation = 'source-over';
    fogCtx.globalAlpha = 1;
    fogCtx.fillStyle = overlayColor;
    fogCtx.fillRect(camera.x, camera.y, camera.width, camera.height);
    if(areas.length){
      fogCtx.globalCompositeOperation = 'destination-out';
      fogCtx.fillStyle = '#000';
      for(const area of areas){
        if(area.type === 'capsule'){
          const { metrics } = area;
          fogCtx.save();
          fogCtx.beginPath();
          fogCtx.translate(area.x, area.y);
          fogCtx.rotate(metrics.angle);
          const radius = metrics.radius;
          if(metrics.span <= 0){
            fogCtx.arc(0, 0, radius, 0, Math.PI * 2);
          } else {
            const halfSpan = metrics.span / 2;
            fogCtx.moveTo(-halfSpan, -radius);
            fogCtx.lineTo(halfSpan, -radius);
            fogCtx.arc(halfSpan, 0, radius, -Math.PI / 2, Math.PI / 2);
            fogCtx.lineTo(-halfSpan, radius);
            fogCtx.arc(-halfSpan, 0, radius, Math.PI / 2, -Math.PI / 2);
            fogCtx.closePath();
          }
          fogCtx.fill();
          fogCtx.restore();
          continue;
        }
        fogCtx.beginPath();
        if(area.type === 'crescent'){
          const { metrics } = area;
          fogCtx.moveTo(metrics.cx + metrics.radius, metrics.cy);
          fogCtx.arc(metrics.cx, metrics.cy, metrics.radius, 0, Math.PI * 2);
          if(metrics.innerRadius > 0){
            fogCtx.moveTo(metrics.innerCx + metrics.innerRadius, metrics.innerCy);
            fogCtx.arc(metrics.innerCx, metrics.innerCy, metrics.innerRadius, 0, Math.PI * 2, true);
            fogCtx.fill('evenodd');
          } else {
            fogCtx.fill();
          }
          continue;
        }
        fogCtx.arc(area.x, area.y, area.radius, 0, Math.PI * 2);
        fogCtx.fill();
      }
      fogCtx.globalCompositeOperation = 'source-over';
    }

    fogCtx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(fogCanvas, 0, 0);
    ctx.restore();
  }
  function drawPracticeDummyCapsule(m){
    const size = clampPracticeDummySize(m && m.size, 120);
    const radius = Math.max(10, size * 0.5);
    const span = Math.max(radius * 2, size * 2.2);
    const halfSpan = span / 2;
    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.beginPath();
    ctx.moveTo(-halfSpan, -radius);
    ctx.lineTo(halfSpan, -radius);
    ctx.arc(halfSpan, 0, radius, -Math.PI / 2, Math.PI / 2);
    ctx.lineTo(-halfSpan, radius);
    ctx.arc(-halfSpan, 0, radius, Math.PI / 2, -Math.PI / 2);
    ctx.closePath();
    ctx.fillStyle = '#ff5577';
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#32050c';
    ctx.stroke();
    ctx.restore();
  }

  function drawMonster(){
    if(!monsterState || monsterState.active === false){
      return;
    }
    const x = Number(monsterState.x) || 0;
    const y = Number(monsterState.y) || 0;
    const size = Math.max(40, Number(monsterState.size) || 140);
    const radius = size / 2;
    const aggroRadius = Math.max(0, Number(monsterState.aggroRadius) || 0);
    if(aggroRadius > 0 && circleInCamera(x, y, aggroRadius + 24)){
      ctx.save();
      const engaged = !!monsterState.engaged;
      ctx.globalAlpha = engaged ? 0.18 : 0.12;
      ctx.fillStyle = engaged ? '#c593ff' : '#7b56ff';
      ctx.beginPath();
      ctx.arc(x, y, aggroRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = engaged ? 0.75 : 0.45;
      ctx.lineWidth = engaged ? 3 : 2;
      ctx.strokeStyle = engaged ? '#f1c6ff' : '#c3b2ff';
      ctx.beginPath();
      ctx.arc(x, y, aggroRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    if(!circleInCamera(x, y, radius + 20)){
      return;
    }
    if(!pointInVision(x, y, radius)){
      return;
    }
    ctx.save();
    const engaged = !!monsterState.engaged;
    const bodyGradient = ctx.createRadialGradient(x, y - radius * 0.4, radius * 0.2, x, y, radius);
    bodyGradient.addColorStop(0, engaged ? '#ffcef8' : '#f3ddff');
    bodyGradient.addColorStop(0.5, engaged ? '#bd6eff' : '#8650d6');
    bodyGradient.addColorStop(1, engaged ? '#5e1a86' : '#35105c');
    ctx.fillStyle = bodyGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 4;
    ctx.strokeStyle = engaged ? '#f8cfff' : '#7b4cff';
    ctx.stroke();
    ctx.restore();
  }

  function drawTurrets(){
    const turretList = ensureTurrets();
    if(!turretList.length){
      return;
    }
    const bodyRadius = Math.max(12, minionRadius + 6);
    for(const turret of turretList){
      if(!turret){
        continue;
      }
      const range = Math.max(0, Number(turret.range) || 0);
      const color = turret.teamColor || teamColorForSide(turret.side);
      const rangeVisible = range > 0 && circleInCamera(turret.x, turret.y, range + 18);
      if(rangeVisible){
        ctx.save();
        ctx.globalAlpha = turret.target === player ? 0.2 : 0.12;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(turret.x, turret.y, range, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = turret.target === player ? 0.8 : 0.5;
        ctx.lineWidth = turret.target === player ? 3 : 2;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.arc(turret.x, turret.y, range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      if(!circleInCamera(turret.x, turret.y, bodyRadius + 10)){
        continue;
      }
      ctx.save();
      const gradient = ctx.createRadialGradient(turret.x, turret.y - bodyRadius * 0.3, bodyRadius * 0.2, turret.x, turret.y, bodyRadius);
      gradient.addColorStop(0, '#fdfdfd');
      gradient.addColorStop(0.6, color);
      gradient.addColorStop(1, '#05121a');
      ctx.beginPath();
      ctx.arc(turret.x, turret.y, bodyRadius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#05121a';
      ctx.stroke();
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.arc(turret.x, turret.y, bodyRadius * 0.58, 0, Math.PI * 2);
      ctx.stroke();
      if(turret.target){
        const angle = Math.atan2(turret.target.y - turret.y, turret.target.x - turret.x);
        ctx.beginPath();
        ctx.moveTo(turret.x, turret.y);
        ctx.lineTo(turret.x + Math.cos(angle) * (bodyRadius + 6), turret.y + Math.sin(angle) * (bodyRadius + 6));
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ffe27a';
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawTurretShots(){
    for(const shot of turretShots){
      if(!shot){
        continue;
      }
      if(!rectIntersectsCamera(shot.fromX, shot.fromY, shot.toX, shot.toY, 12)){
        continue;
      }
      const life = Math.max(0.05, Number(shot.duration) || 0.2);
      const age = Math.max(0, Math.min(life, Number(shot.age) || 0));
      const t = life > 0 ? age / life : 1;
      const color = shot.teamColor || teamColorForSide(shot.side, '#9ad7ff');
      ctx.save();
      ctx.globalAlpha = 0.9 - t * 0.35;
      ctx.lineWidth = 3;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(shot.fromX, shot.fromY);
      ctx.lineTo(shot.toX, shot.toY);
      ctx.stroke();
      ctx.globalAlpha = 1 - t * 0.6;
      ctx.fillStyle = '#fdf6d0';
      ctx.beginPath();
      ctx.arc(shot.toX, shot.toY, Math.max(2.5, 6 - t * 3), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawMinion(m){
    if(m && m.isPracticeDummy){
      drawPracticeDummyCapsule(m);
      return;
    }
    const fill = m.teamColor
      ? m.teamColor
      : (m.side==='blue' ? '#2aa9ff' : (m.side==='red' ? '#ff5577' : '#a0a0a0'));
    const stroke = '#05121a';

    // Body
    ctx.beginPath();
    ctx.arc(m.x, m.y, minionRadius, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = stroke;
    ctx.stroke();

    // Facing indicator (tiny notch toward destination)
    const ang = (typeof m.facing === 'number') ? m.facing : Math.atan2(m.to.y - m.y, m.to.x - m.x);
    ctx.beginPath();
    ctx.moveTo(m.x, m.y);
    ctx.lineTo(m.x + Math.cos(ang)*minionRadius, m.y + Math.sin(ang)*minionRadius);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#ffffffaa';
    ctx.stroke();

    // HP bar
    const w = 16, h = 3, pad = 10;
    const pct = Math.max(0, Math.min(1, m.hp / m.maxHp));
    ctx.fillStyle = '#000000aa';
    ctx.fillRect(m.x - w/2, m.y - minionRadius - pad, w, h);
    ctx.fillStyle = '#6cff8b';
    ctx.fillRect(m.x - w/2, m.y - minionRadius - pad, w*pct, h);
    ctx.strokeStyle = '#0b1b28';
    ctx.lineWidth = 1;
    ctx.strokeRect(m.x - w/2, m.y - minionRadius - pad, w, h);
  }

  function drawLaserProjectiles(){
    for(const laser of laserProjectiles){
      const endX = Number.isFinite(laser.currentX) ? laser.currentX : laser.startX;
      const endY = Number.isFinite(laser.currentY) ? laser.currentY : laser.startY;
      const width = Math.max(2, Number(laser.width) || 0);
      if(!rectIntersectsCamera(laser.startX, laser.startY, endX, endY, Math.max(width, 12))) continue;
      const shadowColor = typeof laser.shadowColor === 'string' && laser.shadowColor.trim() ? laser.shadowColor : '#7fe3ff';
      const outerColor = typeof laser.outerColor === 'string' && laser.outerColor.trim() ? laser.outerColor : '#7fe3ffaa';
      const innerColor = typeof laser.innerColor === 'string' && laser.innerColor.trim() ? laser.innerColor : '#d8f6ff';
      const tipColor = typeof laser.tipColor === 'string' && laser.tipColor.trim() ? laser.tipColor : '#f4fdff';
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.85;
      ctx.shadowColor = shadowColor;
      ctx.shadowBlur = 12;
      ctx.lineWidth = width;
      ctx.strokeStyle = outerColor;
      ctx.beginPath();
      ctx.moveTo(laser.startX, laser.startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.95;
      ctx.lineWidth = Math.max(1, width * 0.55);
      ctx.strokeStyle = innerColor;
      ctx.beginPath();
      ctx.moveTo(laser.startX, laser.startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(endX, endY, Math.max(4, Math.min(12, width * 0.4)), 0, Math.PI * 2);
      ctx.fillStyle = tipColor;
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.restore();
    }
  }

  function drawDuskwaveVolleys(){
    if(!duskwaveVolleys.length) return;
    for(const volley of duskwaveVolleys){
      if(!volley) continue;
      const startX = Number.isFinite(volley.prevX) ? volley.prevX : volley.startX;
      const startY = Number.isFinite(volley.prevY) ? volley.prevY : volley.startY;
      const endX = Number.isFinite(volley.x) ? volley.x : (volley.startX || 0);
      const endY = Number.isFinite(volley.y) ? volley.y : (volley.startY || 0);
      if(!rectIntersectsCamera(startX, startY, endX, endY, Math.max(volley.width || 0, 6))) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineWidth = Math.max(2, volley.width || 6);
      ctx.globalAlpha = 0.85;
      ctx.strokeStyle = volley.color || '#ff9a41';
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.fillStyle = volley.trailColor || '#ffd089';
      ctx.beginPath();
      ctx.arc(endX, endY, Math.max(3, (volley.width || 0) * 0.35), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawRicochetBombProjectiles(){
    for(const bomb of ricochetBombProjectiles){
      const headX = Number.isFinite(bomb.currentX) ? bomb.currentX : bomb.startX;
      const headY = Number.isFinite(bomb.currentY) ? bomb.currentY : bomb.startY;
      const tailLength = Math.max(12, Math.min(40, Number(bomb.traveled) || 0));
      const dirX = Number(bomb.dirX) || 0;
      const dirY = Number(bomb.dirY) || 0;
      const tailX = headX - dirX * tailLength;
      const tailY = headY - dirY * tailLength;
      const radius = Math.max(6, Math.min(16, (Number(bomb.explosionRadius) || 0) * 0.12 + 6));
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, radius + 8)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.shadowColor = '#ffb347';
      ctx.shadowBlur = 16;
      ctx.strokeStyle = '#ffb347';
      ctx.lineWidth = Math.max(3, radius * 0.6);
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#ffe4b5';
      ctx.beginPath();
      ctx.arc(headX, headY, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#3a2620';
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawBlinkingBoltProjectiles(){
    for(const bolt of blinkingBoltProjectiles){
      const tailX = Number.isFinite(bolt.prevX) ? bolt.prevX : bolt.x;
      const tailY = Number.isFinite(bolt.prevY) ? bolt.prevY : bolt.y;
      const headX = Number.isFinite(bolt.x) ? bolt.x : tailX;
      const headY = Number.isFinite(bolt.y) ? bolt.y : tailY;
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, 10)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.85;
      ctx.shadowColor = '#7fe3ff';
      ctx.shadowBlur = 14;
      ctx.lineWidth = 3.5;
      ctx.strokeStyle = '#8feaff';
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#e8faff';
      ctx.beginPath();
      ctx.arc(headX, headY, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#1e2b3a';
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawEmberWaltzFlames(){
    for(const flame of emberWaltzFlames){
      if(!flame) continue;
      const headX = Number.isFinite(flame.x) ? flame.x : 0;
      const headY = Number.isFinite(flame.y) ? flame.y : 0;
      const tailX = Number.isFinite(flame.prevX) ? flame.prevX : headX;
      const tailY = Number.isFinite(flame.prevY) ? flame.prevY : headY;
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, 16)) continue;
      const orbiting = flame.state === 'orbit';
      const radius = Math.max(6, Math.min(12, (Number(flame.orbitRadius) || 0) * 0.05 + 6));
      const glow = orbiting ? '#ffb347' : '#ffcfa1';
      const core = orbiting ? '#fff7ec' : '#fffef6';
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.shadowColor = glow;
      ctx.shadowBlur = 16;
      ctx.strokeStyle = glow;
      ctx.lineWidth = Math.max(3, radius * 0.65);
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = core;
      ctx.beginPath();
      ctx.arc(headX, headY, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#32160c';
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawFlipbladeProjectiles(){
    for(const proj of flipbladeProjectiles){
      if(!proj) continue;
      const headX = Number.isFinite(proj.currentX) ? proj.currentX : proj.startX;
      const headY = Number.isFinite(proj.currentY) ? proj.currentY : proj.startY;
      const tailX = Number.isFinite(proj.startX) ? proj.startX : headX;
      const tailY = Number.isFinite(proj.startY) ? proj.startY : headY;
      const width = Math.max(4, (Number(proj.width) || 0) * 0.5);
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, width + 8)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.88;
      ctx.shadowColor = '#7fffd4';
      ctx.shadowBlur = 14;
      ctx.strokeStyle = '#6ff2c4';
      ctx.lineWidth = Math.max(3, width * 0.55);
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#e8fff4';
      ctx.beginPath();
      ctx.arc(headX, headY, Math.max(5, width * 0.45), 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#12352c';
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawReboundOrbProjectiles(){
    for(const orb of reboundOrbProjectiles){
      if(!orb) continue;
      const headX = Number.isFinite(orb.currentX) ? orb.currentX : orb.startX;
      const headY = Number.isFinite(orb.currentY) ? orb.currentY : orb.startY;
      const dirX = Number(orb.dirX) || 0;
      const dirY = Number(orb.dirY) || 0;
      const speed = orb.state === 'return' ? Math.max(0, Number(orb.speedReturn) || 0) : Math.max(0, Number(orb.speedOut) || 0);
      const trailLength = Math.max(12, Math.min(80, speed * 0.04 + (Number(orb.width) || 0) * 0.3));
      const tailX = headX - dirX * trailLength;
      const tailY = headY - dirY * trailLength;
      const radius = Math.max(6, (Number(orb.width) || 0) * 0.18 + 6);
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, radius + 12)) continue;
      const returning = orb.state === 'return';
      const glow = returning ? '#ffc9a8' : '#b7e7ff';
      const core = returning ? '#ffe9d7' : '#f5fbff';
      const stroke = returning ? '#6b3a24' : '#243645';
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.shadowColor = glow;
      ctx.shadowBlur = 16;
      ctx.strokeStyle = glow;
      ctx.lineWidth = Math.max(4, radius * 0.7);
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = core;
      ctx.beginPath();
      ctx.arc(headX, headY, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = stroke;
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawCycloneAxes(){
    for(const axis of cycloneAxes){
      if(!axis) continue;
      const headX = Number.isFinite(axis.currentX) ? axis.currentX : axis.prevX;
      const headY = Number.isFinite(axis.currentY) ? axis.currentY : axis.prevY;
      const tailX = Number.isFinite(axis.prevX) ? axis.prevX : headX;
      const tailY = Number.isFinite(axis.prevY) ? axis.prevY : headY;
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, Math.max(axis.width || 0, 12))) continue;
      const returning = axis.state === 'return';
      const trailColor = returning ? '#ffd6b0' : '#8fe3ff';
      const coreColor = returning ? '#ffe8d7' : '#f5fbff';
      const strokeColor = returning ? '#7d4f2d' : '#1f3646';
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.shadowColor = trailColor;
      ctx.shadowBlur = 16;
      ctx.strokeStyle = trailColor;
      ctx.lineWidth = Math.max(4, Math.min(18, Math.max(axis.width || 0, 6) * 0.35));
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = coreColor;
      ctx.beginPath();
      ctx.arc(headX, headY, Math.max(5, Math.max(axis.width || 0, 6) * 0.35), 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = strokeColor;
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawShatterburstOrbProjectiles(){
    for(const proj of shatterburstOrbProjectiles){
      if(!proj) continue;
      const headX = Number.isFinite(proj.currentX) ? proj.currentX : proj.startX;
      const headY = Number.isFinite(proj.currentY) ? proj.currentY : proj.startY;
      const dirX = Number(proj.dirX) || 0;
      const dirY = Number(proj.dirY) || 0;
      const speed = Math.max(0, Number(proj.speed) || 0);
      const trailLength = Math.max(16, Math.min(90, speed * 0.05 + (Number(proj.width) || 0) * 0.4));
      const tailX = headX - dirX * trailLength;
      const tailY = headY - dirY * trailLength;
      const radius = Math.max(6, (Number(proj.width) || 0) * 0.2 + 6);
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, radius + 12)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.92;
      ctx.shadowColor = '#d9f1ff';
      ctx.shadowBlur = 14;
      ctx.strokeStyle = '#9fd7ff';
      ctx.lineWidth = Math.max(4, radius * 0.65);
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#e9f7ff';
      ctx.beginPath();
      ctx.arc(headX, headY, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#1f3b52';
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSkyhookSwingCasts(){
    for(const swing of skyhookSwingCasts){
      if(!swing) continue;
      const anchorX = Number(swing.anchorX) || 0;
      const anchorY = Number(swing.anchorY) || 0;
      const endX = Number.isFinite(swing.currentX) ? swing.currentX : player.x;
      const endY = Number.isFinite(swing.currentY) ? swing.currentY : player.y;
      const radius = Math.max(0, Number(swing.radius) || 0);
      const reach = Math.max(radius, Math.hypot(endX - anchorX, endY - anchorY));
      if(reach > 0 && !circleInCamera(anchorX, anchorY, reach + 30)) continue;
      const hookT = swing.phase === 'hook' ? Math.max(0, Math.min(1, Number(swing.hookProgress) || 0)) : 1;
      const tipX = swing.phase === 'hook' ? endX + (anchorX - endX) * hookT : endX;
      const tipY = swing.phase === 'hook' ? endY + (anchorY - endY) * hookT : endY;
      ctx.save();
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.85;
      ctx.strokeStyle = '#9fe3ff';
      ctx.beginPath();
      ctx.moveTo(anchorX, anchorY);
      ctx.lineTo(tipX, tipY);
      ctx.stroke();
      ctx.lineWidth = 6;
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.arc(anchorX, anchorY, Math.max(6, Math.min(14, radius * 0.1 + 6)), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSnapbackEchoes(){
    for(const echo of snapbackEchoes){
      if(!echo) continue;
      const x = Number.isFinite(echo.x) ? echo.x : echo.startX;
      const y = Number.isFinite(echo.y) ? echo.y : echo.startY;
      const caster = echo.casterRef || player;
      const pathWidth = Math.max(0, Number(echo.width) || 0);
      const radius = Math.max(12, Math.min(48, pathWidth * 0.5 + 10));
      const targetX = echo.state === 'delay'
        ? (Number.isFinite(echo.dashEndX) ? echo.dashEndX : (caster ? caster.x : x))
        : (caster ? caster.x : x);
      const targetY = echo.state === 'delay'
        ? (Number.isFinite(echo.dashEndY) ? echo.dashEndY : (caster ? caster.y : y))
        : (caster ? caster.y : y);
      const boundRadius = Math.max(radius, pathWidth * 0.5, Math.hypot((targetX || x) - x, (targetY || y) - y));
      if(!circleInCamera(x, y, boundRadius + 30)) continue;

      if(Number.isFinite(targetX) && Number.isFinite(targetY)){
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = Math.max(2, Math.min(6, pathWidth * 0.25 + 2));
        ctx.strokeStyle = '#bde7ff';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(targetX, targetY);
        ctx.stroke();
        ctx.restore();
      }

      if(echo.state === 'return' && Number.isFinite(echo.prevX) && Number.isFinite(echo.prevY)){
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = Math.max(2, Math.min(8, pathWidth * 0.35 + 2));
        ctx.strokeStyle = '#d6f2ff';
        ctx.beginPath();
        ctx.moveTo(echo.prevX, echo.prevY);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.restore();
      }

      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#9bd7ff';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#7fc5ff';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSpinningAxeMarkers(){
    if(!spinningAxeMarkers.length) return;
    ctx.save();
    for(const marker of spinningAxeMarkers){
      if(!marker) continue;
      const radius = Math.max(0, Number(marker.catchRadius) || 0);
      if(radius <= 0) continue;
      if(!circleInCamera(marker.x, marker.y, radius + 12)) continue;
      const windowDuration = Math.max(0.001, Number(marker.catchWindow) || 1);
      const remaining = Math.max(0, Number(marker.remaining) || 0);
      const progress = Math.max(0, Math.min(1, remaining / windowDuration));
      const fillAlpha = 0.18 + 0.4 * progress;
      const strokeAlpha = 0.5 + 0.4 * progress;
      ctx.globalAlpha = fillAlpha;
      ctx.fillStyle = '#ffd27f';
      ctx.beginPath();
      ctx.arc(marker.x, marker.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = strokeAlpha;
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#ffb347';
      ctx.beginPath();
      ctx.arc(marker.x, marker.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.arc(marker.x, marker.y, Math.max(6, radius * 0.35), 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    ctx.restore();
  }

  function drawChronoLoopGrenades(){
    if(!Array.isArray(chronoLoopGrenades) || !chronoLoopGrenades.length) return;
    for(const loop of chronoLoopGrenades){
      if(!loop) continue;
      const x = Number.isFinite(loop.x) ? loop.x : loop.startX;
      const y = Number.isFinite(loop.y) ? loop.y : loop.startY;
      const width = Math.max(0, Number(loop.width) || 0);
      const auraRadius = Math.max(0, Number(loop.fieldRadius) || 0);
      if(loop.state === 'field' && auraRadius > 0){
        const timer = Math.max(0, Number(loop.fieldTimer) || 0);
        const duration = Math.max(0.1, Number(loop.fieldDuration) || 0.1);
        const auraAlpha = Math.max(0.1, Math.min(0.5, timer / duration * 0.45));
        ctx.save();
        ctx.globalAlpha = auraAlpha;
        ctx.fillStyle = '#7acafe';
        ctx.beginPath();
        ctx.arc(x, y, auraRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      const projectileRadius = Math.max(6, Math.min(28, width * 0.4 + 10));
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = '#9df1ff';
      ctx.beginPath();
      ctx.arc(x, y, projectileRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#57c6ff';
      ctx.beginPath();
      ctx.arc(x, y, projectileRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawTwinstrikeTrails(){
    for(const trail of twinstrikeTrails){
      if(!trail) continue;
      const midX = (Number(trail.startX) + Number(trail.endX)) * 0.5;
      const midY = (Number(trail.startY) + Number(trail.endY)) * 0.5;
      const halfLen = Math.hypot((trail.endX || 0) - (trail.startX || 0), (trail.endY || 0) - (trail.startY || 0)) * 0.5;
      const bound = halfLen + Math.max(20, Number(trail.width) || 0);
      if(!circleInCamera(midX, midY, bound)) continue;
      const duration = Math.max(0.01, Number(trail.duration) || 0.4);
      const age = Math.max(0, Number(trail.age) || 0);
      const t = Math.max(0, Math.min(1, age / duration));
      const alpha = 1 - t;
      const primary = trail.stage === 'second' ? '#ff6fa8' : '#6ac2ff';
      const secondary = trail.stage === 'second' ? '#ff9cc7' : '#a8e1ff';
      const width = Math.max(2, Number(trail.width) || 8);
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = Math.max(0.08, 0.6 * alpha);
      ctx.lineWidth = Math.max(2, width * 0.32);
      ctx.strokeStyle = primary;
      ctx.beginPath();
      ctx.moveTo(trail.startX, trail.startY);
      ctx.lineTo(trail.endX, trail.endY);
      ctx.stroke();
      ctx.globalAlpha = Math.max(0.1, 0.85 * alpha);
      ctx.lineWidth = Math.max(1.5, width * 0.22);
      ctx.strokeStyle = secondary;
      ctx.beginPath();
      ctx.moveTo(trail.startX, trail.startY);
      ctx.lineTo(trail.endX, trail.endY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawCleaveCrushCasts(){
    for(const cast of cleaveCrushCasts){
      if(!cast) continue;
      const caster = cast.casterRef || player;
      const origin = getSpellOrigin(caster);
      const state = cast.state || 'sweepWindup';
      if(state === 'recastReady'){
        const radius = Math.max(18, (caster && caster.r ? caster.r : player.r || 10) + 12);
        if(circleInCamera(origin.x, origin.y, radius + 8)){
          const windowLen = Math.max(0.0001, Number(cast.recastWindow) || 0.0001);
          const remaining = Math.max(0, Number(cast.recastRemaining) || 0);
          const pulse = Math.cos(Math.min(1, remaining / windowLen) * Math.PI * 2) * 0.25 + 0.55;
          ctx.save();
          ctx.globalAlpha = Math.max(0.25, pulse);
          ctx.lineWidth = 3;
          ctx.strokeStyle = '#7fe3ff';
          ctx.beginPath();
          ctx.arc(origin.x, origin.y, radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        continue;
      }
      if(state !== 'sweepWindup' && state !== 'slamWindup') continue;
      const range = state === 'sweepWindup'
        ? Math.max(0, Number(cast.sweepRange) || 0)
        : Math.max(0, Number(cast.slamRange) || 0);
      const width = state === 'sweepWindup'
        ? Math.max(0, Number(cast.sweepWidth) || 0)
        : Math.max(0, Number(cast.slamWidth) || 0);
      const rawDirX = state === 'sweepWindup' ? Number(cast.sweepDirX) : Number(cast.slamDirX);
      const rawDirY = state === 'sweepWindup' ? Number(cast.sweepDirY) : Number(cast.slamDirY);
      let dirX = Number.isFinite(rawDirX) ? rawDirX : 1;
      let dirY = Number.isFinite(rawDirY) ? rawDirY : 0;
      let len = Math.hypot(dirX, dirY);
      if(!(len > 0.0001)){
        dirX = 1;
        dirY = 0;
        len = 1;
      }
      dirX /= len;
      dirY /= len;
      const halfWidth = width * 0.5;
      const endX = origin.x + dirX * range;
      const endY = origin.y + dirY * range;
      if(!rectIntersectsCamera(origin.x, origin.y, endX, endY, halfWidth + 14)) continue;
      const lockout = Math.max(0, Number(cast.lockout) || 0);
      const elapsed = Math.max(0, Number(cast.elapsed) || 0);
      const progress = lockout > 0 ? Math.max(0, Math.min(1, elapsed / Math.max(lockout, 0.0001))) : 1;
      ctx.save();
      ctx.globalAlpha = 0.28 + 0.35 * progress;
      ctx.fillStyle = '#7fe3ff';
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(endX + (-dirY) * halfWidth, endY + dirX * halfWidth);
      ctx.lineTo(endX - (-dirY) * halfWidth, endY - dirX * halfWidth);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  function drawTwinstrikeRecastIndicators(){
    for(const cast of twinstrikeCasts){
      if(!cast) continue;
      if(cast.state !== 'recast_locked' && cast.state !== 'recast_ready') continue;
      const caster = cast.casterRef || player;
      if(!caster) continue;
      const radius = Math.max(24, (Number(caster.r) || Number(player.r) || 20) + 18);
      if(!circleInCamera(caster.x, caster.y, radius + 8)) continue;
      const windowSeconds = Math.max(0, Number(cast.recastWindow) || 0);
      const remaining = Math.max(0, Number(cast.recastRemaining) || 0);
      const lockRemaining = Math.max(0, Number(cast.recastUnlockRemaining) || 0);
      ctx.save();
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#7fe3ff';
      ctx.beginPath();
      ctx.arc(caster.x, caster.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      if(windowSeconds > 0 && remaining > 0){
        const windowT = Math.max(0, Math.min(1, remaining / windowSeconds));
        ctx.globalAlpha = 0.8;
        ctx.lineWidth = 4;
        ctx.strokeStyle = cast.state === 'recast_ready' ? '#ff9cc7' : '#9fdcff';
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, radius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * windowT, false);
        ctx.stroke();
      }
      if(lockRemaining > 0){
        const denom = Math.max(lockRemaining, Math.max(0, Number(cast.recastLockout) || lockRemaining));
        const lockT = Math.max(0, Math.min(1, lockRemaining / denom));
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = '#5f8cff';
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, radius - 5, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * lockT, false);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawPiercingArrowProjectiles(){
    for(const proj of piercingArrowProjectiles){
      const startX = Number.isFinite(proj.startX) ? proj.startX : 0;
      const startY = Number.isFinite(proj.startY) ? proj.startY : 0;
      const headX = Number.isFinite(proj.currentX) ? proj.currentX : startX;
      const headY = Number.isFinite(proj.currentY) ? proj.currentY : startY;
      const width = Math.max(2, Number(proj.width) || 0);
      if(!rectIntersectsCamera(startX, startY, headX, headY, Math.max(width, 10))) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.shadowColor = '#9de0ff';
      ctx.shadowBlur = 20;
      ctx.strokeStyle = '#9de0ff';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#eaf6ff';
      ctx.lineWidth = Math.max(1.2, width * 0.45);
      const tailOffset = Math.min(width * 0.6, 14);
      const tailX = headX - (Number(proj.dirX) || 0) * tailOffset;
      const tailY = headY - (Number(proj.dirY) || 0) * tailOffset;
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawBoneSkewerChargePreviews(){
    for(const cast of boneSkewerCasts){
      if(!cast || cast.released) continue;
      if(cast.state !== 'channel' && cast.state !== 'windup') continue;
      if(cast.casterRef && cast.casterRef !== player) continue;
      const caster = cast.casterRef || player;
      const origin = getSpellOrigin(caster);
      const aimPoint = beamAimPoint();
      let dx = aimPoint.x - origin.x;
      let dy = aimPoint.y - origin.y;
      let len = Math.hypot(dx, dy);
      if(!(len > 0.0001)){
        dx = cast.dirX || 1;
        dy = cast.dirY || 0;
        len = Math.hypot(dx, dy);
      }
      if(!(len > 0.0001)){
        dx = 1;
        dy = 0;
        len = 1;
      }
      const dirX = dx / len;
      const dirY = dy / len;
      const range = resolveBoneSkewerRange(cast);
      const maxRange = Math.max(range, Number(cast.rangeMax) || range);
      const widthStart = Math.max(6, Number(cast.widthStart) || 0);
      const widthEnd = Math.max(6, Number(cast.widthEnd) || widthStart);
      const previewRadius = Math.max(maxRange, range) + Math.max(widthEnd, 40);
      if(!circleInCamera(origin.x, origin.y, previewRadius)) continue;
      const angle = Math.atan2(dirY, dirX);
      ctx.save();
      ctx.translate(origin.x, origin.y);
      ctx.rotate(angle);
      const halfStart = widthStart / 2;
      const halfEnd = widthEnd / 2;
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#9ce7ff33';
      ctx.beginPath();
      ctx.moveTo(0, -halfStart);
      ctx.lineTo(range, -halfEnd);
      ctx.lineTo(range, halfEnd);
      ctx.lineTo(0, halfStart);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 0.6;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#9ce7ff';
      ctx.beginPath();
      ctx.moveTo(0, -halfStart);
      ctx.lineTo(range, -halfEnd);
      ctx.lineTo(range, halfEnd);
      ctx.lineTo(0, halfStart);
      ctx.closePath();
      ctx.stroke();
      const minRange = Math.max(0, Number(cast.rangeMin) || 0);
      if(minRange > 0){
        ctx.setLineDash([6, 6]);
        ctx.strokeStyle = '#bde8ff';
        ctx.beginPath();
        ctx.moveTo(minRange, -halfEnd);
        ctx.lineTo(minRange, halfEnd);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      if(maxRange > range + 0.5){
        ctx.setLineDash([10, 6]);
        ctx.strokeStyle = '#d6f4ff';
        ctx.beginPath();
        ctx.moveTo(maxRange, -halfEnd);
        ctx.lineTo(maxRange, halfEnd);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#e4f6ff';
      ctx.beginPath();
      ctx.arc(0, 0, Math.max(6, Math.min(halfStart, 10)), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawSlingshotCrashLeaps(){
    for(const leap of slingshotCrashLeaps){
      if(!leap) continue;
      const startX = Number.isFinite(leap.startX) ? leap.startX : player.x;
      const startY = Number.isFinite(leap.startY) ? leap.startY : player.y;
      const currentX = Number.isFinite(leap.currentX) ? leap.currentX : startX;
      const currentY = Number.isFinite(leap.currentY) ? leap.currentY : startY;
      const targetX = Number.isFinite(leap.targetX) ? leap.targetX : currentX;
      const targetY = Number.isFinite(leap.targetY) ? leap.targetY : currentY;
      const landingRadius = Math.max(0, Number(leap.landingRadius) || 0);
      const width = Math.max(6, landingRadius * 0.12);
      if(!rectIntersectsCamera(startX, startY, targetX, targetY, landingRadius + width + 10)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.72;
      ctx.strokeStyle = '#7fe3ffaa';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(currentX, currentY);
      ctx.stroke();
      ctx.setLineDash([8, 6]);
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = '#b8e0ff';
      ctx.lineWidth = Math.max(2, width * 0.65);
      ctx.beginPath();
      ctx.moveTo(currentX, currentY);
      ctx.lineTo(targetX, targetY);
      ctx.stroke();
      ctx.setLineDash([]);
      if(landingRadius > 0){
        ctx.globalAlpha = 0.24;
        ctx.fillStyle = '#7fe3ff33';
        ctx.beginPath();
        ctx.arc(targetX, targetY, landingRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.78;
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#e4f8ff';
        ctx.beginPath();
        ctx.arc(targetX, targetY, landingRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = '#eaf6ff';
      ctx.beginPath();
      ctx.arc(currentX, currentY, Math.max(12, Math.min(landingRadius * 0.35, 18)), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawSlingshotCrashChargePreviews(){
    for(const cast of slingshotCrashCasts){
      if(!cast || cast.launched) continue;
      if(cast.casterRef && cast.casterRef !== player) continue;
      const caster = cast.casterRef || player;
      const origin = getSpellOrigin(caster);
      let dirX = Number(cast.initialDirX) || 0;
      let dirY = Number(cast.initialDirY) || 0;
      const dirLen = Math.hypot(dirX, dirY);
      if(dirLen > 0.0001){
        dirX /= dirLen;
        dirY /= dirLen;
      } else {
        dirX = 1;
        dirY = 0;
      }
      const minRange = Math.max(0, Number(cast.minRange) || 0);
      const maxRange = Math.max(minRange, Number(cast.maxRange) || minRange);
      const chargeDuration = Math.max(0, Number(cast.chargeDuration) || 0);
      const chargeElapsed = Math.max(0, Number(cast.chargeElapsed) || 0);
      const t = chargeDuration > 0 ? clamp01(chargeElapsed / Math.max(chargeDuration, 0.0001)) : 1;
      const range = minRange + (maxRange - minRange) * t;
      const impactRadius = Math.max(0, Number(cast.impactRadius) || 0);
      const coneHalf = Math.max(0, Number(cast.coneHalfAngle) || 0);
      const coneScale = coneHalf > 0 ? Math.tan(coneHalf) : 0;
      const maxHalfWidth = coneHalf > 0 ? Math.min(coneScale * maxRange, maxRange * 2) : Math.max(impactRadius, 40);
      const halfWidth = coneHalf > 0 ? Math.min(coneScale * range, maxHalfWidth) : maxHalfWidth;
      const previewRadius = Math.max(range, maxRange) + Math.max(maxHalfWidth, impactRadius, 60);
      if(!circleInCamera(origin.x, origin.y, previewRadius)) continue;
      const angle = Math.atan2(dirY, dirX);
      ctx.save();
      ctx.translate(origin.x, origin.y);
      ctx.rotate(angle);
      ctx.globalAlpha = 0.18;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(range, -halfWidth);
      ctx.lineTo(range, halfWidth);
      ctx.closePath();
      ctx.fillStyle = '#7fe3ff33';
      ctx.fill();
      ctx.globalAlpha = 0.6;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#7fe3ff';
      ctx.stroke();
      if(minRange > 0){
        const minHalfWidth = coneHalf > 0 ? Math.min(coneScale * minRange, maxHalfWidth) : halfWidth;
        ctx.setLineDash([6, 6]);
        ctx.strokeStyle = '#b8e0ff';
        ctx.beginPath();
        ctx.moveTo(minRange, -minHalfWidth);
        ctx.lineTo(minRange, minHalfWidth);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      if(maxRange > range + 0.5){
        ctx.setLineDash([10, 6]);
        ctx.strokeStyle = '#d6f4ff';
        ctx.beginPath();
        ctx.moveTo(maxRange, -maxHalfWidth);
        ctx.lineTo(maxRange, maxHalfWidth);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      if(impactRadius > 0){
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#7fe3ff33';
        ctx.beginPath();
        ctx.arc(range, 0, impactRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.85;
        ctx.strokeStyle = '#e4f8ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(range, 0, impactRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawChargingGaleChargePreviews(){
    for(const cast of chargingGaleCasts){
      if(!cast || cast.released) continue;
      if(cast.casterRef && cast.casterRef !== player) continue;
      const caster = cast.casterRef || player;
      const originFallback = getSpellOrigin(caster);
      const originX = Number.isFinite(cast.originX) ? cast.originX : originFallback.x;
      const originY = Number.isFinite(cast.originY) ? cast.originY : originFallback.y;
      let dirX = Number(cast.initialDirX) || 0;
      let dirY = Number(cast.initialDirY) || 0;
      const dirLen = Math.hypot(dirX, dirY);
      if(dirLen > 0.0001){
        dirX /= dirLen;
        dirY /= dirLen;
      } else {
        dirX = 1;
        dirY = 0;
      }
      const minRange = Math.max(0, Number(cast.minRange) || 0);
      const maxRange = Math.max(minRange, Number(cast.maxRange) || minRange);
      const width = Math.max(12, Number(cast.width) || 0);
      const chargeDuration = Math.max(0, Number(cast.chargeDuration) || 0);
      const chargeElapsed = Math.max(0, Number(cast.chargeElapsed) || 0);
      const t = chargeDuration > 0 ? clamp01(chargeElapsed / Math.max(chargeDuration, 0.0001)) : 1;
      const currentRange = maxRange > minRange ? (minRange + (maxRange - minRange) * t) : maxRange;
      const previewRadius = Math.max(maxRange, currentRange, minRange) + Math.max(width, 60);
      if(!circleInCamera(originX, originY, previewRadius)) continue;
      const angle = Math.atan2(dirY, dirX);
      ctx.save();
      ctx.translate(originX, originY);
      ctx.rotate(angle);
      const halfWidth = width / 2;
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = '#7fe3ff33';
      ctx.fillRect(0, -halfWidth, currentRange, width);
      ctx.globalAlpha = 0.45;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#7fe3ff';
      ctx.strokeRect(0, -halfWidth, currentRange, width);
      if(minRange > 0){
        ctx.setLineDash([6, 6]);
        ctx.strokeStyle = '#b8e0ff';
        ctx.beginPath();
        ctx.moveTo(minRange, -halfWidth);
        ctx.lineTo(minRange, halfWidth);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      if(maxRange > currentRange){
        ctx.setLineDash([10, 6]);
        ctx.strokeStyle = '#d6f4ff';
        ctx.beginPath();
        ctx.moveTo(maxRange, -halfWidth);
        ctx.lineTo(maxRange, halfWidth);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = '#9fd1ff';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(currentRange, 0);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawAvalancheRollChargePreviews(){
    for(const cast of snowballRollCasts){
      if(!cast || cast.released || cast.state !== 'charging') continue;
      if(cast.casterRef && cast.casterRef !== player) continue;
      const originX = Number(cast.originX) || player.x;
      const originY = Number(cast.originY) || player.y;
      const maxCharge = Math.max(0, Number(cast.chargeDuration) || 0);
      const chargeT = maxCharge > 0 ? clamp01(cast.chargeElapsed / maxCharge) : (cast.chargeElapsed > 0 ? 1 : 0);
      const minRadius = Math.max(0, Number(cast.minRadius) || 0);
      const maxRadius = Math.max(minRadius, Number(cast.maxRadius) || minRadius);
      const radius = minRadius + (maxRadius - minRadius) * chargeT;
      const previewRadius = Math.max(radius, 12) + 28;
      if(!circleInCamera(originX, originY, previewRadius)) continue;
      ctx.save();
      ctx.translate(originX, originY);
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#cdeef9';
      ctx.strokeStyle = '#7fe3ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#9ce8ff';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(cast.dirX * (radius + 40), cast.dirY * (radius + 40));
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawChargingGaleProjectiles(){
    for(const proj of chargingGaleProjectiles){
      const startX = Number.isFinite(proj.startX) ? proj.startX : 0;
      const startY = Number.isFinite(proj.startY) ? proj.startY : 0;
      const headX = Number.isFinite(proj.currentX) ? proj.currentX : startX;
      const headY = Number.isFinite(proj.currentY) ? proj.currentY : startY;
      const width = Math.max(2.5, Number(proj.width) || 0);
      if(!rectIntersectsCamera(startX, startY, headX, headY, width * 2)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.82;
      ctx.shadowColor = '#7fe3ff';
      ctx.shadowBlur = 22;
      ctx.strokeStyle = '#7fe3ffaa';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.95;
      ctx.strokeStyle = '#e4f8ff';
      ctx.lineWidth = Math.max(1.5, width * 0.55);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawAvalancheRollProjectiles(){
    for(const proj of snowballRollProjectiles){
      if(!proj) continue;
      const radius = Math.max(0, Number(proj.radius) || 0);
      const previewRadius = Math.max(radius, 12);
      if(!circleInCamera(proj.currentX, proj.currentY, previewRadius)) continue;
      ctx.save();
      ctx.globalAlpha = 0.42;
      ctx.fillStyle = '#d8f6ff';
      ctx.strokeStyle = '#7fe3ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(proj.currentX, proj.currentY, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.globalAlpha = 0.85;
      ctx.strokeStyle = '#9bdfff';
      ctx.lineWidth = Math.max(1.2, radius * 0.08);
      ctx.beginPath();
      ctx.arc(proj.currentX, proj.currentY, Math.max(2, radius * 0.6), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawLaserConeCasts(){
    for(const cast of laserConeCasts){
      const geom = resolveLaserConeCastGeometry(cast);
      if(!geom || geom.count <= 0) continue;
      const duration = Math.max(0.0001, Number(cast.castDuration) || 0.0001);
      const progressRaw = Math.max(0, Math.min(1, (cast.elapsed || 0) / duration));
      const eased = progressRaw * progressRaw * (3 - 2 * progressRaw);
      const previewLength = Math.max(1, geom.distance);
      const perpX = -geom.dirY;
      const perpY = geom.dirX;
      for(let i=0;i<geom.count;i++){
        const fraction = geom.count > 1 ? (i / (geom.count - 1)) : 0.5;
        const offset = (fraction - 0.5) * geom.coneWidth;
        const endX = geom.startX + geom.dirX * previewLength + perpX * offset;
        const endY = geom.startY + geom.dirY * previewLength + perpY * offset;
        const width = Math.max(1.5, geom.thickness * (0.35 + 0.45 * eased));
        if(!rectIntersectsCamera(geom.startX, geom.startY, endX, endY, width * 2)) continue;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.globalAlpha = 0.25 + 0.55 * eased;
        ctx.shadowBlur = 12 + 26 * eased;
        ctx.shadowColor = '#2aa9ff';
        ctx.lineWidth = width;
        ctx.strokeStyle = '#59c6ff';
        ctx.beginPath();
        ctx.moveTo(geom.startX, geom.startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.4 + 0.45 * eased;
        ctx.lineWidth = Math.max(1, width * 0.55);
        ctx.strokeStyle = '#d3f3ff';
        ctx.beginPath();
        ctx.moveTo(geom.startX, geom.startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.restore();
      }
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.45 * eased;
      ctx.fillStyle = '#59c6ff';
      ctx.beginPath();
      ctx.arc(geom.startX, geom.startY, 6 + 10 * eased, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawPiercingArrowCasts(){
    for(const cast of piercingArrowCasts){
      if(!cast) continue;
      const caster = cast.casterRef || player;
      const { x: originX, y: originY } = getSpellOrigin(caster);
      const state = cast.chargeState || computePiercingArrowChargeState(cast);
      const maxRange = Math.max(0, Number(state.rangeMax) || 0);
      if(!(maxRange > 0)) continue;
      let dirX = Number.isFinite(cast.dirX) ? cast.dirX : (Number.isFinite(cast.initialDirX) ? cast.initialDirX : 1);
      let dirY = Number.isFinite(cast.dirY) ? cast.dirY : (Number.isFinite(cast.initialDirY) ? cast.initialDirY : 0);
      const dirLen = Math.hypot(dirX, dirY) || 1;
      dirX /= dirLen;
      dirY /= dirLen;
      const previewRange = state.range;
      const previewEndX = originX + dirX * previewRange;
      const previewEndY = originY + dirY * previewRange;
      const maxEndX = originX + dirX * maxRange;
      const maxEndY = originY + dirY * maxRange;
      const width = Math.max(2, Number(cast.width) || 0);
      if(!rectIntersectsCamera(originX, originY, maxEndX, maxEndY, width * 2)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.32;
      ctx.setLineDash([10, 8]);
      ctx.lineWidth = Math.max(1.5, width * 0.4);
      ctx.strokeStyle = '#3d6eff';
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(maxEndX, maxEndY);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.88;
      ctx.shadowColor = '#9de0ff';
      ctx.shadowBlur = 18;
      ctx.lineWidth = Math.max(2.5, width * 0.65);
      ctx.strokeStyle = '#bde8ff';
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(previewEndX, previewEndY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#d6f3ff';
      ctx.beginPath();
      ctx.arc(originX, originY, Math.max(6, width * 0.45), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawGrabCasts(){
    for(const cast of grabCasts){
      if(!cast) continue;
      const state = cast.state || 'flying';
      const caster = cast.casterRef;
      const baseOrigin = resolveCastOrigin(cast);
      const dynamicOrigin = state === 'pulling' && cast.pullCaster && caster;
      const originX = dynamicOrigin ? caster.x : (Number.isFinite(cast.casterOriginX) ? Number(cast.casterOriginX) : baseOrigin.x);
      const originY = dynamicOrigin ? caster.y : (Number.isFinite(cast.casterOriginY) ? Number(cast.casterOriginY) : baseOrigin.y);

      if(state === 'channel'){
        const elapsed = Math.max(0, Number(cast.elapsed) || 0);
        const duration = Math.max(0.0001, Number(cast.channelDuration) || 0.0001);
        const progress = Math.max(0, Math.min(1, elapsed / duration));
        const pulse = progress * progress * (3 - 2 * progress);
        const baseRadius = (player && player.r ? player.r : 10) + 8;
        if(!circleInCamera(originX, originY, baseRadius + 12)) continue;
        ctx.save();
        ctx.globalAlpha = 0.35 + 0.4 * pulse;
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#9ce7ff';
        ctx.beginPath();
        ctx.arc(originX, originY, baseRadius + pulse * 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        continue;
      }

      const traveled = Math.max(0, Number(cast.distanceTraveled) || 0);
      const tipX = state === 'pulling' && cast.targetRef
        ? cast.targetRef.x
        : (Number.isFinite(cast.hitPointX) ? cast.hitPointX : originX + (Number(cast.dirX) || 0) * traveled);
      const tipY = state === 'pulling' && cast.targetRef
        ? cast.targetRef.y
        : (Number.isFinite(cast.hitPointY) ? cast.hitPointY : originY + (Number(cast.dirY) || 0) * traveled);

      const width = Math.max(6, grabWidthAt(cast, traveled) * 0.5 + 4);
      if(!rectIntersectsCamera(originX, originY, tipX, tipY, width * 1.5)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.82;
      ctx.shadowColor = '#5ad7ff';
      ctx.shadowBlur = 18;
      ctx.strokeStyle = '#5ad7ff';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(tipX, tipY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#e3faff';
      ctx.beginPath();
      ctx.arc(tipX, tipY, Math.max(6, width * 0.45), 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0b1b28';
      ctx.stroke();
      ctx.restore();

      if(state === 'pulling'){
        ctx.save();
        ctx.setLineDash([8, 6]);
        ctx.globalAlpha = 0.7;
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#9ce7ffaa';
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.lineTo(tipX, tipY);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawExpandingShotProjectiles(){
    for(const proj of expandingShotProjectiles){
      const startX = Number.isFinite(proj.startX) ? proj.startX : 0;
      const startY = Number.isFinite(proj.startY) ? proj.startY : 0;
      const headX = Number.isFinite(proj.currentX) ? proj.currentX : startX;
      const headY = Number.isFinite(proj.currentY) ? proj.currentY : startY;
      const width = Math.max(2, Number(proj.width) || 0);
      if(!rectIntersectsCamera(startX, startY, headX, headY, Math.max(width, 10))) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.shadowColor = '#ffd27a';
      ctx.shadowBlur = 20;
      ctx.strokeStyle = '#ffb347';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#ffe9c7';
      ctx.lineWidth = Math.max(1.2, width * 0.45);
      const tailOffset = Math.min(width * 0.6, 14);
      const tailX = headX - (Number(proj.dirX) || 0) * tailOffset;
      const tailY = headY - (Number(proj.dirY) || 0) * tailOffset;
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawBacklineSeizureCasts(){
    for(const cast of backlineSeizureCasts){
      if(!cast) continue;
      const origin = resolveCastOrigin(cast);
      const dirX = Number(cast.dirX) || 0;
      const dirY = Number(cast.dirY) || 0;
      const range = Math.max(0, Number(cast.range) || 0);
      const width = Math.max(6, Number(cast.width) || 0);
      const endX = origin.x + dirX * range;
      const endY = origin.y + dirY * range;
      if(!rectIntersectsCamera(origin.x, origin.y, endX, endY, width * 1.5)) continue;
      const angle = Math.atan2(dirY, dirX);
      const duration = Math.max(0.0001, Number(cast.castDuration) || 0.0001);
      const state = cast.state || 'seeking';
      const progress = state === 'windup' && duration > 0 ? clamp01((Number(cast.elapsed) || 0) / duration) : 1;
      ctx.save();
      ctx.translate(origin.x, origin.y);
      ctx.rotate(angle);
      ctx.globalAlpha = state === 'seizing' ? 0.6 : 0.35 + 0.35 * progress;
      ctx.fillStyle = state === 'seizing' ? '#ffb88a33' : '#ff9f7a26';
      ctx.fillRect(0, -width / 2, range, width);
      ctx.lineWidth = 2;
      ctx.strokeStyle = state === 'seizing' ? '#ffb25f' : '#ff9f7a';
      ctx.strokeRect(0, -width / 2, range, width);
      ctx.restore();
      if(state === 'seizing' && cast.targetRef){
        const tx = cast.targetRef.x;
        const ty = cast.targetRef.y;
        if(rectIntersectsCamera(origin.x, origin.y, tx, ty, width * 1.2)){
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.lineWidth = 2.5;
          ctx.strokeStyle = '#ffb25f';
          ctx.beginPath();
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(tx, ty);
          ctx.stroke();
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = '#ffb25f';
          ctx.beginPath();
          ctx.arc(tx, ty, Math.max(8, width * 0.4), 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
    }
  }

  function drawLinkLashCasts(){
    for(const cast of linkLashCasts){
      if(!cast) continue;
      const state = cast.state || 'flying';
      const originX = Number.isFinite(cast.startX) ? cast.startX : player.x;
      const originY = Number.isFinite(cast.startY) ? cast.startY : player.y;

      if(state === 'channel'){
        const elapsed = Math.max(0, Number(cast.elapsed) || 0);
        const duration = Math.max(0.0001, Number(cast.channelDuration) || 0.0001);
        const progress = Math.max(0, Math.min(1, elapsed / duration));
        const pulse = progress * progress * (3 - 2 * progress);
        const baseRadius = (player && player.r ? player.r : 10) + 6;
        if(!circleInCamera(originX, originY, baseRadius + 12)) continue;
        ctx.save();
        ctx.globalAlpha = 0.35 + 0.4 * pulse;
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#7fe3ff';
        ctx.beginPath();
        ctx.arc(originX, originY, baseRadius + pulse * 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        continue;
      }

      const traveled = Math.max(0, Number(cast.distanceTraveled) || 0);
      const tipX = Number.isFinite(cast.hitPointX) ? cast.hitPointX : originX + (Number(cast.dirX) || 0) * traveled;
      const tipY = Number.isFinite(cast.hitPointY) ? cast.hitPointY : originY + (Number(cast.dirY) || 0) * traveled;
      const width = Math.max(6, linkLashWidthAt(cast, traveled) * 0.5 + 5);
      if(!rectIntersectsCamera(originX, originY, tipX, tipY, width * 1.5)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.85;
      ctx.shadowColor = '#7fe3ff';
      ctx.shadowBlur = 16;
      ctx.strokeStyle = '#7fe3ff';
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(tipX, tipY);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#e4fbff';
      ctx.beginPath();
      ctx.arc(tipX, tipY, Math.max(5, width * 0.4), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawLinkLashTethers(){
    for(const tether of linkLashTethers){
      if(!tether) continue;
      const primary = tether.primaryRef;
      if(!linkLashTargetAlive(primary)) continue;
      const caster = tether.casterRef || player;
      const origin = getSpellOrigin(caster);
      if(!rectIntersectsCamera(origin.x, origin.y, primary.x, primary.y, 10)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = tether.followupUsed ? 0.65 : 0.82;
      ctx.lineWidth = tether.followupUsed ? 3 : 4;
      ctx.strokeStyle = tether.followupUsed ? '#bde8ff' : '#7fe3ff';
      ctx.setLineDash(tether.followupUsed ? [6, 6] : [12, 6]);
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(primary.x, primary.y);
      ctx.stroke();
      ctx.restore();
      if(tether.followupUsed && linkLashTargetAlive(tether.secondaryRef)){
        ctx.save();
        ctx.lineCap = 'round';
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = '#9ce7ff';
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(primary.x, primary.y);
        ctx.lineTo(tether.secondaryRef.x, tether.secondaryRef.y);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawShadowPursuitTrails(){
    if(!shadowPursuitCasts.length) return;
    for(const cast of shadowPursuitCasts){
      if(!cast || cast.state !== 'active' || cast.ended) continue;
      const caster = cast.casterRef || player;
      if(!caster || Number(caster.hp) <= 0) continue;
      const detectionRadius = Math.max(0, Number(cast.detectionRadius) || 0);
      if(detectionRadius > 0 && circleInCamera(caster.x, caster.y, detectionRadius + 12)){
        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = '#7fe3ff';
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, detectionRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.45;
        ctx.setLineDash([6, 6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#7fe3ff';
        ctx.beginPath();
        ctx.arc(caster.x, caster.y, detectionRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      const target = cast.trackedTarget;
      if(!target || Number(target.hp) <= 0) continue;
      if(!rectIntersectsCamera(caster.x, caster.y, target.x, target.y, 12)) continue;
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.setLineDash([10, 8]);
      ctx.lineWidth = 3;
      const gradient = ctx.createLinearGradient(caster.x, caster.y, target.x, target.y);
      gradient.addColorStop(0, 'rgba(127, 227, 255, 0.9)');
      gradient.addColorStop(1, 'rgba(64, 196, 255, 0.35)');
      ctx.strokeStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(caster.x, caster.y);
      ctx.lineTo(target.x, target.y);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawFlipbladeMarks(){
    for(const mark of flipbladeMarks){
      if(!mark) continue;
      const targetAlive = mark.targetRef && mark.targetRef.hp > 0 && mark.targetRef.portalizing <= 0;
      const x = targetAlive ? mark.targetRef.x : mark.lastKnownX;
      const y = targetAlive ? mark.targetRef.y : mark.lastKnownY;
      if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
      const outerRadius = minionRadius + 18;
      if(!circleInCamera(x, y, outerRadius + 12)) continue;
      const duration = Math.max(0.0001, Number(mark.duration) || Number(mark.remaining) || 1);
      const t = clamp01((Number(mark.remaining) || 0) / duration);
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.5 + 0.4 * t;
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#7fffd4';
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = '#104437';
      ctx.beginPath();
      ctx.arc(x, y, Math.max(minionRadius + 6, outerRadius * 0.6), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function removeEdgeFluxMark(mark){
    if(!mark){
      return;
    }
    const idx = edgeFluxMarks.indexOf(mark);
    if(idx >= 0){
      edgeFluxMarks.splice(idx, 1);
    }
    if(mark.targetRef && mark.targetRef.edgeFluxMark === mark){
      delete mark.targetRef.edgeFluxMark;
    }
  }

  function tryDetonateEdgeFluxMark(target, { prevHp = null, cause = 'attack' } = {}){
    if(!target){
      return false;
    }
    const mark = target.edgeFluxMark;
    if(!mark || mark.casterRef !== player){
      return false;
    }
    const damage = Math.max(0, Number(mark.bonusDamage) || 0);
    if(!(damage > 0)){
      removeEdgeFluxMark(mark);
      return false;
    }
    const beforeHp = Number.isFinite(prevHp) ? Math.max(0, prevHp) : Math.max(0, Number(target.hp) || 0) + damage;
    const nextHp = Math.max(0, Number(target.hp) - damage);
    target.hp = nextHp;
    const offset = target === monsterState ? Math.max(24, monsterAttackRadius()) : minionRadius;
    spawnHitSplat(target.x, target.y - offset, damage);
    flash(target.x, target.y, { startRadius: 12, endRadius: 36, color: '#9ff1ff' });
    if(target === monsterState){
      updateMonsterHud();
    }
    if(target.isPracticeDummy === true){
      handlePracticeDummyDamage(target, beforeHp);
    }
    playerDrewTurretAggro(target);
    setHudMessage(`${mark.abilityName || 'Edgeflare Mark'} detonated!`);
    removeEdgeFluxMark(mark);
    return true;
  }

  function spawnEdgeFluxProjectile(opts){
    const range = Math.max(0, Number(opts && opts.range) || 0);
    const speed = Math.max(0, Number(opts && opts.speed) || 0);
    if(range <= 0 || speed <= 0){
      return null;
    }
    let dirX = Number(opts && opts.dirX) || 0;
    let dirY = Number(opts && opts.dirY) || 0;
    const len = Math.hypot(dirX, dirY);
    if(len <= 0.0001){
      return null;
    }
    dirX /= len;
    dirY /= len;
    const proj = {
      abilityId: opts && opts.abilityId,
      abilityName: opts && opts.abilityName,
      casterRef: opts && opts.casterRef || player,
      slotIndex: Number.isFinite(opts && opts.slotIndex) ? opts.slotIndex : null,
      startX: Number(opts && opts.startX) || 0,
      startY: Number(opts && opts.startY) || 0,
      dirX,
      dirY,
      speed,
      range,
      width: Math.max(0, Number(opts && opts.width) || 0),
      bonusDamage: Math.max(0, Number(opts && opts.bonusDamage) || 0),
      markDuration: Math.max(0, Number(opts && opts.markDuration) || 0),
      traveled: 0
    };
    edgeFluxProjectiles.push(proj);
    return proj;
  }

  function applyEdgeFluxProjectileHit(proj, target){
    if(!proj || !target){
      return false;
    }
    const duration = Math.max(0, Number(proj.markDuration) || 0);
    const bonusDamage = Math.max(0, Number(proj.bonusDamage) || 0);
    if(duration <= 0 || bonusDamage <= 0){
      return false;
    }
    removeEdgeFluxMark(target.edgeFluxMark);
    const mark = {
      id: `edgeflux-${abilityRuntime.edgeFluxSequence++}`,
      abilityId: proj.abilityId,
      abilityName: proj.abilityName,
      slotIndex: proj.slotIndex,
      casterRef: proj.casterRef || player,
      targetRef: target,
      targetId: target.id || null,
      lastKnownX: target.x,
      lastKnownY: target.y,
      remaining: duration,
      duration,
      bonusDamage
    };
    target.edgeFluxMark = mark;
    edgeFluxMarks.push(mark);
    if(proj.casterRef === player){
      flash(target.x, target.y, { startRadius: 10, endRadius: 32, color: '#c2f3ff' });
      setHudMessage(`${mark.abilityName || 'Edgeflare Mark'} tagged the target!`);
    }
    return true;
  }

  function updateEdgeFluxProjectiles(dt){
    for(let i = edgeFluxProjectiles.length - 1; i >= 0; i--){
      const proj = edgeFluxProjectiles[i];
      if(!proj){
        edgeFluxProjectiles.splice(i, 1);
        continue;
      }
      const speed = Math.max(0, Number(proj.speed) || 0);
      if(speed <= 0){
        edgeFluxProjectiles.splice(i, 1);
        continue;
      }
      const range = Math.max(0, Number(proj.range) || 0);
      const prevTraveled = Math.max(0, Number(proj.traveled) || 0);
      const travel = speed * dt;
      const nextTraveled = range > 0 ? Math.min(range, prevTraveled + travel) : prevTraveled + travel;
      const hitTarget = (() => {
        let best = null;
        let bestAlong = Infinity;
        const halfWidth = Math.max(0, Number(proj.width) || 0) * 0.5;
        const consider = (entity, radius) => {
          if(!entity || entity.hp <= 0 || entity.portalizing > 0) return;
          if(entity === player) return;
          const relX = entity.x - proj.startX;
          const relY = entity.y - proj.startY;
          const along = relX * proj.dirX + relY * proj.dirY;
          if(along < prevTraveled - radius || along > nextTraveled + radius) return;
          const closestX = proj.startX + proj.dirX * along;
          const closestY = proj.startY + proj.dirY * along;
          const dx = entity.x - closestX;
          const dy = entity.y - closestY;
          const effRadius = radius + halfWidth;
          if(dx * dx + dy * dy <= effRadius * effRadius && along < bestAlong){
            bestAlong = along;
            best = entity;
          }
        };
        for(const m of minions){
          if(!m || !isEnemyMinionForPlayer(m)) continue;
          consider(m, minionRadius);
        }
        if(practiceDummy && practiceDummy.active !== false && !(practiceDummy.respawnTimer > 0)){
          consider(practiceDummy, Math.max(minionRadius, Number(practiceDummy.radius) || minionRadius));
        }
        if(monsterState && Number(monsterState.hp) > 0){
          consider(monsterState, Math.max(24, Number(monsterState.radius) || 30));
        }
        return best;
      })();
      if(hitTarget){
        applyEdgeFluxProjectileHit(proj, hitTarget);
        edgeFluxProjectiles.splice(i, 1);
        continue;
      }
      if(range > 0 && nextTraveled >= range - 0.001){
        edgeFluxProjectiles.splice(i, 1);
        continue;
      }
      proj.traveled = nextTraveled;
    }
  }

  function updateEdgeFluxMarks(dt){
    for(let i = edgeFluxMarks.length - 1; i >= 0; i--){
      const mark = edgeFluxMarks[i];
      if(!mark){
        edgeFluxMarks.splice(i, 1);
        continue;
      }
      const target = mark.targetRef;
      const targetAlive = target && target.hp > 0 && target.portalizing <= 0;
      if(targetAlive){
        mark.lastKnownX = target.x;
        mark.lastKnownY = target.y;
      }
      mark.remaining = Math.max(0, Number(mark.remaining) || 0) - dt;
      if(mark.remaining <= 0 || !targetAlive){
        removeEdgeFluxMark(mark);
      }
    }
  }

  function drawEdgeFluxMarks(){
    for(const mark of edgeFluxMarks){
      if(!mark) continue;
      const targetAlive = mark.targetRef && mark.targetRef.hp > 0 && mark.targetRef.portalizing <= 0;
      const x = targetAlive ? mark.targetRef.x : mark.lastKnownX;
      const y = targetAlive ? mark.targetRef.y : mark.lastKnownY;
      if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
      const duration = Math.max(0.0001, Number(mark.duration) || 1);
      const t = clamp01((Number(mark.remaining) || 0) / duration);
      const radius = Math.max(minionRadius + 12, minionRadius * 1.5 + (1 - t) * 18);
      if(!circleInCamera(x, y, radius + 12)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.4 + 0.35 * t;
      ctx.setLineDash([8, 6]);
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#9ff3ff';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#104437';
      ctx.beginPath();
      ctx.arc(x, y, Math.max(radius * 0.6, minionRadius + 4), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawVerdictSalvoChannels(){
    for(const cast of verdictSalvoCasts){
      if(!cast || cast.ended) continue;
      const caster = cast.casterRef || player;
      const { x: originX, y: originY } = getSpellOrigin(caster);
      const dirX = Number(cast.lockDirX) || 0;
      const dirY = Number(cast.lockDirY) || 0;
      const previewLength = Math.max(0, Number(cast.projectileRange) || 0);
      const lineLength = previewLength > 0 ? previewLength : 160;
      const muzzleOffset = (caster && Number.isFinite(caster.r) ? caster.r : player.r || 10) + 6;
      const startX = originX + dirX * muzzleOffset;
      const startY = originY + dirY * muzzleOffset;
      const endX = startX + dirX * lineLength;
      const endY = startY + dirY * lineLength;
      const baseWidth = Math.max(2, (Number(cast.projectileWidth) || 0) * 0.35 + 2);
      if(!rectIntersectsCamera(startX, startY, endX, endY, baseWidth * 2)) continue;
      const stored = Math.max(0, Math.min(Math.round(Number(cast.storedBullets) || 0), Math.round(Number(cast.maxStoredBullets) || 0)));
      const readiness = cast.maxStoredBullets > 0 ? Math.min(1, stored / cast.maxStoredBullets) : 1;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.35 + readiness * 0.35;
      ctx.lineWidth = baseWidth;
      ctx.strokeStyle = '#f7d469';
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.globalAlpha = 0.8;
      ctx.lineWidth = Math.max(1, baseWidth * 0.45);
      ctx.strokeStyle = '#fff4bf';
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawCullingBarrageChannels(){
    for(const channel of cullingBarrageChannels){
      if(!channel || channel.ended) continue;
      const caster = channel.casterRef || player;
      const { x: originX, y: originY } = getSpellOrigin(caster);
      const dirX = Number(channel.aimDirX) || 0;
      const dirY = Number(channel.aimDirY) || 0;
      const previewLength = Math.max(0, Number(channel.aimPreviewRange) || Number(channel.projectileRange) || 0);
      const lineLength = previewLength > 0 ? previewLength : 160;
      const muzzleOffset = (caster && Number.isFinite(caster.r) ? caster.r : player.r || 10) + 6;
      const startX = originX + dirX * muzzleOffset;
      const startY = originY + dirY * muzzleOffset;
      const endX = startX + dirX * lineLength;
      const endY = startY + dirY * lineLength;
      const baseWidth = Math.max(2, (Number(channel.projectileWidth) || 0) * 0.35 + 2);
      if(!rectIntersectsCamera(startX, startY, endX, endY, baseWidth * 2)) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.45;
      ctx.lineWidth = baseWidth;
      ctx.strokeStyle = '#9ce7ff';
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.globalAlpha = 0.75;
      ctx.lineWidth = Math.max(1, baseWidth * 0.4);
      ctx.strokeStyle = '#e4f6ff';
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawVerdictSalvoProjectiles(){
    for(const proj of verdictSalvoProjectiles){
      if(!proj) continue;
      const traveled = Math.max(0, Number(proj.traveled) || 0);
      const dirX = Number(proj.dirX) || 0;
      const dirY = Number(proj.dirY) || 0;
      const headX = proj.startX + dirX * traveled;
      const headY = proj.startY + dirY * traveled;
      const tailLength = Math.min(traveled, 160);
      const tailX = headX - dirX * tailLength;
      const tailY = headY - dirY * tailLength;
      const width = Math.max(2, (Number(proj.width) || 0) * 0.35 + 1.5);
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, Math.max(width, 12))) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = width;
      ctx.strokeStyle = '#f7d469cc';
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.lineWidth = Math.max(1, width * 0.45);
      ctx.strokeStyle = '#fff4bf';
      ctx.beginPath();
      ctx.moveTo(headX - dirX * Math.max(6, width * 0.6), headY - dirY * Math.max(6, width * 0.6));
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawSkyfireVolleyProjectiles(){
    for(const proj of skyfireVolleyProjectiles){
      if(!proj) continue;
      const traveled = Math.max(0, Number(proj.traveled) || 0);
      const dirX = Number(proj.dirX) || 0;
      const dirY = Number(proj.dirY) || 0;
      const x = Number.isFinite(proj.currentX) ? proj.currentX : proj.startX + dirX * traveled;
      const y = Number.isFinite(proj.currentY) ? proj.currentY : proj.startY + dirY * traveled;
      if(!circleInCamera(x, y, 32)) continue;
      const tailLength = Math.min(traveled, 120);
      const tailX = x - dirX * tailLength;
      const tailY = y - dirY * tailLength;
      const width = Math.max(2, (Number(proj.width) || 0) * 0.45 + 2);
      const color = proj.bigShot ? '#ffe2b3' : '#ffb77f';
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.75;
      ctx.lineWidth = width;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff4cf';
      ctx.beginPath();
      ctx.arc(x, y, Math.max(4, width * 0.85), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawCascadeBarrageMissiles(){
    for(const missile of cascadeBarrageMissiles){
      if(!missile) continue;
      const startX = Number.isFinite(missile.startX) ? missile.startX : player.x;
      const startY = Number.isFinite(missile.startY) ? missile.startY : player.y;
      const targetX = Number.isFinite(missile.targetX)
        ? missile.targetX
        : Number.isFinite(missile.startX) ? missile.startX : player.x;
      const targetY = Number.isFinite(missile.targetY)
        ? missile.targetY
        : Number.isFinite(missile.startY) ? missile.startY : player.y;
      const delay = Math.max(0, Number(missile.delay) || 0);
      const progress = delay > 0 ? Math.min(1, Math.max(0, Number(missile.elapsed) || 0) / delay) : 1;
      const alpha = Math.max(0, 0.45 + (1 - progress) * 0.5);
      const width = Math.max(1, 3 + (1 - progress) * 4);
      const radius = Math.max(3, 6 + (1 - progress) * 6);
      const minX = Math.min(startX, targetX) - width;
      const minY = Math.min(startY, targetY) - width;
      const maxX = Math.max(startX, targetX) + width;
      const maxY = Math.max(startY, targetY) + width;
      const bboxWidth = Math.max(1, maxX - minX);
      const bboxHeight = Math.max(1, maxY - minY);
      if(!rectIntersectsCamera(minX, minY, bboxWidth, bboxHeight)) continue;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.lineWidth = width;
      ctx.strokeStyle = '#9ef0ff';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(targetX, targetY);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.globalAlpha = Math.max(0, 0.65 - progress * 0.35);
      ctx.fillStyle = '#c4f7ff';
      ctx.beginPath();
      ctx.arc(targetX, targetY, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawCullingBarrageProjectiles(){
    for(const proj of cullingBarrageProjectiles){
      if(!proj) continue;
      const traveled = Math.max(0, Number(proj.traveled) || 0);
      const dirX = Number(proj.dirX) || 0;
      const dirY = Number(proj.dirY) || 0;
      const headX = proj.startX + dirX * traveled;
      const headY = proj.startY + dirY * traveled;
      const tailLength = Math.min(traveled, 200);
      const tailX = headX - dirX * tailLength;
      const tailY = headY - dirY * tailLength;
      const width = Math.max(2, (Number(proj.width) || 0) * 0.4 + 1.5);
      if(!rectIntersectsCamera(tailX, tailY, headX, headY, Math.max(width, 12))) continue;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = width;
      ctx.strokeStyle = '#9ce7ffcc';
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.lineWidth = Math.max(1, width * 0.45);
      ctx.strokeStyle = '#f1fbff';
      ctx.beginPath();
      ctx.moveTo(headX - dirX * Math.max(6, width * 0.6), headY - dirY * Math.max(6, width * 0.6));
      ctx.lineTo(headX, headY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawMonsterProjectileVisual(p, progress, cx, cy){
    const abilityId = p.monsterAbility;
    if(!abilityId){
      return false;
    }
    const startX = p.startX;
    const startY = p.startY;
    const targetX = p.targetX;
    const targetY = p.targetY;
    const dirX = targetX - startX;
    const dirY = targetY - startY;
    const length = Math.hypot(dirX, dirY) || 1;
    const normX = dirX / length;
    const normY = dirY / length;
    const perpX = -normY;
    const perpY = normX;
    const travel = Math.max(18, Math.min(length * progress, 220));
    const tailX = cx - normX * travel;
    const tailY = cy - normY * travel;
    ctx.save();
    if(abilityId === 'blue'){
      const waveCount = 3;
      for(let i = 0; i < waveCount; i++){
        const radius = 10 + i * 6;
        const alpha = 0.55 - i * 0.15;
        ctx.globalAlpha = Math.max(0.2, alpha);
        ctx.lineWidth = 2.5 - i * 0.6;
        ctx.strokeStyle = '#7fc7ff';
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#2a8cff66';
      ctx.beginPath();
      ctx.moveTo(tailX + perpX * 8, tailY + perpY * 8);
      ctx.quadraticCurveTo((tailX + cx) / 2, (tailY + cy) / 2, cx, cy);
      ctx.stroke();
    } else if(abilityId === 'red'){
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#ff8255dd';
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(tailX + perpX * 10, tailY + perpY * 10);
      ctx.lineTo(tailX - perpX * 10, tailY - perpY * 10);
      ctx.closePath();
      ctx.fill();
      const flameRadius = 11;
      const gradient = ctx.createRadialGradient(cx, cy, 2, cx, cy, flameRadius);
      gradient.addColorStop(0, '#ffd1a8');
      gradient.addColorStop(0.5, '#ff874d');
      gradient.addColorStop(1, '#b32718');
      ctx.beginPath();
      ctx.fillStyle = gradient;
      ctx.arc(cx, cy, flameRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#320d04';
      ctx.stroke();
    } else if(abilityId === 'green'){
      const rockRadius = 12;
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = '#6f7f52';
      ctx.beginPath();
      ctx.arc(cx, cy, rockRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = '#2f381c';
      ctx.stroke();
      ctx.globalAlpha = 0.75;
      ctx.strokeStyle = '#a9c47a';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx + perpX * 6, cy + perpY * 6);
      ctx.lineTo(cx - perpX * 4, cy - perpY * 6);
      ctx.lineTo(cx - normX * 6, cy - normY * 6);
      ctx.stroke();
    } else {
      ctx.restore();
      return false;
    }
    const emoji = resolveMonsterAbilityEmoji(p.monsterRef || monsterState, abilityId);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, cx, cy);
    ctx.restore();
    return true;
  }

  function drawProjectiles(){
    for(const p of projectiles){
      const clamped = Math.min(1, Math.max(0, p.progress));
      const tx = p.targetX;
      const ty = p.targetY;
      const cx = p.startX + (tx - p.startX) * clamped;
      const cy = p.startY + (ty - p.startY) * clamped;
      if(!rectIntersectsCamera(p.startX, p.startY, cx, cy, 18)) continue;
      if(p.monsterAbility && drawMonsterProjectileVisual(p, clamped, cx, cy)){
        continue;
      }
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(p.startX, p.startY);
      ctx.lineTo(cx, cy);
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = '#a5e8ff55';
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#d9f6ff';
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#0b1b28';
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawHitSplats(){
    for(const h of hitsplats){
      const life = Math.max(0.001, h.lifetime || 0.001);
      const progress = Math.max(0, Math.min(1, h.age / life));
      const alpha = Math.max(0, 1 - progress);
      if(alpha <= 0) continue;
      const rise = Math.max(0, h.rise || 0);
      const size = Math.max(8, h.size || 0);
      const text = String(h.amount);
      const drawY = h.y - rise * progress;
      if(!circleInCamera(h.x, drawY, size * 0.75)) continue;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = `bold ${size}px system-ui`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.lineJoin = 'round';
      const outline = Math.max(2, size * 0.15);
      ctx.lineWidth = outline;
      ctx.strokeStyle = '#05121a';
      ctx.strokeText(text, h.x, drawY);
      ctx.fillStyle = '#ffe27a';
      ctx.fillText(text, h.x, drawY);
      ctx.restore();
    }
  }

  function drawPlayer(){
    if(!Number.isFinite(player.x) || !Number.isFinite(player.y)){
      player.x = mapState.width / 2;
      player.y = mapState.height / 2;
    }
    if(!Number.isFinite(player.r)){
      player.r = Math.max(6, playerRadius || 10);
    }
    const range = Math.max(0, Number(player.attackRange) || 0);
    const rangeOpacityRaw = Number(player.attackRangeOpacity);
    const rangeOpacity = Math.max(0, Math.min(1, Number.isFinite(rangeOpacityRaw) ? rangeOpacityRaw : 0));
    if(range > 0){
      ctx.save();
      const isRed = player.team === 'red';
      if(rangeOpacity > 0){
        const fillColor = isRed
          ? `rgba(255, 85, 119, ${rangeOpacity})`
          : `rgba(42, 169, 255, ${rangeOpacity})`;
        ctx.beginPath();
        ctx.arc(player.x, player.y, range, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
      }
      ctx.setLineDash([10, 6]);
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = isRed ? '#ff5577aa' : '#2aa9ffaa';
      ctx.beginPath();
      ctx.arc(player.x, player.y, range, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    const windupRemaining = Math.max(0, Number(player.attackWindup) || 0);
    if(windupRemaining > 0 && range > 0){
      const windupTotal = Math.max(0, Number(player.attackWindupMs) || 0) / 1000;
      if(windupTotal > 0){
        const normalized = Math.max(0, Math.min(1, 1 - (windupRemaining / windupTotal)));
        const innerRadius = Math.max(0, range - 18);
        const outerRadius = Math.max(innerRadius + 12, range + 32);
        const gradient = ctx.createRadialGradient(player.x, player.y, innerRadius, player.x, player.y, outerRadius);
        gradient.addColorStop(0, 'rgba(255, 255, 190, 0)');
        gradient.addColorStop(0.35, 'rgba(221, 255, 102, 0.72)');
        gradient.addColorStop(0.7, 'rgba(168, 255, 0, 0.36)');
        gradient.addColorStop(1, 'rgba(132, 255, 0, 0)');
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const baseAlpha = 0.95 - normalized * 0.28;
        ctx.globalAlpha = Math.min(1, baseAlpha * 1.25);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(player.x, player.y, outerRadius, 0, Math.PI * 2);
        if(innerRadius > 0){
          ctx.arc(player.x, player.y, innerRadius, 0, Math.PI * 2, true);
          ctx.fill('evenodd');
        } else {
          ctx.fill();
        }
        ctx.restore();
      }
    }

    // Simple player marker circle.
    const renderPlayerCircle = ()=>{
      const radius = Math.max(6, Number(player.r) || 12);
      if(!circleInCamera(player.x, player.y, radius + 6)) return;
      const baseColor = typeof player.color === 'string' ? player.color : '#7fe3ff';
      ctx.save();
      const shadowActive = playerRuntime.shadowPursuitActive === true;
      if(shadowActive){
        ctx.globalAlpha = 0.72;
      }
      ctx.beginPath();
      ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = baseColor;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#05121a';
      ctx.stroke();
      if(shadowActive){
        ctx.globalAlpha = 0.65;
        ctx.setLineDash([4, 6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#7fe3ff';
        ctx.beginPath();
        ctx.arc(player.x, player.y, radius + 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.restore();
    };
    renderPlayerCircle();

    const showHitbox = player.hitboxVisible !== false;
    const showHurtbox = player.hurtboxVisible !== false;
    const hasRuntimeModel = playerRuntime.model && playerRuntime.model.isActive();
    const hitboxLengthRaw = Number(player.hitboxLength);
    const hitboxWidthRaw = Number(player.hitboxWidth);
    const hitboxLength = Number.isFinite(hitboxLengthRaw) ? Math.max(0, hitboxLengthRaw) : 0;
    const hitboxWidth = Number.isFinite(hitboxWidthRaw) ? Math.max(0, hitboxWidthRaw) : 0;
    const hitboxShape = typeof player.hitboxShape === 'string' ? player.hitboxShape : 'capsule';
    const hurtboxLengthRaw = Number(player.hurtboxLength);
    const hurtboxWidthRaw = Number(player.hurtboxWidth);
    const hurtboxLength = Number.isFinite(hurtboxLengthRaw) ? Math.max(0, hurtboxLengthRaw) : hitboxLength;
    const hurtboxWidth = Number.isFinite(hurtboxWidthRaw) ? Math.max(0, hurtboxWidthRaw) : hitboxWidth;
    const hurtboxShape = typeof player.hurtboxShape === 'string' ? player.hurtboxShape : hitboxShape;
    const playerRadius = Math.max(0, Number(player.r) || 0);
    if(showHitbox && (hitboxLength > 0 || hitboxWidth > 0)){
      ctx.save();
      ctx.beginPath();
      if(hitboxShape === 'rectangle'){
        const halfLength = hitboxLength > 0 ? hitboxLength / 2 : 0;
        const halfWidth = hitboxWidth > 0 ? hitboxWidth / 2 : 0;
        ctx.rect(player.x - halfWidth, player.y - halfLength, halfWidth * 2, halfLength * 2);
      } else if(hitboxShape === 'circle'){
        const diameter = hitboxWidth > 0 ? hitboxWidth : (hitboxLength > 0 ? hitboxLength : playerRadius * 2);
        const radius = Math.max(0, diameter / 2);
        ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
      } else {
        const halfWidth = hitboxWidth > 0 ? hitboxWidth / 2 : Math.max(playerRadius, hitboxLength / 2);
        const radius = Math.max(0, halfWidth);
        const halfLength = hitboxLength > 0 ? hitboxLength / 2 : Math.max(radius, playerRadius * 2);
        const bodyHalf = Math.max(0, halfLength - radius);
        if(bodyHalf <= 0){
          ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
        } else {
          ctx.arc(player.x, player.y - bodyHalf, radius, Math.PI, 0);
          ctx.arc(player.x, player.y + bodyHalf, radius, 0, Math.PI);
          ctx.closePath();
        }
      }
      if(hasRuntimeModel){
        ctx.lineWidth = 3;
        ctx.strokeStyle = player.color;
        ctx.stroke();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = '#05121a';
        ctx.stroke();
      } else {
        ctx.fillStyle = player.color;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#05121a';
        ctx.stroke();
      }
      ctx.restore();
    }

    if(isPlayerRecalling()){
      const duration = Math.max(0.1, Number(player.recall.duration) || RECALL_CHANNEL_SECONDS);
      const progress = Math.min(1, Math.max(0, player.recall.timer / duration));
      const recallRadius = Math.max(playerRadius + 36, 28);
      if(circleInCamera(player.x, player.y, recallRadius + 12)){
        ctx.save();
        ctx.globalAlpha = 0.28;
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#7fe3ff';
        ctx.beginPath();
        ctx.arc(player.x, player.y, recallRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 0.85;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(player.x, player.y, recallRadius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress);
        ctx.strokeStyle = '#7fe3ff';
        ctx.stroke();
        ctx.restore();
      }
    }

    if(showHitbox){
      const origin = getSpellOrigin(player);
      ctx.save();
      ctx.beginPath();
      ctx.arc(origin.x, origin.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#ffe27a';
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#05121a';
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(origin.x - 10, origin.y);
      ctx.lineTo(origin.x + 10, origin.y);
      ctx.moveTo(origin.x, origin.y - 10);
      ctx.lineTo(origin.x, origin.y + 10);
      ctx.strokeStyle = '#ffe27a88';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }
    if(showHurtbox && (hurtboxLength > 0 || hurtboxWidth > 0)){
      ctx.save();
      ctx.beginPath();
      if(hurtboxShape === 'rectangle'){
        const halfLength = hurtboxLength > 0 ? hurtboxLength / 2 : 0;
        const halfWidth = hurtboxWidth > 0 ? hurtboxWidth / 2 : 0;
        ctx.rect(player.x - halfWidth, player.y - halfLength, halfWidth * 2, halfLength * 2);
      } else if(hurtboxShape === 'circle'){
        const diameter = hurtboxWidth > 0 ? hurtboxWidth : (hurtboxLength > 0 ? hurtboxLength : playerRadius * 2);
        const radius = Math.max(1, diameter / 2);
        ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
      } else {
        const halfWidth = hurtboxWidth > 0 ? hurtboxWidth / 2 : Math.max(playerRadius, hurtboxLength / 2);
        const radius = Math.max(1, halfWidth);
        const halfLength = hurtboxLength > 0 ? hurtboxLength / 2 : Math.max(radius, playerRadius * 2);
        const bodyHalf = Math.max(0, halfLength - radius);
        if(bodyHalf <= 0){
          ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
        } else {
          ctx.arc(player.x, player.y - bodyHalf, radius, Math.PI, 0);
          ctx.arc(player.x, player.y + bodyHalf, radius, 0, Math.PI);
          ctx.closePath();
        }
      }
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = '#7fe3ffaa';
      ctx.stroke();
      ctx.restore();
    }
  }

  // Update & draw
  function tick(dt, now){
    const frameStart = perfNow();
    perfCounters.circleChecks = 0;
    perfCounters.pathfindCalls = 0;
    perfCounters.pathfindNodesVisited = 0;
    perfCounters.minimapRenders = 0;
    pathfindBudget = stressNavMode ? 6 : PATHFIND_BUDGET_PER_FRAME;
    // timer
    const gameTime = timerState.running ? now - timerState.start : timerState.elapsedMs;
    if(timerEl){
      const nextTimerText = fmt(gameTime);
      if(nextTimerText !== timerState.lastText){
        timerEl.textContent = nextTimerText;
        timerState.lastText = nextTimerText;
        scheduleHudFit();
      }
    }
    tickPracticeDummy(dt);
    updateMonsterState(dt);
    if(player.combatLockTimer > 0){
      player.combatLockTimer = Math.max(0, player.combatLockTimer - dt);
    }
    updatePlayerBaseState(dt);
    updatePlayerRecall(dt);
    updateShopState(dt);
    updateFrenziedSurgeAttackBuffs(dt);
    updateFrenziedSurgeMoveBuffs(dt);
    updateStrideSurgeAttackBuffs(dt);
    updateStrideSurgeMoveBuffs(dt);
    updatePhantomOverdriveAttackBuffs(dt);
    updatePhantomOverdriveMoveBuffs(dt);
    updateRoyalOnslaughtBuffs(dt);
    updateSpinningAxeFlights(dt);
    updateSpinningAxeMarkers(dt);
    updatePhantomOverdriveCasts(dt);
    updateShadowPursuitCasts(dt);
    updatePlayerShields(dt);
    const prevPlayerX = player.x;
    const prevPlayerY = player.y;
    const activeCast = player.casting;
    const isPlayerCasting = !!(activeCast && !activeCast.allowMovementWhileCasting);
    const isPlayerMovementLocked = Number(player.stunTimer) > 0 || Number(player.knockupTimer) > 0 || Number(player.polymorphTimer) > 0;
    const castMovementMultiplier = activeCast && Number.isFinite(activeCast.movementSpeedMultiplier)
      ? Math.max(0, activeCast.movementSpeedMultiplier)
      : 1;
    const slowRaw = Number(player.slowPct) || 0;
    const slowFraction = slowRaw > 1 ? slowRaw / 100 : slowRaw;
    const hasteRaw = Number(player.hastePct) || 0;
    const hasteFraction = hasteRaw > 1 ? hasteRaw / 100 : hasteRaw;
    const statusMovementMultiplier =
      (player.slowTimer > 0 ? Math.max(0, 1 - Math.min(1, slowFraction)) : 1) *
      (player.hasteTimer > 0 ? 1 + Math.max(0, hasteFraction) : 1);
    const baseMovementMultiplier = castMovementMultiplier * statusMovementMultiplier;
    const shadowPursuitMult = Math.max(0, Number(playerRuntime.shadowPursuitMoveMult) || 1);
    const movementMultiplier = isPlayerMovementLocked ? 0 : baseMovementMultiplier
      * Math.max(0, Number(frenziedSurgeMoveMultiplier) || 1)
      * Math.max(0, Number(phantomOverdriveMoveMultiplier) || 1)
      * Math.max(0, Number(strideSurgeMoveMultiplier) || 1)
      * Math.max(0, Number(spiralRamMoveMultiplier) || 1)
      * shadowPursuitMult;
    updateHudHealth();
    updatePracticeDummyHud();
    updateMonsterHud();

    if(timerState.running && !scoreState.gameOver && goldState.perSecond > 0){
      addGold(goldState.perSecond * dt);
    }

    // waves
    if (timerState.running && !scoreState.gameOver){
      const lanePlan = ensureLaneLayout();
      const bluePaths = lanePlan ? lanePlan.bluePaths : [];
      const redPaths = lanePlan ? lanePlan.redPaths : [];
      let canSpawn = bluePaths.length > 0 && redPaths.length > 0;
      if(!canSpawn){
        const fallbackBlue = getPath('blue');
        const fallbackRed = getPath('red');
        canSpawn = !!(fallbackBlue && fallbackRed);
      }
      if (canSpawn && gameTime >= timerState.nextWaveAtMs){
        waveState.waveNumber = (waveState.waveNumber|0) + 1;
        spawnWave('blue', gameTime, bluePaths);
        spawnWave('red', gameTime, redPaths);
        timerState.nextWaveAtMs = gameTime + waveState.waveIntervalMs;
      }
    }

    if (timerState.running && pendingSpawns.length){
      while (pendingSpawns.length && gameTime >= pendingSpawns[0].at){
        const job = pendingSpawns.shift();
        spawnFromQueue(job);
      }
    }

    // minion logic (move or attack)
    for(const m of minions){
      m.cd = Math.max(0, m.cd - dt);
      if(m && m.slowTimer > 0){
        m.slowTimer = Math.max(0, m.slowTimer - dt);
        if(m.slowTimer <= 0){
          m.slowPct = 0;
        }
      }
      if(m && m.chillTimer > 0){
        m.chillTimer = Math.max(0, m.chillTimer - dt);
      }
      if(m && m.poisonTimer > 0){
        m.poisonTimer = Math.max(0, m.poisonTimer - dt);
      }
      if(m && m.stunTimer > 0){
        m.stunTimer = Math.max(0, m.stunTimer - dt);
        if(m.stunTimer <= 0 && !m.beingPulledBy){
          m.stunTimer = 0;
        }
      }
      if(m && Number(m.damageReductionTimer) > 0){
        m.damageReductionTimer = Math.max(0, m.damageReductionTimer - dt);
        if(m.damageReductionTimer <= 0){
          m.damageReductionTimer = 0;
          m.damageReductionFraction = 0;
        }
      } else if(m && Number(m.damageReductionFraction) > 0){
        m.damageReductionFraction = 0;
      }
      if(m && m.plasmaTimer > 0){
        m.plasmaTimer = Math.max(0, m.plasmaTimer - dt);
      }
      if(m && m.moonlightTimer > 0){
        m.moonlightTimer = Math.max(0, m.moonlightTimer - dt);
      }
    }

    if(player){
      if(Number(player.slowTimer) > 0){
        player.slowTimer = Math.max(0, player.slowTimer - dt);
        if(player.slowTimer <= 0){
          player.slowTimer = 0;
          player.slowPct = 0;
        }
      }
      if(Number(player.chillTimer) > 0){
        player.chillTimer = Math.max(0, player.chillTimer - dt);
        if(player.chillTimer <= 0){
          player.chillTimer = 0;
        }
      }
      if(Number(player.poisonTimer) > 0){
        player.poisonTimer = Math.max(0, player.poisonTimer - dt);
      }
      if(Number(player.hasteTimer) > 0){
        player.hasteTimer = Math.max(0, player.hasteTimer - dt);
        const decay = Math.max(0, Number(player.hasteDecayRate) || 0);
        const hasteMin = Math.max(0, Number(player.hasteMinPct) || 0);
        if(decay > 0){
          player.hastePct = Math.max(hasteMin, player.hastePct - decay * dt);
        }
        if(player.hasteTimer <= 0){
          player.hasteTimer = 0;
          player.hastePct = 0;
          player.hasteDecayRate = 0;
          player.hasteMinPct = 0;
        }
      }
      if(Number(player.stunTimer) > 0){
        player.stunTimer = Math.max(0, player.stunTimer - dt);
        if(player.stunTimer <= 0){
          player.stunTimer = 0;
        }
      }
      if(Number(player.knockupTimer) > 0){
        player.knockupTimer = Math.max(0, player.knockupTimer - dt);
        if(player.knockupTimer <= 0){
          player.knockupTimer = 0;
        }
      }
      const miscTimers = ['silenceTimer', 'disarmTimer', 'polymorphTimer'];
      for(const key of miscTimers){
        if(Number(player[key]) > 0){
          player[key] = Math.max(0, Number(player[key]) - dt);
        }
      }
      if(Number(player.damageReductionTimer) > 0){
        player.damageReductionTimer = Math.max(0, player.damageReductionTimer - dt);
        if(player.damageReductionTimer <= 0){
          player.damageReductionTimer = 0;
          player.damageReductionFraction = 0;
        }
      } else if(Number(player.damageReductionFraction) > 0){
        player.damageReductionFraction = 0;
      }
      if(Number(player.ghostTimer) > 0){
        player.ghostTimer = Math.max(0, player.ghostTimer - dt);
      }
    }
    updatePlayerStatusIcons();
    updatePracticeDummyStatusIcons();
    if(monsterState && Number(monsterState.plasmaTimer) > 0){
      monsterState.plasmaTimer = Math.max(0, monsterState.plasmaTimer - dt);
    }
    if(monsterState && Number(monsterState.poisonTimer) > 0){
      monsterState.poisonTimer = Math.max(0, monsterState.poisonTimer - dt);
    }
    if(monsterState && Number(monsterState.moonlightTimer) > 0){
      monsterState.moonlightTimer = Math.max(0, monsterState.moonlightTimer - dt);
    }

    for(const m of minions){
      const laneProjection = updateMinionLaneFrame(m);
      const isSummonedPet = !!(m && m.isSummonedPet);
      const petMode = isSummonedPet ? (m.petMode || 'guard') : null;
      const guardLocksLane = isSummonedPet && petMode === 'guard';
      const preventPortal = isSummonedPet && m.disablePortal === true;
      if(m && m.isPracticeDummy){
        continue;
      }
      if(m.portalizing > 0){
        const portalAngle = Math.atan2(m.to.y - m.y, m.to.x - m.x);
        const laneFacing = typeof m.laneFacing === 'number' ? m.laneFacing : portalAngle;
        m.facing = blendAngles(portalAngle, laneFacing, 0.75);
        m.portalizing += dt;
        // on complete portalization: score + remove (via hp 0)
        if(m.portalizing >= 0.25 && !m.scored){
          const scoringSide = m.side; // owner scores at enemy portal
          addScore(scoringSide, scoreState.pointsPer);
          m.scored = true;
          m.hp = 0;
        }
        continue;
      }

      const friendlyTeam = (GameState.multiTeam && GameState.multiTeam.enabled)
        ? (m.teamId ?? m.side)
        : m.side;

      // nearest enemy
      let targetMinion = null;
      let best = Infinity;
      for(const n of minions){
        if(!isEnemyMinionForSide(n, friendlyTeam)) continue;
        const d = Math.hypot(n.x - m.x, n.y - m.y);
        if(d < best){
          best = d;
          targetMinion = n;
        }
      }

      const canConsiderPlayer = player && player.team !== m.side && Number.isFinite(player.hp) && player.hp > 0;
      const playerHitR = getPlayerHurtRadius();
      const playerCollR = playerCollisionRadius();
      let playerDistance = Infinity;
      if(canConsiderPlayer){
        playerDistance = Math.hypot(player.x - m.x, player.y - m.y);
      }
      const attackRange = MINION_RANGE + minionRadius;
      const engagedWithMinion = targetMinion && best <= attackRange;
      const hasNearbyEnemyMinions = targetMinion && best <= MINION_PLAYER_AGGRO_RANGE;
      const shouldChasePlayer = canConsiderPlayer && !engagedWithMinion && playerDistance <= MINION_PLAYER_AGGRO_RANGE;
      const canAttackPlayer = shouldChasePlayer && playerDistance <= (attackRange + playerHitR);
      const enemyPresence = hasNearbyEnemyMinions || shouldChasePlayer;
      const laneFree = !enemyPresence && !guardLocksLane;

      // portal zone detection
      const dToPortal = Math.hypot(m.to.x - m.x, m.to.y - m.y);
      m.inPortalZone = !preventPortal && laneFree && dToPortal <= PORTAL_INTAKE_R;
      const angleToPortal = Math.atan2(m.to.y - m.y, m.to.x - m.x);
      const laneFacing = typeof m.laneFacing === 'number' ? m.laneFacing : angleToPortal;

      if(!preventPortal && laneFree && dToPortal <= PORTAL_R){
        m.facing = blendAngles(angleToPortal, laneFacing, 0.65);
        m.portalizing = 0.0001;
        continue;
      }
      const angleToTarget = targetMinion ? Math.atan2(targetMinion.y - m.y, targetMinion.x - m.x) : null;
      const angleToPlayer = shouldChasePlayer ? Math.atan2(player.y - m.y, player.x - m.x) : null;
      let primaryAngle = angleToTarget;
      if(shouldChasePlayer && angleToPlayer !== null){
        primaryAngle = angleToPlayer;
      } else if(primaryAngle === null){
        primaryAngle = angleToPortal;
      }
      let facing = blendAngles(primaryAngle, laneFacing, (shouldChasePlayer || targetMinion) ? 0.35 : 0.6);

      if(m.stunTimer > 0 || m.beingPulledBy){
        if(m.beingPulledBy && typeof m.beingPulledBy.dirX === 'number' && typeof m.beingPulledBy.dirY === 'number'){
          facing = Math.atan2(m.beingPulledBy.dirY, m.beingPulledBy.dirX);
        }
        m.facing = facing;
        continue;
      }

      if(targetMinion && best <= attackRange){
        if(m.cd <= 0){
          const damage = Math.max(0, Number(m.dmg) || 0);
          if(damage > 0){
            const prevHp = Number(targetMinion.hp) || 0;
            targetMinion.hp = Math.max(0, prevHp - damage);
            spawnHitSplat(targetMinion.x, targetMinion.y - minionRadius, damage);
            separateMinionsAfterAttack(m, targetMinion, best);
            handlePracticeDummyDamage(targetMinion, prevHp);
          }
          m.cd = MINION_ATTACK_COOLDOWN;
        }
        if(angleToTarget !== null){
          facing = blendAngles(angleToTarget, laneFacing, 0.35);
        }
      } else if(shouldChasePlayer && canAttackPlayer){
        if(m.cd <= 0){
          const damage = Math.max(0, Number(m.dmg) || 0);
          if(damage > 0){
            damagePlayer(damage, { attacker: m });
            separateMinionFromPlayer(m, playerDistance, playerCollR);
          }
          m.cd = MINION_ATTACK_COOLDOWN;
        }
        if(angleToPlayer !== null){
          facing = blendAngles(angleToPlayer, laneFacing, 0.35);
        }
      } else {
        const chasingPlayer = shouldChasePlayer;
        let dest;
        let navGoal = null;
        const lanePoint = laneProjection || null;
        const lanePath = lanePoint && m.lanePath ? m.lanePath : null;
        const laneLength = lanePath
          ? (Number.isFinite(m.laneLength) ? m.laneLength : (Number.isFinite(lanePath.totalLength) ? lanePath.totalLength : undefined))
          : undefined;
        const offLaneDistance = lanePoint ? (Number.isFinite(m.offLaneDistance) ? m.offLaneDistance : (Number.isFinite(lanePoint.dist) ? lanePoint.dist : 0)) : 0;
        const onLaneTolerance = Math.max(minionRadius * 0.5, laneFanSpacing * 0.3);
        let followLane = false;
        let laneDestX = null;
        let laneDestY = null;

        if(laneFree){
          dest = m.to;
          navGoal = m.to;
          if(lanePath && lanePoint && lanePoint.point){
            const priorProgress = Number.isFinite(m.laneProgress) ? m.laneProgress : lanePoint.distance;
            const baseProgress = Math.max(priorProgress, lanePoint.distance);
            let lookAhead = Math.max(minionDiameter, (Number.isFinite(laneLength) ? Math.min(laneLength * 0.08, 80) : 40));
            if(offLaneDistance > onLaneTolerance){
              lookAhead = Math.max(minionDiameter * 0.75, laneFanSpacing);
            }
            let targetDistance = baseProgress + lookAhead;
            if(Number.isFinite(laneLength)){
              targetDistance = Math.min(laneLength, targetDistance);
            }
            const aheadPoint = offLaneDistance > onLaneTolerance
              ? lanePoint
              : (lanePointAtDistance(lanePath, targetDistance) || lanePoint);
            laneDestX = aheadPoint.point.x;
            laneDestY = aheadPoint.point.y;
            m.laneProgress = Math.max(baseProgress, aheadPoint.distance ?? baseProgress);
            followLane = true;
            navGoal = null;
            dest = { x: laneDestX, y: laneDestY };
          }
        } else if(chasingPlayer){
          dest = player;
          navGoal = { x: player.x, y: player.y };
        } else if(targetMinion){
          dest = targetMinion;
        } else if(m.neutralPoint){
          dest = m.neutralPoint;
          navGoal = m.neutralPoint;
        } else {
          dest = m.to;
        }
        if(stressNavMode && m.stressNav){
          if(followLane && laneDestX !== null && laneDestY !== null){
            navGoal = { x: laneDestX, y: laneDestY };
          } else if(!navGoal && dest){
            navGoal = { x: dest.x, y: dest.y };
          }
        }
        let navWaypoint = null;
        let usingNav = false;
        if(navGoal){
          navWaypoint = ensureNavForEntity(m, navGoal, minionRadius);
          usingNav = !!navWaypoint;
        } else if(m.nav){
          clearEntityNav(m);
        }
        let destX = dest ? dest.x : m.to.x;
        let destY = dest ? dest.y : m.to.y;
        if(followLane && laneDestX !== null && laneDestY !== null){
          destX = laneDestX;
          destY = laneDestY;
          if(usingNav){
            clearEntityNav(m);
            navWaypoint = null;
            usingNav = false;
          }
        }
        const rawDx = destX - m.x;
        const rawDy = destY - m.y;
        let moveX = usingNav && navWaypoint ? (navWaypoint.x - m.x) : rawDx;
        let moveY = usingNav && navWaypoint ? (navWaypoint.y - m.y) : rawDy;
        let speed = MINION_SPEED;
        if(m.slowTimer > 0 && m.slowPct > 0){
          const slowFactor = Math.max(0, 1 - Math.min(1, m.slowPct));
          speed *= slowFactor;
        }
        if(laneFree && m.inPortalZone){
          const t = Math.max(0, Math.min(1, 1 - (dToPortal/PORTAL_INTAKE_R)));
          speed *= (1 + PORTAL_SUCTION * t);
        }
        if(!usingNav){
          if(lanePoint){
            const shouldFan = !laneFree && (!!targetMinion || chasingPlayer);
            const neutralProj = typeof m.neutralProj === 'number' ? m.neutralProj : (m.laneLength || 0) * 0.5;
            const distFromNeutral = Math.abs(lanePoint.distance - neutralProj);
            const neutralBlend = smoothstep01(distFromNeutral / (laneFanSpacing * 1.75));
            const livelyOffset = shouldFan ? m.fanOffset : 0;
            const desiredOffset = livelyOffset * neutralBlend;
            if(lanePoint.point && Number.isFinite(lanePoint.normalX) && Number.isFinite(lanePoint.normalY)){
              const desiredX = lanePoint.point.x + lanePoint.normalX * desiredOffset;
              const desiredY = lanePoint.point.y + lanePoint.normalY * desiredOffset;
              const lateralX = m.x - desiredX;
              const lateralY = m.y - desiredY;
              const neutralPull = (1 - neutralBlend) * 0.45;
              const pull = (shouldFan ? 0.4 : 0.22) + neutralPull;
              moveX -= lateralX * pull;
              moveY -= lateralY * pull;
            }
            const forwardBias = shouldFan ? 0.06 : 0.16;
            const rawLen = Math.hypot(rawDx, rawDy) || 1;
            moveX += lanePoint.dirX * rawLen * forwardBias;
            moveY += lanePoint.dirY * rawLen * forwardBias;
          } else if(m.spawn && m.laneDir){
            const relX = m.x - m.spawn.x;
            const relY = m.y - m.spawn.y;
            const proj = relX * m.laneDir.x + relY * m.laneDir.y;
            const baseLaneX = m.spawn.x + m.laneDir.x * proj;
            const baseLaneY = m.spawn.y + m.laneDir.y * proj;
            const shouldFan = !laneFree && (!!targetMinion || chasingPlayer);
            const neutralProj = typeof m.neutralProj === 'number' ? m.neutralProj : (m.laneLength || 0) * 0.5;
            const distFromNeutral = Math.abs(proj - neutralProj);
            const neutralBlend = smoothstep01(distFromNeutral / (laneFanSpacing * 1.75));
            const livelyOffset = shouldFan && m.laneNormal ? m.fanOffset : 0;
            const desiredOffset = livelyOffset * neutralBlend;
            if(m.laneNormal){
              const desiredX = baseLaneX + m.laneNormal.x * desiredOffset;
              const desiredY = baseLaneY + m.laneNormal.y * desiredOffset;
              const lateralX = m.x - desiredX;
              const lateralY = m.y - desiredY;
              const neutralPull = (1 - neutralBlend) * 0.45;
              const pull = (shouldFan ? 0.4 : 0.22) + neutralPull;
              moveX -= lateralX * pull;
              moveY -= lateralY * pull;
            }
            const forwardBias = shouldFan ? 0.06 : 0.16;
            const rawLen = Math.hypot(rawDx, rawDy) || 1;
            moveX += m.laneDir.x * rawLen * forwardBias;
            moveY += m.laneDir.y * rawLen * forwardBias;
          }
        }
        let step = speed * dt;
        let moveLen = Math.hypot(moveX, moveY);
        if(moveLen === 0){ moveLen = 1; }
        const nx = moveX / moveLen;
        const ny = moveY / moveLen;

        if(targetMinion && angleToTarget !== null){
          const tx = targetMinion.x - m.x;
          const ty = targetMinion.y - m.y;
          const distToEnemy = best;
          const dot = distToEnemy ? (tx*nx + ty*ny) / distToEnemy : 0;
          if(dot > 0.5){
            const buffer = minionDiameter;
            const maxAdvance = distToEnemy - buffer;
            if(maxAdvance <= 0){
              step = 0;
            } else {
              step = Math.min(step, maxAdvance);
            }
            facing = blendAngles(angleToTarget, laneFacing, 0.35);
          }
        } else if(chasingPlayer && angleToPlayer !== null){
          const tx = player.x - m.x;
          const ty = player.y - m.y;
          const distToPlayer = playerDistance;
          const dot = distToPlayer ? (tx*nx + ty*ny) / distToPlayer : 0;
          if(dot > 0.5){
            const buffer = minionRadius + playerCollR;
            const maxAdvance = distToPlayer - buffer;
            if(maxAdvance <= 0){
              step = 0;
            } else {
              step = Math.min(step, maxAdvance);
            }
            facing = blendAngles(angleToPlayer, laneFacing, 0.35);
          }
        }

        if(step>0){
          let moveVecX = nx * step;
          let moveVecY = ny * step;
          if(laneProjection){
            const lanePath = m.lanePath || null;
            const forwardUnit = nx * laneProjection.dirX + ny * laneProjection.dirY;
            const latX = nx - forwardUnit * laneProjection.dirX;
            const latY = ny - forwardUnit * laneProjection.dirY;
            const latLen = Math.hypot(latX, latY);
            let forwardStep = step * forwardUnit;
            if(enemyPresence && forwardStep > 0){
              const proj = laneProjection.distance;
              const laneLength = m.laneLength || (lanePath ? lanePath.totalLength : Math.hypot(m.to.x - m.spawn.x, m.to.y - m.spawn.y) || 1);
              const baseLimit = Math.min(laneLength, m.offsideLimit ?? laneLength * OFFSIDE_FRACTION);
              let maxProj = baseLimit;
              if(targetMinion && lanePath){
                const targetProj = projectPointOntoLane(lanePath, targetMinion.x, targetMinion.y);
                if(targetProj && targetProj.distance >= proj){
                  const chaseLimit = Math.min(laneLength, targetProj.distance - minionDiameter);
                  maxProj = Math.max(proj, chaseLimit);
                }
              } else if(chasingPlayer && lanePath){
                const playerProj = projectPointOntoLane(lanePath, player.x, player.y);
                if(playerProj && playerProj.distance >= proj){
                  const chaseLimit = Math.min(laneLength, playerProj.distance - (minionDiameter + playerCollR));
                  maxProj = Math.max(proj, chaseLimit);
                }
              }
              const nextProj = proj + forwardStep;
              if(nextProj > maxProj){
                forwardStep = Math.max(0, maxProj - proj);
              }
            }
            moveVecX = laneProjection.dirX * forwardStep;
            moveVecY = laneProjection.dirY * forwardStep;
            if(latLen > 1e-6){
              const latStep = step * latLen;
              const normLatX = latX / latLen;
              const normLatY = latY / latLen;
              moveVecX += normLatX * latStep;
              moveVecY += normLatY * latStep;
            }
          } else if(m.spawn && m.laneDir){
            const forwardUnit = nx * m.laneDir.x + ny * m.laneDir.y;
            const latX = nx - forwardUnit * m.laneDir.x;
            const latY = ny - forwardUnit * m.laneDir.y;
            const latLen = Math.hypot(latX, latY);
            let forwardStep = step * forwardUnit;
            if(enemyPresence && forwardStep > 0){
              const relX = m.x - m.spawn.x;
              const relY = m.y - m.spawn.y;
              const proj = relX * m.laneDir.x + relY * m.laneDir.y;
              const laneLength = m.laneLength || Math.hypot(m.to.x - m.spawn.x, m.to.y - m.spawn.y) || 1;
              const baseLimit = Math.min(laneLength, m.offsideLimit ?? laneLength * OFFSIDE_FRACTION);
              let maxProj = baseLimit;
              if(targetMinion){
                const tx = targetMinion.x - m.spawn.x;
                const ty = targetMinion.y - m.spawn.y;
                const targetProj = tx * m.laneDir.x + ty * m.laneDir.y;
                if(Number.isFinite(targetProj) && targetProj >= proj){
                  const chaseLimit = Math.min(laneLength, targetProj - minionDiameter);
                  maxProj = Math.max(proj, chaseLimit);
                }
              } else if(chasingPlayer){
                const px = player.x - m.spawn.x;
                const py = player.y - m.spawn.y;
                const playerProj = px * m.laneDir.x + py * m.laneDir.y;
                if(Number.isFinite(playerProj) && playerProj >= proj){
                  const chaseLimit = Math.min(laneLength, playerProj - (minionDiameter + playerCollR));
                  maxProj = Math.max(proj, chaseLimit);
                }
              }
              const nextProj = proj + forwardStep;
              if(nextProj > maxProj){
                forwardStep = Math.max(0, maxProj - proj);
              }
            }
            moveVecX = m.laneDir.x * forwardStep;
            moveVecY = m.laneDir.y * forwardStep;
            if(latLen > 1e-6){
              const latStep = step * latLen;
              const normLatX = latX / latLen;
              const normLatY = latY / latLen;
              moveVecX += normLatX * latStep;
              moveVecY += normLatY * latStep;
            }
          }
          const baseMoveMag = Math.hypot(moveVecX, moveVecY);
          if(baseMoveMag > 0){
            let desiredMoveX = moveVecX;
            let desiredMoveY = moveVecY;
            if(laneFree || (!targetMinion && !chasingPlayer)){
              if(dToPortal <= baseMoveMag){
                desiredMoveX = m.to.x - m.x;
                desiredMoveY = m.to.y - m.y;
              }
            }
            const prevX = m.x;
            const prevY = m.y;
            const moved = moveCircleWithCollision(m.x, m.y, desiredMoveX, desiredMoveY, minionRadius);
            m.x = moved.x;
            m.y = moved.y;
            const actualMoveX = m.x - prevX;
            const actualMoveY = m.y - prevY;
            const actualMag = Math.hypot(actualMoveX, actualMoveY);
            if(actualMag > 0){
              const moveAngle = Math.atan2(actualMoveY, actualMoveX);
              const moveBlend = enemyPresence ? 0.3 : 0.65;
              facing = blendAngles(moveAngle, laneFacing, moveBlend);
            } else if(usingNav){
              clearEntityNav(m);
            }
          }
        }
      }

      m.x = Math.max(minionRadius, Math.min(mapState.width - minionRadius, m.x));
      m.y = Math.max(minionRadius, Math.min(mapState.height - minionRadius, m.y));
      m.facing = facing;
    }

    // spacing (relaxed near portal)
    resolveOverlaps(3);
    resolvePlayerMinionSeparation(2);

    // player move
    let playerWaypoint = null;
    if(!isPlayerCasting && !isPlayerMovementLocked && player.navGoal && hitboxActive()){
      playerWaypoint = ensureNavForEntity(player, player.navGoal, player.r);
    } else if(!hitboxActive()){
      clearEntityNav(player);
    }
    let moveTargetX = player.target.x;
    let moveTargetY = player.target.y;
    if(playerWaypoint){
      moveTargetX = playerWaypoint.x;
      moveTargetY = playerWaypoint.y;
    }
    const dx = moveTargetX - player.x;
    const dy = moveTargetY - player.y;
    const dist = Math.hypot(dx,dy);
    if(!isPlayerCasting && !isPlayerMovementLocked && dist>0.5){
      const step = Math.min(dist, player.speed * movementMultiplier * dt);
      const moveX = dx/dist * step;
      const moveY = dy/dist * step;
      const moved = moveCircleWithCollision(player.x, player.y, moveX, moveY, player.r);
      const actualMoveX = moved.x - player.x;
      const actualMoveY = moved.y - player.y;
      const actualDist = Math.hypot(actualMoveX, actualMoveY);
      player.x = moved.x;
      player.y = moved.y;
      if(actualDist < 0.1 && playerWaypoint){
        clearEntityNav(player);
      }
    }
    if(!isPlayerCasting){
      const remainingToGoal = Math.hypot(player.target.x - player.x, player.target.y - player.y);
      if(remainingToGoal <= Math.max(0.5, player.r * 0.6)){
        player.navGoal = null;
        player.nav = null;
      }
    }
    player.x = Math.max(player.r, Math.min(mapState.width - player.r, player.x));
    player.y = Math.max(player.r, Math.min(mapState.height - player.r, player.y));
    resolvePlayerMinionSeparation(1);
    positionPlayerFloatingHud();
    positionPracticeDummyHud();
    positionMonsterHud();
    if(dt > 0){
      lastPlayerVelocityX = (player.x - prevPlayerX) / dt;
      lastPlayerVelocityY = (player.y - prevPlayerY) / dt;
      camera.lastPlayerVelocity.x = lastPlayerVelocityX;
      camera.lastPlayerVelocity.y = lastPlayerVelocityY;
    } else {
      lastPlayerVelocityX = 0;
      lastPlayerVelocityY = 0;
      camera.lastPlayerVelocity.x = lastPlayerVelocityX;
      camera.lastPlayerVelocity.y = lastPlayerVelocityY;
    }
    applyEdgeScroll(dt);
    updateCamera(true, dt);
    const playerMoveDuringFrame = Math.hypot(player.x - prevPlayerX, player.y - prevPlayerY);
    if(player.attackWindup > 0 && playerMoveDuringFrame > 0.5){
      cancelPlayerAttack();
    }
    updateTurrets(dt);
    updatePlayerAutoAttack(dt);
    updatePlayerAnimationFromGameplay(dt);
    updateAbilityCooldowns(dt);
    updateSkyScoutCharges(dt);
    updateSkyScoutFlights(dt);
    updateSkyScoutVisionSources(dt);
    updateTemporalVisionSources(dt);
    updateTrapVisionSources(dt);
    updateArcaneRiteModes(dt);
    updateArcaneRiteExplosions(dt);
    updateMourningMarchCasts(dt);
    updateEmberGuardianCasts(dt);
    updateBedrockBurstCasts(dt);
    updateGroundbreakerCasts(dt);
    updateRagePulseCasts(dt);
    updateSlamCasts(dt);
    updateSlamFissures(dt);
    updateSlamIceFields(dt);
    updateSlamImpacts(dt);
    updateBeamCasts(dt);
    updateExpandingShotCasts(dt);
    updateShatterburstOrbCasts(dt);
    updateReboundOrbCasts(dt);
    updateCycloneCasts(dt);
    updateLaserConeCasts(dt);
    updateDuskwaveCasts(dt);
    updateSirensKissCasts(dt);
    updateShiverSpikeCasts(dt);
    updateSkullRushCasts(dt);
    updateRiptideLungeCasts(dt);
    updateBoneSkewerCasts(dt);
    updateGrabCasts(dt);
    updateBacklineSeizureCasts(dt);
    updateLinkLashCasts(dt);
    updateAstralSnareCasts(dt);
    updatePiercingArrowCasts(dt);
    updateFocusedLockshotCasts(dt);
    updateFlipbladeCasts(dt);
    updatePlasmaFissionCasts(dt);
    updateChargingGaleCasts(dt);
    updateAvalancheRollCasts(dt);
    updateSlingshotCrashCasts(dt);
    updateSpringquakeCasts(dt);
    updateVerdictSalvoCasts(dt);
    updateRicochetBombCasts(dt);
    updateCullingBarrageChannels(dt);
    updateReapingMaelstromCasts(dt);
    updateScarecrowStormCasts(dt);
    updateScarecrowStormZones(dt);
    updateScoutflareBombCasts(dt);
    updateScoutflareVisionSources(dt);
    updateScoutflareRevealRecords(dt);
    updateConvergingGaleCasts(dt);
    updateConvergingGaleBlasts(dt);
    updateConvergingGaleTornadoes(dt);
    updateTemporalVeilCasts(dt);
    updateMoonlitArcCasts(dt);
    updateCelestialCrashCasts(dt);
    updateCelestialShockwaves(dt);
    updateDirgeBloomCasts(dt);
    updateDriftingVeilCasts(dt);
    updateDriftingVeils(dt);
    updateEventHorizonCasts(dt);
    updateEventHorizons(dt);
    updateHailboundTempestCasts(dt);
    updateHailboundTempests(dt);
    updateTranquilTorrentCasts(dt);
    updateSerenityFields(dt);
    updateQuiverstormBuffs(dt);
    updateScatterChargeCasts(dt);
    updateScatterCharges(dt);
    updateLinkLashTethers(dt);
    updateDirgeBloomCurses(dt);
    updateFlameChomperTraps(dt);
    updateGlacialUpliftCasts(dt);
    updateGlacialUpliftWalls(dt);
    updateSpectralStockadeCasts(dt);
    updateSpectralStockades(dt);
    updateVenomBloomCasts(dt);
    updateVenomClouds(dt);
    updateMiasmaFieldCasts(dt);
    updateMiasmaClouds(dt);
    updateFangStrikeCasts(dt);
    updateStoneGazeCasts(dt);
    updateStoneGazeEffects(dt);
    updateBoltburstRushCasts(dt);
    updateCascadeBarrageMissiles(dt);
    updateDawnfallBarrageCasts(dt);
    updateInfernoBarrageCasts(dt);
    updateBulletTimeCasts(dt);
    updateEmberWaltzCasts(dt);
    updateEmberWaltzFlames(dt);
    updateSkyhookSwingCasts(dt);
    updateSnapbackEchoes(dt);
    updateChronoLoopGrenades(dt);
    updateTwinstrikeCasts(dt);
    updateTwinstrikeTrails(dt);
    updateStormwingSequences(dt);
    updateFlipbladeDashes(dt);
    updateLuminousDartCasts(dt);
    updatePlunderShotCasts(dt);
    updateShadowTalonCasts(dt);
    updateShadowTalonRecasts(dt);
    updateShadowTalonMarks(dt);
    updatePestilentTossCasts(dt);
    updateVoidTrackCasts(dt);
    updateTrailblazeDashes(dt);
    updateTrailblazePatches(dt);
    updateSandRushDashes(dt);
    updateSpiralRamRoll(dt);
    updateGaleThrustStacks(dt);
    updateGaleThrustCasts(dt);
    updateLaserProjectiles(dt);
    updateDuskwaveVolleys(dt);
    updateGraviticCasts(dt);
    updateGravityProjectiles(dt);
    updateGraviticSlowDecays(dt);
    updateSlingshotCrashLeaps(dt);
    updateRicochetBombProjectiles(dt);
    updateBlinkingBoltProjectiles(dt);
    updateFlipbladeProjectiles(dt);
    updateShatterburstOrbProjectiles(dt);
    updateReboundOrbProjectiles(dt);
    updateCycloneAxes(dt);
    updateEdgeFluxProjectiles(dt);
    updatePiercingArrowProjectiles(dt);
    updateFocusedLockshotProjectiles(dt);
    updateExpandingShotProjectiles(dt);
    updatePlasmaFissionProjectiles(dt);
    updateFlipbladeMarks(dt);
    updateEdgeFluxMarks(dt);
    updateChargingGaleProjectiles(dt);
    updateAvalancheRollProjectiles(dt);
    updateVerdictSalvoProjectiles(dt);
    updateCullingBarrageProjectiles(dt);
    updateProjectiles(dt);
    updateBeams(dt);
    updateHitSplats(dt);
    updatePings(dt);
    for(let i=minions.length-1;i>=0;i--){ if(minions[i].hp<=0) minions.splice(i,1); }

    const updateEnd = perfNow();
    // draw
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, camera.baseWidth, camera.baseHeight);
    const cameraScale = Math.max(0.001, Number(camera.scale) || 1);
    ctx.setTransform(cameraScale, 0, 0, cameraScale, -camera.x * cameraScale, -camera.y * cameraScale);

    drawBaseZones();
    drawColliders();
    drawSlamIceFields();
    drawSlamFissures();
    drawSlamImpacts();
    drawVerdictSalvoChannels();
    drawCullingBarrageChannels();
    drawArcaneRiteTelegraphs();
    drawScarecrowStormZones();
    drawScoutflareTelegraphs();
    drawConvergingGaleEffects();
    drawTemporalVeilCasts();
    drawMoonlitArcCasts();
    drawCelestialCrashTelegraphs();
    drawCelestialShockwaves();
    drawDirgeBloomCasts();
    drawEventHorizonTelegraphs();
    drawEventHorizons();
    drawTrailblazePatches();
    drawSandRushDashes();
    drawHailboundTempests();
    drawSerenityFields();
    drawDriftingVeils();
    drawVenomClouds();
    drawMiasmaClouds();
    drawStoneGazeEffects();
    drawArcaneRiteModeIndicators();
    drawFlameChomperTraps();
    drawGlacialUpliftWalls();
    drawSpectralStockades();
    drawScatterCharges();
    drawSpinningAxeMarkers();
    drawSpringquakeFields();
    drawQuakingStrideAuras();
    drawSkyhookSwingCasts();
    drawSnapbackEchoes();
    drawChronoLoopGrenades();
    drawTwinstrikeTrails();
    drawGravityProjectiles();
    drawAstralSnareCasts();
    drawLinkLashTethers();
    drawTwinstrikeRecastIndicators();
    drawShadowPursuitTrails();
    drawFlipbladeMarks();
    drawEdgeFluxMarks();
    drawCascadeBarrageMissiles();

    // pulses
    for(let i=pulses.length-1;i>=0;i--){
      const p=pulses[i];
      p.t+=dt;
      const progress = Math.max(0, Math.min(1, p.t));
      const startRadius = Number.isFinite(p.startRadius) ? Math.max(0, p.startRadius) : 12;
      const endRadiusCandidate = Number.isFinite(p.endRadius) ? Math.max(0, p.endRadius) : (startRadius + 40);
      const endRadius = Math.max(startRadius, endRadiusCandidate);
      if(!circleInCamera(p.x, p.y, endRadius + 8)){
        if(p.t>=1) pulses.splice(i,1);
        continue;
      }
      const radius = startRadius + (endRadius - startRadius) * progress;
      const alpha = 1 - progress;
      const color = (typeof p.color === 'string' && p.color.trim()) ? p.color : '#7fe3ff';
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;
      ctx.stroke();
      ctx.globalAlpha = 1;
      if(p.t>=1) pulses.splice(i,1);
    }

    // spawns + portals
    portalState.spin += dt*2.5;
    function drawSpawnAndPortal(s,color,label){
      if(!circleInCamera(s.x, s.y, PORTAL_R + 32)) return;
      ctx.save(); ctx.translate(s.x,s.y);
      // diamond marker
      ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(12,0); ctx.lineTo(0,12); ctx.lineTo(-12,0); ctx.closePath();
      ctx.fillStyle=color; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#05121a'; ctx.stroke();
      ctx.fillStyle='#fff'; ctx.font='bold 11px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(label,0,0);
      // portal ring
      ctx.rotate(portalState.spin);
      for(let k=0;k<2;k++){
        ctx.beginPath();
        ctx.lineWidth = 3-k;
        ctx.strokeStyle = k ? '#7fe3ff66' : '#7fe3ff';
        ctx.arc(0,0,PORTAL_R + k*3, k?Math.PI*0.2:0, k?Math.PI*1.6:Math.PI*1.2);
        ctx.stroke();
      }
      ctx.restore();
    }
    const lanePlanForDraw = ensureLaneLayout();
    if(lanePlanForDraw && lanePlanForDraw.lanes.length){
      ctx.save();
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      const laneTotal = lanePlanForDraw.lanes.length;
      const baseRadius = Math.max(12, 20 - Math.max(0, laneTotal - 1));
      for(const lane of lanePlanForDraw.lanes){
        const laneColor = lane.teamColor || '#32d97c';
        ctx.strokeStyle = laneColor;
        const points = (lane.bluePath && Array.isArray(lane.bluePath.points) && lane.bluePath.points.length > 1)
          ? lane.bluePath.points
          : [lane.bluePath.from, lane.bluePath.to];
        if(points && points.length > 1){
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for(let i=1;i<points.length;i++){
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.stroke();
        }

        const radius = baseRadius;
        ctx.beginPath();
        ctx.arc(lane.middle.x, lane.middle.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = lane.teamColor || '#164d2c';
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = laneColor;
        ctx.stroke();
        ctx.fillStyle = '#d7ffde';
        ctx.font = `bold ${Math.max(12, radius + 2)}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(lane.label, lane.middle.x, lane.middle.y + 1);

        if(Array.isArray(lane.breaks) && lane.breaks.length){
          const breakRadius = Math.max(9, radius - 5);
          for(const bp of lane.breaks){
            if(!bp) continue;
            ctx.beginPath();
            ctx.arc(bp.x, bp.y, breakRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#0f3621';
            ctx.fill();
            ctx.lineWidth = 2.2;
            ctx.strokeStyle = '#32d97c';
            ctx.stroke();
          }
        }
      }
      ctx.restore();
    } else if(blueSpawns[0] && redSpawns[0]){
      const b = blueSpawns[0];
      const r = redSpawns[0];
      const midX = (b.x + r.x) / 2;
      const midY = (b.y + r.y) / 2;
      const dx = r.x - b.x;
      const dy = r.y - b.y;
      const laneLen = Math.hypot(dx, dy) || 1;
      const dirX = dx / laneLen;
      const dirY = dy / laneLen;
      const normX = -dirY;
      const normY = dirX;
      const mainHalf = laneLen / 2;
      const barHalf = Math.max(28, Math.min(laneLen * 0.3, 88));
      ctx.save();
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#32d97c';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(midX - dirX * mainHalf, midY - dirY * mainHalf);
      ctx.lineTo(midX + dirX * mainHalf, midY + dirY * mainHalf);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(midX - normX * barHalf, midY - normY * barHalf);
      ctx.lineTo(midX + normX * barHalf, midY + normY * barHalf);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(midX, midY, 16, 0, Math.PI * 2);
      ctx.fillStyle = '#164d2c';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#32d97c';
      ctx.stroke();
      ctx.fillStyle = '#d7ffde';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('M', midX, midY + 1);
      ctx.restore();
    }
    if(blueSpawns[0]) drawSpawnAndPortal(blueSpawns[0],'#2aa9ff','B');
    if(redSpawns[0])  drawSpawnAndPortal(redSpawns[0],'#ff5577','R');

    drawTurrets();
    drawMonster();
    drawDirgeBloomCurses();

    // MINIONS (finally rendered)
    for(const m of minions){
      if(!m) continue;
      if(m.isPracticeDummy && (m.active === false || (m.respawnTimer > 0) || !(Number(m.hp) > 0))){
        continue;
      }
      if(!circleInCamera(m.x, m.y, minionRadius + 32)) continue;
      if(!pointInVision(m.x, m.y, minionRadius)) continue;
      drawMinion(m);
    }

    drawTurretShots();
    drawSlamCasts();
    drawBeamCasts();
    drawLaserConeCasts();
    drawPiercingArrowCasts();
    drawGrabCasts();
    drawBacklineSeizureCasts();
    drawLinkLashCasts();
    drawBeams();

    // LASER ABILITIES
    drawLaserProjectiles();
    drawDuskwaveVolleys();
    drawRicochetBombProjectiles();
    drawBlinkingBoltProjectiles();
    drawEmberWaltzFlames();
    drawFlipbladeProjectiles();
    drawShatterburstOrbProjectiles();
    drawReboundOrbProjectiles();
    drawCycloneAxes();
    drawPiercingArrowProjectiles();
    drawExpandingShotProjectiles();
    drawPlasmaFissionProjectiles();
    drawChargingGaleProjectiles();
    drawAvalancheRollProjectiles();
    drawSlingshotCrashLeaps();
    drawVerdictSalvoProjectiles();
    drawCullingBarrageProjectiles();
    drawScoutflareProjectiles();

    drawBoneSkewerChargePreviews();
    drawSlingshotCrashChargePreviews();
    drawChargingGaleChargePreviews();
    drawAvalancheRollChargePreviews();
    drawSkillshotIndicator();

    // PROJECTILES
    drawProjectiles();
    drawPings();
    drawPingWheel();
    drawHoverHighlight();

    drawVisionDummy();
    // PLAYER
    if(playerRuntime.model){
      playerRuntime.model.setPosition(player.x, player.y + player.r, player.r);
      playerRuntime.model.update(dt);
    }
    drawPlayer();

    // DAMAGE NUMBERS
    drawHitSplats();

    drawFogOfWar();
    drawVisionShapes();

    renderMinimap();

    const frameEnd = perfNow();
    recordPerfFrame(frameEnd - frameStart, updateEnd - frameStart, frameEnd - updateEnd, frameStart);
  }

  if(typeof window !== 'undefined'){
    window.exportGameState = exportGameState;
    window.importGameState = importGameState;
    window.playerShopBuy = shopBuy;
    window.playerShopSell = shopSell;
    window.playerShopUndo = shopUndo;
    window.toggleRecall = toggleRecall;
    window.canPlayerShop = canPlayerShop;
    window.copyPerformanceLog = buildPerfLog;
  }

  if(perfCopyLogBtn){
    perfCopyLogBtn.addEventListener('click', async ()=>{
      const log = perfState.history.length ? perfState.history[perfState.history.length - 1] : buildPerfLog();
      const extended = perfState.history.length
        ? perfState.history.slice(-10).join('\\n\\n')
        : log;
      if(navigator && navigator.clipboard && navigator.clipboard.writeText){
        try {
          await navigator.clipboard.writeText(extended);
          setHudMessage('Performance log copied to clipboard.');
          return;
        } catch (err){
          console.warn('Clipboard copy failed, falling back to prompt', err);
        }
      }
      const fallback = window.prompt('Copy performance log:', extended);
      if(fallback !== null){
        setHudMessage('Performance log ready to share.');
      }
    });
  }

  if(perfDownloadLogBtn){
    perfDownloadLogBtn.addEventListener('click', ()=>{
      const logs = perfState.history.length ? perfState.history.slice(-20) : [buildPerfLog()];
      const content = logs.join('\\n\\n');
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `MakaGame-perf-${new Date().toISOString().replace(/[:.]/g,'-')}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  }

  function generateStressColliders(width, height){
    const colliders = [];
    const rows = 6;
    const cols = 9;
    const margin = 220;
    const spacingX = Math.max(120, (width - margin * 2) / Math.max(1, cols - 1));
    const spacingY = Math.max(140, (height - margin * 2) / Math.max(1, rows - 1));
    let nextId = Math.max(1, Number(mapState.colliders.nextId) || 1);
    for(let row=0; row<rows; row++){
      for(let col=0; col<cols; col++){
        const offset = (row % 2) ? spacingX * 0.35 : 0;
        const x = Math.min(width - margin, margin + col * spacingX + offset);
        const y = Math.min(height - margin, margin + row * spacingY);
        const radius = (row % 3 === 0) ? 140 : 110;
        colliders.push({ id: nextId++, type: 'circle', x, y, radius });
      }
    }
    const coreLength = Math.min(width, height) * 0.65;
    colliders.push({ id: nextId++, type: 'capsule', x: width * 0.5, y: height * 0.5, radius: 140, length: coreLength, angle: Math.PI * 0.25 });
    colliders.push({ id: nextId++, type: 'capsule', x: width * 0.5, y: height * 0.5, radius: 140, length: coreLength, angle: -Math.PI * 0.25 });
    return { colliders, nextId };
  }

  function buildNavGridFromColliders(cellSize = NAV_COARSE_CELL){
    const size = Math.max(8, Math.floor(cellSize) || NAV_COARSE_CELL);
    const cols = Math.ceil(mapState.width / size);
    const rows = Math.ceil(mapState.height / size);
    const mask = new Uint8Array(cols * rows);
    for(let cy = 0; cy < rows; cy++){
      const y = cy * size + size * 0.5;
      for(let cx = 0; cx < cols; cx++){
        const x = cx * size + size * 0.5;
        if(collidersBlockCircle(x, y, size * 0.5)){
          mask[cy * cols + cx] = 1;
        }
      }
    }
    return { cellSize: size, cols, rows, mask };
  }

  function ensureStressScenario(){
    const hadColliders = customColliders.length > 0;
    const hasNavGrid = !!(mapState.hitbox && mapState.hitbox.grid && mapState.hitbox.grid.mask && mapState.hitbox.grid.mask.length);
    if(hadColliders || hasNavGrid){
      return null;
    }
    const prev = {
      mapWidth: mapState.width,
      mapHeight: mapState.height,
      mapLoaded: mapState.loaded,
      colliders: customColliders.slice(),
      nextId: mapState.colliders.nextId,
      selectedId: mapState.colliders.selectedId,
      spatial: mapState.colliders.spatial,
      hitbox: {
        loaded: mapState.hitbox.loaded,
        width: mapState.hitbox.width,
        height: mapState.hitbox.height,
        data: mapState.hitbox.data,
        coarse: mapState.hitbox.coarse,
        grid: mapState.hitbox.grid
      }
    };
    const width = prev.mapWidth || 5000;
    const height = prev.mapHeight || 5000;
    const generated = generateStressColliders(width, height);
    customColliders.length = 0;
    customColliders.push(...generated.colliders);
    mapState.colliders.nextId = generated.nextId;
    mapState.colliders.selectedId = null;
    mapState.colliders.spatial = null;
    mapState.width = width;
    mapState.height = height;
    mapState.loaded = true;
    const navGrid = buildNavGridFromColliders(NAV_COARSE_CELL);
    mapState.hitbox.grid = navGrid;
    mapState.hitbox.coarse = navGrid;
    mapState.hitbox.loaded = true;
    mapState.hitbox.width = width;
    mapState.hitbox.height = height;
    clearAllNavigation(true);
    refreshColliderList();
    updatePerfPanel();
    return ()=> {
      customColliders.length = 0;
      customColliders.push(...prev.colliders);
      mapState.colliders.nextId = prev.nextId;
      mapState.colliders.selectedId = prev.selectedId;
      mapState.colliders.spatial = prev.spatial || null;
      mapState.width = prev.mapWidth;
      mapState.height = prev.mapHeight;
      mapState.loaded = prev.mapLoaded;
      mapState.hitbox.grid = prev.hitbox.grid;
      mapState.hitbox.coarse = prev.hitbox.coarse;
      mapState.hitbox.data = prev.hitbox.data;
      mapState.hitbox.loaded = prev.hitbox.loaded;
      mapState.hitbox.width = prev.hitbox.width;
      mapState.hitbox.height = prev.hitbox.height;
      clearAllNavigation(true);
      refreshColliderList();
      updatePerfPanel();
    };
  }

  function ensureStressSpawns(durationMs = 30000){
    if(minions.length || pendingSpawns.length){
      return null;
    }
    ensureDefaultSpawns(true);
    const plan = ensureLaneLayout();
    const bluePaths = plan && plan.bluePaths ? plan.bluePaths.filter(Boolean) : [];
    const redPaths = plan && plan.redPaths ? plan.redPaths.filter(Boolean) : [];
    if(!bluePaths.length || !redPaths.length){
      return null;
    }
    const prevWaveNumber = waveState.waveNumber;
    const prevWaveCount = waveState.waveCount;
    const prevTimerRunning = timerState.running;

    const stressTotal = Math.max(20, waveState.waveCount || 20);
    const stressLaneEmit = (side, paths)=>{
      const { hp, dmg } = statsForWave(Math.max(1, waveState.waveNumber || 1));
      const counts = distributeMinions(stressTotal, paths.length);
      for(let laneIndex = 0; laneIndex < paths.length; laneIndex++){
        const lanePath = paths[laneIndex];
        const count = counts[laneIndex] || 0;
        for(let i=0; i<count; i++){
          const slotIndex = i % 5;
          enqueueMinionSpawn(side, lanePath, hp, dmg, 0, slotIndex, laneIndex);
        }
      }
    };

    const spawnBurst = ()=>{
      stressLaneEmit('blue', bluePaths);
      stressLaneEmit('red', redPaths);
      while(pendingSpawns.length){
        const job = pendingSpawns.shift();
        spawnFromQueue(job);
      }
      let flagged = 0;
      const cap = 6;
      for(const m of minions){
        if(flagged >= cap) break;
        m.stressNav = true;
        m.nav = null;
        flagged += 1;
      }
    };

    const intervalMs = Math.max(4000, Math.min(8000, durationMs / 4));
    const handle = setInterval(spawnBurst, intervalMs);
    spawnBurst();

    return ()=>{
      clearInterval(handle);
      minions.length = 0;
      pendingSpawns.length = 0;
      waveState.waveNumber = prevWaveNumber;
      waveState.waveCount = prevWaveCount;
      timerState.running = prevTimerRunning;
    };
  }

  function ensureStressNavFlags(count = 6){
    let flagged = 0;
    for(const m of minions){
      if(flagged >= count) break;
      m.stressNav = true;
      m.nav = null;
      flagged += 1;
    }
    return flagged;
  }

  function runStressTest({ durationMs = 30000, sampleMs = 1000, autoSetup = true } = {}){
    if(perfStressTestBtn){
      perfStressTestBtn.disabled = true;
    }
    const cleanups = [];
    if(autoSetup){
      stressNavMode = true;
      cleanups.push(()=>{ stressNavMode = false; });
    }
    const restoreStress = autoSetup ? ensureStressScenario() : null;
    if(restoreStress) cleanups.push(restoreStress);
    const restoreSpawns = autoSetup ? ensureStressSpawns(durationMs) : null;
    if(restoreSpawns) cleanups.push(restoreSpawns);
    if(autoSetup){
      ensureStressNavFlags(6);
    }
    const logs = [];
    const t0 = perfNow();
    const sample = ()=>{
      logs.push(buildPerfLog());
      const elapsed = perfNow() - t0;
      if(elapsed + sampleMs * 0.5 < durationMs){
        setTimeout(sample, sampleMs);
      } else {
        const content = logs.join('\\n\\n');
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `MakaGame-stress-${new Date().toISOString().replace(/[:.]/g,'-')}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        while(cleanups.length){
          const fn = cleanups.pop();
          if(typeof fn === 'function'){
            fn();
          }
        }
        if(perfStressTestBtn){
          perfStressTestBtn.disabled = false;
        }
      }
    };
    sample();
    const autoMsg = [];
    if(restoreStress){ autoMsg.push('auto collision board'); }
    if(restoreSpawns){ autoMsg.push('auto minion waves'); }
    const msg = autoMsg.length
      ? `Stress test running (${autoMsg.join(' + ')}, restoring after).`
      : 'Stress test running (sampling perf)...';
    setHudMessage(msg);
  }

  if(perfStressTestBtn){
    perfStressTestBtn.addEventListener('click', ()=> runStressTest());
  }

  // CSS vars init + UI initialize
  setVars();
  ensureDefaultSpawns(true);
  updateScoreUI();
  playGame();
  engine.registerSystem(tick);
  engine.start();








  function normalizeLaneLengths(laneIndex){
    ensureLaneConfigCount(GameState.lanes.count);
    if(laneIndex < 0 || laneIndex >= laneConfigs.length){
      return;
    }
    if(GameState.multiTeam && GameState.multiTeam.enabled){
      // For multi-team, distances are symmetric by construction (center hub lanes)
      return;
    }
    const startBlue = blueSpawns[0];
    const startRed = redSpawns[0];
    if(!startBlue || !startRed){
      return;
    }
    const cfg = laneConfigs[laneIndex];
    const mapStateWidth = mapState.width;
    const mapStateHeight = mapState.height;
    const clampCoord = (value, max) => Math.max(0, Math.min(max, value));
    const start = { x: startBlue.x, y: startBlue.y };
    const end = { x: startRed.x, y: startRed.y };
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const laneLen = Math.hypot(dx, dy) || 1;
    const dirX = dx / laneLen;
    const dirY = dy / laneLen;
    const diagX = dirY;
    const diagY = -dirX;
    const maxOffset = Math.min(laneLen * 0.35, Math.max(mapStateWidth, mapStateHeight) * 0.4);
    const center = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };
    const baseNorm = GameState.lanes.count > 1 ? (-1 + (2 * laneIndex) / (GameState.lanes.count - 1)) : 0;
    const userNorm = Math.max(-1, Math.min(1, Number(cfg.offset) || 0));
    const finalNorm = Math.max(-1, Math.min(1, baseNorm + userNorm));
    const offset = finalNorm * maxOffset;
    const middle = {
      x: clampCoord(center.x + diagX * offset, mapStateWidth),
      y: clampCoord(center.y + diagY * offset, mapStateHeight)
    };
    const breaks = sanitizeLaneBreaks(cfg).map((b)=>{
      const offsetPx = Math.max(-maxOffset, Math.min(maxOffset, Number(b.offset) * maxOffset));
      const tClamped = Math.max(0.05, Math.min(0.95, Number(b.t) || 0.5));
      const baseX = start.x + dirX * laneLen * tClamped;
      const baseY = start.y + dirY * laneLen * tClamped;
      return {
        x: clampCoord(baseX + diagX * offsetPx, mapStateWidth),
        y: clampCoord(baseY + diagY * offsetPx, mapStateHeight),
        t: tClamped,
        offset: Math.max(-1, Math.min(1, Number(b.offset) || 0))
      };
    }).sort((a, b)=>a.t - b.t);
    const anchors = [
      { x: start.x, y: start.y, t: 0 },
      ...breaks,
      { x: middle.x, y: middle.y, t: 0.5 },
      { x: end.x, y: end.y, t: 1 }
    ].sort((a, b) => a.t - b.t);
    const calcLengths = (pts)=>{
      let total = 0;
      let pre = 0;
      const midIdx = pts.findIndex(p => Math.abs(p.t - 0.5) < 1e-6);
      for(let i=0;i<pts.length - 1;i++){
        const a = pts[i];
        const b = pts[i + 1];
        const seg = Math.hypot((b.x ?? 0) - (a.x ?? 0), (b.y ?? 0) - (a.y ?? 0));
        total += seg;
        if(i < midIdx){
          pre += seg;
        }
      }
      return { total, pre, post: total - pre };
    };
    let working = breaks;
    for(let iter=0; iter<4; iter++){
      const anchorsIter = [
        { x: start.x, y: start.y, t: 0 },
        ...working,
        { x: middle.x, y: middle.y, t: 0.5 },
        { x: end.x, y: end.y, t: 1 }
      ].sort((a, b) => a.t - b.t);
      const lengths = calcLengths(anchorsIter);
      if(!(lengths.total > 0)) break;
      const targetHalf = lengths.total / 2;
      if(Math.abs(lengths.pre - targetHalf) < 0.5 && Math.abs(lengths.post - targetHalf) < 0.5){
        break;
      }
      const factorPre = lengths.pre > 0 ? Math.min(5, Math.max(0.1, targetHalf / lengths.pre)) : 1;
      const factorPost = lengths.post > 0 ? Math.min(5, Math.max(0.1, targetHalf / lengths.post)) : 1;
      working = working.map((b)=>{
        if(b.t < 0.5){
          return { ...b, t: Math.max(0.05, Math.min(0.49, b.t * factorPre)) };
        }
        return { ...b, t: Math.min(0.95, Math.max(0.51, 1 - (1 - b.t) * factorPost)) };
      }).sort((a, b)=>a.t - b.t);
    }
    cfg.breaks = working;
    cfg.manualBreaks = true;
    invalidateLaneLayout({ resetMinions: true });
    updateLaneDistanceDisplays();
    updateLaneOffsetControls();
  }

  function addLaneBreak(laneIndex){
    ensureLaneConfigCount(GameState.lanes.count);
    if(laneIndex < 0 || laneIndex >= laneConfigs.length){
      return;
    }
    const cfg = laneConfigs[laneIndex];
    const breaks = sanitizeLaneBreaks(cfg);
    const points = [0, ...breaks.map(b => Math.max(0.05, Math.min(0.95, Number(b.t) || 0.5))), 1].sort((a, b) => a - b);
    let bestGap = 0;
    let insertT = 0.5;
    for(let i=0;i<points.length - 1;i++){
      const gap = points[i + 1] - points[i];
      if(gap > bestGap){
        bestGap = gap;
        insertT = points[i] + gap / 2;
      }
    }
    const clampedT = Math.max(0.05, Math.min(0.95, insertT));
    breaks.push({ t: clampedT, offset: 0 });
    breaks.sort((a, b) => a.t - b.t);
    cfg.breaks = breaks;
    cfg.manualBreaks = true;
    invalidateLaneLayout({ resetMinions: true });
    updateLaneDistanceDisplays();
    updateLaneOffsetControls();
  }

  // Scoring / Multi-team UI
  function renderMultiTeamColors(){
    if(!multiTeamColorsWrap){
      return;
    }
    multiTeamColorsWrap.innerHTML = '';
    const count = multiTeamState.teamCount || 2;
    for(let i=0;i<count;i++){
      const input = document.createElement('input');
      input.type = 'color';
      input.value = sanitizeHexColor(multiTeamState.colors[i] || defaultTeamColors[i % defaultTeamColors.length], '#7fe3ff');
      input.dataset.teamIndex = String(i);
      input.addEventListener('input', ()=>{
        multiTeamState.colors[i] = sanitizeHexColor(input.value, defaultTeamColors[i % defaultTeamColors.length]);
        ensureMultiTeamBases();
        invalidateLaneLayout({ resetMinions: true });
        renderMinimap(true);
      });
      multiTeamColorsWrap.appendChild(input);
    }
  }

  function applyScoreModeUi(){
    if(scoreModeSelect){
      scoreModeSelect.value = scoreState.mode;
      scoreModeSelect.addEventListener('change', ()=>{
        scoreState.mode = scoreModeSelect.value;
        invalidateLaneLayout({ resetMinions: false });
      });
    }
    if(multiTeamEnabledInput){
      multiTeamEnabledInput.checked = !!multiTeamState.enabled;
      multiTeamEnabledInput.addEventListener('change', ()=>{
        multiTeamState.enabled = multiTeamEnabledInput.checked;
        if(multiTeamState.enabled){
          setMultiTeamCount(multiTeamState.teamCount);
        }
        invalidateLaneLayout({ resetMinions: true });
        updateLaneOffsetControls();
        renderMinimap(true);
      });
    }
    if(multiTeamCountInput){
      multiTeamCountInput.value = String(multiTeamState.teamCount);
      multiTeamCountInput.addEventListener('change', ()=>{
        const next = clampMultiTeamCount(multiTeamCountInput.value);
        setMultiTeamCount(next);
        multiTeamCountInput.value = String(next);
        renderMultiTeamColors();
        invalidateLaneLayout({ resetMinions: true });
        updateLaneOffsetControls();
        renderMinimap(true);
      });
    }
    renderMultiTeamColors();
  }
